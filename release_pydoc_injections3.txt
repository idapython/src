Module "ida_allins"s docstring:
"""
"""

Module "ida_auto"s docstring:
"""
Functions that work with the autoanalyzer queue.

The autoanalyzer works when IDA is not busy processing the user keystrokes. It
has several queues, each queue having its own priority. The analyzer stops when
all queues are empty.

A queue contains addresses or address ranges. The addresses are kept sorted by
their values. The analyzer will process all addresses from the first queue, then
switch to the second queue and so on. There are no limitations on the size of
the queues.

This file also contains functions that deal with the IDA status indicator and
the autoanalysis indicator. You may use these functions to change the indicator
value."""

Help on function auto_apply_tail in module ida_auto:

auto_apply_tail(*args) -> 'void'
    auto_apply_tail(tail_ea, parent_ea)
    Plan to apply the tail_ea chunk to the parent
    
    @param tail_ea: (C++: ea_t) linear address of start of tail
    @param parent_ea: (C++: ea_t) linear address within parent. If BADADDR, automatically try to
                      find parent via xrefs.

Help on function auto_apply_type in module ida_auto:

auto_apply_type(*args) -> 'void'
    auto_apply_type(caller, callee)
    Plan to apply the callee's type to the calling point.
    
    @param caller: (C++: ea_t)
    @param callee: (C++: ea_t)

Help on function auto_cancel in module ida_auto:

auto_cancel(*args) -> 'void'
    auto_cancel(ea1, ea2)
    Remove an address range (ea1..ea2) from queues AU_CODE, AU_PROC, AU_USED. To
    remove an address range from other queues use auto_unmark() function. 'ea1' may
    be higher than 'ea2', the kernel will swap them in this case. 'ea2' doesn't
    belong to the range.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

Help on class auto_display_t in module ida_auto:

class auto_display_t(builtins.object)
 |  Proxy of C++ auto_display_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> auto_display_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_auto_display_t(...)
 |      delete_auto_display_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  state
 |      state
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type

Help on function auto_get in module ida_auto:

auto_get(*args) -> 'ea_t'
    auto_get(type, lowEA, highEA) -> ea_t
    Retrieve an address from queues regarding their priority. Returns BADADDR if no
    addresses not lower than 'lowEA' and less than 'highEA' are found in the queues.
    Otherwise *type will have queue type.
    
    @param type: (C++: atype_t *)
    @param lowEA: (C++: ea_t)
    @param highEA: (C++: ea_t)

Help on function auto_is_ok in module ida_auto:

auto_is_ok(*args) -> 'bool'
    auto_is_ok() -> bool
    Are all queues empty? (i.e. has autoanalysis finished?).

Help on function auto_make_code in module ida_auto:

auto_make_code(*args) -> 'void'
    auto_make_code(ea)
    Plan to make code.
    
    @param ea: (C++: ea_t)

Help on function auto_make_proc in module ida_auto:

auto_make_proc(*args) -> 'void'
    auto_make_proc(ea)
    Plan to make code&function.
    
    @param ea: (C++: ea_t)

Help on function auto_make_step in module ida_auto:

auto_make_step(*args) -> 'bool'
    auto_make_step(ea1, ea2) -> bool
    Analyze one address in the specified range and return true.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)
    @return: if processed anything. false means that there is nothing to process in
             the specified range.

Help on function auto_mark in module ida_auto:

auto_mark(*args) -> 'void'
    auto_mark(ea, type)
    Put single address into a queue. Queues keep addresses sorted.
    
    @param ea: (C++: ea_t)
    @param type: (C++: atype_t)

Help on function auto_mark_range in module ida_auto:

auto_mark_range(*args) -> 'void'
    auto_mark_range(start, end, type)
    Put range of addresses into a queue. 'start' may be higher than 'end', the
    kernel will swap them in this case. 'end' doesn't belong to the range.
    
    @param start: (C++: ea_t)
    @param end: (C++: ea_t)
    @param type: (C++: atype_t)

Help on function auto_recreate_insn in module ida_auto:

auto_recreate_insn(*args) -> 'int'
    auto_recreate_insn(ea) -> int
    Try to create instruction
    
    @param ea: (C++: ea_t) linear address of callee
    @return: the length of the instruction or 0

Help on function auto_unmark in module ida_auto:

auto_unmark(*args) -> 'void'
    auto_unmark(start, end, type)
    Remove range of addresses from a queue. 'start' may be higher than 'end', the
    kernel will swap them in this case. 'end' doesn't belong to the range.
    
    @param start: (C++: ea_t)
    @param end: (C++: ea_t)
    @param type: (C++: atype_t)

Help on function auto_wait in module ida_auto:

auto_wait(*args) -> 'bool'
    auto_wait() -> bool
    Process everything in the queues and return true.
    
    @return: false if the user clicked cancel. (the wait box must be displayed by
             the caller if desired)

Help on function auto_wait_range in module ida_auto:

auto_wait_range(*args) -> 'ssize_t'
    auto_wait_range(ea1, ea2) -> ssize_t
    Process everything in the specified range and return true.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)
    @return: number of autoanalysis steps made. -1 if the user clicked cancel. (the
             wait box must be displayed by the caller if desired)

Help on function enable_auto in module ida_auto:

enable_auto(*args) -> 'bool'
    enable_auto(enable) -> bool
    Temporarily enable/disable autoanalyzer. Not user-facing, but rather because IDA
    sometimes need to turn AA on/off regardless of inf.s_genflags:INFFL_AUTO
    
    @param enable: (C++: bool)
    @return: old state

Help on function get_auto_display in module ida_auto:

get_auto_display(*args) -> 'bool'
    get_auto_display(auto_display) -> bool
    Get structure which holds the autoanalysis indicator contents.
    
    @param auto_display: (C++: auto_display_t *)

Help on function get_auto_state in module ida_auto:

get_auto_state(*args) -> 'atype_t'
    get_auto_state() -> atype_t
    Get current state of autoanalyzer. If auto_state == AU_NONE, IDA is currently
    not running the analysis (it could be temporarily interrupted to perform the
    user's requests, for example).

Help on function is_auto_enabled in module ida_auto:

is_auto_enabled(*args) -> 'bool'
    is_auto_enabled() -> bool
    Get autoanalyzer state.

Help on function may_create_stkvars in module ida_auto:

may_create_stkvars(*args) -> 'bool'
    may_create_stkvars() -> bool
    Is it allowed to create stack variables automatically?. This function should be
    used by IDP modules before creating stack vars.

Help on function may_trace_sp in module ida_auto:

may_trace_sp(*args) -> 'bool'
    may_trace_sp() -> bool
    Is it allowed to trace stack pointer automatically?. This function should be
    used by IDP modules before tracing sp.

Help on function peek_auto_queue in module ida_auto:

peek_auto_queue(*args) -> 'ea_t'
    peek_auto_queue(low_ea, type) -> ea_t
    Peek into a queue 'type' for an address not lower than 'low_ea'. Do not remove
    address from the queue.
    
    @param low_ea: (C++: ea_t)
    @param type: (C++: atype_t)
    @return: the address or BADADDR

Help on function plan_and_wait in module ida_auto:

plan_and_wait(*args) -> 'int'
    plan_and_wait(ea1, ea2, final_pass=True) -> int
    Analyze the specified range. Try to create instructions where possible. Make the
    final pass over the specified range if specified. This function doesn't return
    until the range is analyzed.
    @retval 1: ok
    @retval 0: Ctrl-Break was pressed
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)
    @param final_pass: (C++: bool)

Help on function plan_ea in module ida_auto:

plan_ea(*args) -> 'void'
    plan_ea(ea)
    Plan to perform reanalysis.
    
    @param ea: (C++: ea_t)

Help on function plan_range in module ida_auto:

plan_range(*args) -> 'void'
    plan_range(sEA, eEA)
    Plan to perform reanalysis.
    
    @param sEA: (C++: ea_t)
    @param eEA: (C++: ea_t)

Help on function reanalyze_callers in module ida_auto:

reanalyze_callers(*args) -> 'void'
    reanalyze_callers(ea, noret)
    Plan to reanalyze callers of the specified address. This function will add to
    AU_USED queue all instructions that call (not jump to) the specified address.
    
    @param ea: (C++: ea_t) linear address of callee
    @param noret: (C++: bool) !=0: the callee doesn't return, mark to undefine subsequent
                  instructions in the caller. 0: do nothing.

Help on function revert_ida_decisions in module ida_auto:

revert_ida_decisions(*args) -> 'void'
    revert_ida_decisions(ea1, ea2)
    Delete all analysis info that IDA generated for for the given range.
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

Help on function set_auto_state in module ida_auto:

set_auto_state(*args) -> 'atype_t'
    set_auto_state(new_state) -> atype_t
    Set current state of autoanalyzer.
    
    @param new_state: (C++: atype_t) new state of autoanalyzer
    @return: previous state

Help on function set_ida_state in module ida_auto:

set_ida_state(*args) -> 'idastate_t'
    set_ida_state(st) -> idastate_t
    Change IDA status indicator value
    
    @param st: (C++: idastate_t) - new indicator status
    @return: old indicator status

Help on function show_addr in module ida_auto:

show_addr(*args) -> 'void'
    show_addr(ea)
    Show an address on the autoanalysis indicator. The address is displayed in the
    form " @:12345678".
    
    @param ea: (C++: ea_t) - linear address to display

Help on function show_auto in module ida_auto:

show_auto(*args) -> 'void'
    show_auto(ea, type=AU_NONE)
    Change autoanalysis indicator value.
    
    @param ea: (C++: ea_t) linear address being analyzed
    @param type: (C++: atype_t) autoanalysis type (see Autoanalysis queues)

Module "ida_bitrange"s docstring:
"""
Definition of the bitrange_t class."""

Help on class bitrange_t in module ida_bitrange:

class bitrange_t(builtins.object)
 |  Proxy of C++ bitrange_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: bitrange_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: bitrange_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: bitrange_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, bit_ofs=0, size_in_bits=0) -> bitrange_t
 |      
 |      @param bit_ofs: uint16
 |      @param size_in_bits: uint16
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: bitrange_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: bitrange_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: bitrange_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'qstring'
 |      __str__(self) -> qstring
 |  
 |  __swig_destroy__ = delete_bitrange_t(...)
 |      delete_bitrange_t(self)
 |  
 |  apply_mask(self, *args) -> 'bool'
 |      apply_mask(self, subrange) -> bool
 |      Apply mask to a bitrange
 |      
 |      @param subrange: (C++: const bitrange_t &) range *inside* the main bitrange to keep After this operation
 |                       the main bitrange will be truncated to have only the bits that
 |                       are specified by subrange. Example: [off=8,nbits=4],
 |                       subrange[off=1,nbits=2] => [off=9,nbits=2]
 |      @return: success
 |  
 |  bitoff(self, *args) -> 'uint'
 |      bitoff(self) -> uint
 |      Get offset of 1st bit.
 |  
 |  bitsize(self, *args) -> 'uint'
 |      bitsize(self) -> uint
 |      Get size of the value in bits.
 |  
 |  bytesize(self, *args) -> 'uint'
 |      bytesize(self) -> uint
 |      Size of the value in bytes.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: bitrange_t const &
 |  
 |  create_union(self, *args) -> 'void'
 |      create_union(self, r)
 |      Create union of 2 ranges including the hole between them.
 |      
 |      @param r: (C++: const bitrange_t &) bitrange_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the bitrange empty?
 |  
 |  extract(self, *args) -> 'bool'
 |      extract(self, src, is_mf) -> bool
 |      
 |      @param src: void const *
 |      @param is_mf: bool
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, r) -> bool
 |      Does have common bits with another bitrange?
 |      
 |      @param r: (C++: const bitrange_t &) bitrange_t const &
 |  
 |  init(self, *args) -> 'void'
 |      init(self, bit_ofs, size_in_bits)
 |      Initialize offset and size to given values.
 |      
 |      @param bit_ofs: (C++: uint16)
 |      @param size_in_bits: (C++: uint16)
 |  
 |  inject(self, *args) -> 'bool'
 |      inject(self, dst, src, is_mf) -> bool
 |      
 |      @param dst: void *
 |      @param src: bytevec_t const &
 |      @param is_mf: bool
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Intersect two ranges.
 |      
 |      @param r: (C++: const bitrange_t &) bitrange_t const &
 |  
 |  mask64(self, *args) -> 'uint64'
 |      mask64(self) -> uint64
 |      Convert to mask of 64 bits.
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |      Make the bitrange empty.
 |  
 |  shift_down(self, *args) -> 'void'
 |      shift_down(self, cnt)
 |      Shift range down (left)
 |      
 |      @param cnt: (C++: uint)
 |  
 |  shift_up(self, *args) -> 'void'
 |      shift_up(self, cnt)
 |      Shift range up (right)
 |      
 |      @param cnt: (C++: uint)
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, r) -> bool
 |      Subtract a bitrange.
 |      
 |      @param r: (C++: const bitrange_t &) bitrange_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Module "ida_bytes"s docstring:
"""
Contains functions that deal with individual byte characteristics.

Each byte of the disassembled program is represented by a 32-bit value. We will
call this value 'flags'. The structure of the flags is here.

You are not allowed to inspect individual bits of flags and modify them
directly. Use special functions to inspect and/or modify flags.

Flags are kept in a virtual array file (*.id1). Addresses (ea) are all 32-bit
(or 64-bit) quantities."""

Help on function __walk_types_and_formats in module ida_bytes:

__walk_types_and_formats(formats, type_action, format_action, installing)
    # -----------------------------------------------------------------------

Help on function add_byte in module ida_bytes:

add_byte(*args) -> 'void'
    add_byte(ea, value)
    Add a value to one byte of the program. This function works for wide byte
    processors too.
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint32) byte value

Help on function add_dword in module ida_bytes:

add_dword(*args) -> 'void'
    add_dword(ea, value)
    Add a value to one dword of the program. This function works for wide byte
    processors too. This function takes into account order of bytes specified in
    idainfo::is_be()
    @note: this function works incorrectly if processor_t::nbits > 16
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint64) byte value

Help on function add_hidden_range in module ida_bytes:

add_hidden_range(*args) -> 'bool'
    add_hidden_range(ea1, ea2, description, header, footer, color=bgcolor_t(-1)) -> bool
    Mark a range of addresses as hidden. The range will be created in the invisible
    state with the default color
    
    @param ea1: (C++: ea_t) linear address of start of the address range
    @param ea2: (C++: ea_t) linear address of end of the address range
    @param description: (C++: const char *) ,header,footer: range parameters
    @param header: (C++: const char *) char const *
    @param footer: (C++: const char *) char const *
    @param color: (C++: bgcolor_t) the range color
    @return: success

Help on function add_mapping in module ida_bytes:

add_mapping(*args) -> 'bool'
    add_mapping(_from, to, size) -> bool
    IDA supports memory mapping. References to the addresses from the mapped range
    use data and meta-data from the mapping range.
    @note: You should set flag PR2_MAPPING in ph.flag2 to use memory mapping Add
           memory mapping range.
    
    @param from: (C++: ea_t) start of the mapped range (nonexistent address)
    @param to: (C++: ea_t) start of the mapping range (existent address)
    @param size: (C++: asize_t) size of the range
    @return: success

Help on function add_qword in module ida_bytes:

add_qword(*args) -> 'void'
    add_qword(ea, value)
    Add a value to one qword of the program. This function does not work for wide
    byte processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint64) byte value

Help on function add_word in module ida_bytes:

add_word(*args) -> 'void'
    add_word(ea, value)
    Add a value to one word of the program. This function works for wide byte
    processors too. This function takes into account order of bytes specified in
    idainfo::is_be()
    
    @param ea: (C++: ea_t) linear address
    @param value: (C++: uint64) byte value

Help on function align_flag in module ida_bytes:

align_flag(*args) -> 'flags_t'
    align_flag() -> flags_t
    Get a flags_t representing an alignment directive.

Help on function append_cmt in module ida_bytes:

append_cmt(*args) -> 'bool'
    append_cmt(ea, str, rptble) -> bool
    Append to an indented comment. Creates a new comment if none exists. Appends a
    newline character and the specified string otherwise.
    
    @param ea: (C++: ea_t) linear address
    @param str: (C++: const char *) comment string to append
    @param rptble: (C++: bool) append to repeatable comment?
    @return: success

Help on function attach_custom_data_format in module ida_bytes:

attach_custom_data_format(*args) -> 'bool'
    attach_custom_data_format(dtid, dfid) -> bool
    Attach the data format to the data type.
    
    @param dtid: (C++: int) data type id that can use the data format. 0 means all standard
                 data types. Such data formats can be applied to any data item or
                 instruction operands. For instruction operands, the
                 data_format_t::value_size check is not performed by the kernel.
    @param dfid: (C++: int) data format id
    @retval true: ok
    @retval false: no such `dtid', or no such `dfid', or the data format has already
                   been attached to the data type

Help on function bin_flag in module ida_bytes:

bin_flag(*args) -> 'flags_t'
    bin_flag() -> flags_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

Help on function bin_search in module ida_bytes:

bin_search(*args) -> 'ea_t'
    bin_search(start_ea, end_ea, data, flags) -> ea_t
    Search for a set of bytes in the program
    
    @param start_ea: linear address, start of range to search
    @param end_ea: linear address, end of range to search (exclusive)
    @param data: the prepared data to search for (see parse_binpat_str())
    @param flags: combination of BIN_SEARCH_* flags
    @return: the address of a match, or ida_idaapi.BADADDR if not found
    bin_search(start_ea, end_ea, image, imask, step, flags) -> ea_t
    
    @param start_ea: ea_t
    @param end_ea: ea_t
    @param image: bytevec_t const &
    @param imask: bytevec_t const &
    @param step: int
    @param flags: int

Help on function bin_search3 in module ida_bytes:

bin_search3(*args) -> 'size_t *'
    bin_search3(start_ea, end_ea, data, flags) -> ea_t
    Search for a patter in the program.
    
    @param start_ea: (C++: ea_t) linear address, start of range to search
    @param end_ea: (C++: ea_t) linear address, end of range to search (exclusive)
    @param data: (C++: const compiled_binpat_vec_t &) the prepared data to search for (see parse_binpat_str())
    @param flags: (C++: int) combination of Search flags
    @return: BADADDR (if pressed Ctrl-Break or not found) or pattern address.

Help on function byte_flag in module ida_bytes:

byte_flag(*args) -> 'flags_t'
    byte_flag() -> flags_t
    Get a flags_t representing a byte.

Help on function bytesize in module ida_bytes:

bytesize(*args) -> 'int'
    bytesize(ea) -> int
    Get number of bytes required to store a byte at the given address.
    
    @param ea: (C++: ea_t)

Help on function calc_def_align in module ida_bytes:

calc_def_align(*args) -> 'int'
    calc_def_align(ea, mina, maxa) -> int
    Calculate the default alignment exponent.
    
    @param ea: (C++: ea_t) linear address
    @param mina: (C++: int) minimal possible alignment exponent.
    @param maxa: (C++: int) minimal possible alignment exponent.

Help on function calc_dflags in module ida_bytes:

calc_dflags(*args) -> 'flags_t'
    calc_dflags(f, force) -> flags_t
    
    @param f: flags_t
    @param force: bool

Help on function calc_max_align in module ida_bytes:

calc_max_align(*args) -> 'int'
    calc_max_align(endea) -> int
    Calculate the maximal possible alignment exponent.
    
    @param endea: (C++: ea_t) end address of the alignment item.
    @return: a value in the 0..32 range

Help on function calc_max_item_end in module ida_bytes:

calc_max_item_end(*args) -> 'ea_t'
    calc_max_item_end(ea, how=15) -> ea_t
    Calculate maximal reasonable end address of a new item. This function will limit
    the item with the current segment bounds.
    
    @param ea: (C++: ea_t) linear address
    @param how: (C++: int) when to stop the search. A combination of Item end search flags
    @return: end of new item. If it is not possible to create an item, it will
             return 'ea'.

Help on function calc_min_align in module ida_bytes:

calc_min_align(*args) -> 'int'
    calc_min_align(length) -> int
    Calculate the minimal possible alignment exponent.
    
    @param length: (C++: asize_t) size of the item in bytes.
    @return: a value in the 1..32 range

Help on function can_define_item in module ida_bytes:

can_define_item(*args) -> 'bool'
    can_define_item(ea, length, flags) -> bool
    Can define item (instruction/data) of the specified 'length', starting at 'ea'?
    @note: if there is an item starting at 'ea', this function ignores it
    @note: this function converts to unexplored all encountered data items with
           fixup information. Should be fixed in the future.
    
    @param ea: (C++: ea_t) start of the range for the new item
    @param length: (C++: asize_t) length of the new item in bytes
    @param flags: (C++: flags_t) if not 0, then the kernel will ignore the data types specified by
                  the flags and destroy them. For example:
    1000 dw 5
                     1002 db 5 ; undef
                     1003 db 5 ; undef
                     1004 dw 5
                     1006 dd 5
                      can_define_item(1000, 6, 0) - false because of dw at 1004
    can_define_item(1000, 6, word_flag()) - true, word at 1004 is destroyed
    @return: 1-yes, 0-no
    * a new item would cross segment boundaries
    * a new item would overlap with existing items (except items specified by
    'flags')

Help on function change_storage_type in module ida_bytes:

change_storage_type(*args) -> 'error_t'
    change_storage_type(start_ea, end_ea, stt) -> error_t
    Change flag storage type for address range.
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @param stt: (C++: storage_type_t)
    @return: error code

Help on function char_flag in module ida_bytes:

char_flag(*args) -> 'flags_t'
    char_flag() -> flags_t
    see Bits: instruction operand types

Help on function chunk_size in module ida_bytes:

chunk_size(*args) -> 'asize_t'
    chunk_size(ea) -> asize_t
    Get size of the contiguous address block containing 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 0 if 'ea' doesn't belong to the program.

Help on function chunk_start in module ida_bytes:

chunk_start(*args) -> 'ea_t'
    chunk_start(ea) -> ea_t
    Get start of the contiguous address block containing 'ea'.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if 'ea' doesn't belong to the program.

Help on function clr_lzero in module ida_bytes:

clr_lzero(*args) -> 'bool'
    clr_lzero(ea, n) -> bool
    Clear toggle lzero bit. This function reset the display of leading zeroes for
    the specified operand to the default. If the default is not to display leading
    zeroes, leading zeroes will not be displayed, as vice versa.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

Help on function clr_op_type in module ida_bytes:

clr_op_type(*args) -> 'bool'
    clr_op_type(ea, n) -> bool
    Remove operand representation information. (set operand representation to be
    'undefined')
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: success

Help on function code_flag in module ida_bytes:

code_flag(*args) -> 'flags_t'
    code_flag() -> flags_t
    FF_CODE

Help on class compiled_binpat_t in module ida_bytes:

class compiled_binpat_t(builtins.object)
 |  Proxy of C++ compiled_binpat_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: compiled_binpat_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> compiled_binpat_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: compiled_binpat_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_compiled_binpat_t(...)
 |      delete_compiled_binpat_t(self)
 |  
 |  all_bytes_defined(self, *args) -> 'bool'
 |      all_bytes_defined(self) -> bool
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      bytes
 |  
 |  encidx
 |      encidx
 |  
 |  mask
 |      mask
 |  
 |  strlits
 |      strlits
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class compiled_binpat_vec_t in module ida_bytes:

class compiled_binpat_vec_t(builtins.object)
 |  Proxy of C++ qvector< compiled_binpat_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< compiled_binpat_t > const &
 |  
 |  __getitem__(self, *args) -> 'compiled_binpat_t const &'
 |      __getitem__(self, i) -> compiled_binpat_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> compiled_binpat_vec_t
 |      __init__(self, x) -> compiled_binpat_vec_t
 |      
 |      @param x: qvector< compiled_binpat_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< compiled_binpat_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: compiled_binpat_t const &
 |  
 |  __swig_destroy__ = delete_compiled_binpat_vec_t(...)
 |      delete_compiled_binpat_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: compiled_binpat_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: compiled_binpat_t const &
 |  
 |  at(self, *args) -> 'compiled_binpat_t const &'
 |      at(self, _idx) -> compiled_binpat_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< compiled_binpat_t >::const_iterator'
 |      begin(self) -> compiled_binpat_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< compiled_binpat_t >::const_iterator'
 |      end(self) -> compiled_binpat_t
 |  
 |  erase(self, *args) -> 'qvector< compiled_binpat_t >::iterator'
 |      erase(self, it) -> compiled_binpat_t
 |      
 |      @param it: qvector< compiled_binpat_t >::iterator
 |      
 |      erase(self, first, last) -> compiled_binpat_t
 |      
 |      @param first: qvector< compiled_binpat_t >::iterator
 |      @param last: qvector< compiled_binpat_t >::iterator
 |  
 |  extract(self, *args) -> 'compiled_binpat_t *'
 |      extract(self) -> compiled_binpat_t
 |  
 |  find(self, *args) -> 'qvector< compiled_binpat_t >::const_iterator'
 |      find(self, x) -> compiled_binpat_t
 |      
 |      @param x: compiled_binpat_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=compiled_binpat_t())
 |      
 |      @param x: compiled_binpat_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: compiled_binpat_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: compiled_binpat_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< compiled_binpat_t >::iterator'
 |      insert(self, it, x) -> compiled_binpat_t
 |      
 |      @param it: qvector< compiled_binpat_t >::iterator
 |      @param x: compiled_binpat_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'compiled_binpat_t &'
 |      push_back(self, x)
 |      
 |      @param x: compiled_binpat_t const &
 |      
 |      push_back(self) -> compiled_binpat_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: compiled_binpat_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< compiled_binpat_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function create_16bit_data in module ida_bytes:

create_16bit_data(*args) -> 'bool'
    create_16bit_data(ea, length) -> bool
    Convert to 16-bit quantity (take the byte size into account)
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)

Help on function create_32bit_data in module ida_bytes:

create_32bit_data(*args) -> 'bool'
    create_32bit_data(ea, length) -> bool
    Convert to 32-bit quantity (take the byte size into account)
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)

Help on function create_align in module ida_bytes:

create_align(*args) -> 'bool'
    create_align(ea, length, alignment) -> bool
    Create an alignment item.
    
    @param ea: (C++: ea_t) linear address
    @param length: (C++: asize_t) size of the item in bytes. 0 means to infer from ALIGNMENT
    @param alignment: (C++: int) alignment exponent. Example: 3 means align to 8 bytes. 0 means
                      to infer from LENGTH It is forbidden to specify both LENGTH
                      and ALIGNMENT as 0.
    @return: success

Help on function create_byte in module ida_bytes:

create_byte(*args) -> 'bool'
    create_byte(ea, length, force=False) -> bool
    Convert to byte.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_custdata in module ida_bytes:

create_custdata(*args) -> 'bool'
    create_custdata(ea, length, dtid, fid, force=False) -> bool
    Convert to custom data type.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param dtid: (C++: int)
    @param fid: (C++: int)
    @param force: (C++: bool)

Help on function create_data in module ida_bytes:

create_data(*args) -> 'bool'
    create_data(ea, dataflag, size, tid) -> bool
    Convert to data (byte, word, dword, etc). This function may be used to create
    arrays.
    
    @param ea: (C++: ea_t) linear address
    @param dataflag: (C++: flags_t) type of data. Value of function byte_flag(), word_flag(), etc.
    @param size: (C++: asize_t) size of array in bytes. should be divisible by the size of one item
                 of the specified type. for variable sized items it can be specified
                 as 0, and the kernel will try to calculate the size.
    @param tid: (C++: tid_t) type id. If the specified type is a structure, then tid is structure
                id. Otherwise should be BADNODE.
    @return: success

Help on function create_double in module ida_bytes:

create_double(*args) -> 'bool'
    create_double(ea, length, force=False) -> bool
    Convert to double.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_dword in module ida_bytes:

create_dword(*args) -> 'bool'
    create_dword(ea, length, force=False) -> bool
    Convert to dword.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_float in module ida_bytes:

create_float(*args) -> 'bool'
    create_float(ea, length, force=False) -> bool
    Convert to float.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_oword in module ida_bytes:

create_oword(*args) -> 'bool'
    create_oword(ea, length, force=False) -> bool
    Convert to octaword/xmm word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_packed_real in module ida_bytes:

create_packed_real(*args) -> 'bool'
    create_packed_real(ea, length, force=False) -> bool
    Convert to packed decimal real.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_qword in module ida_bytes:

create_qword(*args) -> 'bool'
    create_qword(ea, length, force=False) -> bool
    Convert to quadword.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_strlit in module ida_bytes:

create_strlit(*args) -> 'bool'
    create_strlit(start, len, strtype) -> bool
    Convert to string literal and give a meaningful name. 'start' may be higher than
    'end', the kernel will swap them in this case
    
    @param start: (C++: ea_t) starting address
    @param len: (C++: size_t) length of the string in bytes. if 0, then get_max_strlit_length()
                will be used to determine the length
    @param strtype: (C++: int32) string type. one of String type codes
    @return: success

Help on function create_struct in module ida_bytes:

create_struct(*args) -> 'bool'
    create_struct(ea, length, tid, force=False) -> bool
    Convert to struct.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param tid: (C++: tid_t)
    @param force: (C++: bool)

Help on function create_tbyte in module ida_bytes:

create_tbyte(*args) -> 'bool'
    create_tbyte(ea, length, force=False) -> bool
    Convert to tbyte.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_word in module ida_bytes:

create_word(*args) -> 'bool'
    create_word(ea, length, force=False) -> bool
    Convert to word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_yword in module ida_bytes:

create_yword(*args) -> 'bool'
    create_yword(ea, length, force=False) -> bool
    Convert to ymm word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function create_zword in module ida_bytes:

create_zword(*args) -> 'bool'
    create_zword(ea, length, force=False) -> bool
    Convert to zmm word.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param force: (C++: bool)

Help on function cust_flag in module ida_bytes:

cust_flag(*args) -> 'flags_t'
    cust_flag() -> flags_t
    Get a flags_t representing custom type data.

Help on function custfmt_flag in module ida_bytes:

custfmt_flag(*args) -> 'flags_t'
    custfmt_flag() -> flags_t
    see Bits: instruction operand types

Help on class data_format_t in module ida_bytes:

class data_format_t(builtins.object)
 |  Proxy of C++ data_format_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __real__init__ = __init__(self, *args)
 |      __init__(self, _self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t
 |      
 |      @param self: PyObject *
 |      @param name: char const *
 |      @param value_size: asize_t
 |      @param menu_name: char const *
 |      @param props: int
 |      @param hotkey: char const *
 |      @param text_width: int32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_data_format_t(...)
 |      delete_data_format_t(self)
 |  
 |  _data_format_t__get_id = __get_id(self, *args) -> 'int'
 |      __get_id(self) -> int
 |  
 |  is_present_in_menus(self, *args) -> 'bool'
 |      is_present_in_menus(self) -> bool
 |      Should this format be shown in UI menus
 |      
 |      @return: success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hotkey
 |      hotkey
 |  
 |  id
 |      __get_id(self) -> int
 |  
 |  menu_name
 |      menu_name
 |  
 |  name
 |      name
 |  
 |  props
 |      props
 |  
 |  text_width
 |      text_width
 |  
 |  thisown
 |      The membership flag
 |  
 |  value_size
 |      value_size

Help on class data_type_t in module ida_bytes:

class data_type_t(builtins.object)
 |  Proxy of C++ data_type_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __real__init__ = __init__(self, *args)
 |      __init__(self, _self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t
 |      
 |      @param self: PyObject *
 |      @param name: char const *
 |      @param value_size: asize_t
 |      @param menu_name: char const *
 |      @param hotkey: char const *
 |      @param asm_keyword: char const *
 |      @param props: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_data_type_t(...)
 |      delete_data_type_t(self)
 |  
 |  _data_type_t__get_id = __get_id(self, *args) -> 'int'
 |      __get_id(self) -> int
 |  
 |  is_present_in_menus(self, *args) -> 'bool'
 |      is_present_in_menus(self) -> bool
 |      Should this type be shown in UI menus
 |      
 |      @return: success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  asm_keyword
 |      asm_keyword
 |  
 |  hotkey
 |      hotkey
 |  
 |  id
 |      __get_id(self) -> int
 |  
 |  menu_name
 |      menu_name
 |  
 |  name
 |      name
 |  
 |  props
 |      props
 |  
 |  thisown
 |      The membership flag
 |  
 |  value_size
 |      value_size

Help on function dec_flag in module ida_bytes:

dec_flag(*args) -> 'flags_t'
    dec_flag() -> flags_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

Help on function del_hidden_range in module ida_bytes:

del_hidden_range(*args) -> 'bool'
    del_hidden_range(ea) -> bool
    Delete hidden range.
    
    @param ea: (C++: ea_t) any address in the hidden range
    @return: success

Help on function del_items in module ida_bytes:

del_items(*args) -> 'bool'
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
    Convert item (instruction/data) to unexplored bytes. The whole item (including
    the head and tail bytes) will be destroyed. It is allowed to pass any address in
    the item to this function
    
    @param ea: (C++: ea_t) any address within the first item to delete
    @param flags: (C++: int) combination of Unexplored byte conversion flags
    @param nbytes: (C++: asize_t) number of bytes in the range to be undefined
    @param may_destroy: (C++: may_destroy_cb_t *) optional routine invoked before deleting a head item. If
                        callback returns false then item is not to be deleted and
                        operation fails
    @return: true on sucessful operation, otherwise false

Help on function del_mapping in module ida_bytes:

del_mapping(*args) -> 'void'
    del_mapping(ea)
    Delete memory mapping range.
    
    @param ea: (C++: ea_t) any address in the mapped range

Help on function del_value in module ida_bytes:

del_value(*args) -> 'void'
    del_value(ea)
    Delete byte value from flags. The corresponding byte becomes uninitialized.
    
    @param ea: (C++: ea_t)

Help on function detach_custom_data_format in module ida_bytes:

detach_custom_data_format(*args) -> 'bool'
    detach_custom_data_format(dtid, dfid) -> bool
    Detach the data format from the data type. Unregistering a custom data type
    detaches all attached data formats, no need to detach them explicitly. You still
    need unregister them. Unregistering a custom data format detaches it from all
    attached data types.
    
    @param dtid: (C++: int) data type id to detach data format from
    @param dfid: (C++: int) data format id to detach
    @retval true: ok
    @retval false: no such `dtid', or no such `dfid', or the data format was not
                   attached to the data type

Help on function disable_flags in module ida_bytes:

disable_flags(*args) -> 'error_t'
    disable_flags(start_ea, end_ea) -> error_t
    Deallocate flags for address range. Exit with an error message if not enough
    disk space (this may occur too).
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @return: 0 if ok, otherwise return error code

Help on function double_flag in module ida_bytes:

double_flag(*args) -> 'flags_t'
    double_flag() -> flags_t
    Get a flags_t representing a double.

Help on function dword_flag in module ida_bytes:

dword_flag(*args) -> 'flags_t'
    dword_flag() -> flags_t
    Get a flags_t representing a double word.

Help on function enable_flags in module ida_bytes:

enable_flags(*args) -> 'error_t'
    enable_flags(start_ea, end_ea, stt) -> error_t
    Allocate flags for address range. This function does not change the storage type
    of existing ranges. Exit with an error message if not enough disk space.
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @param stt: (C++: storage_type_t)
    @return: 0 if ok, otherwise an error code

Help on function enum_flag in module ida_bytes:

enum_flag(*args) -> 'flags_t'
    enum_flag() -> flags_t
    see Bits: instruction operand types

Help on function equal_bytes in module ida_bytes:

equal_bytes(*args) -> 'bool'
    equal_bytes(ea, image, mask, len, bin_search_flags) -> bool
    Compare 'len' bytes of the program starting from 'ea' with 'image'.
    
    @param ea: (C++: ea_t) linear address
    @param image: (C++: const uchar *) bytes to compare with
    @param mask: (C++: const uchar *) array of mask bytes, it's length is 'len'. if the flag
                 BIN_SEARCH_BITMASK is passsed, 'bitwise AND' is used to compare. if
                 not; 1 means to perform the comparison of the corresponding byte. 0
                 means not to perform. if mask == nullptr, then all bytes of 'image'
                 will be compared. if mask == SKIP_FF_MASK then 0xFF bytes will be
                 skipped
    @param len: (C++: size_t) length of block to compare in bytes.
    @param bin_search_flags: (C++: int) combination of Search flags
    @retval 1: equal
    @retval 0: not equal

Help on function f_has_cmt in module ida_bytes:

f_has_cmt(*args) -> 'bool'
    f_has_cmt(f, arg2) -> bool
    
    @param f: flags_t
    @param arg2: void *

Help on function f_has_dummy_name in module ida_bytes:

f_has_dummy_name(*args) -> 'bool'
    f_has_dummy_name(f, arg2) -> bool
    Does the current byte have dummy (auto-generated, with special prefix) name?
    
    @param f: (C++: flags_t)
    @param arg2: void *

Help on function f_has_extra_cmts in module ida_bytes:

f_has_extra_cmts(*args) -> 'bool'
    f_has_extra_cmts(f, arg2) -> bool
    
    @param f: flags_t
    @param arg2: void *

Help on function f_has_name in module ida_bytes:

f_has_name(*args) -> 'bool'
    f_has_name(f, arg2) -> bool
    Does the current byte have non-trivial (non-dummy) name?
    
    @param f: (C++: flags_t)
    @param arg2: void *

Help on function f_has_user_name in module ida_bytes:

f_has_user_name(*args) -> 'bool'
    f_has_user_name(F, arg2) -> bool
    Does the current byte have user-specified name?
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_has_xref in module ida_bytes:

f_has_xref(*args) -> 'bool'
    f_has_xref(f, arg2) -> bool
    Does the current byte have cross-references to it?
    
    @param f: (C++: flags_t)
    @param arg2: void *

Help on function f_is_align in module ida_bytes:

f_is_align(*args) -> 'bool'
    f_is_align(F, arg2) -> bool
    See is_align()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_byte in module ida_bytes:

f_is_byte(*args) -> 'bool'
    f_is_byte(F, arg2) -> bool
    See is_byte()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_code in module ida_bytes:

f_is_code(*args) -> 'bool'
    f_is_code(F, arg2) -> bool
    Does flag denote start of an instruction?
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_custom in module ida_bytes:

f_is_custom(*args) -> 'bool'
    f_is_custom(F, arg2) -> bool
    See is_custom()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_data in module ida_bytes:

f_is_data(*args) -> 'bool'
    f_is_data(F, arg2) -> bool
    Does flag denote start of data?
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_double in module ida_bytes:

f_is_double(*args) -> 'bool'
    f_is_double(F, arg2) -> bool
    See is_double()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_dword in module ida_bytes:

f_is_dword(*args) -> 'bool'
    f_is_dword(F, arg2) -> bool
    See is_dword()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_float in module ida_bytes:

f_is_float(*args) -> 'bool'
    f_is_float(F, arg2) -> bool
    See is_float()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_head in module ida_bytes:

f_is_head(*args) -> 'bool'
    f_is_head(F, arg2) -> bool
    Does flag denote start of instruction OR data?
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_not_tail in module ida_bytes:

f_is_not_tail(*args) -> 'bool'
    f_is_not_tail(F, arg2) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_oword in module ida_bytes:

f_is_oword(*args) -> 'bool'
    f_is_oword(F, arg2) -> bool
    See is_oword()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_pack_real in module ida_bytes:

f_is_pack_real(*args) -> 'bool'
    f_is_pack_real(F, arg2) -> bool
    See is_pack_real()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_qword in module ida_bytes:

f_is_qword(*args) -> 'bool'
    f_is_qword(F, arg2) -> bool
    See is_qword()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_strlit in module ida_bytes:

f_is_strlit(*args) -> 'bool'
    f_is_strlit(F, arg2) -> bool
    See is_strlit()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_struct in module ida_bytes:

f_is_struct(*args) -> 'bool'
    f_is_struct(F, arg2) -> bool
    See is_struct()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_tail in module ida_bytes:

f_is_tail(*args) -> 'bool'
    f_is_tail(F, arg2) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_tbyte in module ida_bytes:

f_is_tbyte(*args) -> 'bool'
    f_is_tbyte(F, arg2) -> bool
    See is_tbyte()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_word in module ida_bytes:

f_is_word(*args) -> 'bool'
    f_is_word(F, arg2) -> bool
    See is_word()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function f_is_yword in module ida_bytes:

f_is_yword(*args) -> 'bool'
    f_is_yword(F, arg2) -> bool
    See is_yword()
    
    @param F: (C++: flags_t)
    @param arg2: void *

Help on function find_byte in module ida_bytes:

find_byte(*args) -> 'ea_t'
    find_byte(sEA, size, value, bin_search_flags) -> ea_t
    Find forward a byte with the specified value (only 8-bit value from the
    database). example: ea=4 size=3 will inspect addresses 4, 5, and 6
    
    @param sEA: (C++: ea_t) linear address
    @param size: (C++: asize_t) number of bytes to inspect
    @param value: (C++: uchar) value to find
    @param bin_search_flags: (C++: int) combination of Search flags
    @return: address of byte or BADADDR

Help on function find_byter in module ida_bytes:

find_byter(*args) -> 'ea_t'
    find_byter(sEA, size, value, bin_search_flags) -> ea_t
    Find reverse a byte with the specified value (only 8-bit value from the
    database). example: ea=4 size=3 will inspect addresses 6, 5, and 4
    
    @param sEA: (C++: ea_t) the lower address of the search range
    @param size: (C++: asize_t) number of bytes to inspect
    @param value: (C++: uchar) value to find
    @param bin_search_flags: (C++: int) combination of Search flags
    @return: address of byte or BADADDR

Help on function find_custom_data_format in module ida_bytes:

find_custom_data_format(*args) -> 'int'
    find_custom_data_format(name) -> int
    Get id of a custom data format.
    
    @param name: (C++: const char *) name of the custom data format
    @return: id or -1

Help on function find_custom_data_type in module ida_bytes:

find_custom_data_type(*args) -> 'int'
    find_custom_data_type(name) -> int
    Get id of a custom data type.
    
    @param name: (C++: const char *) name of the custom data type
    @return: id or -1

Help on function find_free_chunk in module ida_bytes:

find_free_chunk(*args) -> 'ea_t'
    find_free_chunk(start, size, alignment) -> ea_t
    Search for a hole in the addressing space of the program.
    
    @param start: (C++: ea_t) Address to start searching from
    @param size: (C++: asize_t) Size of the desired empty range
    @param alignment: (C++: asize_t) Alignment bitmask, must be a pow2-1. (for example, 0xF would
                      align the returned range to 16 bytes).
    @return: Start of the found empty range or BADADDR

Help on function float_flag in module ida_bytes:

float_flag(*args) -> 'flags_t'
    float_flag() -> flags_t
    Get a flags_t representing a float.

Help on function flt_flag in module ida_bytes:

flt_flag(*args) -> 'flags_t'
    flt_flag() -> flags_t
    see Bits: instruction operand types

Help on function free_chunk in module ida_bytes:

free_chunk(*args) -> 'ea_t'
    free_chunk(bottom, size, step) -> ea_t
    
    @param bottom: ea_t
    @param size: asize_t
    @param step: int32

Help on function get_16bit in module ida_bytes:

get_16bit(*args) -> 'uint32'
    get_16bit(ea) -> uint32
    Get 16bits of the program at 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 1 byte (getFullByte()) if the current processor has 16-bit byte,
             otherwise return get_word()

Help on function get_32bit in module ida_bytes:

get_32bit(*args) -> 'uint32'
    get_32bit(ea) -> uint32
    Get not more than 32bits of the program at 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 32 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_dword(ea);
    * if ( nbits <= 16) return get_wide_word(ea);
    * return get_wide_byte(ea);

Help on function get_64bit in module ida_bytes:

get_64bit(*args) -> 'uint64'
    get_64bit(ea) -> uint64
    Get not more than 64bits of the program at 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 64 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_qword(ea);
    * if ( nbits <= 16) return get_wide_dword(ea);
    * return get_wide_byte(ea);

Help on function get_8bit in module ida_bytes:

get_8bit(*args) -> 'PyObject *'
    get_8bit(ea, v, nbit) -> PyObject *
    
    @param ea: ea_t
    @param v: uint32
    @param nbit: int

Help on function get_byte in module ida_bytes:

get_byte(*args) -> 'uchar'
    get_byte(ea) -> uchar
    Get one byte (8-bit) of the program at 'ea'. This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_bytes in module ida_bytes:

get_bytes(*args) -> 'PyObject *'
    get_bytes(ea, size, gmb_flags=0x01) -> bytes or None
    Get the specified number of bytes of the program.
    
    @param ea: program address
    @param size: number of bytes to return
    @param gmb_flags: int
    @return: the bytes (as a str), or None in case of failure

Help on function get_bytes_and_mask in module ida_bytes:

get_bytes_and_mask(*args) -> 'PyObject *'
    get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *
    Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    
    @param ea: program address
    @param size: number of bytes to return
    @param gmb_flags: int
    @return: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.

Help on function get_cmt in module ida_bytes:

get_cmt(*args) -> 'qstring *'
    get_cmt(ea, rptble) -> str
    Get an indented comment.
    
    @param ea: (C++: ea_t) linear address. may point to tail byte, the function will find start
               of the item
    @param rptble: (C++: bool) get repeatable comment?
    @return: size of comment or -1

Help on function get_custom_data_format in module ida_bytes:

get_custom_data_format(*args) -> 'data_format_t const *'
    get_custom_data_format(dfid) -> data_format_t
    Get definition of a registered custom data format.
    
    @param dfid: (C++: int) data format id
    @return: data format definition or nullptr

Help on function get_custom_data_formats in module ida_bytes:

get_custom_data_formats(*args) -> 'int'
    get_custom_data_formats(out, dtid) -> int
    Get list of attached custom data formats for the specified data type.
    
    @param out: (C++: intvec_t *) buffer for the output. may be nullptr
    @param dtid: (C++: int) data type id
    @return: number of returned custom data formats. if error, returns -1

Help on function get_custom_data_type in module ida_bytes:

get_custom_data_type(*args) -> 'data_type_t const *'
    get_custom_data_type(dtid) -> data_type_t
    Get definition of a registered custom data type.
    
    @param dtid: (C++: int) data type id
    @return: data type definition or nullptr

Help on function get_custom_data_types in module ida_bytes:

get_custom_data_types(*args) -> 'int'
    get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
    Get list of registered custom data type ids.
    
    @param out: (C++: intvec_t *) buffer for the output. may be nullptr
    @param min_size: (C++: asize_t) minimum value size
    @param max_size: (C++: asize_t) maximum value size
    @return: number of custom data types with the specified size limits

Help on function get_data_elsize in module ida_bytes:

get_data_elsize(*args) -> 'asize_t'
    get_data_elsize(ea, F, ti=None) -> asize_t
    Get size of data type specified in flags 'F'.
    
    @param ea: (C++: ea_t) linear address of the item
    @param F: (C++: flags_t) flags
    @param ti: (C++: const opinfo_t *) additional information about the data type. For example, if the
               current item is a structure instance, then ti->tid is structure id.
               Otherwise is ignored (may be nullptr). If specified as nullptr, will
               be automatically retrieved from the database
    @return: * byte : 1
    * word : 2
    * etc...

Help on function get_data_value in module ida_bytes:

get_data_value(*args) -> 'bool'
    get_data_value(v, ea, size) -> bool
    Get the value at of the item at 'ea'. This function works with entities up to
    sizeof(ea_t) (bytes, word, etc)
    
    @param v: (C++: uval_t *) pointer to the result. may be nullptr
    @param ea: (C++: ea_t) linear address
    @param size: (C++: asize_t) size of data to read. If 0, then the item type at 'ea' will be used
    @return: success

Help on function get_db_byte in module ida_bytes:

get_db_byte(*args) -> 'uchar'
    get_db_byte(ea) -> uchar
    Get one byte (8-bit) of the program at 'ea' from the database. Works even if the
    debugger is active. See also get_dbg_byte() to read the process memory directly.
    This function works only for 8bit byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_default_radix in module ida_bytes:

get_default_radix(*args) -> 'int'
    get_default_radix() -> int
    Get default base of number for the current processor.
    
    @return: 2, 8, 10, 16

Help on function get_dword in module ida_bytes:

get_dword(*args) -> 'uint32'
    get_dword(ea) -> uint32
    Get one dword (32-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_enum_id in module ida_bytes:

get_enum_id(*args) -> 'uchar *'
    get_enum_id(ea, n) -> enum_t
    Get enum id of 'enum' operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: id of enum or BADNODE

Help on function get_first_hidden_range in module ida_bytes:

get_first_hidden_range(*args) -> 'hidden_range_t *'
    get_first_hidden_range() -> hidden_range_t
    Get pointer to the first hidden range.
    
    @return: ptr to hidden range or nullptr

Help on function get_flags in module ida_bytes:

get_flags(*args) -> 'flags_t'
    get_flags(ea) -> flags_t
    get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because
    the kernel needs to read the process memory.
    
    @param ea: (C++: ea_t)

Help on function get_flags_by_size in module ida_bytes:

get_flags_by_size(*args) -> 'flags_t'
    get_flags_by_size(size) -> flags_t
    Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32. For other
    sizes returns 0
    
    @param size: (C++: size_t)

Help on function get_flags_ex in module ida_bytes:

get_flags_ex(*args) -> 'flags_t'
    get_flags_ex(ea, how) -> flags_t
    Get flags for the specified address, extended form.
    
    @param ea: (C++: ea_t)
    @param how: (C++: int)

Help on function get_forced_operand in module ida_bytes:

get_forced_operand(*args) -> 'qstring *'
    get_forced_operand(ea, n) -> str
    Get forced operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, 2)
    @return: size of forced operand or -1

Help on function get_full_data_elsize in module ida_bytes:

get_full_data_elsize(*args) -> 'asize_t'
    get_full_data_elsize(ea, F, ti=None) -> asize_t
    Get full size of data type specified in flags 'F'. takes into account processors
    with wide bytes e.g. returns 2 for a byte element with 16-bit bytes
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags_t)
    @param ti: (C++: const opinfo_t *) opinfo_t const *

Help on function get_full_flags in module ida_bytes:

get_full_flags(*args) -> 'flags_t'
    get_full_flags(ea) -> flags_t
    Get flags value for address 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 0 if address is not present in the program

Help on function get_hidden_range in module ida_bytes:

get_hidden_range(*args) -> 'hidden_range_t *'
    get_hidden_range(ea) -> hidden_range_t
    Get pointer to hidden range structure, in: linear address.
    
    @param ea: (C++: ea_t) any address in the hidden range

Help on function get_hidden_range_num in module ida_bytes:

get_hidden_range_num(*args) -> 'int'
    get_hidden_range_num(ea) -> int
    Get number of a hidden range.
    
    @param ea: (C++: ea_t) any address in the hidden range
    @return: number of hidden range (0..get_hidden_range_qty()-1)

Help on function get_hidden_range_qty in module ida_bytes:

get_hidden_range_qty(*args) -> 'int'
    get_hidden_range_qty() -> int
    Get number of hidden ranges.

Help on function get_item_end in module ida_bytes:

get_item_end(*args) -> 'ea_t'
    get_item_end(ea) -> ea_t
    Get the end address of the item at 'ea'. The returned address doesn't belong to
    the current item. Unexplored bytes are counted as 1 byte entities.
    
    @param ea: (C++: ea_t)

Help on function get_item_flag in module ida_bytes:

get_item_flag(*args) -> 'flags_t'
    get_item_flag(_from, n, ea, appzero) -> flags_t
    Get flag of the item at 'ea' even if it is a tail byte of some array or
    structure. This function is used to get flags of structure members or array
    elements.
    
    @param from: (C++: ea_t) linear address of the instruction which refers to 'ea'
    @param n: (C++: int) number of operand which refers to 'ea'
    @param ea: (C++: ea_t) the referenced address
    @param appzero: (C++: bool) append a struct field name if the field offset is zero?
                    meaningful only if the name refers to a structure.
    @return: flags or 0 (if failed)

Help on function get_item_head in module ida_bytes:

get_item_head(*args) -> 'ea_t'
    get_item_head(ea) -> ea_t
    Get the start address of the item at 'ea'. If there is no current item, then
    'ea' will be returned (see definition at the end of bytes.hpp source)
    
    @param ea: (C++: ea_t)

Help on function get_item_size in module ida_bytes:

get_item_size(*args) -> 'asize_t'
    get_item_size(ea) -> asize_t
    Get size of item (instruction/data) in bytes. Unexplored bytes have length of 1
    byte. This function never returns 0.
    
    @param ea: (C++: ea_t)

Help on function get_last_hidden_range in module ida_bytes:

get_last_hidden_range(*args) -> 'hidden_range_t *'
    get_last_hidden_range() -> hidden_range_t
    Get pointer to the last hidden range.
    
    @return: ptr to hidden range or nullptr

Help on function get_manual_insn in module ida_bytes:

get_manual_insn(*args) -> 'qstring *'
    get_manual_insn(ea) -> str
    Retrieve the user-specified string for the manual instruction.
    
    @param ea: (C++: ea_t) linear address of the instruction or data item
    @return: size of manual instruction or -1

Help on function get_mapping in module ida_bytes:

get_mapping(*args) -> 'ea_t *, ea_t *, asize_t *'
    get_mapping(n) -> bool
    Get memory mapping range by its number.
    
    @param n: (C++: size_t) number of mapping range (0..get_mappings_qty()-1)
    @return: false if the specified range doesn't exist, otherwise returns `from',
             `to', `size'

Help on function get_mappings_qty in module ida_bytes:

get_mappings_qty(*args) -> 'size_t'
    get_mappings_qty() -> size_t
    Get number of mappings.

Help on function get_max_strlit_length in module ida_bytes:

get_max_strlit_length(*args) -> 'size_t'
    get_max_strlit_length(ea, strtype, options=0) -> size_t
    Determine maximum length of string literal.
    
    If the string literal has a length prefix (e.g., STRTYPE_LEN2 has a two-byte
    length prefix), the length of that prefix (i.e., 2) will be part of the returned
    value.
    
    @param ea: (C++: ea_t) starting address
    @param strtype: (C++: int32) string type. one of String type codes
    @param options: (C++: int) combination of string literal length options
    @return: length of the string in octets (octet==8bit)

Help on function get_next_hidden_range in module ida_bytes:

get_next_hidden_range(*args) -> 'hidden_range_t *'
    get_next_hidden_range(ea) -> hidden_range_t
    Get pointer to next hidden range.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to hidden range or nullptr if next hidden range doesn't exist

Help on function get_octet in module ida_bytes:

get_octet(*args) -> 'PyObject *'
    get_octet(ea, v, nbit) -> (int, int, int, int)
    
    @param ea: ea_t
    @param v: uint64
    @param nbit: int

Help on function get_octet2 in module ida_bytes:

get_octet2(*args) -> 'uchar *'
    get_octet2(ogen) -> bool
    
    @param ogen: octet_generator_t *

Help on function get_opinfo in module ida_bytes:

get_opinfo(*args) -> 'opinfo_t *'
    get_opinfo(buf, ea, n, flags) -> opinfo_t
    Get additional information about an operand representation.
    
    @param buf: (C++: opinfo_t *) buffer to receive the result. may not be nullptr
    @param ea: (C++: ea_t) linear address of item
    @param n: (C++: int) number of operand, 0 or 1
    @param flags: (C++: flags_t) flags of the item
    @return: nullptr if no additional representation information

Help on function get_optype_flags0 in module ida_bytes:

get_optype_flags0(*args) -> 'flags_t'
    get_optype_flags0(F) -> flags_t
    Get flags for first operand.
    
    @param F: (C++: flags_t)

Help on function get_optype_flags1 in module ida_bytes:

get_optype_flags1(*args) -> 'flags_t'
    get_optype_flags1(F) -> flags_t
    Get flags for second operand.
    
    @param F: (C++: flags_t)

Help on function get_original_byte in module ida_bytes:

get_original_byte(*args) -> 'uint64'
    get_original_byte(ea) -> uint64
    Get original byte value (that was before patching). This function works for wide
    byte processors too.
    
    @param ea: (C++: ea_t)

Help on function get_original_dword in module ida_bytes:

get_original_dword(*args) -> 'uint64'
    get_original_dword(ea) -> uint64
    Get original dword (that was before patching) This function works for wide byte
    processors too. This function takes into account order of bytes specified in
    idainfo::is_be()
    
    @param ea: (C++: ea_t)

Help on function get_original_qword in module ida_bytes:

get_original_qword(*args) -> 'uint64'
    get_original_qword(ea) -> uint64
    Get original qword value (that was before patching) This function DOESN'T work
    for wide byte processors too. This function takes into account order of bytes
    specified in idainfo::is_be()
    
    @param ea: (C++: ea_t)

Help on function get_original_word in module ida_bytes:

get_original_word(*args) -> 'uint64'
    get_original_word(ea) -> uint64
    Get original word value (that was before patching). This function works for wide
    byte processors too. This function takes into account order of bytes specified
    in idainfo::is_be()
    
    @param ea: (C++: ea_t)

Help on function get_predef_insn_cmt in module ida_bytes:

get_predef_insn_cmt(*args) -> 'qstring *'
    get_predef_insn_cmt(ins) -> str
    Get predefined comment.
    
    @param ins: (C++: const insn_t &) current instruction information
    @return: size of comment or -1

Help on function get_prev_hidden_range in module ida_bytes:

get_prev_hidden_range(*args) -> 'hidden_range_t *'
    get_prev_hidden_range(ea) -> hidden_range_t
    Get pointer to previous hidden range.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to hidden range or nullptr if previous hidden range doesn't exist

Help on function get_qword in module ida_bytes:

get_qword(*args) -> 'uint64'
    get_qword(ea) -> uint64
    Get one qword (64-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_radix in module ida_bytes:

get_radix(*args) -> 'int'
    get_radix(F, n) -> int
    Get radix of the operand, in: flags. If the operand is not a number, returns
    get_default_radix()
    
    @param F: (C++: flags_t) flags
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: 2, 8, 10, 16

Help on function get_strlit_contents in module ida_bytes:

get_strlit_contents(*args) -> 'PyObject *'
    get_strlit_contents(ea, py_len, type, flags=0) -> bytes or None
    Get contents of string literal, as UTF-8-encoded codepoints.
    It works even if the string has not been created in the database yet.
    
    Note that the returned value will be of type 'bytes'; if
    you want auto-conversion to unicode strings (that is: real Python
    strings), you should probably be using the idautils.Strings class.
    
    @param ea: linear address of the string
    @param py_len: length of the string in bytes (including terminating 0)
    @param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    @param flags: combination of STRCONV_..., to perform output conversion.
    @return: a bytes-filled str object.

Help on function get_stroff_path in module ida_bytes:

get_stroff_path(*args) -> 'int'
    get_stroff_path(path, delta, ea, n) -> int
    Get struct path of operand.
    
    @param path: (C++: tid_t *) buffer for structure path (strpath). see nalt.hpp for more info.
    @param delta: (C++: adiff_t *) struct offset delta
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: length of strpath

Help on function get_wide_byte in module ida_bytes:

get_wide_byte(*args) -> 'uint64'
    get_wide_byte(ea) -> uint64
    Get one wide byte of the program at 'ea'. Some processors may access more than
    8bit quantity at an address. These processors have 32-bit byte organization from
    the IDA's point of view.
    
    @param ea: (C++: ea_t)

Help on function get_wide_dword in module ida_bytes:

get_wide_dword(*args) -> 'uint64'
    get_wide_dword(ea) -> uint64
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors may
    access more than 8bit quantity at an address. These processors have 32-bit byte
    organization from the IDA's point of view. This function takes into account
    order of bytes specified in idainfo::is_be()
    @note: this function works incorrectly if processor_t::nbits > 16
    
    @param ea: (C++: ea_t)

Help on function get_wide_word in module ida_bytes:

get_wide_word(*args) -> 'uint64'
    get_wide_word(ea) -> uint64
    Get one wide word (2 'byte') of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit byte
    organization from the IDA's point of view. This function takes into account
    order of bytes specified in idainfo::is_be()
    
    @param ea: (C++: ea_t)

Help on function get_word in module ida_bytes:

get_word(*args) -> 'ushort'
    get_word(ea) -> ushort
    Get one word (16-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_zero_ranges in module ida_bytes:

get_zero_ranges(*args) -> 'bool'
    get_zero_ranges(zranges, range) -> bool
    Return set of ranges with zero initialized bytes. The returned set includes only
    big zero initialized ranges (at least >1KB). Some zero initialized byte ranges
    may be not included. Only zero bytes that use the sparse storage method (STT_MM)
    are reported.
    
    @param zranges: (C++: rangeset_t *) pointer to the return value. cannot be nullptr
    @param range: (C++: const range_t *) the range of addresses to verify. can be nullptr - means all
                  ranges
    @return: true if the result is a non-empty set

Help on function getn_hidden_range in module ida_bytes:

getn_hidden_range(*args) -> 'hidden_range_t *'
    getn_hidden_range(n) -> hidden_range_t
    Get pointer to hidden range structure, in: number of hidden range.
    
    @param n: (C++: int) number of hidden range, is in range 0..get_hidden_range_qty()-1

Help on function has_any_name in module ida_bytes:

has_any_name(*args) -> 'bool'
    has_any_name(F) -> bool
    Does the current byte have any name?
    
    @param F: (C++: flags_t)

Help on function has_auto_name in module ida_bytes:

has_auto_name(*args) -> 'bool'
    has_auto_name(F) -> bool
    Does the current byte have auto-generated (no special prefix) name?
    
    @param F: (C++: flags_t)

Help on function has_cmt in module ida_bytes:

has_cmt(*args) -> 'bool'
    has_cmt(F) -> bool
    Does the current byte have an indented comment?
    
    @param F: (C++: flags_t)

Help on function has_dummy_name in module ida_bytes:

has_dummy_name(*args) -> 'bool'
    has_dummy_name(F) -> bool
    Does the current byte have dummy (auto-generated, with special prefix) name?
    
    @param F: (C++: flags_t)

Help on function has_extra_cmts in module ida_bytes:

has_extra_cmts(*args) -> 'bool'
    has_extra_cmts(F) -> bool
    Does the current byte have additional anterior or posterior lines?
    
    @param F: (C++: flags_t)

Help on function has_immd in module ida_bytes:

has_immd(*args) -> 'bool'
    has_immd(F) -> bool
    Has immediate value?
    
    @param F: (C++: flags_t)

Help on function has_name in module ida_bytes:

has_name(*args) -> 'bool'
    has_name(F) -> bool
    Does the current byte have non-trivial (non-dummy) name?
    
    @param F: (C++: flags_t)

Help on function has_user_name in module ida_bytes:

has_user_name(*args) -> 'bool'
    has_user_name(F) -> bool
    Does the current byte have user-specified name?
    
    @param F: (C++: flags_t)

Help on function has_value in module ida_bytes:

has_value(*args) -> 'bool'
    has_value(F) -> bool
    Do flags contain byte value?
    
    @param F: (C++: flags_t)

Help on function has_xref in module ida_bytes:

has_xref(*args) -> 'bool'
    has_xref(F) -> bool
    Does the current byte have cross-references to it?
    
    @param F: (C++: flags_t)

Help on function hex_flag in module ida_bytes:

hex_flag(*args) -> 'flags_t'
    hex_flag() -> flags_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

Help on class hidden_range_t in module ida_bytes:

class hidden_range_t(ida_range.range_t)
 |  Proxy of C++ hidden_range_t class.
 |  
 |  Method resolution order:
 |      hidden_range_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hidden_range_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_hidden_range_t(...)
 |      delete_hidden_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  color
 |      color
 |  
 |  description
 |      description
 |  
 |  footer
 |      footer
 |  
 |  header
 |      header
 |  
 |  thisown
 |      The membership flag
 |  
 |  visible
 |      visible
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function is_align in module ida_bytes:

is_align(*args) -> 'bool'
    is_align(F) -> bool
    FF_ALIGN
    
    @param F: (C++: flags_t)

Help on function is_attached_custom_data_format in module ida_bytes:

is_attached_custom_data_format(*args) -> 'bool'
    is_attached_custom_data_format(dtid, dfid) -> bool
    Is the custom data format attached to the custom data type?
    
    @param dtid: (C++: int) data type id
    @param dfid: (C++: int) data format id
    @return: true or false

Help on function is_bnot in module ida_bytes:

is_bnot(*args) -> 'bool'
    is_bnot(ea, F, n) -> bool
    Should we negate the operand?. asm_t::a_bnot should be defined in the idp module
    in order to work with this function
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_byte in module ida_bytes:

is_byte(*args) -> 'bool'
    is_byte(F) -> bool
    FF_BYTE
    
    @param F: (C++: flags_t)

Help on function is_char in module ida_bytes:

is_char(*args) -> 'bool'
    is_char(F, n) -> bool
    is character constant?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_char0 in module ida_bytes:

is_char0(*args) -> 'bool'
    is_char0(F) -> bool
    Is the first operand character constant? (example: push 'a')
    
    @param F: (C++: flags_t)

Help on function is_char1 in module ida_bytes:

is_char1(*args) -> 'bool'
    is_char1(F) -> bool
    Is the second operand character constant? (example: mov al, 'a')
    
    @param F: (C++: flags_t)

Help on function is_code in module ida_bytes:

is_code(*args) -> 'bool'
    is_code(F) -> bool
    Does flag denote start of an instruction?
    
    @param F: (C++: flags_t)

Help on function is_custfmt in module ida_bytes:

is_custfmt(*args) -> 'bool'
    is_custfmt(F, n) -> bool
    is custom data format?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_custfmt0 in module ida_bytes:

is_custfmt0(*args) -> 'bool'
    is_custfmt0(F) -> bool
    Does the first operand use a custom data representation?
    
    @param F: (C++: flags_t)

Help on function is_custfmt1 in module ida_bytes:

is_custfmt1(*args) -> 'bool'
    is_custfmt1(F) -> bool
    Does the second operand use a custom data representation?
    
    @param F: (C++: flags_t)

Help on function is_custom in module ida_bytes:

is_custom(*args) -> 'bool'
    is_custom(F) -> bool
    FF_CUSTOM
    
    @param F: (C++: flags_t)

Help on function is_data in module ida_bytes:

is_data(*args) -> 'bool'
    is_data(F) -> bool
    Does flag denote start of data?
    
    @param F: (C++: flags_t)

Help on function is_defarg in module ida_bytes:

is_defarg(*args) -> 'bool'
    is_defarg(F, n) -> bool
    is defined?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_defarg0 in module ida_bytes:

is_defarg0(*args) -> 'bool'
    is_defarg0(F) -> bool
    Is the first operand defined? Initially operand has no defined representation.
    
    @param F: (C++: flags_t)

Help on function is_defarg1 in module ida_bytes:

is_defarg1(*args) -> 'bool'
    is_defarg1(F) -> bool
    Is the second operand defined? Initially operand has no defined representation.
    
    @param F: (C++: flags_t)

Help on function is_double in module ida_bytes:

is_double(*args) -> 'bool'
    is_double(F) -> bool
    FF_DOUBLE
    
    @param F: (C++: flags_t)

Help on function is_dword in module ida_bytes:

is_dword(*args) -> 'bool'
    is_dword(F) -> bool
    FF_DWORD
    
    @param F: (C++: flags_t)

Help on function is_enum in module ida_bytes:

is_enum(*args) -> 'bool'
    is_enum(F, n) -> bool
    is enum?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_enum0 in module ida_bytes:

is_enum0(*args) -> 'bool'
    is_enum0(F) -> bool
    Is the first operand a symbolic constant (enum member)?
    
    @param F: (C++: flags_t)

Help on function is_enum1 in module ida_bytes:

is_enum1(*args) -> 'bool'
    is_enum1(F) -> bool
    Is the second operand a symbolic constant (enum member)?
    
    @param F: (C++: flags_t)

Help on function is_float in module ida_bytes:

is_float(*args) -> 'bool'
    is_float(F) -> bool
    FF_FLOAT
    
    @param F: (C++: flags_t)

Help on function is_float0 in module ida_bytes:

is_float0(*args) -> 'bool'
    is_float0(F) -> bool
    Is the first operand a floating point number?
    
    @param F: (C++: flags_t)

Help on function is_float1 in module ida_bytes:

is_float1(*args) -> 'bool'
    is_float1(F) -> bool
    Is the second operand a floating point number?
    
    @param F: (C++: flags_t)

Help on function is_flow in module ida_bytes:

is_flow(*args) -> 'bool'
    is_flow(F) -> bool
    Does the previous instruction exist and pass execution flow to the current byte?
    
    @param F: (C++: flags_t)

Help on function is_fltnum in module ida_bytes:

is_fltnum(*args) -> 'bool'
    is_fltnum(F, n) -> bool
    is floating point number?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_forced_operand in module ida_bytes:

is_forced_operand(*args) -> 'bool'
    is_forced_operand(ea, n) -> bool
    Is operand manually defined?.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, 2)

Help on function is_func in module ida_bytes:

is_func(*args) -> 'bool'
    is_func(F) -> bool
    Is function start?
    
    @param F: (C++: flags_t)

Help on function is_head in module ida_bytes:

is_head(*args) -> 'bool'
    is_head(F) -> bool
    Does flag denote start of instruction OR data?
    
    @param F: (C++: flags_t)

Help on function is_invsign in module ida_bytes:

is_invsign(*args) -> 'bool'
    is_invsign(ea, F, n) -> bool
    Should sign of n-th operand inverted during output?. allowed values of n:
    0-first operand, 1-other operands
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_loaded in module ida_bytes:

is_loaded(*args) -> 'bool'
    is_loaded(ea) -> bool
    Does the specified address have a byte value (is initialized?)
    
    @param ea: (C++: ea_t)

Help on function is_lzero in module ida_bytes:

is_lzero(*args) -> 'bool'
    is_lzero(ea, n) -> bool
    Display leading zeroes? Display leading zeroes in operands. The global switch
    for the leading zeroes is in idainfo::s_genflags Note: the leading zeroes
    doesn't work if for the target assembler octal numbers start with 0.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

Help on function is_manual in module ida_bytes:

is_manual(*args) -> 'bool'
    is_manual(F, n) -> bool
    is forced operand? (use is_forced_operand())
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_manual_insn in module ida_bytes:

is_manual_insn(*args) -> 'bool'
    is_manual_insn(ea) -> bool
    Is the instruction overridden?
    
    @param ea: (C++: ea_t) linear address of the instruction or data item

Help on function is_mapped in module ida_bytes:

is_mapped(*args) -> 'bool'
    is_mapped(ea) -> bool
    Is the specified address 'ea' present in the program?
    
    @param ea: (C++: ea_t)

Help on function is_not_tail in module ida_bytes:

is_not_tail(*args) -> 'bool'
    is_not_tail(F) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags_t)

Help on function is_numop in module ida_bytes:

is_numop(*args) -> 'bool'
    is_numop(F, n) -> bool
    is number (bin, oct, dec, hex)?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_numop0 in module ida_bytes:

is_numop0(*args) -> 'bool'
    is_numop0(F) -> bool
    Is the first operand a number (i.e. binary, octal, decimal or hex?)
    
    @param F: (C++: flags_t)

Help on function is_numop1 in module ida_bytes:

is_numop1(*args) -> 'bool'
    is_numop1(F) -> bool
    Is the second operand a number (i.e. binary, octal, decimal or hex?)
    
    @param F: (C++: flags_t)

Help on function is_off in module ida_bytes:

is_off(*args) -> 'bool'
    is_off(F, n) -> bool
    is offset?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_off0 in module ida_bytes:

is_off0(*args) -> 'bool'
    is_off0(F) -> bool
    Is the first operand offset? (example: push offset xxx)
    
    @param F: (C++: flags_t)

Help on function is_off1 in module ida_bytes:

is_off1(*args) -> 'bool'
    is_off1(F) -> bool
    Is the second operand offset? (example: mov ax, offset xxx)
    
    @param F: (C++: flags_t)

Help on function is_oword in module ida_bytes:

is_oword(*args) -> 'bool'
    is_oword(F) -> bool
    FF_OWORD
    
    @param F: (C++: flags_t)

Help on function is_pack_real in module ida_bytes:

is_pack_real(*args) -> 'bool'
    is_pack_real(F) -> bool
    FF_PACKREAL
    
    @param F: (C++: flags_t)

Help on function is_qword in module ida_bytes:

is_qword(*args) -> 'bool'
    is_qword(F) -> bool
    FF_QWORD
    
    @param F: (C++: flags_t)

Help on function is_same_data_type in module ida_bytes:

is_same_data_type(*args) -> 'bool'
    is_same_data_type(F1, F2) -> bool
    Do the given flags specify the same data type?
    
    @param F1: (C++: flags_t)
    @param F2: (C++: flags_t)

Help on function is_seg in module ida_bytes:

is_seg(*args) -> 'bool'
    is_seg(F, n) -> bool
    is segment?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_seg0 in module ida_bytes:

is_seg0(*args) -> 'bool'
    is_seg0(F) -> bool
    Is the first operand segment selector? (example: push seg seg001)
    
    @param F: (C++: flags_t)

Help on function is_seg1 in module ida_bytes:

is_seg1(*args) -> 'bool'
    is_seg1(F) -> bool
    Is the second operand segment selector? (example: mov dx, seg dseg)
    
    @param F: (C++: flags_t)

Help on function is_stkvar in module ida_bytes:

is_stkvar(*args) -> 'bool'
    is_stkvar(F, n) -> bool
    is stack variable?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_stkvar0 in module ida_bytes:

is_stkvar0(*args) -> 'bool'
    is_stkvar0(F) -> bool
    Is the first operand a stack variable?
    
    @param F: (C++: flags_t)

Help on function is_stkvar1 in module ida_bytes:

is_stkvar1(*args) -> 'bool'
    is_stkvar1(F) -> bool
    Is the second operand a stack variable?
    
    @param F: (C++: flags_t)

Help on function is_strlit in module ida_bytes:

is_strlit(*args) -> 'bool'
    is_strlit(F) -> bool
    FF_STRLIT
    
    @param F: (C++: flags_t)

Help on function is_stroff in module ida_bytes:

is_stroff(*args) -> 'bool'
    is_stroff(F, n) -> bool
    is struct offset?
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_stroff0 in module ida_bytes:

is_stroff0(*args) -> 'bool'
    is_stroff0(F) -> bool
    Is the first operand an offset within a struct?
    
    @param F: (C++: flags_t)

Help on function is_stroff1 in module ida_bytes:

is_stroff1(*args) -> 'bool'
    is_stroff1(F) -> bool
    Is the second operand an offset within a struct?
    
    @param F: (C++: flags_t)

Help on function is_struct in module ida_bytes:

is_struct(*args) -> 'bool'
    is_struct(F) -> bool
    FF_STRUCT
    
    @param F: (C++: flags_t)

Help on function is_suspop in module ida_bytes:

is_suspop(*args) -> 'bool'
    is_suspop(ea, F, n) -> bool
    is suspicious operand?
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function is_tail in module ida_bytes:

is_tail(*args) -> 'bool'
    is_tail(F) -> bool
    Does flag denote tail byte?
    
    @param F: (C++: flags_t)

Help on function is_tbyte in module ida_bytes:

is_tbyte(*args) -> 'bool'
    is_tbyte(F) -> bool
    FF_TBYTE
    
    @param F: (C++: flags_t)

Help on function is_unknown in module ida_bytes:

is_unknown(*args) -> 'bool'
    is_unknown(F) -> bool
    Does flag denote unexplored byte?
    
    @param F: (C++: flags_t)

Help on function is_varsize_item in module ida_bytes:

is_varsize_item(*args) -> 'int'
    is_varsize_item(ea, F, ti=None, itemsize=None) -> int
    Is the item at 'ea' variable size?.
    
    @param ea: (C++: ea_t) linear address of the item
    @param F: (C++: flags_t) flags
    @param ti: (C++: const opinfo_t *) additional information about the data type. For example, if the
               current item is a structure instance, then ti->tid is structure id.
               Otherwise is ignored (may be nullptr). If specified as nullptr, will
               be automatically retrieved from the database
    @param itemsize: (C++: asize_t *) if not nullptr and the item is varsize, itemsize will contain
                     the calculated item size (for struct types, the minimal size is
                     returned)
    @retval 1: varsize item
    @retval 0: fixed item
    @retval -1: error (bad data definition)

Help on function is_word in module ida_bytes:

is_word(*args) -> 'bool'
    is_word(F) -> bool
    FF_WORD
    
    @param F: (C++: flags_t)

Help on function is_yword in module ida_bytes:

is_yword(*args) -> 'bool'
    is_yword(F) -> bool
    FF_YWORD
    
    @param F: (C++: flags_t)

Help on function is_zword in module ida_bytes:

is_zword(*args) -> 'bool'
    is_zword(F) -> bool
    FF_ZWORD
    
    @param F: (C++: flags_t)

Help on function leading_zero_important in module ida_bytes:

leading_zero_important(*args) -> 'bool'
    leading_zero_important(ea, n) -> bool
    Check if leading zeroes are important.
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function nbits in module ida_bytes:

nbits(*args) -> 'int'
    nbits(ea) -> int
    Get number of bits in a byte at the given address.
    
    @param ea: (C++: ea_t)
    @return: processor_t::dnbits() if the address doesn't belong to a segment,
             otherwise the result depends on the segment type

Help on function next_addr in module ida_bytes:

next_addr(*args) -> 'ea_t'
    next_addr(ea) -> ea_t
    Get next address in the program (i.e. next address which has flags).
    
    @param ea: (C++: ea_t)
    @return: BADADDR if no such address exist.

Help on function next_chunk in module ida_bytes:

next_chunk(*args) -> 'ea_t'
    next_chunk(ea) -> ea_t
    Get the first address of next contiguous chunk in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if next chunk doesn't exist.

Help on function next_head in module ida_bytes:

next_head(*args) -> 'ea_t'
    next_head(ea, maxea) -> ea_t
    Get start of next defined item.
    
    @param ea: (C++: ea_t) begin search at this address
    @param maxea: (C++: ea_t) not included in the search range
    @return: BADADDR if none exists.

Help on function next_inited in module ida_bytes:

next_inited(*args) -> 'ea_t'
    next_inited(ea, maxea) -> ea_t
    Find the next initialized address.
    
    @param ea: (C++: ea_t)
    @param maxea: (C++: ea_t)

Help on function next_not_tail in module ida_bytes:

next_not_tail(*args) -> 'ea_t'
    next_not_tail(ea) -> ea_t
    Get address of next non-tail byte.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

Help on function next_that in module ida_bytes:

next_that(*args) -> 'ea_t'
    next_that(ea, maxea, testf) -> ea_t
    Find next address with a flag satisfying the function 'testf'.
    @note: do not pass is_unknown() to this function to find unexplored bytes. It
           will fail under the debugger. To find unexplored bytes, use
           next_unknown().
    
    @param ea: (C++: ea_t) start searching at this address + 1
    @param maxea: (C++: ea_t) not included in the search range.
    @param testf: (C++: testf_t *) test function to find next address
    @return: the found address or BADADDR.

Help on function next_unknown in module ida_bytes:

next_unknown(*args) -> 'ea_t'
    next_unknown(ea, maxea) -> ea_t
    Similar to next_that(), but will find the next address that is unexplored.
    
    @param ea: (C++: ea_t)
    @param maxea: (C++: ea_t)

Help on function next_visea in module ida_bytes:

next_visea(*args) -> 'ea_t'
    next_visea(ea) -> ea_t
    Get next visible address.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

Help on function num_flag in module ida_bytes:

num_flag(*args) -> 'flags_t'
    num_flag() -> flags_t
    Get number of default base (bin, oct, dec, hex)

Help on function oct_flag in module ida_bytes:

oct_flag(*args) -> 'flags_t'
    oct_flag() -> flags_t
    Get number flag of the base, regardless of current processor - better to use
    num_flag()

Help on class octet_generator_t in module ida_bytes:

class octet_generator_t(builtins.object)
 |  Proxy of C++ octet_generator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> octet_generator_t
 |      
 |      @param _ea: ea_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_octet_generator_t(...)
 |      delete_octet_generator_t(self)
 |  
 |  invert_byte_order(self, *args) -> 'void'
 |      invert_byte_order(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  avail_bits
 |      avail_bits
 |  
 |  ea
 |      ea
 |  
 |  high_byte_first
 |      high_byte_first
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value

Help on function off_flag in module ida_bytes:

off_flag(*args) -> 'flags_t'
    off_flag() -> flags_t
    see Bits: instruction operand types

Help on function op_adds_xrefs in module ida_bytes:

op_adds_xrefs(*args) -> 'bool'
    op_adds_xrefs(F, n) -> bool
    Should processor module create xrefs from the operand?. Currently 'offset' and
    'structure offset' operands create xrefs
    
    @param F: (C++: flags_t)
    @param n: (C++: int)

Help on function op_bin in module ida_bytes:

op_bin(*args) -> 'bool'
    op_bin(ea, n) -> bool
    set op type to bin_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_chr in module ida_bytes:

op_chr(*args) -> 'bool'
    op_chr(ea, n) -> bool
    set op type to char_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_custfmt in module ida_bytes:

op_custfmt(*args) -> 'bool'
    op_custfmt(ea, n, fid) -> bool
    Set custom data format for operand (fid-custom data format id)
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param fid: (C++: int)

Help on function op_dec in module ida_bytes:

op_dec(*args) -> 'bool'
    op_dec(ea, n) -> bool
    set op type to dec_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_enum in module ida_bytes:

op_enum(*args) -> 'bool'
    op_enum(ea, n, id, serial) -> bool
    Set operand representation to be 'enum_t'. If applied to unexplored bytes,
    converts them to 16/32bit word data
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @param id: (C++: enum_t) id of enum
    @param serial: (C++: uchar) the serial number of the constant in the enumeration, usually 0.
                   the serial numbers are used if the enumeration contains several
                   constants with the same value
    @return: success

Help on function op_flt in module ida_bytes:

op_flt(*args) -> 'bool'
    op_flt(ea, n) -> bool
    set op type to flt_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_hex in module ida_bytes:

op_hex(*args) -> 'bool'
    op_hex(ea, n) -> bool
    set op type to hex_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_num in module ida_bytes:

op_num(*args) -> 'bool'
    op_num(ea, n) -> bool
    set op type to num_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_oct in module ida_bytes:

op_oct(*args) -> 'bool'
    op_oct(ea, n) -> bool
    set op type to oct_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_seg in module ida_bytes:

op_seg(*args) -> 'bool'
    op_seg(ea, n) -> bool
    Set operand representation to be 'segment'. If applied to unexplored bytes,
    converts them to 16/32bit word data
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: success

Help on function op_stkvar in module ida_bytes:

op_stkvar(*args) -> 'bool'
    op_stkvar(ea, n) -> bool
    Set operand representation to be 'stack variable'. Should be applied to an
    instruction within a function. Should be applied after creating a stack var
    using insn_t::create_stkvar().
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: success

Help on function op_stroff in module ida_bytes:

op_stroff(*args) -> 'bool'
    op_stroff(insn, n, path, path_len, delta) -> bool
    Set operand representation to be 'struct offset'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    @param insn: (C++: const insn_t &) the instruction
    @param n: (C++: int) number of operand (0, 1, -1)
    @param path: (C++: const tid_t *) structure path (strpath). see nalt.hpp for more info.
    @param path_len: (C++: int) length of the structure path
    @param delta: (C++: adiff_t) struct offset delta. usually 0. denotes the difference between the
                  structure base and the pointer into the structure.
    @return: success

Help on function oword_flag in module ida_bytes:

oword_flag(*args) -> 'flags_t'
    oword_flag() -> flags_t
    Get a flags_t representing a octaword.

Help on function packreal_flag in module ida_bytes:

packreal_flag(*args) -> 'flags_t'
    packreal_flag() -> flags_t
    Get a flags_t representing a packed decimal real.

Help on function parse_binpat_str in module ida_bytes:

parse_binpat_str(*args) -> 'qstring *'
    parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -> str
    Convert user-specified binary string to internal representation. The 'in'
    parameter contains space-separated tokens:
    - numbers (numeric base is determined by 'radix')
    - if value of number fits a byte, it is considered as a byte
    - if value of number fits a word, it is considered as 2 bytes
    - if value of number fits a dword,it is considered as 4 bytes
    - "..." string constants
    - 'x'  single-character constants
    - ?    variable bytes
    
    Note that string constants are surrounded with double quotes.
    
    Here are a few examples (assuming base 16):
    CD 21          - bytes 0xCD, 0x21
    21CD           - bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)
    "Hello", 0     - the null terminated string "Hello"
    L"Hello"       - 'H', 0, 'e', 0, 'l', 0, 'l', 0, 'o', 0
    B8 ? ? ? ? 90  - byte 0xB8, 4 bytes with any value, byte 0x90
    
    @param out: (C++: compiled_binpat_vec_t *) a vector of compiled binary patterns, for use with bin_search2()
    @param ea: (C++: ea_t) linear address to convert for (the conversion depends on the address,
               because the number of bits in a byte depend on the segment type)
    @param in: (C++: const char *) input text string
    @param radix: (C++: int) numeric base of numbers (8,10,16)
    @param strlits_encoding: (C++: int) the target encoding into which the string literals
                             present in 'in', should be encoded. Can be any from [1,
                             get_encoding_qty()), or the special values PBSENC_*
    @return: false either in case of parsing error, or if at least one requested
             target encoding couldn't encode the string literals present in "in".

Help on function patch_byte in module ida_bytes:

patch_byte(*args) -> 'bool'
    patch_byte(ea, x) -> bool
    Patch a byte of the program. The original value of the byte is saved and can be
    obtained by get_original_byte(). This function works for wide byte processors
    too.
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function patch_bytes in module ida_bytes:

patch_bytes(*args) -> 'void'
    patch_bytes(ea, buf)
    Patch the specified number of bytes of the program. Original values of bytes are
    saved and are available with get_original...() functions. See also put_bytes().
    
    @param ea: (C++: ea_t) linear address
    @param buf: (C++: const void *) buffer with new values of bytes

Help on function patch_dword in module ida_bytes:

patch_dword(*args) -> 'bool'
    patch_dword(ea, x) -> bool
    Patch a dword of the program. The original value of the dword is saved and can
    be obtained by get_original_dword(). This function DOESN'T work for wide byte
    processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function patch_qword in module ida_bytes:

patch_qword(*args) -> 'bool'
    patch_qword(ea, x) -> bool
    Patch a qword of the program. The original value of the qword is saved and can
    be obtained by get_original_qword(). This function DOESN'T work for wide byte
    processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function patch_word in module ida_bytes:

patch_word(*args) -> 'bool'
    patch_word(ea, x) -> bool
    Patch a word of the program. The original value of the word is saved and can be
    obtained by get_original_word(). This function works for wide byte processors
    too. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function prev_addr in module ida_bytes:

prev_addr(*args) -> 'ea_t'
    prev_addr(ea) -> ea_t
    Get previous address in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if no such address exist.

Help on function prev_chunk in module ida_bytes:

prev_chunk(*args) -> 'ea_t'
    prev_chunk(ea) -> ea_t
    Get the last address of previous contiguous chunk in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if previous chunk doesn't exist.

Help on function prev_head in module ida_bytes:

prev_head(*args) -> 'ea_t'
    prev_head(ea, minea) -> ea_t
    Get start of previous defined item.
    
    @param ea: (C++: ea_t) begin search at this address
    @param minea: (C++: ea_t) included in the search range
    @return: BADADDR if none exists.

Help on function prev_inited in module ida_bytes:

prev_inited(*args) -> 'ea_t'
    prev_inited(ea, minea) -> ea_t
    Find the previous initialized address.
    
    @param ea: (C++: ea_t)
    @param minea: (C++: ea_t)

Help on function prev_not_tail in module ida_bytes:

prev_not_tail(*args) -> 'ea_t'
    prev_not_tail(ea) -> ea_t
    Get address of previous non-tail byte.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

Help on function prev_that in module ida_bytes:

prev_that(*args) -> 'ea_t'
    prev_that(ea, minea, testf) -> ea_t
    Find previous address with a flag satisfying the function 'testf'.
    @note: do not pass is_unknown() to this function to find unexplored bytes It
           will fail under the debugger. To find unexplored bytes, use
           prev_unknown().
    
    @param ea: (C++: ea_t) start searching from this address - 1.
    @param minea: (C++: ea_t) included in the search range.
    @param testf: (C++: testf_t *) test function to find previous address
    @return: the found address or BADADDR.

Help on function prev_unknown in module ida_bytes:

prev_unknown(*args) -> 'ea_t'
    prev_unknown(ea, minea) -> ea_t
    Similar to prev_that(), but will find the previous address that is unexplored.
    
    @param ea: (C++: ea_t)
    @param minea: (C++: ea_t)

Help on function prev_visea in module ida_bytes:

prev_visea(*args) -> 'ea_t'
    prev_visea(ea) -> ea_t
    Get previous visible address.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

Help on function print_strlit_type in module ida_bytes:

print_strlit_type(*args) -> 'PyObject *'
    print_strlit_type(strtype, flags=0) -> (str, str)
    Get string type information: the string type name (possibly decorated with
    hotkey markers), and the tooltip.
    
    @param strtype: (C++: int32) the string type
    @param flags: (C++: int) or'ed PSTF_* constants
    @return: length of generated text

Help on function put_byte in module ida_bytes:

put_byte(*args) -> 'bool'
    put_byte(ea, x) -> bool
    Set value of one byte of the program. This function modifies the database. If
    the debugger is active then the debugged process memory is patched too.
    @note: The original value of the byte is completely lost and can't be recovered
           by the get_original_byte() function. See also put_dbg_byte() to write to
           the process memory directly when the debugger is active. This function
           can handle wide byte processors.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint64) byte value
    @return: true if the database has been modified

Help on function put_bytes in module ida_bytes:

put_bytes(*args) -> 'void'
    put_bytes(ea, buf)
    Modify the specified number of bytes of the program. This function does not save
    the original values of bytes. See also patch_bytes().
    
    @param ea: (C++: ea_t) linear address
    @param buf: (C++: const void *) buffer with new values of bytes

Help on function put_dword in module ida_bytes:

put_dword(*args) -> 'void'
    put_dword(ea, x)
    Set value of one dword of the program. This function takes into account order of
    bytes specified in idainfo::is_be() This function works for wide byte processors
    too.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint64) dword value
    @note: the original value of the dword is completely lost and can't be recovered
           by the get_original_dword() function.

Help on function put_qword in module ida_bytes:

put_qword(*args) -> 'void'
    put_qword(ea, x)
    Set value of one qword (8 bytes) of the program. This function takes into
    account order of bytes specified in idainfo::is_be() This function DOESN'T works
    for wide byte processors.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint64) qword value

Help on function put_word in module ida_bytes:

put_word(*args) -> 'void'
    put_word(ea, x)
    Set value of one word of the program. This function takes into account order of
    bytes specified in idainfo::is_be() This function works for wide byte processors
    too.
    @note: The original value of the word is completely lost and can't be recovered
           by the get_original_word() function. ea - linear address x - word value
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function qword_flag in module ida_bytes:

qword_flag(*args) -> 'flags_t'
    qword_flag() -> flags_t
    Get a flags_t representing a quad word.

Help on function register_custom_data_format in module ida_bytes:

register_custom_data_format(*args) -> 'int'
    register_custom_data_format(py_df) -> int
    Registers a custom data format with a given data type.
    
    @param py_df: an instance of data_format_t
    @return:     < 0 if failed to register
        > 0 data format id

Help on function register_custom_data_type in module ida_bytes:

register_custom_data_type(*args) -> 'int'
    register_custom_data_type(py_dt) -> int
    Registers a custom data type.
    
    @param py_dt: an instance of the data_type_t class
    @return:     < 0 if failed to register
        > 0 data type id

Help on function register_data_types_and_formats in module ida_bytes:

register_data_types_and_formats(formats)
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
    It employs a special table of types and formats described below:
    
    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1

Help on function revert_byte in module ida_bytes:

revert_byte(*args) -> 'bool'
    revert_byte(ea) -> bool
    Revert patched byte
    @retval true: byte was patched before and reverted now
    
    @param ea: (C++: ea_t)

Help on function seg_flag in module ida_bytes:

seg_flag(*args) -> 'flags_t'
    seg_flag() -> flags_t
    see Bits: instruction operand types

Help on function set_cmt in module ida_bytes:

set_cmt(*args) -> 'bool'
    set_cmt(ea, comm, rptble) -> bool
    Set an indented comment.
    
    @param ea: (C++: ea_t) linear address
    @param comm: (C++: const char *) comment string
    * nullptr: do nothing (return 0)
    * "" : delete comment
    @param rptble: (C++: bool) is repeatable?
    @return: success

Help on function set_forced_operand in module ida_bytes:

set_forced_operand(*args) -> 'bool'
    set_forced_operand(ea, n, op) -> bool
    Set forced operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, 2)
    @param op: (C++: const char *) text of operand
    * nullptr: do nothing (return 0)
    * "" : delete forced operand
    @return: success

Help on function set_immd in module ida_bytes:

set_immd(*args) -> 'bool'
    set_immd(ea) -> bool
    Set 'has immediate operand' flag. Returns true if the FF_IMMD bit was not set
    and now is set
    
    @param ea: (C++: ea_t)

Help on function set_lzero in module ida_bytes:

set_lzero(*args) -> 'bool'
    set_lzero(ea, n) -> bool
    Set toggle lzero bit. This function changes the display of leading zeroes for
    the specified operand. If the default is not to display leading zeroes, this
    function will display them and vice versa.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

Help on function set_manual_insn in module ida_bytes:

set_manual_insn(*args) -> 'void'
    set_manual_insn(ea, manual_insn)
    Set manual instruction string.
    
    @param ea: (C++: ea_t) linear address of the instruction or data item
    @param manual_insn: (C++: const char *) "" - delete manual string. nullptr - do nothing

Help on function set_op_type in module ida_bytes:

set_op_type(*args) -> 'bool'
    set_op_type(ea, type, n) -> bool
    (internal function) change representation of operand(s).
    
    @param ea: (C++: ea_t) linear address
    @param type: (C++: flags_t) new flag value (should be obtained from char_flag(), num_flag() and
                 similar functions)
    @param n: (C++: int) number of operand (0, 1, -1)
    @retval 1: ok
    @retval 0: failed (applied to a tail byte)

Help on function set_opinfo in module ida_bytes:

set_opinfo(*args) -> 'bool'
    set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
    Set additional information about an operand representation. This function is a
    low level one. Only the kernel should use it.
    
    @param ea: (C++: ea_t) linear address of the item
    @param n: (C++: int) number of operand, 0 or 1 (see the note below)
    @param flag: (C++: flags_t) flags of the item
    @param ti: (C++: const opinfo_t *) additional representation information
    @param suppress_events: (C++: bool) do not generate changing_op_type and op_type_changed
                            events
    @return: success
    @note: for custom formats (if is_custfmt(flag, n) is true) or for offsets (if
           is_off(flag, n) is true) N can be in range -1..UA_MAXOP-1. In the case of
           -1 the additional information about all operands will be set.

Help on function stkvar_flag in module ida_bytes:

stkvar_flag(*args) -> 'flags_t'
    stkvar_flag() -> flags_t
    see Bits: instruction operand types

Help on function strlit_flag in module ida_bytes:

strlit_flag(*args) -> 'flags_t'
    strlit_flag() -> flags_t
    Get a flags_t representing a string literal.

Help on function stroff_flag in module ida_bytes:

stroff_flag(*args) -> 'flags_t'
    stroff_flag() -> flags_t
    see Bits: instruction operand types

Help on function stru_flag in module ida_bytes:

stru_flag(*args) -> 'flags_t'
    stru_flag() -> flags_t
    Get a flags_t representing a struct.

Help on function tbyte_flag in module ida_bytes:

tbyte_flag(*args) -> 'flags_t'
    tbyte_flag() -> flags_t
    Get a flags_t representing a tbyte.

Help on function toggle_bnot in module ida_bytes:

toggle_bnot(*args) -> 'bool'
    toggle_bnot(ea, n) -> bool
    Toggle binary negation of operand. also see is_bnot()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function toggle_lzero in module ida_bytes:

toggle_lzero(*args) -> 'bool'
    toggle_lzero(ea, n) -> bool
    Toggle lzero bit.
    
    @param ea: (C++: ea_t) the item (insn/data) address
    @param n: (C++: int) the operand number (0-first operand, 1-other operands)
    @return: success

Help on function toggle_sign in module ida_bytes:

toggle_sign(*args) -> 'bool'
    toggle_sign(ea, n) -> bool
    Toggle sign of n-th operand. allowed values of n: 0-first operand, 1-other
    operands
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function unregister_custom_data_format in module ida_bytes:

unregister_custom_data_format(*args) -> 'bool'
    unregister_custom_data_format(dfid) -> bool
    Unregisters a custom data format
    
    @param dfid: data format id
    @return: Boolean

Help on function unregister_custom_data_type in module ida_bytes:

unregister_custom_data_type(*args) -> 'bool'
    unregister_custom_data_type(dtid) -> bool
    Unregisters a custom data type.
    
    @param dtid: the data type id
    @return: Boolean

Help on function unregister_data_types_and_formats in module ida_bytes:

unregister_data_types_and_formats(formats)
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.

Help on function update_hidden_range in module ida_bytes:

update_hidden_range(*args) -> 'bool'
    update_hidden_range(ha) -> bool
    Update hidden range information in the database. You cannot use this function to
    change the range boundaries
    
    @param ha: (C++: const hidden_range_t *) range to update
    @return: success

Help on function use_mapping in module ida_bytes:

use_mapping(*args) -> 'ea_t'
    use_mapping(ea) -> ea_t
    Translate address according to current mappings.
    
    @param ea: (C++: ea_t) address to translate
    @return: translated address

Help on function visit_patched_bytes in module ida_bytes:

visit_patched_bytes(*args) -> 'int'
    visit_patched_bytes(ea1, ea2, py_callable) -> int
    Enumerates patched bytes in the given range and invokes a callable
    
    @param ea1: start address
    @param ea2: end address
    @param py_callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    @return: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.

Help on function word_flag in module ida_bytes:

word_flag(*args) -> 'flags_t'
    word_flag() -> flags_t
    Get a flags_t representing a word.

Help on function yword_flag in module ida_bytes:

yword_flag(*args) -> 'flags_t'
    yword_flag() -> flags_t
    Get a flags_t representing a ymm word.

Help on function zword_flag in module ida_bytes:

zword_flag(*args) -> 'flags_t'
    zword_flag() -> flags_t
    Get a flags_t representing a zmm word.

Module "ida_dbg"s docstring:
"""
Contains functions to control the debugging of a process.

See Debugger functions for a complete explanation of these functions.

These functions are inlined for the kernel. They are not inlined for the user-
interfaces."""

Help on class DBG_Hooks in module ida_dbg:

class DBG_Hooks(builtins.object)
 |  Proxy of C++ DBG_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> DBG_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_DBG_Hooks(...)
 |      delete_DBG_Hooks(self)
 |  
 |  dbg_bpt(self, *args) -> 'int'
 |      dbg_bpt(self, tid, bptea) -> int
 |      A user defined breakpoint was reached.
 |      
 |      @param tid: (thid_t)
 |      @param bptea: (::ea_t)
 |  
 |  dbg_bpt_changed(self, *args) -> 'void'
 |      dbg_bpt_changed(self, bptev_code, bpt)
 |      Breakpoint has been changed.
 |      
 |      @param bptev_code: (int) Breakpoint modification events
 |      @param bpt: (bpt_t *)
 |  
 |  dbg_exception(self, *args) -> 'int'
 |      dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
 |      
 |      @param event: (const debug_event_t *)
 |      @param warn: (int *) filled with:
 |      * -1: display an exception warning dialog if the process is suspended.
 |      * 0: never display an exception warning dialog.
 |      * 1: always display an exception warning dialog.
 |      @param ea: ea_t
 |      @param exc_code: int
 |      @param exc_can_cont: bool
 |      @param exc_ea: ea_t
 |      @param exc_info: char const *
 |  
 |  dbg_finished_loading_bpts(self, *args) -> 'void'
 |      dbg_finished_loading_bpts(self)
 |      Finished loading breakpoint info from idb.
 |  
 |  dbg_information(self, *args) -> 'void'
 |      dbg_information(self, pid, tid, ea, info)
 |      
 |      @param event: (const debug_event_t *)
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param info: char const *
 |  
 |  dbg_library_load(self, *args) -> 'void'
 |      dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |      
 |      @param event: (const debug_event_t *)
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param modinfo_name: char const *
 |      @param modinfo_base: ea_t
 |      @param modinfo_size: asize_t
 |  
 |  dbg_library_unload(self, *args) -> 'void'
 |      dbg_library_unload(self, pid, tid, ea, info)
 |      
 |      @param event: (const debug_event_t *)
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param info: char const *
 |  
 |  dbg_process_attach(self, *args) -> 'void'
 |      dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |      
 |      @param event: (const debug_event_t *)
 |      @note: This event notification is also an asynchronous function result
 |             notification for start_process() !
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param modinfo_name: char const *
 |      @param modinfo_base: ea_t
 |      @param modinfo_size: asize_t
 |  
 |  dbg_process_detach(self, *args) -> 'void'
 |      dbg_process_detach(self, pid, tid, ea)
 |      
 |      @param event: (const debug_event_t *)
 |      @note: This event notification is also an asynchronous function result
 |             notification for start_process() !
 |      @param tid: thid_t
 |      @param ea: ea_t
 |  
 |  dbg_process_exit(self, *args) -> 'void'
 |      dbg_process_exit(self, pid, tid, ea, exit_code)
 |      
 |      @param event: (const debug_event_t *)
 |      @note: This event notification is also an asynchronous function result
 |             notification for start_process() !
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param exit_code: int
 |  
 |  dbg_process_start(self, *args) -> 'void'
 |      dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
 |      
 |      @param event: (const debug_event_t *)
 |      @note: This event notification is also an asynchronous function result
 |             notification for start_process() !
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param modinfo_name: char const *
 |      @param modinfo_base: ea_t
 |      @param modinfo_size: asize_t
 |  
 |  dbg_request_error(self, *args) -> 'void'
 |      dbg_request_error(self, failed_command, failed_dbg_notification)
 |      An error occurred during the processing of a request.
 |      
 |      @param failed_command: (ui_notification_t)
 |      @param failed_dbg_notification: (dbg_notification_t)
 |  
 |  dbg_run_to(self, *args) -> 'void'
 |      dbg_run_to(self, pid, tid, ea)
 |      
 |      @param event: (const debug_event_t *)
 |      @param tid: thid_t
 |      @param ea: ea_t
 |  
 |  dbg_started_loading_bpts(self, *args) -> 'void'
 |      dbg_started_loading_bpts(self)
 |      Started loading breakpoint info from idb.
 |  
 |  dbg_step_into(self, *args) -> 'void'
 |      dbg_step_into(self)
 |  
 |  dbg_step_over(self, *args) -> 'void'
 |      dbg_step_over(self)
 |  
 |  dbg_step_until_ret(self, *args) -> 'void'
 |      dbg_step_until_ret(self)
 |  
 |  dbg_suspend_process(self, *args) -> 'void'
 |      dbg_suspend_process(self)
 |      The process is now suspended.
 |  
 |  dbg_thread_exit(self, *args) -> 'void'
 |      dbg_thread_exit(self, pid, tid, ea, exit_code)
 |      
 |      @param event: (const debug_event_t *)
 |      @param tid: thid_t
 |      @param ea: ea_t
 |      @param exit_code: int
 |  
 |  dbg_thread_start(self, *args) -> 'void'
 |      dbg_thread_start(self, pid, tid, ea)
 |      
 |      @param event: (const debug_event_t *)
 |      @param tid: thid_t
 |      @param ea: ea_t
 |  
 |  dbg_trace(self, *args) -> 'int'
 |      dbg_trace(self, tid, ip) -> int
 |      A step occurred (one instruction was executed). This event notification is only
 |      generated if step tracing is enabled.
 |      
 |      @param tid: (thid_t) thread ID
 |      @param ip: (::ea_t) current instruction pointer. usually points after the
 |                 executed instruction
 |      @retval 1: do not log this trace event
 |      @retval 0: log it
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function add_bpt in module ida_dbg:

add_bpt(*args) -> 'bool'
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param bpt: (C++: const bpt_t &) Breakpoint to add. It describes the break condition, type, flags,
                location (module relative, source breakpoint or absolute) and other
                attributes.
    @param size: asize_t
    @param type: bpttype_t
    
    add_bpt(bpt) -> bool
    
    @param bpt: bpt_t const &

Help on function add_path_mapping in module ida_dbg:

add_path_mapping(*args) -> 'void'
    add_path_mapping(src, dst)
    
    @param src: char const *
    @param dst: char const *

Help on function add_virt_module in module ida_dbg:

add_virt_module(*args) -> 'bool'
    add_virt_module(mod) -> bool
    
    @param mod: modinfo_t const *

Help on function attach_process in module ida_dbg:

attach_process(*args) -> 'int'
    attach_process(pid=pid_t(-1), event_id=-1) -> int
    Attach the debugger to a running process. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_process_attach}
    @note: This function shouldn't be called as a request if NO_PROCESS is used.
    
    @param pid: (C++: pid_t) PID of the process to attach to. If NO_PROCESS, a dialog box will
                interactively ask the user for the process to attach to.
    @retval -4: debugger was not inited
    @retval -3: the attaching is not supported
    @retval -2: impossible to find a compatible process
    @retval -1: impossible to attach to the given process (process died, privilege
                needed, not supported by the debugger plugin, ...)
    @retval 0: the user cancelled the attaching to the process
    @retval 1: the debugger properly attached to the process

Help on class bpt_location_t in module ida_dbg:

class bpt_location_t(builtins.object)
 |  Proxy of C++ bpt_location_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: bpt_location_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: bpt_location_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: bpt_location_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_location_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: bpt_location_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: bpt_location_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: bpt_location_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bpt_location_t(...)
 |      delete_bpt_location_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Lexically compare two breakpoint locations. Bpt locations are first compared
 |      based on type (i.e. BPLT_ABS < BPLT_REL). BPLT_ABS locations are compared based
 |      on their ea values. For all other location types, locations are first compared
 |      based on their string (path/filename/symbol), then their offset/lineno.
 |      
 |      @param r: (C++: const bpt_location_t &) bpt_location_t const &
 |  
 |  ea(self, *args) -> 'ea_t'
 |      ea(self) -> ea_t
 |      Get address (BPLT_ABS)
 |  
 |  is_empty_path(self, *args) -> 'bool'
 |      is_empty_path(self) -> bool
 |      No path/filename specified? (BPLT_REL, BPLT_SRC)
 |  
 |  lineno(self, *args) -> 'int'
 |      lineno(self) -> int
 |      Get line number (BPLT_SRC)
 |  
 |  offset(self, *args) -> 'uval_t'
 |      offset(self) -> uval_t
 |      Get offset (BPLT_REL, BPLT_SYM)
 |  
 |  path(self, *args) -> 'char const *'
 |      path(self) -> char const *
 |      Get path/filename (BPLT_REL, BPLT_SRC)
 |  
 |  set_abs_bpt(self, *args) -> 'void'
 |      set_abs_bpt(self, a)
 |      Specify an absolute address location.
 |      
 |      @param a: (C++: ea_t)
 |  
 |  set_rel_bpt(self, *args) -> 'void'
 |      set_rel_bpt(self, mod, _offset)
 |      Specify a relative address location.
 |      
 |      @param mod: (C++: const char *) char const *
 |      @param _offset: (C++: uval_t)
 |  
 |  set_src_bpt(self, *args) -> 'void'
 |      set_src_bpt(self, fn, _lineno)
 |      Specify a source level location.
 |      
 |      @param fn: (C++: const char *) char const *
 |      @param _lineno: (C++: int)
 |  
 |  set_sym_bpt(self, *args) -> 'void'
 |      set_sym_bpt(self, _symbol, _offset=0)
 |      Specify a symbolic location.
 |      
 |      @param _symbol: (C++: const char *) char const *
 |      @param _offset: (C++: uval_t)
 |  
 |  symbol(self, *args) -> 'char const *'
 |      symbol(self) -> char const *
 |      Get symbol name (BPLT_SYM)
 |  
 |  type(self, *args) -> 'bpt_loctype_t'
 |      type(self) -> bpt_loctype_t
 |      Get bpt type.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  index
 |      index
 |  
 |  info
 |      info
 |  
 |  loctype
 |      loctype
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class bpt_t in module ida_dbg:

class bpt_t(builtins.object)
 |  Proxy of C++ bpt_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bpt_t(...)
 |      delete_bpt_t(self)
 |  
 |  badbpt(self, *args) -> 'bool'
 |      badbpt(self) -> bool
 |      Failed to write bpt to process memory?
 |  
 |  enabled(self, *args) -> 'bool'
 |      enabled(self) -> bool
 |      Is breakpoint enabled?
 |  
 |  get_cnd_elang_idx(self, *args) -> 'size_t'
 |      get_cnd_elang_idx(self) -> size_t
 |  
 |  get_size(self, *args) -> 'int'
 |      get_size(self) -> int
 |      Get bpt size.
 |  
 |  is_absbpt(self, *args) -> 'bool'
 |      is_absbpt(self) -> bool
 |      Is absolute address breakpoint?
 |  
 |  is_active(self, *args) -> 'bool'
 |      is_active(self) -> bool
 |      Written completely to process?
 |  
 |  is_compiled(self, *args) -> 'bool'
 |      is_compiled(self) -> bool
 |      Condition has been compiled?
 |  
 |  is_hwbpt(self, *args) -> 'bool'
 |      is_hwbpt(self) -> bool
 |      Is hardware breakpoint?
 |  
 |  is_inactive(self, *args) -> 'bool'
 |      is_inactive(self) -> bool
 |      Not written to process at all?
 |  
 |  is_low_level(self, *args) -> 'bool'
 |      is_low_level(self) -> bool
 |      Is bpt condition calculated at low level?
 |  
 |  is_page_bpt(self, *args) -> 'bool'
 |      is_page_bpt(self) -> bool
 |      Page breakpoint?
 |  
 |  is_partially_active(self, *args) -> 'bool'
 |      is_partially_active(self) -> bool
 |      Written partially to process?
 |  
 |  is_relbpt(self, *args) -> 'bool'
 |      is_relbpt(self) -> bool
 |      Is relative address breakpoint?
 |  
 |  is_srcbpt(self, *args) -> 'bool'
 |      is_srcbpt(self) -> bool
 |      Is source level breakpoint?
 |  
 |  is_symbpt(self, *args) -> 'bool'
 |      is_symbpt(self) -> bool
 |      Is symbolic breakpoint?
 |  
 |  is_tracemodebpt(self, *args) -> 'bool'
 |      is_tracemodebpt(self) -> bool
 |      Does breakpoint trace anything?
 |  
 |  is_traceoffbpt(self, *args) -> 'bool'
 |      is_traceoffbpt(self) -> bool
 |      Is this a tracing breakpoint, and is tracing disabled?
 |  
 |  is_traceonbpt(self, *args) -> 'bool'
 |      is_traceonbpt(self) -> bool
 |      Is this a tracing breakpoint, and is tracing enabled?
 |  
 |  listbpt(self, *args) -> 'bool'
 |      listbpt(self) -> bool
 |      Include in the bpt list?
 |  
 |  set_abs_bpt(self, *args) -> 'void'
 |      set_abs_bpt(self, a)
 |      Set bpt location to an absolute address.
 |      
 |      @param a: (C++: ea_t)
 |  
 |  set_rel_bpt(self, *args) -> 'void'
 |      set_rel_bpt(self, mod, o)
 |      Set bpt location to a relative address.
 |      
 |      @param mod: (C++: const char *) char const *
 |      @param o: (C++: uval_t)
 |  
 |  set_src_bpt(self, *args) -> 'void'
 |      set_src_bpt(self, fn, lineno)
 |      Set bpt location to a source line.
 |      
 |      @param fn: (C++: const char *) char const *
 |      @param lineno: (C++: int)
 |  
 |  set_sym_bpt(self, *args) -> 'void'
 |      set_sym_bpt(self, sym, o)
 |      Set bpt location to a symbol.
 |      
 |      @param sym: (C++: const char *) char const *
 |      @param o: (C++: uval_t)
 |  
 |  set_trace_action(self, *args) -> 'bool'
 |      set_trace_action(self, enable, trace_types) -> bool
 |      Configure tracing options.
 |      
 |      @param enable: (C++: bool)
 |      @param trace_types: (C++: int)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bptid
 |      bptid
 |  
 |  cb
 |      cb
 |  
 |  cndidx
 |      cndidx
 |  
 |  condition
 |      condition
 |  
 |  ea
 |      ea
 |  
 |  elang
 |      elang
 |  
 |  flags
 |      flags
 |  
 |  loc
 |      loc
 |  
 |  pass_count
 |      pass_count
 |  
 |  pid
 |      pid
 |  
 |  props
 |      props
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tid
 |  
 |  type
 |      type

Help on class bpt_vec_t in module ida_dbg:

class bpt_vec_t(builtins.object)
 |  Proxy of C++ qvector< bpt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'bpt_t const &'
 |      __getitem__(self, i) -> bpt_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bpt_vec_t
 |      __init__(self, x) -> bpt_vec_t
 |      
 |      @param x: qvector< bpt_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: bpt_t const &
 |  
 |  __swig_destroy__ = delete_bpt_vec_t(...)
 |      delete_bpt_vec_t(self)
 |  
 |  at(self, *args) -> 'bpt_t const &'
 |      at(self, _idx) -> bpt_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< bpt_t >::const_iterator'
 |      begin(self) -> bpt_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< bpt_t >::const_iterator'
 |      end(self) -> bpt_t
 |  
 |  erase(self, *args) -> 'qvector< bpt_t >::iterator'
 |      erase(self, it) -> bpt_t
 |      
 |      @param it: qvector< bpt_t >::iterator
 |      
 |      erase(self, first, last) -> bpt_t
 |      
 |      @param first: qvector< bpt_t >::iterator
 |      @param last: qvector< bpt_t >::iterator
 |  
 |  extract(self, *args) -> 'bpt_t *'
 |      extract(self) -> bpt_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=bpt_t())
 |      
 |      @param x: bpt_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: bpt_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< bpt_t >::iterator'
 |      insert(self, it, x) -> bpt_t
 |      
 |      @param it: qvector< bpt_t >::iterator
 |      @param x: bpt_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'bpt_t &'
 |      push_back(self, x)
 |      
 |      @param x: bpt_t const &
 |      
 |      push_back(self) -> bpt_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: bpt_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< bpt_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class bptaddrs_t in module ida_dbg:

class bptaddrs_t(builtins.object)
 |  Proxy of C++ bptaddrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bptaddrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bptaddrs_t(...)
 |      delete_bptaddrs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bpt
 |      bpt
 |  
 |  thisown
 |      The membership flag

Help on function bring_debugger_to_front in module ida_dbg:

bring_debugger_to_front(*args) -> 'void'
    bring_debugger_to_front()

Help on function check_bpt in module ida_dbg:

check_bpt(*args) -> 'int'
    check_bpt(ea) -> int
    Check the breakpoint at the specified address.
    
    @param ea: (C++: ea_t)
    @return: one of Breakpoint status codes

Help on function choose_trace_file in module ida_dbg:

choose_trace_file(*args) -> 'qstring *'
    choose_trace_file() -> str
    Show the choose trace dialog.

Help on function clear_requests_queue in module ida_dbg:

clear_requests_queue(*args) -> 'void'
    clear_requests_queue()
    Clear the queue of waiting requests. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    @note: If a request is currently running, this one isn't stopped.

Help on function clear_trace in module ida_dbg:

clear_trace(*args) -> 'void'
    clear_trace()
    Clear all events in the trace buffer. \sq{Type, Synchronous function - available
    as request, Notification, none (synchronous function)}

Help on function collect_stack_trace in module ida_dbg:

collect_stack_trace(*args) -> 'bool'
    collect_stack_trace(tid, trace) -> bool
    
    @param tid: thid_t
    @param trace: call_stack_t *

Help on function continue_process in module ida_dbg:

continue_process(*args) -> 'bool'
    continue_process() -> bool
    Continue the execution of the process in the debugger. \sq{Type, Synchronous
    function - available as Request, Notification, none (synchronous function)}
    @note: The continue_process() function can be called from a notification handler
           to force the continuation of the process. In this case the request queue
           will not be examined, IDA will simply resume execution. Usually it makes
           sense to call request_continue_process() followed by run_requests(), so
           that IDA will first start a queued request (if any) and then resume the
           application.

Help on function create_source_viewer in module ida_dbg:

create_source_viewer(*args) -> 'source_view_t *'
    create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *
    Create a source code view.
    
    @param out_ccv: (C++: TWidget **)
    @param parent: (C++: TWidget *)
    @param custview: (C++: TWidget *)
    @param sf: (C++: source_file_ptr)
    @param lines: (C++: strvec_t *)
    @param lnnum: (C++: int)
    @param colnum: (C++: int)
    @param flags: (C++: int)

Help on function dbg_add_bpt_tev in module ida_dbg:

dbg_add_bpt_tev(*args) -> 'bool'
    dbg_add_bpt_tev(tid, ea, bp) -> bool
    Add a new breakpoint trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param ea: (C++: ea_t)
    @param bp: (C++: ea_t)
    @return: false if the operation failed, true otherwise

Help on function dbg_add_call_tev in module ida_dbg:

dbg_add_call_tev(*args) -> 'void'
    dbg_add_call_tev(tid, caller, callee)
    Add a new call trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param caller: (C++: ea_t)
    @param callee: (C++: ea_t)

Help on function dbg_add_debug_event in module ida_dbg:

dbg_add_debug_event(*args) -> 'void'
    dbg_add_debug_event(event)
    Add a new debug event to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param event: (C++: debug_event_t *)

Help on function dbg_add_insn_tev in module ida_dbg:

dbg_add_insn_tev(*args) -> 'bool'
    dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool
    Add a new instruction trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param ea: (C++: ea_t)
    @param save: (C++: save_reg_values_t) enum save_reg_values_t
    @return: false if the operation failed, true otherwise

Help on function dbg_add_many_tevs in module ida_dbg:

dbg_add_many_tevs(*args) -> 'bool'
    dbg_add_many_tevs(new_tevs) -> bool
    Add many new trace elements to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param new_tevs: (C++: tevinforeg_vec_t *)
    @return: false if the operation failed for any tev_info_t object

Help on function dbg_add_ret_tev in module ida_dbg:

dbg_add_ret_tev(*args) -> 'void'
    dbg_add_ret_tev(tid, ret_insn, return_to)
    Add a new return trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)
    @param ret_insn: (C++: ea_t)
    @param return_to: (C++: ea_t)

Help on function dbg_add_tev in module ida_dbg:

dbg_add_tev(*args) -> 'void'
    dbg_add_tev(type, tid, address)
    Add a new trace element to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param type: (C++: tev_type_t) enum tev_type_t
    @param tid: (C++: thid_t)
    @param address: (C++: ea_t)

Help on function dbg_add_thread in module ida_dbg:

dbg_add_thread(*args) -> 'void'
    dbg_add_thread(tid)
    Add a thread to the current trace. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param tid: (C++: thid_t)

Help on function dbg_bin_search in module ida_dbg:

dbg_bin_search(*args) -> 'unsigned-ea-like-numeric-type *, qstring *'
    dbg_bin_search(start_ea, end_ea, data, srch_flags) -> str
    
    @param start_ea: ea_t
    @param end_ea: ea_t
    @param data: compiled_binpat_vec_t const &
    @param srch_flags: int

Help on function dbg_can_query in module ida_dbg:

dbg_can_query(*args) -> 'bool'
    dbg_can_query() -> bool
    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    
    @return: Boolean

Help on function dbg_del_thread in module ida_dbg:

dbg_del_thread(*args) -> 'void'
    dbg_del_thread(tid)
    Delete a thread from the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t)

Help on function dbg_is_loaded in module ida_dbg:

dbg_is_loaded(*args) -> 'bool'
    dbg_is_loaded() -> bool
    Checks if a debugger is loaded
    
    @return: Boolean

Help on function define_exception in module ida_dbg:

define_exception(*args) -> 'char const *'
    define_exception(code, name, desc, flags) -> char const *
    Convenience function: define new exception code.
    
    @param code: (C++: uint) exception code (cannot be 0)
    @param name: (C++: const char *) exception name (cannot be empty or nullptr)
    @param desc: (C++: const char *) exception description (maybe nullptr)
    @param flags: (C++: int) combination of Exception info flags
    @return: failure message or nullptr. You must call store_exceptions() if this
             function succeeds

Help on function del_bpt in module ida_dbg:

del_bpt(*args) -> 'bool'
    del_bpt(ea) -> bool
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) Breakpoint location
    del_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

Help on function del_bptgrp in module ida_dbg:

del_bptgrp(*args) -> 'bool'
    del_bptgrp(name) -> bool
    Delete a folder, bpt that were part of this folder are moved to the root folder
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param name: (C++: const char *) full path to the folder to be deleted
    @return: success

Help on function del_virt_module in module ida_dbg:

del_virt_module(*args) -> 'bool'
    del_virt_module(base) -> bool
    
    @param base: ea_t const

Help on function detach_process in module ida_dbg:

detach_process(*args) -> 'bool'
    detach_process() -> bool
    Detach the debugger from the debugged process. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_process_detach}

Help on function diff_trace_file in module ida_dbg:

diff_trace_file(*args) -> 'bool'
    diff_trace_file(NONNULL_filename) -> bool
    Show difference between the current trace and the one from 'filename'.
    
    @param NONNULL_filename: (C++: const char *) char const *

Help on function disable_bblk_trace in module ida_dbg:

disable_bblk_trace(*args) -> 'bool'
    disable_bblk_trace() -> bool

Help on function disable_bpt in module ida_dbg:

disable_bpt(*args) -> 'bool'
    disable_bpt(ea) -> bool
    
    @param ea: ea_t
    
    disable_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

Help on function disable_func_trace in module ida_dbg:

disable_func_trace(*args) -> 'bool'
    disable_func_trace() -> bool

Help on function disable_insn_trace in module ida_dbg:

disable_insn_trace(*args) -> 'bool'
    disable_insn_trace() -> bool

Help on function disable_step_trace in module ida_dbg:

disable_step_trace(*args) -> 'bool'
    disable_step_trace() -> bool

Help on function edit_manual_regions in module ida_dbg:

edit_manual_regions(*args) -> 'void'
    edit_manual_regions()

Help on function enable_bblk_trace in module ida_dbg:

enable_bblk_trace(*args) -> 'bool'
    enable_bblk_trace(enable=True) -> bool
    
    @param enable: bool

Help on function enable_bpt in module ida_dbg:

enable_bpt(*args) -> 'bool'
    enable_bpt(ea, enable=True) -> bool
    
    @param ea: ea_t
    @param enable: bool
    
    enable_bpt(bptloc, enable=True) -> bool
    
    @param bptloc: bpt_location_t const &
    @param enable: bool

Help on function enable_bptgrp in module ida_dbg:

enable_bptgrp(*args) -> 'int'
    enable_bptgrp(bptgrp_name, enable=True) -> int
    Enable (or disable) all bpts in a folder \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param bptgrp_name: (C++: const char *) absolute path to the folder
    @param enable: (C++: bool) by default true, enable bpts, false disable bpts
    @return: -1 an error occured 0 no changes >0 nubmers of bpts udpated

Help on function enable_func_trace in module ida_dbg:

enable_func_trace(*args) -> 'bool'
    enable_func_trace(enable=True) -> bool
    
    @param enable: bool

Help on function enable_insn_trace in module ida_dbg:

enable_insn_trace(*args) -> 'bool'
    enable_insn_trace(enable=True) -> bool
    
    @param enable: bool

Help on function enable_manual_regions in module ida_dbg:

enable_manual_regions(*args) -> 'void'
    enable_manual_regions(enable)
    
    @param enable: bool

Help on function enable_step_trace in module ida_dbg:

enable_step_trace(*args) -> 'bool'
    enable_step_trace(enable=1) -> bool
    
    @param enable: int

Help on class eval_ctx_t in module ida_dbg:

class eval_ctx_t(builtins.object)
 |  Proxy of C++ eval_ctx_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> eval_ctx_t
 |      
 |      @param _ea: ea_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_eval_ctx_t(...)
 |      delete_eval_ctx_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  thisown
 |      The membership flag

Help on function exist_bpt in module ida_dbg:

exist_bpt(*args) -> 'bool'
    exist_bpt(ea) -> bool
    Does a breakpoint exist at the given location?
    
    @param ea: (C++: ea_t)

Help on function exit_process in module ida_dbg:

exit_process(*args) -> 'bool'
    exit_process() -> bool
    Terminate the debugging of the current process. \sq{Type, Asynchronous function
    - available as Request, Notification, dbg_process_exit}

Help on function find_bpt in module ida_dbg:

find_bpt(*args) -> 'bool'
    find_bpt(bptloc, bpt) -> bool
    Find a breakpoint by location. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) Breakpoint location
    @param bpt: (C++: bpt_t *) bpt is filled if the breakpoint was found

Help on function get_bblk_trace_options in module ida_dbg:

get_bblk_trace_options(*args) -> 'int'
    get_bblk_trace_options() -> int
    Get current basic block tracing options. Also see BT_LOG_INSTS \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_bpt in module ida_dbg:

get_bpt(*args) -> 'bool'
    get_bpt(ea, bpt) -> bool
    Get the characteristics of a breakpoint. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param ea: (C++: ea_t) any address in the breakpoint range
    @param bpt: (C++: bpt_t *) if not nullptr, is filled with the characteristics.
    @return: false if no breakpoint exists

Help on function get_bpt_group in module ida_dbg:

get_bpt_group(*args) -> 'qstring *'
    get_bpt_group(bptloc) -> str
    Retrieve the absolute path to the folder of the bpt based on the bpt_location
    find_bpt is called to retrieve the bpt \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) bptlocation of the bpt
    @return: breakpoint correclty moved to the directory
    success

Help on function get_bpt_qty in module ida_dbg:

get_bpt_qty(*args) -> 'int'
    get_bpt_qty() -> int
    Get number of breakpoints. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_bpt_tev_ea in module ida_dbg:

get_bpt_tev_ea(*args) -> 'ea_t'
    get_bpt_tev_ea(n) -> ea_t
    Get the address associated to a read, read/write or execution trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a read, read/write or execution trace event.
    @note: Usually, a breakpoint is associated with a read, read/write or execution
           trace event. However, the returned address could be any address in the
           range of this breakpoint. If the breakpoint was deleted after the trace
           event, the address no longer corresponds to a valid breakpoint.

Help on function get_bptloc_string in module ida_dbg:

get_bptloc_string(*args) -> 'char const *'
    get_bptloc_string(i) -> char const *
    
    @param i: int

Help on function get_call_tev_callee in module ida_dbg:

get_call_tev_callee(*args) -> 'ea_t'
    get_call_tev_callee(n) -> ea_t
    Get the called function from a function call trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a function call event.

Help on function get_current_source_file in module ida_dbg:

get_current_source_file(*args) -> 'qstring *'
    get_current_source_file() -> str

Help on function get_current_source_line in module ida_dbg:

get_current_source_line(*args) -> 'int'
    get_current_source_line() -> int

Help on function get_current_thread in module ida_dbg:

get_current_thread(*args) -> 'thid_t'
    get_current_thread() -> thid_t
    Get current thread ID. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_dbg_byte in module ida_dbg:

get_dbg_byte(*args) -> 'bool'
    get_dbg_byte(x, ea) -> bool
    Get one byte of the debugged process memory.
    
    @param x: (C++: uint32 *) pointer to byte value
    @param ea: (C++: ea_t) linear address
    @return: true success
    false address inaccessible or debugger not running

Help on function get_dbg_memory_info in module ida_dbg:

get_dbg_memory_info(*args) -> 'int'
    get_dbg_memory_info(ranges) -> int
    
    @param ranges: meminfo_vec_t *

Help on function get_dbg_reg_info in module ida_dbg:

get_dbg_reg_info(*args) -> 'bool'
    get_dbg_reg_info(regname, ri) -> bool
    Get register information \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param regname: (C++: const char *) char const *
    @param ri: (C++: register_info_t *)

Help on function get_debug_event in module ida_dbg:

get_debug_event(*args) -> 'debug_event_t const *'
    get_debug_event() -> debug_event_t
    Get the current debugger event.

Help on function get_debugger_event_cond in module ida_dbg:

get_debugger_event_cond(*args) -> 'char const *'
    get_debugger_event_cond() -> char const *

Help on function get_first_module in module ida_dbg:

get_first_module(*args) -> 'bool'
    get_first_module(modinfo) -> bool
    
    @param modinfo: modinfo_t *

Help on function get_func_trace_options in module ida_dbg:

get_func_trace_options(*args) -> 'int'
    get_func_trace_options() -> int
    Get current function tracing options. Also see FT_LOG_RET \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function get_global_var in module ida_dbg:

get_global_var(*args) -> 'bool'
    get_global_var(prov, ea, name, out) -> bool
    
    @param prov: srcinfo_provider_t *
    @param ea: ea_t
    @param name: char const *
    @param out: source_item_ptr *

Help on function get_grp_bpts in module ida_dbg:

get_grp_bpts(*args) -> 'ssize_t'
    get_grp_bpts(bpts, grp_name) -> ssize_t
    Retrieve a copy the bpts stored in a folder \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param bpts: (C++: bpt_vec_t *) : pointer to a vector where the copy of bpts are stored
    @param grp_name: (C++: const char *) absolute path to the folder
    @return: number of bpts present in the vector

Help on function get_insn_tev_reg_mem in module ida_dbg:

get_insn_tev_reg_mem(*args) -> 'bool'
    get_insn_tev_reg_mem(n, memmap) -> bool
    Read the memory pointed by register values from an instruction trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param memmap: (C++: memreg_infos_t *) result
    @return: false if not an instruction event or no memory is available

Help on function get_insn_tev_reg_result in module ida_dbg:

get_insn_tev_reg_result(*args) -> 'bool'
    get_insn_tev_reg_result(n, regname, regval) -> bool
    
    @param n: int
    @param regname: char const *
    @param regval: regval_t *

Help on function get_insn_tev_reg_val in module ida_dbg:

get_insn_tev_reg_val(*args) -> 'bool'
    get_insn_tev_reg_val(n, regname, regval) -> bool
    
    @param n: int
    @param regname: char const *
    @param regval: regval_t *

Help on function get_insn_trace_options in module ida_dbg:

get_insn_trace_options(*args) -> 'int'
    get_insn_trace_options() -> int
    Get current instruction tracing options. Also see IT_LOG_SAME_IP \sq{Type,
    Synchronous function, Notification, none (synchronous function)}

Help on function get_ip_val in module ida_dbg:

get_ip_val(*args) -> 'unsigned-ea-like-numeric-type *'
    get_ip_val() -> bool
    Get value of the IP (program counter) register for the current thread. Requires
    a suspended debugger.

Help on function get_local_var in module ida_dbg:

get_local_var(*args) -> 'bool'
    get_local_var(prov, ea, name, out) -> bool
    
    @param prov: srcinfo_provider_t *
    @param ea: ea_t
    @param name: char const *
    @param out: source_item_ptr *

Help on function get_local_vars in module ida_dbg:

get_local_vars(*args) -> 'bool'
    get_local_vars(prov, ea, out) -> bool
    
    @param prov: srcinfo_provider_t *
    @param ea: ea_t
    @param out: source_items_t *

Help on function get_manual_regions in module ida_dbg:

get_manual_regions(*args) -> 'PyObject *'
    get_manual_regions(ranges)
    Returns the manual memory regions
    
    @param ranges: meminfo_vec_t *
    
    @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)
    get_manual_regions() -> [(int, int, str, str, int, int, int), ...] or None

Help on function get_module_info in module ida_dbg:

get_module_info(*args) -> 'bool'
    get_module_info(ea, modinfo) -> bool
    
    @param ea: ea_t
    @param modinfo: modinfo_t *

Help on function get_next_module in module ida_dbg:

get_next_module(*args) -> 'bool'
    get_next_module(modinfo) -> bool
    
    @param modinfo: modinfo_t *

Help on function get_process_options in module ida_dbg:

get_process_options(*args) -> 'qstring *, qstring *, qstring *, qstring *, qstring *, int *'
    get_process_options()
    Get process options. Any of the arguments may be nullptr

Help on function get_process_state in module ida_dbg:

get_process_state(*args) -> 'int'
    get_process_state() -> int
    Return the state of the currently debugged process. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @return: one of Debugged process states

Help on function get_processes in module ida_dbg:

get_processes(*args) -> 'ssize_t'
    get_processes(proclist) -> ssize_t
    Take a snapshot of running processes and return their description. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param proclist: (C++: procinfo_vec_t *) array with information about each running process
    @return: number of processes or -1 on error

Help on function get_reg_val in module ida_dbg:

get_reg_val(*args) -> 'PyObject *'
    get_reg_val(regname, regval) -> bool
    Get register value as an unsigned 64-bit int.
    
    @param regname: (C++: const char *) char const *
    @param regval: regval_t *
    
    get_reg_val(regname, ival) -> bool
    
    @param regname: char const *
    @param ival: uint64 *
    
    get_reg_val(regname) -> bool, float, int
    
    @param regname: char const *

Help on function get_reg_vals in module ida_dbg:

get_reg_vals(*args) -> 'int'
    get_reg_vals(tid, clsmask, values) -> int
    
    @param tid: thid_t
    @param clsmask: int
    @param values: regval_t *

Help on function get_ret_tev_return in module ida_dbg:

get_ret_tev_return(*args) -> 'ea_t'
    get_ret_tev_return(n) -> ea_t
    Get the return address from a function return trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a function return event.

Help on function get_running_notification in module ida_dbg:

get_running_notification(*args) -> 'dbg_notification_t'
    get_running_notification() -> dbg_notification_t
    Get the notification associated (if any) with the current running request.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @return: dbg_null if no running request

Help on function get_running_request in module ida_dbg:

get_running_request(*args) -> 'ui_notification_t'
    get_running_request() -> ui_notification_t
    Get the current running request. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @return: ui_null if no running request

Help on function get_sp_val in module ida_dbg:

get_sp_val(*args) -> 'unsigned-ea-like-numeric-type *'
    get_sp_val() -> bool
    Get value of the SP register for the current thread. Requires a suspended
    debugger.

Help on function get_srcinfo_provider in module ida_dbg:

get_srcinfo_provider(*args) -> 'srcinfo_provider_t *'
    get_srcinfo_provider(name) -> srcinfo_provider_t *
    
    @param name: char const *

Help on function get_step_trace_options in module ida_dbg:

get_step_trace_options(*args) -> 'int'
    get_step_trace_options() -> int
    Get current step tracing options. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @return: Step trace options

Help on function get_tev_ea in module ida_dbg:

get_tev_ea(*args) -> 'ea_t'
    get_tev_ea(n) -> ea_t
    
    @param n: int

Help on function get_tev_event in module ida_dbg:

get_tev_event(*args) -> 'bool'
    get_tev_event(n, d) -> bool
    Get the corresponding debug event, if any, for the specified tev object.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param d: (C++: debug_event_t *) result
    @return: false if the tev_t object doesn't have any associated debug event, true
             otherwise, with the debug event in "d".

Help on function get_tev_info in module ida_dbg:

get_tev_info(*args) -> 'bool'
    get_tev_info(n, tev_info) -> bool
    Get main information about a trace event. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param tev_info: (C++: tev_info_t *) result
    @return: success

Help on function get_tev_memory_info in module ida_dbg:

get_tev_memory_info(*args) -> 'bool'
    get_tev_memory_info(n, mi) -> bool
    Get the memory layout, if any, for the specified tev object. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @param mi: (C++: meminfo_vec_t *) result
    @return: false if the tev_t object is not of type tev_mem, true otherwise, with
             the new memory layout in "mi".

Help on function get_tev_qty in module ida_dbg:

get_tev_qty(*args) -> 'int'
    get_tev_qty() -> int
    Get number of trace events available in trace buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function get_tev_reg_mem in module ida_dbg:

get_tev_reg_mem(tev, idx)

Help on function get_tev_reg_mem_ea in module ida_dbg:

get_tev_reg_mem_ea(tev, idx)

Help on function get_tev_reg_mem_qty in module ida_dbg:

get_tev_reg_mem_qty(tev)

Help on function get_tev_reg_val in module ida_dbg:

get_tev_reg_val(tev, reg)

Help on function get_tev_tid in module ida_dbg:

get_tev_tid(*args) -> 'int'
    get_tev_tid(n) -> int
    
    @param n: int

Help on function get_tev_type in module ida_dbg:

get_tev_type(*args) -> 'int'
    get_tev_type(n) -> int
    
    @param n: int

Help on function get_thread_qty in module ida_dbg:

get_thread_qty(*args) -> 'int'
    get_thread_qty() -> int
    Get number of threads. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_trace_base_address in module ida_dbg:

get_trace_base_address(*args) -> 'ea_t'
    get_trace_base_address() -> ea_t
    Get the base address of the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @return: the base address of the currently loaded trace

Help on function get_trace_dynamic_register_set in module ida_dbg:

get_trace_dynamic_register_set(*args) -> 'void'
    get_trace_dynamic_register_set(idaregs)
    Get dynamic register set of current trace.
    
    @param idaregs: (C++: dynamic_register_set_t *)

Help on function get_trace_file_desc in module ida_dbg:

get_trace_file_desc(*args) -> 'qstring *'
    get_trace_file_desc(filename) -> str
    Get the file header of the specified trace file.
    
    @param filename: (C++: const char *) char const *

Help on function get_trace_platform in module ida_dbg:

get_trace_platform(*args) -> 'char const *'
    get_trace_platform() -> char const *
    Get platform name of current trace.

Help on function getn_bpt in module ida_dbg:

getn_bpt(*args) -> 'bool'
    getn_bpt(n, bpt) -> bool
    Get the characteristics of a breakpoint. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param n: (C++: int) number of breakpoint, is in range 0..get_bpt_qty()-1
    @param bpt: (C++: bpt_t *) filled with the characteristics.
    @return: false if no breakpoint exists

Help on function getn_thread in module ida_dbg:

getn_thread(*args) -> 'thid_t'
    getn_thread(n) -> thid_t
    Get the ID of a thread. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: (C++: int) number of thread, is in range 0..get_thread_qty()-1
    @return: NO_THREAD if the thread doesn't exist.

Help on function getn_thread_name in module ida_dbg:

getn_thread_name(*args) -> 'char const *'
    getn_thread_name(n) -> char const *
    Get the NAME of a thread \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: (C++: int) number of thread, is in range 0..get_thread_qty()-1 or -1 for the
              current thread
    @return: thread name or nullptr if the thread doesn't exist.

Help on function graph_trace in module ida_dbg:

graph_trace(*args) -> 'bool'
    graph_trace() -> bool
    Show the trace callgraph.

Help on function handle_debug_event in module ida_dbg:

handle_debug_event(*args) -> 'int'
    handle_debug_event(ev, rqflags) -> int
    
    @param ev: debug_event_t const *
    @param rqflags: int

Help on function hide_all_bpts in module ida_dbg:

hide_all_bpts(*args) -> 'int'
    hide_all_bpts() -> int

Help on function internal_get_sreg_base in module ida_dbg:

internal_get_sreg_base(*args) -> 'ea_t'
    internal_get_sreg_base(tid, sreg_value) -> ea_t
    Get the sreg base, for the given thread.
    
    @param tid: thid_t
    @param sreg_value: int
    @return: The sreg base, or BADADDR on failure.

Help on function internal_ioctl in module ida_dbg:

internal_ioctl(*args) -> 'int'
    internal_ioctl(fn, buf, poutbuf, poutsize) -> int
    
    @param fn: int
    @param buf: void const *
    @param poutbuf: void **
    @param poutsize: ssize_t *

Help on function invalidate_dbg_state in module ida_dbg:

invalidate_dbg_state(*args) -> 'int'
    invalidate_dbg_state(dbginv) -> int
    Invalidate cached debugger information. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param dbginv: (C++: int) Debugged process invalidation options
    @return: current debugger state (one of Debugged process states)

Help on function invalidate_dbgmem_config in module ida_dbg:

invalidate_dbgmem_config(*args) -> 'void'
    invalidate_dbgmem_config()
    Invalidate the debugged process memory configuration. Call this function if the
    debugged process might have changed its memory layout (allocated more memory,
    for example)

Help on function invalidate_dbgmem_contents in module ida_dbg:

invalidate_dbgmem_contents(*args) -> 'void'
    invalidate_dbgmem_contents(ea, size)
    Invalidate the debugged process memory contents. Call this function each time
    the process has been stopped or the process memory is modified. If ea ==
    BADADDR, then the whole memory contents will be invalidated
    
    @param ea: (C++: ea_t)
    @param size: (C++: asize_t)

Help on function is_bblk_trace_enabled in module ida_dbg:

is_bblk_trace_enabled(*args) -> 'bool'
    is_bblk_trace_enabled() -> bool

Help on function is_debugger_busy in module ida_dbg:

is_debugger_busy(*args) -> 'bool'
    is_debugger_busy() -> bool
    Is the debugger busy?. Some debuggers do not accept any commands while the
    debugged application is running. For such a debugger, it is unsafe to do
    anything with the database (even simple queries like get_byte may lead to
    undesired consequences). Returns: true if the debugged application is running
    under such a debugger

Help on function is_debugger_memory in module ida_dbg:

is_debugger_memory(*args) -> 'bool'
    is_debugger_memory(ea) -> bool
    Is the address mapped to debugger memory?
    
    @param ea: (C++: ea_t)

Help on function is_debugger_on in module ida_dbg:

is_debugger_on(*args) -> 'bool'
    is_debugger_on() -> bool
    Is the debugger currently running?

Help on function is_func_trace_enabled in module ida_dbg:

is_func_trace_enabled(*args) -> 'bool'
    is_func_trace_enabled() -> bool
    Get current state of functions tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function is_insn_trace_enabled in module ida_dbg:

is_insn_trace_enabled(*args) -> 'bool'
    is_insn_trace_enabled() -> bool
    Get current state of instruction tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}

Help on function is_reg_custom in module ida_dbg:

is_reg_custom(*args) -> 'bool'
    is_reg_custom(regname) -> bool
    Does a register contain a value of a custom data type? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param regname: (C++: const char *) char const *

Help on function is_reg_float in module ida_dbg:

is_reg_float(*args) -> 'bool'
    is_reg_float(regname) -> bool
    Does a register contain a floating point value? \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param regname: (C++: const char *) char const *

Help on function is_reg_integer in module ida_dbg:

is_reg_integer(*args) -> 'bool'
    is_reg_integer(regname) -> bool
    Does a register contain an integer value? \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param regname: (C++: const char *) char const *

Help on function is_request_running in module ida_dbg:

is_request_running(*args) -> 'bool'
    is_request_running() -> bool
    Is a request currently running?

Help on function is_step_trace_enabled in module ida_dbg:

is_step_trace_enabled(*args) -> 'bool'
    is_step_trace_enabled() -> bool
    Get current state of step tracing. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}

Help on function is_valid_dstate in module ida_dbg:

is_valid_dstate(*args) -> 'bool'
    is_valid_dstate(state) -> bool
    
    @param state: int

Help on function is_valid_trace_file in module ida_dbg:

is_valid_trace_file(*args) -> 'bool'
    is_valid_trace_file(filename) -> bool
    Is the specified file a valid trace file for the current database?
    
    @param filename: (C++: const char *) char const *

Help on function list_bptgrps in module ida_dbg:

list_bptgrps(*args) -> 'PyObject *'
    list_bptgrps(bptgrps) -> size_t
    Retrieve the list of absolute path of all folders of bpt dirtree \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param bptgrps: (C++: qstrvec_t *) list of absolute path in the bpt dirtree
    @return: number of folders returned
    list_bptgrps() -> [str, ...]

Help on function load_debugger in module ida_dbg:

load_debugger(*args) -> 'bool'
    load_debugger(dbgname, use_remote) -> bool
    
    @param dbgname: char const *
    @param use_remote: bool

Help on function load_trace_file in module ida_dbg:

load_trace_file(*args) -> 'qstring *'
    load_trace_file(filename) -> str
    Load a recorded trace file in the 'Tracing' window. If the call succeeds and
    'buf' is not null, the description of the trace stored in the binary trace file
    will be returned in 'buf'
    
    @param filename: (C++: const char *) char const *

Help on class memreg_info_t in module ida_dbg:

class memreg_info_t(builtins.object)
 |  Proxy of C++ memreg_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memreg_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_memreg_info_t(...)
 |      delete_memreg_info_t(self)
 |  
 |  get_bytes(self, *args) -> 'PyObject *'
 |      get_bytes(self) -> PyObject *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      get_bytes(self) -> PyObject *
 |  
 |  ea
 |      ea
 |  
 |  thisown
 |      The membership flag

Help on class memreg_infos_t in module ida_dbg:

class memreg_infos_t(builtins.object)
 |  Proxy of C++ qvector< memreg_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'memreg_info_t const &'
 |      __getitem__(self, i) -> memreg_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memreg_infos_t
 |      __init__(self, x) -> memreg_infos_t
 |      
 |      @param x: qvector< memreg_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: memreg_info_t const &
 |  
 |  __swig_destroy__ = delete_memreg_infos_t(...)
 |      delete_memreg_infos_t(self)
 |  
 |  at(self, *args) -> 'memreg_info_t const &'
 |      at(self, _idx) -> memreg_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< memreg_info_t >::const_iterator'
 |      begin(self) -> memreg_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< memreg_info_t >::const_iterator'
 |      end(self) -> memreg_info_t
 |  
 |  erase(self, *args) -> 'qvector< memreg_info_t >::iterator'
 |      erase(self, it) -> memreg_info_t
 |      
 |      @param it: qvector< memreg_info_t >::iterator
 |      
 |      erase(self, first, last) -> memreg_info_t
 |      
 |      @param first: qvector< memreg_info_t >::iterator
 |      @param last: qvector< memreg_info_t >::iterator
 |  
 |  extract(self, *args) -> 'memreg_info_t *'
 |      extract(self) -> memreg_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=memreg_info_t())
 |      
 |      @param x: memreg_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: memreg_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< memreg_info_t >::iterator'
 |      insert(self, it, x) -> memreg_info_t
 |      
 |      @param it: qvector< memreg_info_t >::iterator
 |      @param x: memreg_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'memreg_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: memreg_info_t const &
 |      
 |      push_back(self) -> memreg_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: memreg_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< memreg_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function set_bpt_group in module ida_dbg:

set_bpt_group(*args) -> 'bool'
    set_bpt_group(bpt, grp_name) -> bool
    Move a bpt into a folder in the breakpoint dirtree if the folder didn't exists,
    it will be created \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param bpt: (C++: bpt_t &) bpt that will be moved
    @param grp_name: (C++: const char *) absolute path to the breakpoint dirtree folder
    @return: success

Help on function put_dbg_byte in module ida_dbg:

put_dbg_byte(*args) -> 'bool'
    put_dbg_byte(ea, x) -> bool
    Change one byte of the debugged process memory.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint32) byte value
    @return: true if the process memory has been modified

Help on function read_dbg_memory in module ida_dbg:

read_dbg_memory(*args) -> 'ssize_t'
    read_dbg_memory(ea, buffer, size) -> ssize_t
    
    @param ea: ea_t
    @param buffer: void *
    @param size: size_t

Help on function refresh_debugger_memory in module ida_dbg:

refresh_debugger_memory(*args) -> 'PyObject *'
    refresh_debugger_memory() -> PyObject *
    Refreshes the debugger memory
    
    @return: Nothing

Help on function rename_bptgrp in module ida_dbg:

rename_bptgrp(*args) -> 'bool'
    rename_bptgrp(old_name, new_name) -> bool
    Rename a folder of bpt dirtree \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param old_name: (C++: const char *) absolute path to the folder to be renamed
    @param new_name: (C++: const char *) absolute path of the new folder name
    @return: success

Help on function request_add_bpt in module ida_dbg:

request_add_bpt(*args) -> 'bool'
    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    Post an add_bpt(const bpt_t &) request.
    
    @param ea: ea_t
    @param size: asize_t
    @param type: bpttype_t
    
    request_add_bpt(bpt) -> bool
    
    @param bpt: bpt_t const &

Help on function request_attach_process in module ida_dbg:

request_attach_process(*args) -> 'int'
    request_attach_process(pid, event_id) -> int
    Post an attach_process() request.
    
    @param pid: (C++: pid_t)
    @param event_id: (C++: int)

Help on function request_clear_trace in module ida_dbg:

request_clear_trace(*args) -> 'void'
    request_clear_trace()
    Post a clear_trace() request.

Help on function request_continue_process in module ida_dbg:

request_continue_process(*args) -> 'bool'
    request_continue_process() -> bool
    Post a continue_process() request.
    @note: This requires an explicit call to run_requests()

Help on function request_del_bpt in module ida_dbg:

request_del_bpt(*args) -> 'bool'
    request_del_bpt(ea) -> bool
    Post a del_bpt(const bpt_location_t &) request.
    
    @param ea: ea_t
    
    request_del_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

Help on function request_detach_process in module ida_dbg:

request_detach_process(*args) -> 'bool'
    request_detach_process() -> bool
    Post a detach_process() request.

Help on function request_disable_bblk_trace in module ida_dbg:

request_disable_bblk_trace(*args) -> 'bool'
    request_disable_bblk_trace() -> bool

Help on function request_disable_bpt in module ida_dbg:

request_disable_bpt(*args) -> 'bool'
    request_disable_bpt(ea) -> bool
    
    @param ea: ea_t
    
    request_disable_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

Help on function request_disable_func_trace in module ida_dbg:

request_disable_func_trace(*args) -> 'bool'
    request_disable_func_trace() -> bool

Help on function request_disable_insn_trace in module ida_dbg:

request_disable_insn_trace(*args) -> 'bool'
    request_disable_insn_trace() -> bool

Help on function request_disable_step_trace in module ida_dbg:

request_disable_step_trace(*args) -> 'bool'
    request_disable_step_trace() -> bool

Help on function request_enable_bblk_trace in module ida_dbg:

request_enable_bblk_trace(*args) -> 'bool'
    request_enable_bblk_trace(enable=True) -> bool
    
    @param enable: bool

Help on function request_enable_bpt in module ida_dbg:

request_enable_bpt(*args) -> 'bool'
    request_enable_bpt(ea, enable=True) -> bool
    
    @param ea: ea_t
    @param enable: bool
    
    request_enable_bpt(bptloc, enable=True) -> bool
    
    @param bptloc: bpt_location_t const &
    @param enable: bool

Help on function request_enable_func_trace in module ida_dbg:

request_enable_func_trace(*args) -> 'bool'
    request_enable_func_trace(enable=True) -> bool
    
    @param enable: bool

Help on function request_enable_insn_trace in module ida_dbg:

request_enable_insn_trace(*args) -> 'bool'
    request_enable_insn_trace(enable=True) -> bool
    
    @param enable: bool

Help on function request_enable_step_trace in module ida_dbg:

request_enable_step_trace(*args) -> 'bool'
    request_enable_step_trace(enable=1) -> bool
    
    @param enable: int

Help on function request_exit_process in module ida_dbg:

request_exit_process(*args) -> 'bool'
    request_exit_process() -> bool
    Post an exit_process() request.

Help on function request_resume_thread in module ida_dbg:

request_resume_thread(*args) -> 'int'
    request_resume_thread(tid) -> int
    Post a resume_thread() request.
    
    @param tid: (C++: thid_t)

Help on function request_run_to in module ida_dbg:

request_run_to(*args) -> 'bool'
    request_run_to(ea, pid=pid_t(-1), tid=0) -> bool
    Post a run_to() request.
    
    @param ea: (C++: ea_t)
    @param pid: (C++: pid_t)

Help on function request_select_thread in module ida_dbg:

request_select_thread(*args) -> 'bool'
    request_select_thread(tid) -> bool
    Post a select_thread() request.
    
    @param tid: (C++: thid_t)

Help on function request_set_bblk_trace_options in module ida_dbg:

request_set_bblk_trace_options(*args) -> 'void'
    request_set_bblk_trace_options(options)
    Post a set_bblk_trace_options() request.
    
    @param options: (C++: int)

Help on function request_set_func_trace_options in module ida_dbg:

request_set_func_trace_options(*args) -> 'void'
    request_set_func_trace_options(options)
    Post a set_func_trace_options() request.
    
    @param options: (C++: int)

Help on function request_set_insn_trace_options in module ida_dbg:

request_set_insn_trace_options(*args) -> 'void'
    request_set_insn_trace_options(options)
    Post a set_insn_trace_options() request.
    
    @param options: (C++: int)

Help on function request_set_reg_val in module ida_dbg:

request_set_reg_val(*args) -> 'PyObject *'
    request_set_reg_val(regname, o) -> PyObject *
    Post a set_reg_val() request.
    
    @param regname: (C++: const char *) char const *
    @param o: PyObject *

Help on function request_set_resume_mode in module ida_dbg:

request_set_resume_mode(*args) -> 'bool'
    request_set_resume_mode(tid, mode) -> bool
    Post a set_resume_mode() request.
    
    @param tid: (C++: thid_t)
    @param mode: (C++: resume_mode_t) enum resume_mode_t

Help on function request_set_step_trace_options in module ida_dbg:

request_set_step_trace_options(*args) -> 'void'
    request_set_step_trace_options(options)
    Post a set_step_trace_options() request.
    
    @param options: (C++: int)

Help on function request_start_process in module ida_dbg:

request_start_process(*args) -> 'int'
    request_start_process(path=None, args=None, sdir=None) -> int
    Post a start_process() request.
    
    @param path: (C++: const char *) char const *
    @param args: (C++: const char *) char const *
    @param sdir: (C++: const char *) char const *

Help on function request_step_into in module ida_dbg:

request_step_into(*args) -> 'bool'
    request_step_into() -> bool
    Post a step_into() request.

Help on function request_step_over in module ida_dbg:

request_step_over(*args) -> 'bool'
    request_step_over() -> bool
    Post a step_over() request.

Help on function request_step_until_ret in module ida_dbg:

request_step_until_ret(*args) -> 'bool'
    request_step_until_ret() -> bool
    Post a step_until_ret() request.

Help on function request_suspend_process in module ida_dbg:

request_suspend_process(*args) -> 'bool'
    request_suspend_process() -> bool
    Post a suspend_process() request.

Help on function request_suspend_thread in module ida_dbg:

request_suspend_thread(*args) -> 'int'
    request_suspend_thread(tid) -> int
    Post a suspend_thread() request.
    
    @param tid: (C++: thid_t)

Help on function resume_thread in module ida_dbg:

resume_thread(*args) -> 'int'
    resume_thread(tid) -> int
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

Help on function retrieve_exceptions in module ida_dbg:

retrieve_exceptions(*args) -> 'excvec_t *'
    retrieve_exceptions() -> excvec_t
    Retrieve the exception information. You may freely modify the returned vector
    and add/edit/delete exceptions You must call store_exceptions() after any
    modifications Note: exceptions with code zero, multiple exception codes or names
    are prohibited

Help on function run_requests in module ida_dbg:

run_requests(*args) -> 'bool'
    run_requests() -> bool
    Execute requests until all requests are processed or an asynchronous function is
    called. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    @return: false if not all requests could be processed (indicates an asynchronous
             function was started)
    @note: If called from a notification handler, the execution of requests will be
           postponed to the end of the execution of all notification handlers.

Help on function run_to in module ida_dbg:

run_to(*args) -> 'bool'
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
    Execute the process until the given address is reached. If no process is active,
    a new process is started. Technically, the debugger sets up a temporary
    breakpoint at the given address, and continues (or starts) the execution of the
    whole process. So, all threads continue their execution! \sq{Type, Asynchronous
    function - available as Request, Notification, dbg_run_to}
    
    @param ea: (C++: ea_t) target address
    @param pid: (C++: pid_t) not used yet. please do not specify this parameter.

Help on function save_trace_file in module ida_dbg:

save_trace_file(*args) -> 'bool'
    save_trace_file(filename, description) -> bool
    Save the current trace in the specified file.
    
    @param filename: (C++: const char *) char const *
    @param description: (C++: const char *) char const *

Help on function select_thread in module ida_dbg:

select_thread(*args) -> 'bool'
    select_thread(tid) -> bool
    Select the given thread as the current debugged thread. All thread related
    execution functions will work on this thread. The process must be suspended to
    select a new thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) ID of the thread to select
    @return: false if the thread doesn't exist.

Help on function send_dbg_command in module ida_dbg:

send_dbg_command(command)
    Send a direct command to the debugger backend, and
    retrieve the result as a string.
    
    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure

Help on function set_bblk_trace_options in module ida_dbg:

set_bblk_trace_options(*args) -> 'void'
    set_bblk_trace_options(options)
    Modify basic block tracing options (see BT_LOG_INSTS)
    
    @param options: (C++: int)

Help on function set_bptloc_group in module ida_dbg:

set_bptloc_group(*args) -> 'bool'
    set_bptloc_group(bptloc, grp_name) -> bool
    Move a bpt into a folder in the breakpoint dirtree based on the bpt_location
    find_bpt is called to retrieve the bpt and then set_bpt_group if the folder
    didn't exists, it will be created \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) bptlocation of the bpt that will be moved
    @param grp_name: (C++: const char *) absolute path to the breakpoint dirtree folder
    @return: success

Help on function set_bptloc_string in module ida_dbg:

set_bptloc_string(*args) -> 'int'
    set_bptloc_string(s) -> int
    
    @param s: char const *

Help on function set_debugger_event_cond in module ida_dbg:

set_debugger_event_cond(*args) -> 'void'
    set_debugger_event_cond(NONNULL_evcond)
    
    @param NONNULL_evcond: char const *

Help on function set_debugger_options in module ida_dbg:

set_debugger_options(*args) -> 'uint'
    set_debugger_options(options) -> uint
    Set debugger options. Replaces debugger options with the specification
    combination Debugger options
    
    @param options: (C++: uint)
    @return: the old debugger options

Help on function set_func_trace_options in module ida_dbg:

set_func_trace_options(*args) -> 'void'
    set_func_trace_options(options)
    Modify function tracing options. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

Help on function set_highlight_trace_options in module ida_dbg:

set_highlight_trace_options(*args) -> 'void'
    set_highlight_trace_options(hilight, color, diff)
    Set highlight trace parameters.
    
    @param hilight: (C++: bool)
    @param color: (C++: bgcolor_t)
    @param diff: (C++: bgcolor_t)

Help on function set_insn_trace_options in module ida_dbg:

set_insn_trace_options(*args) -> 'void'
    set_insn_trace_options(options)
    Modify instruction tracing options. \sq{Type, Synchronous function - available
    as request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

Help on function set_manual_regions in module ida_dbg:

set_manual_regions(*args) -> 'void'
    set_manual_regions(ranges)
    
    @param ranges: meminfo_vec_t const *

Help on function set_process_options in module ida_dbg:

set_process_options(*args) -> 'void'
    set_process_options(path, args, sdir, host, _pass, port)
    Set process options. Any of the arguments may be nullptr, which means 'do not
    modify'
    
    @param path: (C++: const char *) char const *
    @param args: (C++: const char *) char const *
    @param sdir: (C++: const char *) char const *
    @param host: (C++: const char *) char const *
    @param pass: (C++: const char *) char const *
    @param port: (C++: int)

Help on function set_process_state in module ida_dbg:

set_process_state(*args) -> 'int'
    set_process_state(newstate, p_thid, dbginv) -> int
    Set new state for the debugged process. Notifies the IDA kernel about the change
    of the debugged process state. For example, a debugger module could call this
    function when it knows that the process is suspended for a short period of time.
    Some IDA API calls can be made only when the process is suspended. The process
    state is usually restored before returning control to the caller. You must know
    that it is ok to change the process state, doing it at arbitrary moments may
    crash the application or IDA. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param newstate: (C++: int) new process state (one of Debugged process states) if
                     DSTATE_NOTASK is passed then the state is not changed
    @param p_thid: (C++: thid_t *) ptr to new thread id. may be nullptr or pointer to NO_THREAD. the
                   pointed variable will contain the old thread id upon return
    @param dbginv: (C++: int) Debugged process invalidation options
    @return: old debugger state (one of Debugged process states)

Help on function set_reg_val in module ida_dbg:

set_reg_val(*args) -> 'PyObject *'
    set_reg_val(regname, o) -> PyObject
    Write a register value to the current thread.
    
    @param regname: (C++: const char *) char const *
    @param o: PyObject *
    
    set_reg_val(tid, regidx, o) -> bool, int
    
    @param tid: thid_t
    @param regidx: int
    @param o: PyObject *

Help on function set_remote_debugger in module ida_dbg:

set_remote_debugger(*args) -> 'void'
    set_remote_debugger(host, _pass, port=-1)
    Set remote debugging options. Should be used before starting the debugger.
    
    @param host: (C++: const char *) If empty, IDA will use local debugger. If nullptr, the host will
                 not be set.
    @param pass: (C++: const char *) If nullptr, the password will not be set
    @param port: (C++: int) If -1, the default port number will be used

Help on function set_resume_mode in module ida_dbg:

set_resume_mode(*args) -> 'bool'
    set_resume_mode(tid, mode) -> bool
    How to resume the application. Set resume mode but do not resume process.
    
    @param tid: (C++: thid_t)
    @param mode: (C++: resume_mode_t) enum resume_mode_t

Help on function set_step_trace_options in module ida_dbg:

set_step_trace_options(*args) -> 'void'
    set_step_trace_options(options)
    Modify step tracing options. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

Help on function set_trace_base_address in module ida_dbg:

set_trace_base_address(*args) -> 'void'
    set_trace_base_address(ea)
    Set the base address of the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param ea: (C++: ea_t)

Help on function set_trace_dynamic_register_set in module ida_dbg:

set_trace_dynamic_register_set(*args) -> 'void'
    set_trace_dynamic_register_set(idaregs)
    Set dynamic register set of current trace.
    
    @param idaregs: (C++: dynamic_register_set_t &)

Help on function set_trace_file_desc in module ida_dbg:

set_trace_file_desc(*args) -> 'bool'
    set_trace_file_desc(filename, description) -> bool
    Change the description of the specified trace file.
    
    @param filename: (C++: const char *) char const *
    @param description: (C++: const char *) char const *

Help on function set_trace_platform in module ida_dbg:

set_trace_platform(*args) -> 'void'
    set_trace_platform(platform)
    Set platform name of current trace.
    
    @param platform: (C++: const char *) char const *

Help on function set_trace_size in module ida_dbg:

set_trace_size(*args) -> 'bool'
    set_trace_size(size) -> bool
    Specify the new size of the circular buffer. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    @param size: (C++: int) if 0, buffer isn't circular and events are never removed. If the
                 new size is smaller than the existing number of trace events, a
                 corresponding number of trace events are removed.
    @note: If you specify 0, all available memory can be quickly used !!!

Help on function srcdbg_request_step_into in module ida_dbg:

srcdbg_request_step_into(*args) -> 'bool'
    srcdbg_request_step_into() -> bool

Help on function srcdbg_request_step_over in module ida_dbg:

srcdbg_request_step_over(*args) -> 'bool'
    srcdbg_request_step_over() -> bool

Help on function srcdbg_request_step_until_ret in module ida_dbg:

srcdbg_request_step_until_ret(*args) -> 'bool'
    srcdbg_request_step_until_ret() -> bool

Help on function srcdbg_step_into in module ida_dbg:

srcdbg_step_into(*args) -> 'bool'
    srcdbg_step_into() -> bool

Help on function srcdbg_step_over in module ida_dbg:

srcdbg_step_over(*args) -> 'bool'
    srcdbg_step_over() -> bool

Help on function srcdbg_step_until_ret in module ida_dbg:

srcdbg_step_until_ret(*args) -> 'bool'
    srcdbg_step_until_ret() -> bool

Help on function start_process in module ida_dbg:

start_process(*args) -> 'int'
    start_process(path=None, args=None, sdir=None) -> int
    Start a process in the debugger. \sq{Type, Asynchronous function - available as
    Request, Notification, dbg_process_start}
    @note: You can also use the run_to() function to easily start the execution of a
           process until a given address is reached.
    @note: For all parameters, a nullptr value indicates the debugger will take the
           value from the defined Process Options.
    
    @param path: (C++: const char *) path to the executable to start
    @param args: (C++: const char *) arguments to pass to process
    @param sdir: (C++: const char *) starting directory for the process
    @retval -1: impossible to create the process
    @retval 0: the starting of the process was cancelled by the user
    @retval 1: the process was properly started

Help on function step_into in module ida_dbg:

step_into(*args) -> 'bool'
    step_into() -> bool
    Execute one instruction in the current thread. Other threads are kept suspended.
    \sq{Type, Asynchronous function - available as Request, Notification,
    dbg_step_into}

Help on function step_over in module ida_dbg:

step_over(*args) -> 'bool'
    step_over() -> bool
    Execute one instruction in the current thread, but without entering into
    functions. Others threads keep suspended. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_step_over}

Help on function step_until_ret in module ida_dbg:

step_until_ret(*args) -> 'bool'
    step_until_ret() -> bool
    Execute instructions in the current thread until a function return instruction
    is executed (aka "step out"). Other threads are kept suspended. \sq{Type,
    Asynchronous function - available as Request, Notification, dbg_step_until_ret}

Help on function store_exceptions in module ida_dbg:

store_exceptions(*args) -> 'bool'
    store_exceptions() -> bool
    Update the exception information stored in the debugger module by invoking its
    dbg->set_exception_info callback

Help on function suspend_process in module ida_dbg:

suspend_process(*args) -> 'bool'
    suspend_process() -> bool
    Suspend the process in the debugger. \sq{ Type,
    * Synchronous function (if in a notification handler)
    * Asynchronous function (everywhere else)
    * available as Request, Notification,
    * none (if in a notification handler)
    * dbg_suspend_process (everywhere else) }
    @note: The suspend_process() function can be called from a notification handler
           to force the stopping of the process. In this case, no notification will
           be generated. When you suspend a process, the running command is always
           aborted.

Help on function suspend_thread in module ida_dbg:

suspend_thread(*args) -> 'int'
    suspend_thread(tid) -> int
    Suspend thread. Suspending a thread may deadlock the whole application if the
    suspended was owning some synchronization objects. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

Help on class tev_info_reg_t in module ida_dbg:

class tev_info_reg_t(builtins.object)
 |  Proxy of C++ tev_info_reg_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_info_reg_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tev_info_reg_t(...)
 |      delete_tev_info_reg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  info
 |      info
 |  
 |  registers
 |      registers
 |  
 |  thisown
 |      The membership flag

Help on class tev_info_t in module ida_dbg:

class tev_info_t(builtins.object)
 |  Proxy of C++ tev_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tev_info_t(...)
 |      delete_tev_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tid
 |  
 |  type
 |      type

Help on class tev_reg_value_t in module ida_dbg:

class tev_reg_value_t(builtins.object)
 |  Proxy of C++ tev_reg_value_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _reg_idx=-1, _value=uint64(-1)) -> tev_reg_value_t
 |      
 |      @param _reg_idx: int
 |      @param _value: uint64
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tev_reg_value_t(...)
 |      delete_tev_reg_value_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reg_idx
 |      reg_idx
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value

Help on class tev_reg_values_t in module ida_dbg:

class tev_reg_values_t(builtins.object)
 |  Proxy of C++ qvector< tev_reg_value_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'tev_reg_value_t const &'
 |      __getitem__(self, i) -> tev_reg_value_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tev_reg_values_t
 |      __init__(self, x) -> tev_reg_values_t
 |      
 |      @param x: qvector< tev_reg_value_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: tev_reg_value_t const &
 |  
 |  __swig_destroy__ = delete_tev_reg_values_t(...)
 |      delete_tev_reg_values_t(self)
 |  
 |  at(self, *args) -> 'tev_reg_value_t const &'
 |      at(self, _idx) -> tev_reg_value_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< tev_reg_value_t >::const_iterator'
 |      begin(self) -> tev_reg_value_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< tev_reg_value_t >::const_iterator'
 |      end(self) -> tev_reg_value_t
 |  
 |  erase(self, *args) -> 'qvector< tev_reg_value_t >::iterator'
 |      erase(self, it) -> tev_reg_value_t
 |      
 |      @param it: qvector< tev_reg_value_t >::iterator
 |      
 |      erase(self, first, last) -> tev_reg_value_t
 |      
 |      @param first: qvector< tev_reg_value_t >::iterator
 |      @param last: qvector< tev_reg_value_t >::iterator
 |  
 |  extract(self, *args) -> 'tev_reg_value_t *'
 |      extract(self) -> tev_reg_value_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=tev_reg_value_t())
 |      
 |      @param x: tev_reg_value_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: tev_reg_value_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< tev_reg_value_t >::iterator'
 |      insert(self, it, x) -> tev_reg_value_t
 |      
 |      @param it: qvector< tev_reg_value_t >::iterator
 |      @param x: tev_reg_value_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'tev_reg_value_t &'
 |      push_back(self, x)
 |      
 |      @param x: tev_reg_value_t const &
 |      
 |      push_back(self) -> tev_reg_value_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: tev_reg_value_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< tev_reg_value_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class tevinforeg_vec_t in module ida_dbg:

class tevinforeg_vec_t(builtins.object)
 |  Proxy of C++ qvector< tev_info_reg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'tev_info_reg_t const &'
 |      __getitem__(self, i) -> tev_info_reg_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tevinforeg_vec_t
 |      __init__(self, x) -> tevinforeg_vec_t
 |      
 |      @param x: qvector< tev_info_reg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: tev_info_reg_t const &
 |  
 |  __swig_destroy__ = delete_tevinforeg_vec_t(...)
 |      delete_tevinforeg_vec_t(self)
 |  
 |  at(self, *args) -> 'tev_info_reg_t const &'
 |      at(self, _idx) -> tev_info_reg_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< tev_info_reg_t >::const_iterator'
 |      begin(self) -> tev_info_reg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< tev_info_reg_t >::const_iterator'
 |      end(self) -> tev_info_reg_t
 |  
 |  erase(self, *args) -> 'qvector< tev_info_reg_t >::iterator'
 |      erase(self, it) -> tev_info_reg_t
 |      
 |      @param it: qvector< tev_info_reg_t >::iterator
 |      
 |      erase(self, first, last) -> tev_info_reg_t
 |      
 |      @param first: qvector< tev_info_reg_t >::iterator
 |      @param last: qvector< tev_info_reg_t >::iterator
 |  
 |  extract(self, *args) -> 'tev_info_reg_t *'
 |      extract(self) -> tev_info_reg_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=tev_info_reg_t())
 |      
 |      @param x: tev_info_reg_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: tev_info_reg_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< tev_info_reg_t >::iterator'
 |      insert(self, it, x) -> tev_info_reg_t
 |      
 |      @param it: qvector< tev_info_reg_t >::iterator
 |      @param x: tev_info_reg_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'tev_info_reg_t &'
 |      push_back(self, x)
 |      
 |      @param x: tev_info_reg_t const &
 |      
 |      push_back(self) -> tev_info_reg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: tev_info_reg_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< tev_info_reg_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function update_bpt in module ida_dbg:

update_bpt(*args) -> 'bool'
    update_bpt(bpt) -> bool
    Update modifiable characteristics of an existing breakpoint. To update the
    breakpoint location, use change_bptlocs() \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    @note: Only the following fields can be modified:
    * bpt_t::cndbody
    * bpt_t::pass_count
    * bpt_t::flags
    * bpt_t::size
    * bpt_t::type
    @note: Changing some properties will require removing and then re-adding the
           breakpoint to the process memory (or the debugger backend), which can
           lead to race conditions (i.e., breakpoint(s) can be missed) in case the
           process is not suspended. Here are a list of scenarios that will require
           the breakpoint to be removed & then re-added:
    * bpt_t::size is modified
    * bpt_t::type is modified
    * bpt_t::flags's BPT_ENABLED is modified
    * bpt_t::flags's BPT_LOWCND is changed
    * bpt_t::flags's BPT_LOWCND remains set, but cndbody changed
    
    @param bpt: (C++: const bpt_t *) bpt_t const *

Help on function wait_for_next_event in module ida_dbg:

wait_for_next_event(*args) -> 'dbg_event_code_t'
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
    Wait for the next event.
    
    This function (optionally) resumes the process execution, and waits for a
    debugger event until a possible timeout occurs.
    
    @param wfne: (C++: int) combination of Wait for debugger event flags constants
    @param timeout: (C++: int) number of seconds to wait, -1-infinity
    @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <= 0)

Help on function write_dbg_memory in module ida_dbg:

write_dbg_memory(*args) -> 'ssize_t'
    write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t
    
    @param ea: ea_t
    @param py_buf: PyObject *
    @param size: size_t

Module "ida_dirtree"s docstring:
"""
Types involved in grouping of item into folders.

The dirtree_t class is used to organize a directory tree on top of any
collection that allows for accessing its elements by an id (inode).

No requirements are imposed on the inodes apart from the forbidden value -1 (it
is used ot denote a bad inode).

The dirspec_t class is used to specialize the dirtree. It can be used to
introduce a directory structure for:
* local types
* structs
* enums
* functions
* names
* etc

@note: you should be manipulating dirtree_t (and, if implementing a new tree
       backend, dirspec_t) instances, not calling top-level functions in this
       file directly."""

Help on class direntry_t in module ida_dirtree:

class direntry_t(builtins.object)
 |  Proxy of C++ direntry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: direntry_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, i=BADIDX, d=False) -> direntry_t
 |      
 |      @param i: uval_t
 |      @param d: bool
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: direntry_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: direntry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_direntry_t(...)
 |      delete_direntry_t(self)
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      idx
 |  
 |  isdir
 |      isdir
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  BADIDX = unsigned-ea-like-numeric-type(-1)
 |  
 |  ROOTIDX = 0
 |  
 |  __hash__ = None

Help on class direntry_vec_t in module ida_dirtree:

class direntry_vec_t(builtins.object)
 |  Proxy of C++ qvector< direntry_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< direntry_t > const &
 |  
 |  __getitem__(self, *args) -> 'direntry_t const &'
 |      __getitem__(self, i) -> direntry_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> direntry_vec_t
 |      __init__(self, x) -> direntry_vec_t
 |      
 |      @param x: qvector< direntry_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< direntry_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: direntry_t const &
 |  
 |  __swig_destroy__ = delete_direntry_vec_t(...)
 |      delete_direntry_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: direntry_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: direntry_t const &
 |  
 |  at(self, *args) -> 'direntry_t const &'
 |      at(self, _idx) -> direntry_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< direntry_t >::const_iterator'
 |      begin(self) -> direntry_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< direntry_t >::const_iterator'
 |      end(self) -> direntry_t
 |  
 |  erase(self, *args) -> 'qvector< direntry_t >::iterator'
 |      erase(self, it) -> direntry_t
 |      
 |      @param it: qvector< direntry_t >::iterator
 |      
 |      erase(self, first, last) -> direntry_t
 |      
 |      @param first: qvector< direntry_t >::iterator
 |      @param last: qvector< direntry_t >::iterator
 |  
 |  extract(self, *args) -> 'direntry_t *'
 |      extract(self) -> direntry_t
 |  
 |  find(self, *args) -> 'qvector< direntry_t >::const_iterator'
 |      find(self, x) -> direntry_t
 |      
 |      @param x: direntry_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=direntry_t())
 |      
 |      @param x: direntry_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: direntry_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: direntry_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< direntry_t >::iterator'
 |      insert(self, it, x) -> direntry_t
 |      
 |      @param it: qvector< direntry_t >::iterator
 |      @param x: direntry_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'direntry_t &'
 |      push_back(self, x)
 |      
 |      @param x: direntry_t const &
 |      
 |      push_back(self) -> direntry_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: direntry_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< direntry_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class dirspec_t in module ida_dirtree:

class dirspec_t(builtins.object)
 |  Proxy of C++ dirspec_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, nm=None, f=0) -> dirspec_t
 |      
 |      @param nm: char const *
 |      @param f: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_dirspec_t(...)
 |      delete_dirspec_t(self)
 |  
 |  get_attrs(self, *args) -> 'qstring'
 |      get_attrs(self, inode) -> qstring
 |      
 |      @param inode: inode_t
 |  
 |  get_inode(self, *args) -> 'inode_t'
 |      get_inode(self, dirpath, name) -> inode_t
 |      get the entry inode in the specified directory
 |      
 |      @param dirpath: (C++: const char *) the absolute directory path with trailing slash
 |      @param name: (C++: const char *) the entry name in the directory
 |      @return: the entry inode
 |  
 |  get_name(self, *args) -> 'bool'
 |      get_name(self, inode, name_flags=DTN_FULL_NAME) -> bool
 |      get the entry name. for example, the structure name
 |      
 |      @param inode: (C++: inode_t) inode number of the entry
 |      @param name_flags: (C++: uint32) how exactly the name should be retrieved. combination of bits
 |                         for get_...name() methods bits
 |      @return: false if the entry does not exist.
 |  
 |  rename_inode(self, *args) -> 'bool'
 |      rename_inode(self, inode, newname) -> bool
 |      rename the entry
 |      
 |      @param inode: (C++: inode_t)
 |      @param newname: (C++: const char *)
 |      @return: success
 |  
 |  unlink_inode(self, *args) -> 'void'
 |      unlink_inode(self, inode)
 |      
 |      @param inode: (C++: inode_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      flags
 |  
 |  id
 |      id
 |  
 |  nodename
 |      id
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  DSF_INODE_EA = 1
 |  
 |  DSF_PRIVRANGE = 2

Help on class dirtree_cursor_t in module ida_dirtree:

class dirtree_cursor_t(builtins.object)
 |  Proxy of C++ dirtree_cursor_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _parent=BADIDX, _rank=size_t(-1)) -> dirtree_cursor_t
 |      
 |      @param _parent: diridx_t
 |      @param _rank: size_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_dirtree_cursor_t(...)
 |      delete_dirtree_cursor_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: dirtree_cursor_t const &
 |  
 |  is_root_cursor(self, *args) -> 'bool'
 |      is_root_cursor(self) -> bool
 |  
 |  set_root_cursor(self, *args) -> 'void'
 |      set_root_cursor(self)
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  root_cursor(*args) -> 'dirtree_cursor_t'
 |      root_cursor() -> dirtree_cursor_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  parent
 |      parent
 |  
 |  rank
 |      rank
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function dirtree_cursor_t_root_cursor in module ida_dirtree:

dirtree_cursor_t_root_cursor(*args) -> 'dirtree_cursor_t'
    dirtree_cursor_t_root_cursor() -> dirtree_cursor_t

Help on class dirtree_cursor_vec_t in module ida_dirtree:

class dirtree_cursor_vec_t(builtins.object)
 |  Proxy of C++ qvector< dirtree_cursor_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< dirtree_cursor_t > const &
 |  
 |  __getitem__(self, *args) -> 'dirtree_cursor_t const &'
 |      __getitem__(self, i) -> dirtree_cursor_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> dirtree_cursor_vec_t
 |      __init__(self, x) -> dirtree_cursor_vec_t
 |      
 |      @param x: qvector< dirtree_cursor_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< dirtree_cursor_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: dirtree_cursor_t const &
 |  
 |  __swig_destroy__ = delete_dirtree_cursor_vec_t(...)
 |      delete_dirtree_cursor_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: dirtree_cursor_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  at(self, *args) -> 'dirtree_cursor_t const &'
 |      at(self, _idx) -> dirtree_cursor_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< dirtree_cursor_t >::const_iterator'
 |      begin(self) -> dirtree_cursor_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< dirtree_cursor_t >::const_iterator'
 |      end(self) -> dirtree_cursor_t
 |  
 |  erase(self, *args) -> 'qvector< dirtree_cursor_t >::iterator'
 |      erase(self, it) -> dirtree_cursor_t
 |      
 |      @param it: qvector< dirtree_cursor_t >::iterator
 |      
 |      erase(self, first, last) -> dirtree_cursor_t
 |      
 |      @param first: qvector< dirtree_cursor_t >::iterator
 |      @param last: qvector< dirtree_cursor_t >::iterator
 |  
 |  extract(self, *args) -> 'dirtree_cursor_t *'
 |      extract(self) -> dirtree_cursor_t
 |  
 |  find(self, *args) -> 'qvector< dirtree_cursor_t >::const_iterator'
 |      find(self, x) -> dirtree_cursor_t
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=dirtree_cursor_t())
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: dirtree_cursor_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< dirtree_cursor_t >::iterator'
 |      insert(self, it, x) -> dirtree_cursor_t
 |      
 |      @param it: qvector< dirtree_cursor_t >::iterator
 |      @param x: dirtree_cursor_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'dirtree_cursor_t &'
 |      push_back(self, x)
 |      
 |      @param x: dirtree_cursor_t const &
 |      
 |      push_back(self) -> dirtree_cursor_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: dirtree_cursor_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< dirtree_cursor_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class dirtree_iterator_t in module ida_dirtree:

class dirtree_iterator_t(builtins.object)
 |  Proxy of C++ dirtree_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> dirtree_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_dirtree_iterator_t(...)
 |      delete_dirtree_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cursor
 |      cursor
 |  
 |  pattern
 |      pattern
 |  
 |  thisown
 |      The membership flag

Help on class dirtree_selection_t in module ida_dirtree:

class dirtree_selection_t(dirtree_cursor_vec_t)
 |  Proxy of C++ dirtree_selection_t class.
 |  
 |  Method resolution order:
 |      dirtree_selection_t
 |      dirtree_cursor_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> dirtree_selection_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_dirtree_selection_t(...)
 |      delete_dirtree_selection_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from dirtree_cursor_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< dirtree_cursor_t > const &
 |  
 |  __getitem__(self, *args) -> 'dirtree_cursor_t const &'
 |      __getitem__(self, i) -> dirtree_cursor_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< dirtree_cursor_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: dirtree_cursor_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: dirtree_cursor_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  at(self, *args) -> 'dirtree_cursor_t const &'
 |      at(self, _idx) -> dirtree_cursor_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< dirtree_cursor_t >::const_iterator'
 |      begin(self) -> dirtree_cursor_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< dirtree_cursor_t >::const_iterator'
 |      end(self) -> dirtree_cursor_t
 |  
 |  erase(self, *args) -> 'qvector< dirtree_cursor_t >::iterator'
 |      erase(self, it) -> dirtree_cursor_t
 |      
 |      @param it: qvector< dirtree_cursor_t >::iterator
 |      
 |      erase(self, first, last) -> dirtree_cursor_t
 |      
 |      @param first: qvector< dirtree_cursor_t >::iterator
 |      @param last: qvector< dirtree_cursor_t >::iterator
 |  
 |  extract(self, *args) -> 'dirtree_cursor_t *'
 |      extract(self) -> dirtree_cursor_t
 |  
 |  find(self, *args) -> 'qvector< dirtree_cursor_t >::const_iterator'
 |      find(self, x) -> dirtree_cursor_t
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=dirtree_cursor_t())
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: dirtree_cursor_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: dirtree_cursor_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< dirtree_cursor_t >::iterator'
 |      insert(self, it, x) -> dirtree_cursor_t
 |      
 |      @param it: qvector< dirtree_cursor_t >::iterator
 |      @param x: dirtree_cursor_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'dirtree_cursor_t &'
 |      push_back(self, x)
 |      
 |      @param x: dirtree_cursor_t const &
 |      
 |      push_back(self) -> dirtree_cursor_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: dirtree_cursor_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< dirtree_cursor_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from dirtree_cursor_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from dirtree_cursor_vec_t:
 |  
 |  __hash__ = None

Help on class dirtree_t in module ida_dirtree:

class dirtree_t(builtins.object)
 |  Proxy of C++ dirtree_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, ds) -> dirtree_t
 |      
 |      @param ds: dirspec_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_dirtree_t(...)
 |      delete_dirtree_t(self)
 |  
 |  change_rank(self, *args) -> 'dterr_t'
 |      change_rank(self, path, rank_delta) -> dterr_t
 |      Change ordering rank of an item.
 |      
 |      @param path: (C++: const char *) path to the item
 |      @param rank_delta: (C++: ssize_t) the amount of the change. positive numbers mean to move down
 |                         in the list; negative numbers mean to move up.
 |      @return: dterr_t error code
 |      @note: All subdirectories go before all file entries.
 |  
 |  chdir(self, *args) -> 'dterr_t'
 |      chdir(self, path) -> dterr_t
 |      Change current directory
 |      
 |      @param path: (C++: const char *) new current directory
 |      @return: dterr_t error code
 |  
 |  find_entry(self, *args) -> 'dirtree_cursor_t'
 |      find_entry(self, de) -> dirtree_cursor_t
 |      Find the cursor corresponding to an entry of a directory
 |      
 |      @param de: (C++: const direntry_t &) directory entry
 |      @return: cursor corresponding to the directory entry
 |  
 |  findfirst(self, *args) -> 'bool'
 |      findfirst(self, ff, pattern) -> bool
 |      Start iterating over files in a directory
 |      
 |      @param ff: (C++: dirtree_iterator_t *) directory iterator. it will be initialized by the function
 |      @param pattern: (C++: const char *) pattern to search for
 |      @return: success
 |  
 |  findnext(self, *args) -> 'bool'
 |      findnext(self, ff) -> bool
 |      Continue iterating over files in a directory
 |      
 |      @param ff: (C++: dirtree_iterator_t *) directory iterator
 |      @return: success
 |  
 |  get_abspath(self, *args) -> 'qstring'
 |      get_abspath(self, cursor) -> qstring
 |      Construct an absolute path from the specified relative path. This function
 |      verifies the directory part of the specified path. The last component of the
 |      specified path is not verified.
 |      
 |      @param cursor: dirtree_cursor_t const &
 |      
 |      @return: path. empty path means wrong directory part of RELPATH
 |      get_abspath(self, relpath) -> qstring
 |      
 |      @param relpath: char const *
 |  
 |  get_dir_size(self, *args) -> 'ssize_t'
 |      get_dir_size(self, diridx) -> ssize_t
 |      Get dir size
 |      
 |      @param diridx: (C++: diridx_t) directory index
 |      @return: number of entries under this directory; if error, return -1
 |  
 |  get_entry_attrs(self, *args) -> 'qstring'
 |      get_entry_attrs(self, de) -> qstring
 |      Get entry attributes
 |      
 |      @param de: (C++: const direntry_t &) directory entry
 |      @return: name
 |  
 |  get_entry_name(self, *args) -> 'qstring'
 |      get_entry_name(self, de, name_flags=DTN_FULL_NAME) -> qstring
 |      Get entry name
 |      
 |      @param de: (C++: const direntry_t &) directory entry
 |      @param name_flags: (C++: uint32) how exactly the name should be retrieved. combination of bits
 |                         for get_...name() methods bits
 |      @return: name
 |  
 |  get_id(self, *args) -> 'char const *'
 |      get_id(self) -> char const *
 |      netnode name
 |  
 |  get_nodename = get_id(self, *args) -> 'char const *'
 |  
 |  get_parent_cursor(self, *args) -> 'dirtree_cursor_t'
 |      get_parent_cursor(self, cursor) -> dirtree_cursor_t
 |      Get parent cursor.
 |      
 |      @param cursor: (C++: const dirtree_cursor_t &) a valid ditree cursor
 |      @return: cursor's parent
 |  
 |  get_rank(self, *args) -> 'ssize_t'
 |      get_rank(self, diridx, de) -> ssize_t
 |      Get ordering rank of an item.
 |      
 |      @param diridx: (C++: diridx_t) index of the parent directory
 |      @param de: (C++: const direntry_t &) directory entry
 |      @return: number in a range of [0..n) where n is the number of entries in the
 |               parent directory. -1 if error
 |  
 |  getcwd(self, *args) -> 'qstring'
 |      getcwd(self) -> qstring
 |      Get current directory
 |      
 |      @return: the current working directory
 |  
 |  isdir(self, *args) -> 'bool'
 |      isdir(self, de) -> bool
 |      
 |      @param de: direntry_t const &
 |      
 |      isdir(self, path) -> bool
 |      
 |      @param path: char const *
 |  
 |  isfile(self, *args) -> 'bool'
 |      isfile(self, de) -> bool
 |      
 |      @param de: direntry_t const &
 |      
 |      isfile(self, path) -> bool
 |      
 |      @param path: char const *
 |  
 |  link(self, *args) -> 'dterr_t'
 |      link(self, path) -> dterr_t
 |      Add an inode into the current directory
 |      
 |      @param path: char const *
 |      
 |      @return: dterr_t error code
 |      link(self, inode) -> dterr_t
 |      
 |      @param inode: inode_t
 |  
 |  load(self, *args) -> 'bool'
 |      load(self) -> bool
 |      Load the tree structure from the netnode. If dirspec_t::id is empty, the
 |      operation will be considered a success. In addition, calling load() more than
 |      once will not do anything, and will be considered a success.
 |      
 |      @return: success
 |      @see: dirspec_t::id.
 |  
 |  mkdir(self, *args) -> 'dterr_t'
 |      mkdir(self, path) -> dterr_t
 |      Create a directory.
 |      
 |      @param path: (C++: const char *) directory to create
 |      @return: dterr_t error code
 |  
 |  notify_dirtree(self, *args) -> 'void'
 |      notify_dirtree(self, added, inode)
 |      Notify dirtree about a change of an inode.
 |      
 |      @param added: (C++: bool) are we adding or deleting an inode?
 |      @param inode: (C++: inode_t) inode in question
 |  
 |  rename(self, *args) -> 'dterr_t'
 |      rename(self, _from, to) -> dterr_t
 |      Rename a directory entry.
 |      
 |      @param from: (C++: const char *) source path
 |      @param to: (C++: const char *) destination path
 |      @return: dterr_t error code
 |      @note: This function can also rename the item
 |  
 |  resolve_cursor(self, *args) -> 'direntry_t'
 |      resolve_cursor(self, cursor) -> direntry_t
 |      Resolve cursor
 |      
 |      @param cursor: (C++: const dirtree_cursor_t &) to analyze
 |      @return: directory entry; if the cursor is bad, the resolved entry will be
 |               invalid.
 |      @note: see also get_abspath()
 |  
 |  resolve_path(self, *args) -> 'direntry_t'
 |      resolve_path(self, path) -> direntry_t
 |      Resolve path
 |      
 |      @param path: (C++: const char *) to analyze
 |      @return: directory entry
 |  
 |  rmdir(self, *args) -> 'dterr_t'
 |      rmdir(self, path) -> dterr_t
 |      Remove a directory.
 |      
 |      @param path: (C++: const char *) directory to delete
 |      @return: dterr_t error code
 |  
 |  save(self, *args) -> 'bool'
 |      save(self) -> bool
 |      Save the tree structure to the netnode.
 |      
 |      @return: success
 |      @see: dirspec_t::id.
 |  
 |  set_id(self, *args) -> 'void'
 |      set_id(self, nm)
 |      
 |      @param nm: char const *
 |  
 |  set_nodename = set_id(self, *args) -> 'void'
 |  
 |  traverse(self, *args) -> 'ssize_t'
 |      traverse(self, v) -> ssize_t
 |      Traverse dirtree, and be notified at each entry If the the visitor returns
 |      anything other than 0, iteration will stop, and that value returned. The tree is
 |      traversed using a depth-first algorithm. It is forbidden to modify the dirtree_t
 |      during traversal; doing so will result in undefined behavior.
 |      
 |      @param v: (C++: dirtree_visitor_t &) the callback
 |      @return: 0, or whatever the visitor returned
 |  
 |  unlink(self, *args) -> 'dterr_t'
 |      unlink(self, path) -> dterr_t
 |      Remove an inode from the current directory
 |      
 |      @param path: char const *
 |      
 |      @return: dterr_t error code
 |      unlink(self, inode) -> dterr_t
 |      
 |      @param inode: inode_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  errstr(*args) -> 'char const *'
 |      errstr(err) -> char const *
 |      Get textual representation of the error code.
 |      
 |      @param err: (C++: dterr_t) enum dterr_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function dirtree_t_errstr in module ida_dirtree:

dirtree_t_errstr(*args) -> 'char const *'
    dirtree_t_errstr(err) -> char const *
    
    @param err: enum dterr_t

Help on class dirtree_visitor_t in module ida_dirtree:

class dirtree_visitor_t(builtins.object)
 |  Proxy of C++ dirtree_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> dirtree_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_dirtree_visitor_t(...)
 |      delete_dirtree_visitor_t(self)
 |  
 |  visit(self, *args) -> 'ssize_t'
 |      visit(self, c, de) -> ssize_t
 |      Will be called for each entry in the dirtree_t If something other than 0 is
 |      returned, iteration will stop.
 |      
 |      @param c: (C++: const dirtree_cursor_t &) the current cursor
 |      @param de: (C++: const direntry_t &) the current entry
 |      @return: 0 to keep iterating, or anything else to stop
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function get_std_dirtree in module ida_dirtree:

get_std_dirtree(*args) -> 'dirtree_t *'
    get_std_dirtree(id) -> dirtree_t
    
    @param id: enum dirtree_id_t

Module "ida_diskio"s docstring:
"""
File I/O functions for IDA.

You should not use standard C file I/O functions in modules. Use functions from
this header, pro.h and fpro.h instead.

This file also declares a call_system() function."""

Help on function choose_ioport_device2 in module ida_diskio:

choose_ioport_device2(*args) -> 'bool'
    choose_ioport_device2(_device, file, parse_params) -> bool
    
    @param _device: qstring *
    @param file: char const *
    @param parse_params: choose_ioport_parser_t *

Help on class choose_ioport_parser_t in module ida_diskio:

class choose_ioport_parser_t(builtins.object)
 |  Proxy of C++ choose_ioport_parser_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> choose_ioport_parser_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_choose_ioport_parser_t(...)
 |      delete_choose_ioport_parser_t(self)
 |  
 |  parse(self, *args) -> 'bool'
 |      parse(self, param, line) -> bool
 |      @retval true: and fill PARAM with a displayed string
 |      @retval false: and empty PARAM to skip the current device
 |      @retval false: and fill PARAM with an error message
 |      
 |      @param param: (C++: qstring *)
 |      @param line: (C++: const char *) char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function close_linput in module ida_diskio:

close_linput(*args) -> 'void'
    close_linput(li)
    Close loader input.
    
    @param li: (C++: linput_t *)

Help on function create_bytearray_linput in module ida_diskio:

create_bytearray_linput(*args) -> 'linput_t *'
    create_bytearray_linput(s) -> linput_t *
    Trivial memory linput.
    
    @param s: qstring const &

Help on function create_generic_linput in module ida_diskio:

create_generic_linput(*args) -> 'linput_t *'
    create_generic_linput(gl) -> linput_t *
    Create a generic linput
    
    @param gl: (C++: generic_linput_t *) linput description. this object will be destroyed by close_linput()
               using "delete gl;"

Help on function create_memory_linput in module ida_diskio:

create_memory_linput(*args) -> 'linput_t *'
    create_memory_linput(start, size) -> linput_t *
    Create a linput for process memory. This linput will use read_dbg_memory() to
    read data.
    
    @param start: (C++: ea_t) starting address of the input
    @param size: (C++: asize_t) size of the memory area to represent as linput if unknown, may be
                 passed as 0

Help on function eclose in module ida_diskio:

eclose(*args) -> 'void'
    eclose(fp)
    
    @param fp: FILE *

Help on function enumerate_files in module ida_diskio:

enumerate_files(*args) -> 'PyObject *'
    enumerate_files(path, fname, callback) -> PyObject *
    Enumerate files in the specified directory while the callback returns 0.
    
    @param path: directory to enumerate files in
    @param fname: mask of file names to enumerate
    @param callback: a callable object that takes the filename as
                     its first argument and it returns 0 to continue
                     enumeration or non-zero to stop enumeration.
    @return:     None in case of script errors
        tuple(code, fname) : If the callback returns non-zero

Help on function enumerate_files2 in module ida_diskio:

enumerate_files2(*args) -> 'int'
    enumerate_files2(answer, answer_size, path, fname, fv) -> int
    
    @param answer: char *
    @param answer_size: size_t
    @param path: char const *
    @param fname: char const *
    @param fv: file_enumerator_t &

Help on class file_enumerator_t in module ida_diskio:

class file_enumerator_t(builtins.object)
 |  Proxy of C++ file_enumerator_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> file_enumerator_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_file_enumerator_t(...)
 |      delete_file_enumerator_t(self)
 |  
 |  visit_file(self, *args) -> 'int'
 |      visit_file(self, file) -> int
 |      
 |      @param file: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function fopenA in module ida_diskio:

fopenA(*args) -> 'FILE *'
    fopenA(file) -> FILE *
    Open a file for append in text mode, deny none.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

Help on function fopenM in module ida_diskio:

fopenM(*args) -> 'FILE *'
    fopenM(file) -> FILE *
    Open a file for read/write in binary mode, deny write.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

Help on function fopenRB in module ida_diskio:

fopenRB(*args) -> 'FILE *'
    fopenRB(file) -> FILE *
    Open a file for read in binary mode, deny none.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

Help on function fopenRT in module ida_diskio:

fopenRT(*args) -> 'FILE *'
    fopenRT(file) -> FILE *
    Open a file for read in text mode, deny none.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

Help on function fopenWB in module ida_diskio:

fopenWB(*args) -> 'FILE *'
    fopenWB(file) -> FILE *
    Open a new file for write in binary mode, deny read/write. If a file exists, it
    will be removed.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

Help on function fopenWT in module ida_diskio:

fopenWT(*args) -> 'FILE *'
    fopenWT(file) -> FILE *
    Open a new file for write in text mode, deny write. If a file exists, it will be
    removed.
    
    @param file: (C++: const char *) char const *
    @return: nullptr if failure

Help on class generic_linput_t in module ida_diskio:

class generic_linput_t(builtins.object)
 |  Proxy of C++ generic_linput_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_generic_linput_t(...)
 |      delete_generic_linput_t(self)
 |  
 |  read(self, *args) -> 'ssize_t'
 |      read(self, off, buffer, nbytes) -> ssize_t
 |      
 |      @param off: qoff64_t
 |      @param buffer: void *
 |      @param nbytes: size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blocksize
 |      blocksize
 |  
 |  filesize
 |      filesize
 |  
 |  thisown
 |      The membership flag

Help on function get_ida_subdirs in module ida_diskio:

get_ida_subdirs(*args) -> 'qstrvec_t *'
    get_ida_subdirs(subdir, flags=0) -> int
    Get list of directories in which to find a specific IDA resource (see IDA
    subdirectories). The order of the resulting list is as follows:
    - [$IDAUSR/subdir (0..N entries)]
    - $IDADIR/subdir
    
    @param subdir: (C++: const char *) name of the resource to list
    @param flags: (C++: int) Subdirectory modification flags bits
    @return: number of directories appended to 'dirs'

Help on function get_linput_type in module ida_diskio:

get_linput_type(*args) -> 'linput_type_t'
    get_linput_type(li) -> linput_type_t
    Get linput type.
    
    @param li: (C++: linput_t *)

Help on function get_special_folder in module ida_diskio:

get_special_folder(*args) -> 'size_t'
    get_special_folder(csidl) -> str
    Get a folder location by CSIDL (see Common CSIDLs). Path should be of at least
    MAX_PATH size
    
    @param csidl: (C++: int)

Help on function get_user_idadir in module ida_diskio:

get_user_idadir(*args) -> 'char const *'
    get_user_idadir() -> char const *
    Get user ida related directory.
    - if $IDAUSR is defined:
    - the first element in $IDAUSR
    - else
    - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)

Help on function getsysfile in module ida_diskio:

getsysfile(*args) -> 'char const *'
    getsysfile(filename, subdir) -> str
    Search for IDA system file. This function searches for a file in:
    1. each directory specified by IDAUSR%
    2. ida directory [+ subdir] and returns the first match.
    
    @param filename: (C++: const char *) name of file to search
    @param subdir: (C++: const char *) if specified, the file is looked for in the specified
                   subdirectory of the ida directory first (see IDA subdirectories)
    @return: nullptr if not found, otherwise a pointer to full file name.

Help on function idadir in module ida_diskio:

idadir(*args) -> 'char const *'
    idadir(subdir) -> char const *
    Get IDA directory (if subdir==nullptr) or the specified subdirectory (see IDA
    subdirectories)
    
    @param subdir: (C++: const char *) char const *

Help on class ioports_fallback_t in module ida_diskio:

class ioports_fallback_t(builtins.object)
 |  Proxy of C++ ioports_fallback_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ioports_fallback_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ioports_fallback_t(...)
 |      delete_ioports_fallback_t(self)
 |  
 |  handle(self, *args) -> 'bool'
 |      handle(self, ports, line) -> bool
 |      
 |      @param ports: ioports_t const &
 |      @param line: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function open_linput in module ida_diskio:

open_linput(*args) -> 'linput_t *'
    open_linput(file, remote) -> linput_t *
    Open loader input.
    
    @param file: (C++: const char *) char const *
    @param remote: (C++: bool)

Help on function qlgetz in module ida_diskio:

qlgetz(*args) -> 'size_t'
    qlgetz(li, fpos) -> str
    Read a zero-terminated string from the input. If fpos == -1 then no seek will be
    performed.
    
    @param li: (C++: linput_t *)
    @param fpos: (C++: int64)

Help on function read_ioports2 in module ida_diskio:

read_ioports2(*args) -> 'ssize_t'
    read_ioports2(ports, device, file, callback=None) -> ssize_t
    
    @param ports: ioports_t *
    @param device: qstring *
    @param file: char const *
    @param callback: ioports_fallback_t *

Module "ida_entry"s docstring:
"""
Functions that deal with entry points.

Exported functions are considered as entry points as well.

IDA maintains list of entry points to the program. Each entry point:
* has an address
* has a name
* may have an ordinal number"""

Help on function add_entry in module ida_entry:

add_entry(*args) -> 'bool'
    add_entry(ord, ea, name, makecode, flags=0) -> bool
    Add an entry point to the list of entry points.
    
    @param ord: (C++: uval_t) ordinal number if ordinal number is equal to 'ea' then ordinal is
                not used
    @param ea: (C++: ea_t) linear address
    @param name: (C++: const char *) name of entry point. If the specified location already has a name,
                 the old name will be appended to the regular comment. If name ==
                 nullptr, then the old name will be retained.
    @param makecode: (C++: bool) should the kernel convert bytes at the entry point to
                     instruction(s)
    @param flags: (C++: int) See AEF_*
    @return: success (currently always true)

Help on function get_entry in module ida_entry:

get_entry(*args) -> 'ea_t'
    get_entry(ord) -> ea_t
    Get entry point address by its ordinal
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: address or BADADDR

Help on function get_entry_forwarder in module ida_entry:

get_entry_forwarder(*args) -> 'qstring *'
    get_entry_forwarder(ord) -> str
    Get forwarder name for the entry point by its ordinal.
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: size of entry forwarder name or -1

Help on function get_entry_name in module ida_entry:

get_entry_name(*args) -> 'qstring *'
    get_entry_name(ord) -> str
    Get name of the entry point by its ordinal.
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: size of entry name or -1

Help on function get_entry_ordinal in module ida_entry:

get_entry_ordinal(*args) -> 'uval_t'
    get_entry_ordinal(idx) -> uval_t
    Get ordinal number of an entry point.
    
    @param idx: (C++: size_t) internal number of entry point. Should be in the range
                0..get_entry_qty()-1
    @return: ordinal number or 0.

Help on function get_entry_qty in module ida_entry:

get_entry_qty(*args) -> 'size_t'
    get_entry_qty() -> size_t
    Get number of entry points.

Help on function rename_entry in module ida_entry:

rename_entry(*args) -> 'bool'
    rename_entry(ord, name, flags=0) -> bool
    Rename entry point.
    
    @param ord: (C++: uval_t) ordinal number of the entry point
    @param name: (C++: const char *) name of entry point. If the specified location already has a name,
                 the old name will be appended to a repeatable comment.
    @param flags: (C++: int) See AEF_*
    @return: success

Help on function set_entry_forwarder in module ida_entry:

set_entry_forwarder(*args) -> 'bool'
    set_entry_forwarder(ord, name, flags=0) -> bool
    Set forwarder name for ordinal.
    
    @param ord: (C++: uval_t) ordinal number of the entry point
    @param name: (C++: const char *) forwarder name for entry point.
    @param flags: (C++: int) See AEF_*
    @return: success

Module "ida_enum"s docstring:
"""
Assembly level enum management.

Enums and bitfields are represented as enum_t."""

Help on function add_enum in module ida_enum:

add_enum(*args) -> 'enum_t'
    add_enum(idx, name, flag) -> enum_t
    Add new enum type.
    * if idx==BADADDR then add as the last idx
    * if name==nullptr then generate a unique name "enum_%d"
    
    @param idx: (C++: size_t)
    @param name: (C++: const char *) char const *
    @param flag: (C++: flags_t)

Help on function add_enum_member in module ida_enum:

add_enum_member(*args) -> 'int'
    add_enum_member(id, name, value, bmask=(bmask_t(-1))) -> int
    Add member to enum type.
    
    @param id: (C++: enum_t)
    @param name: (C++: const char *) char const *
    @param value: (C++: uval_t)
    @param bmask: (C++: bmask_t)
    @return: 0 if ok, otherwise one of Add enum member result codes

Help on function del_enum in module ida_enum:

del_enum(*args) -> 'void'
    del_enum(id)
    Delete an enum type.
    
    @param id: (C++: enum_t)

Help on function del_enum_member in module ida_enum:

del_enum_member(*args) -> 'bool'
    del_enum_member(id, value, serial, bmask) -> bool
    Delete member of enum type.
    
    @param id: (C++: enum_t)
    @param value: (C++: uval_t)
    @param serial: (C++: uchar)
    @param bmask: (C++: bmask_t)

Help on class enum_member_visitor_t in module ida_enum:

class enum_member_visitor_t(builtins.object)
 |  Proxy of C++ enum_member_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_member_visitor_t(...)
 |      delete_enum_member_visitor_t(self)
 |  
 |  visit_enum_member(self, *args) -> 'int'
 |      visit_enum_member(self, cid, value) -> int
 |      Implements action to take when enum member is visited.
 |      
 |      @param cid: (C++: const_t)
 |      @param value: (C++: uval_t)
 |      @return: nonzero to stop the iteration
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function for_all_enum_members in module ida_enum:

for_all_enum_members(*args) -> 'int'
    for_all_enum_members(id, cv) -> int
    Visit all members of a given enum.
    
    @param id: (C++: enum_t)
    @param cv: (C++: enum_member_visitor_t &)

Help on function get_bmask_cmt in module ida_enum:

get_bmask_cmt(*args) -> 'qstring *'
    get_bmask_cmt(id, bmask, repeatable) -> str
    
    @param id: enum_t
    @param bmask: bmask_t
    @param repeatable: bool

Help on function get_bmask_name in module ida_enum:

get_bmask_name(*args) -> 'qstring *'
    get_bmask_name(id, bmask) -> str
    
    @param id: enum_t
    @param bmask: bmask_t

Help on function get_enum in module ida_enum:

get_enum(*args) -> 'enum_t'
    get_enum(name) -> enum_t
    Get enum by name.
    
    @param name: (C++: const char *) char const *

Help on function get_enum_cmt in module ida_enum:

get_enum_cmt(*args) -> 'qstring *'
    get_enum_cmt(id, repeatable) -> str
    Get enum comment.
    
    @param id: (C++: enum_t)
    @param repeatable: (C++: bool)

Help on function get_enum_flag in module ida_enum:

get_enum_flag(*args) -> 'flags_t'
    get_enum_flag(id) -> flags_t
    Get flags determining the representation of the enum. (currently they define the
    numeric base: octal, decimal, hex, bin) and signness.
    
    @param id: (C++: enum_t)

Help on function get_enum_idx in module ida_enum:

get_enum_idx(*args) -> 'uval_t'
    get_enum_idx(id) -> uval_t
    Get the index in the list of enums.
    
    @param id: (C++: enum_t)

Help on function get_enum_member in module ida_enum:

get_enum_member(*args) -> 'const_t'
    get_enum_member(id, value, serial, mask) -> const_t
    Find an enum member by enum, value and bitmask
    @note: if serial -1, return a member with any serial
    
    @param id: (C++: enum_t)
    @param value: (C++: uval_t)
    @param serial: (C++: int)
    @param mask: (C++: bmask_t)

Help on function get_enum_member_bmask in module ida_enum:

get_enum_member_bmask(*args) -> 'bmask_t'
    get_enum_member_bmask(id) -> bmask_t
    Get bitmask of an enum member.
    
    @param id: (C++: const_t)

Help on function get_enum_member_by_name in module ida_enum:

get_enum_member_by_name(*args) -> 'const_t'
    get_enum_member_by_name(name) -> const_t
    Get a reference to an enum member by its name.
    
    @param name: (C++: const char *) char const *

Help on function get_enum_member_cmt in module ida_enum:

get_enum_member_cmt(*args) -> 'qstring *'
    get_enum_member_cmt(id, repeatable) -> str
    Get enum member's comment.
    
    @param id: (C++: const_t)
    @param repeatable: (C++: bool)

Help on function get_enum_member_enum in module ida_enum:

get_enum_member_enum(*args) -> 'enum_t'
    get_enum_member_enum(id) -> enum_t
    Get the parent enum of an enum member.
    
    @param id: (C++: const_t)

Help on function get_enum_member_name in module ida_enum:

get_enum_member_name(*args) -> 'qstring *'
    get_enum_member_name(id) -> str
    Get name of an enum member by const_t.
    
    @param id: (C++: const_t)

Help on function get_enum_member_serial in module ida_enum:

get_enum_member_serial(*args) -> 'uchar'
    get_enum_member_serial(cid) -> uchar
    Get serial number of an enum member.
    
    @param cid: (C++: const_t)

Help on function get_enum_member_value in module ida_enum:

get_enum_member_value(*args) -> 'uval_t'
    get_enum_member_value(id) -> uval_t
    Get value of an enum member.
    
    @param id: (C++: const_t)

Help on function get_enum_name in module ida_enum:

get_enum_name(*args) -> 'qstring *'
    get_enum_name(id) -> str
    
    @param id: enum_t

Help on function get_enum_name2 in module ida_enum:

get_enum_name2(*args) -> 'qstring *'
    get_enum_name2(id, flags=0) -> str
    Get name of enum
    
    @param id: (C++: enum_t) enum id
    @param flags: (C++: int) Enum name flags

Help on function get_enum_qty in module ida_enum:

get_enum_qty(*args) -> 'size_t'
    get_enum_qty() -> size_t
    Get number of declared enum_t types.

Help on function get_enum_size in module ida_enum:

get_enum_size(*args) -> 'size_t'
    get_enum_size(id) -> size_t
    Get the number of the members of the enum.
    
    @param id: (C++: enum_t)

Help on function get_enum_type_ordinal in module ida_enum:

get_enum_type_ordinal(*args) -> 'int32'
    get_enum_type_ordinal(id) -> int32
    Get corresponding type ordinal number.
    
    @param id: (C++: enum_t)

Help on function get_enum_width in module ida_enum:

get_enum_width(*args) -> 'size_t'
    get_enum_width(id) -> size_t
    Get the width of a enum element allowed values: 0 (unspecified),1,2,4,8,16,32,64
    
    @param id: (C++: enum_t)

Help on function get_first_bmask in module ida_enum:

get_first_bmask(*args) -> 'bmask_t'
    get_first_bmask(enum_id) -> bmask_t
    Get first bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum (bitfield)
    @return: the smallest bitmask for enum, or DEFMASK

Help on function get_first_enum_member in module ida_enum:

get_first_enum_member(*args) -> 'uval_t'
    get_first_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param bmask: bmask_t

Help on function get_first_serial_enum_member in module ida_enum:

get_first_serial_enum_member(*args) -> 'uchar *'
    get_first_serial_enum_member(id, value, bmask) -> const_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

Help on function get_last_bmask in module ida_enum:

get_last_bmask(*args) -> 'bmask_t'
    get_last_bmask(enum_id) -> bmask_t
    Get last bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @return: the biggest bitmask for enum, or DEFMASK

Help on function get_last_enum_member in module ida_enum:

get_last_enum_member(*args) -> 'uval_t'
    get_last_enum_member(id, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param bmask: bmask_t

Help on function get_last_serial_enum_member in module ida_enum:

get_last_serial_enum_member(*args) -> 'uchar *'
    get_last_serial_enum_member(id, value, bmask) -> const_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

Help on function get_next_bmask in module ida_enum:

get_next_bmask(*args) -> 'bmask_t'
    get_next_bmask(enum_id, bmask) -> bmask_t
    Get next bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @param bmask: (C++: bmask_t) the current bitmask
    @return: value of a bitmask with value higher than the specified value, or
             DEFMASK

Help on function get_next_enum_member in module ida_enum:

get_next_enum_member(*args) -> 'uval_t'
    get_next_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

Help on function get_next_serial_enum_member in module ida_enum:

get_next_serial_enum_member(*args) -> 'uchar *'
    get_next_serial_enum_member(in_out_serial, first_cid) -> const_t
    
    @param in_out_serial: uchar *
    @param first_cid: const_t

Help on function get_prev_bmask in module ida_enum:

get_prev_bmask(*args) -> 'bmask_t'
    get_prev_bmask(enum_id, bmask) -> bmask_t
    Get prev bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @param bmask: (C++: bmask_t) the current bitmask
    @return: value of a bitmask with value lower than the specified value, or
             DEFMASK

Help on function get_prev_enum_member in module ida_enum:

get_prev_enum_member(*args) -> 'uval_t'
    get_prev_enum_member(id, value, bmask=(bmask_t(-1))) -> uval_t
    
    @param id: enum_t
    @param value: uval_t
    @param bmask: bmask_t

Help on function get_prev_serial_enum_member in module ida_enum:

get_prev_serial_enum_member(*args) -> 'uchar *'
    get_prev_serial_enum_member(in_out_serial, first_cid) -> const_t
    
    @param in_out_serial: uchar *
    @param first_cid: const_t

Help on function getn_enum in module ida_enum:

getn_enum(*args) -> 'enum_t'
    getn_enum(idx) -> enum_t
    Get enum by its index in the list of enums (0..get_enum_qty()-1).
    
    @param idx: (C++: size_t)

Help on function is_bf in module ida_enum:

is_bf(*args) -> 'bool'
    is_bf(id) -> bool
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for DEFMASK are
    allowed)
    
    @param id: (C++: enum_t)

Help on function is_enum_fromtil in module ida_enum:

is_enum_fromtil(*args) -> 'bool'
    is_enum_fromtil(id) -> bool
    Does enum come from type library?
    
    @param id: (C++: enum_t)

Help on function is_enum_hidden in module ida_enum:

is_enum_hidden(*args) -> 'bool'
    is_enum_hidden(id) -> bool
    Is enum collapsed?
    
    @param id: (C++: enum_t)

Help on function is_ghost_enum in module ida_enum:

is_ghost_enum(*args) -> 'bool'
    is_ghost_enum(id) -> bool
    Is a ghost copy of a local type?
    
    @param id: (C++: enum_t)

Help on function is_one_bit_mask in module ida_enum:

is_one_bit_mask(*args) -> 'bool'
    is_one_bit_mask(mask) -> bool
    Is bitmask one bit?
    
    @param mask: (C++: bmask_t)

Help on function set_bmask_cmt in module ida_enum:

set_bmask_cmt(*args) -> 'bool'
    set_bmask_cmt(id, bmask, cmt, repeatable) -> bool
    
    @param id: enum_t
    @param bmask: bmask_t
    @param cmt: char const *
    @param repeatable: bool

Help on function set_bmask_name in module ida_enum:

set_bmask_name(*args) -> 'bool'
    set_bmask_name(id, bmask, name) -> bool
    
    @param id: enum_t
    @param bmask: bmask_t
    @param name: char const *

Help on function set_enum_bf in module ida_enum:

set_enum_bf(*args) -> 'bool'
    set_enum_bf(id, bf) -> bool
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    @param id: (C++: enum_t)
    @param bf: (C++: bool)

Help on function set_enum_cmt in module ida_enum:

set_enum_cmt(*args) -> 'bool'
    set_enum_cmt(id, cmt, repeatable) -> bool
    Set comment for enum type.
    
    @param id: (C++: enum_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_enum_flag in module ida_enum:

set_enum_flag(*args) -> 'bool'
    set_enum_flag(id, flag) -> bool
    Set data representation flags.
    
    @param id: (C++: enum_t)
    @param flag: (C++: flags_t)

Help on function set_enum_fromtil in module ida_enum:

set_enum_fromtil(*args) -> 'bool'
    set_enum_fromtil(id, fromtil) -> bool
    Specify that enum comes from a type library.
    
    @param id: (C++: enum_t)
    @param fromtil: (C++: bool)

Help on function set_enum_ghost in module ida_enum:

set_enum_ghost(*args) -> 'bool'
    set_enum_ghost(id, ghost) -> bool
    Specify that enum is a ghost copy of a local type.
    
    @param id: (C++: enum_t)
    @param ghost: (C++: bool)

Help on function set_enum_hidden in module ida_enum:

set_enum_hidden(*args) -> 'bool'
    set_enum_hidden(id, hidden) -> bool
    Collapse enum.
    
    @param id: (C++: enum_t)
    @param hidden: (C++: bool)

Help on function set_enum_idx in module ida_enum:

set_enum_idx(*args) -> 'bool'
    set_enum_idx(id, idx) -> bool
    Set serial number of enum. Also see get_enum_idx().
    
    @param id: (C++: enum_t)
    @param idx: (C++: size_t)

Help on function set_enum_member_cmt in module ida_enum:

set_enum_member_cmt(*args) -> 'bool'
    set_enum_member_cmt(id, cmt, repeatable) -> bool
    Set comment for enum member.
    
    @param id: (C++: const_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_enum_member_name in module ida_enum:

set_enum_member_name(*args) -> 'bool'
    set_enum_member_name(id, name) -> bool
    Set name of enum member.
    
    @param id: (C++: const_t)
    @param name: (C++: const char *) char const *

Help on function set_enum_name in module ida_enum:

set_enum_name(*args) -> 'bool'
    set_enum_name(id, name) -> bool
    Set name of enum type.
    
    @param id: (C++: enum_t)
    @param name: (C++: const char *) char const *

Help on function set_enum_type_ordinal in module ida_enum:

set_enum_type_ordinal(*args) -> 'void'
    set_enum_type_ordinal(id, ord)
    Set corresponding type ordinal number.
    
    @param id: (C++: enum_t)
    @param ord: (C++: int32)

Help on function set_enum_width in module ida_enum:

set_enum_width(*args) -> 'bool'
    set_enum_width(id, width) -> bool
    See comment for get_enum_width()
    
    @param id: (C++: enum_t)
    @param width: (C++: int)

Module "ida_expr"s docstring:
"""
Functions that deal with C-like expressions and built-in IDC language.

Functions marked THREAD_SAFE may be called from any thread. No simultaneous
calls should be made for the same variable. We protect only global structures,
individual variables must be protected manually."""

Help on class _IdcFunction in module ida_expr:

class _IdcFunction(builtins.object)
 |  Internal class that calls pyw_call_idc_func() with a context
 |  
 |  Methods defined here:
 |  
 |  __call__(self, args, res)
 |      Call self as a function.
 |  
 |  __init__(self, ctxptr)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fp_ptr

Help on function add_idc_class in module ida_expr:

add_idc_class(*args) -> 'idc_class_t *'
    add_idc_class(name, super=None) -> idc_class_t *
    Create a new IDC class.
    
    @param name: (C++: const char *) name of the new class
    @param super: (C++: const idc_class_t *) the base class for the new class. if the new class is not based on
                  any other class, pass nullptr
    @return: pointer to the created class. If such a class already exists, a pointer
             to it will be returned. Pointers to other existing classes may be
             invalidated by this call.

Help on function add_idc_func in module ida_expr:

add_idc_func(name, fp, args, defvals=(), flags=0)
    Extends the IDC language by exposing a new IDC function that is backed up by a Python function
    
    Add an IDC function. This function does not modify the predefined kernel
    functions. Example:
    static error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
    {
    msg("myfunc is called with arg0=%a and arg1=%s\n", argv[0].num, argv[1].str);
    res->num = 5;     // let's return 5
    return eOk;
    }
    static const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
    static const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args,
    nullptr, 0, EXTFUN_BASE };
    // after this:
    add_idc_func(myfunc_desc);
    // there is a new IDC function which can be called like this:
    MyFunc5(0x123, "test");
    
    @note: If the function already exists, it will be replaced by the new function
    @return: success

Help on function add_idc_gvar in module ida_expr:

add_idc_gvar(*args) -> 'idc_value_t *'
    add_idc_gvar(name) -> idc_value_t
    Add global IDC variable.
    
    @param name: (C++: const char *) name of the global variable
    @return: pointer to the created variable or existing variable. NB: the returned
             pointer is valid until a new global var is added.

Help on function compile_idc_file in module ida_expr:

compile_idc_file(*args) -> 'qstring *'
    compile_idc_file(nonnul_line) -> str
    
    @param nonnul_line: char const *

Help on function compile_idc_snippet in module ida_expr:

compile_idc_snippet(*args) -> 'qstring *'
    compile_idc_snippet(func, text, resolver=None, only_safe_funcs=False) -> str
    Compile text with IDC statements.
    
    @param func: (C++: const char *) name of the function to create out of the snippet
    @param text: (C++: const char *) text to compile
    @param resolver: (C++: idc_resolver_t *) callback object to get values of undefined variables This
                     object will be called if IDC function contains references to
                     undefined variables. May be nullptr.
    @param only_safe_funcs: (C++: bool) if true, any calls to functions without EXTFUN_SAFE flag
                            will lead to a compilation error.
    @retval true: ok
    @retval false: error, see errbuf

Help on function compile_idc_text in module ida_expr:

compile_idc_text(*args) -> 'qstring *'
    compile_idc_text(nonnul_line) -> str
    
    @param nonnul_line: char const *

Help on function copy_idcv in module ida_expr:

copy_idcv(*args) -> 'error_t'
    copy_idcv(dst, src) -> error_t
    Copy 'src' to 'dst'. For idc objects only a reference is copied.
    
    @param dst: (C++: idc_value_t *)
    @param src: (C++: const idc_value_t &) idc_value_t const &

Help on function create_idcv_ref in module ida_expr:

create_idcv_ref(*args) -> 'bool'
    create_idcv_ref(ref, v) -> bool
    Create a variable reference. Currently only references to global variables can
    be created.
    
    @param ref: (C++: idc_value_t *) ptr to the result
    @param v: (C++: const idc_value_t *) variable to reference
    @return: success

Help on function deep_copy_idcv in module ida_expr:

deep_copy_idcv(*args) -> 'error_t'
    deep_copy_idcv(dst, src) -> error_t
    Deep copy an IDC object. This function performs deep copy of idc objects. If
    'src' is not an object, copy_idcv() will be called
    
    @param dst: (C++: idc_value_t *)
    @param src: (C++: const idc_value_t &) idc_value_t const &

Help on function del_idc_func in module ida_expr:

del_idc_func(name)
    Unregisters the specified IDC function
    
    Delete an IDC function

Help on function del_idcv_attr in module ida_expr:

del_idcv_attr(*args) -> 'error_t'
    del_idcv_attr(obj, attr) -> error_t
    Delete an object attribute.
    
    @param obj: (C++: idc_value_t *) variable that holds an object reference
    @param attr: (C++: const char *) attribute name
    @return: error code, eOk on success

Help on function deref_idcv in module ida_expr:

deref_idcv(*args) -> 'idc_value_t *'
    deref_idcv(v, vref_flags) -> idc_value_t
    Dereference a VT_REF variable.
    
    @param v: (C++: idc_value_t *) variable to dereference
    @param vref_flags: (C++: int) Dereference IDC variable flags
    @return: pointer to the dereference result or nullptr. If returns nullptr,
             qerrno is set to eExecBadRef "Illegal variable reference"

Help on function eval_expr in module ida_expr:

eval_expr(*args) -> 'qstring *'
    eval_expr(rv, where, line) -> str
    Compile and calculate an expression.
    
    @param rv: (C++: idc_value_t *) pointer to the result
    @param where: (C++: ea_t) the current linear address in the addressing space of the program
                  being disassembled. If will be used to resolve names of local
                  variables etc. if not applicable, then should be BADADDR.
    @param line: (C++: const char *) the expression to evaluate
    @retval true: ok
    @retval false: error, see errbuf

Help on function eval_idc_expr in module ida_expr:

eval_idc_expr(*args) -> 'qstring *'
    eval_idc_expr(rv, where, line) -> str
    Same as eval_expr(), but will always use the IDC interpreter regardless of the
    currently installed extlang.
    
    @param rv: (C++: idc_value_t *)
    @param where: (C++: ea_t)
    @param line: char const *

Help on function exec_idc_script in module ida_expr:

exec_idc_script(*args) -> 'qstring *'
    exec_idc_script(result, path, func, args, argsnum) -> str
    Compile and execute IDC function(s) from file.
    
    @param result: (C++: idc_value_t *) ptr to idc_value_t to hold result of the function. If execution
                   fails, this variable will contain the exception information. You
                   may pass nullptr if you are not interested in the returned value.
    @param path: (C++: const char *) text file containing text of IDC functions
    @param func: (C++: const char *) function name to execute
    @param args: (C++: const idc_value_t) array of parameters
    @param argsnum: (C++: size_t) number of parameters to pass to 'fname' This number should be
                    equal to number of parameters the function expects.
    @retval true: ok
    @retval false: error, see errbuf

Help on function exec_system_script in module ida_expr:

exec_system_script(*args) -> 'bool'
    exec_system_script(file, complain_if_no_file=True) -> bool
    Compile and execute "main" function from system file.
    
    @param file: (C++: const char *) file name with IDC function(s). The file will be searched using
                 get_idc_filename().
    @param complain_if_no_file: (C++: bool) * 1: display warning if the file is not found
    * 0: don't complain if file doesn't exist
    @retval 1: ok, file is compiled and executed
    @retval 0: failure, compilation or execution error, warning is displayed

Help on function find_idc_class in module ida_expr:

find_idc_class(*args) -> 'idc_class_t *'
    find_idc_class(name) -> idc_class_t *
    Find an existing IDC class by its name.
    
    @param name: (C++: const char *) name of the class
    @return: pointer to the class or nullptr. The returned pointer is valid until a
             new call to add_idc_class()

Help on function find_idc_func in module ida_expr:

find_idc_func(*args) -> 'qstring *'
    find_idc_func(prefix, n=0) -> str
    
    @param prefix: char const *
    @param n: int

Help on function find_idc_gvar in module ida_expr:

find_idc_gvar(*args) -> 'idc_value_t *'
    find_idc_gvar(name) -> idc_value_t
    Find an existing global IDC variable by its name.
    
    @param name: (C++: const char *) name of the global variable
    @return: pointer to the variable or nullptr. NB: the returned pointer is valid
             until a new global var is added. FIXME: it is difficult to use this
             function in a thread safe manner

Help on function first_idcv_attr in module ida_expr:

first_idcv_attr(*args) -> 'char const *'
    first_idcv_attr(obj) -> char const *
    
    @param obj: idc_value_t const *

Help on function free_idcv in module ida_expr:

free_idcv(*args) -> 'void'
    free_idcv(v)
    Free storage used by VT_STR/VT_OBJ IDC variables. After this call the variable
    has a numeric value 0
    
    @param v: (C++: idc_value_t *)

Help on function get_idc_filename in module ida_expr:

get_idc_filename(*args) -> 'char const *'
    get_idc_filename(file) -> str
    Get full name of IDC file name. Search for file in list of include directories,
    IDCPATH directory and system directories.
    
    @param file: (C++: const char *) file name without full path
    @return: nullptr is file not found. otherwise returns pointer to buf

Help on function get_idcv_attr in module ida_expr:

get_idcv_attr(*args) -> 'error_t'
    get_idcv_attr(res, obj, attr, may_use_getattr=False) -> error_t
    Get an object attribute.
    
    @param res: (C++: idc_value_t *) buffer for the attribute value
    @param obj: (C++: const idc_value_t *) variable that holds an object reference. if obj is nullptr it
                searches global variables, then user functions
    @param attr: (C++: const char *) attribute name
    @param may_use_getattr: (C++: bool) may call getattr functions to calculate the attribute if
                            it does not exist
    @return: error code, eOk on success

Help on function get_idcv_class_name in module ida_expr:

get_idcv_class_name(*args) -> 'qstring *'
    get_idcv_class_name(obj) -> str
    Retrieves the IDC object class name.
    
    @param obj: (C++: const idc_value_t *) class instance variable
    @return: error code, eOk on success

Help on function get_idcv_slice in module ida_expr:

get_idcv_slice(*args) -> 'error_t'
    get_idcv_slice(res, v, i1, i2, flags=0) -> error_t
    Get slice.
    
    @param res: (C++: idc_value_t *) output variable that will contain the slice
    @param v: (C++: const idc_value_t *) input variable (string or object)
    @param i1: (C++: uval_t) slice start index
    @param i2: (C++: uval_t) slice end index (excluded)
    @param flags: (C++: int) IDC variable slice flags or 0
    @return: eOk if success

Help on class highlighter_cbs_t in module ida_expr:

class highlighter_cbs_t(builtins.object)
 |  Proxy of C++ highlighter_cbs_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> highlighter_cbs_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_highlighter_cbs_t(...)
 |      delete_highlighter_cbs_t(self)
 |  
 |  cur_block_state(self, *args) -> 'int32'
 |      cur_block_state(self) -> int32
 |  
 |  prev_block_state(self, *args) -> 'int32'
 |      prev_block_state(self) -> int32
 |  
 |  set_block_state(self, *args) -> 'void'
 |      set_block_state(self, arg0)
 |      
 |      @param arg0: int32
 |  
 |  set_style(self, *args) -> 'void'
 |      set_style(self, arg0, arg1, arg2)
 |      
 |      @param arg0: int32
 |      @param arg1: int32
 |      @param arg2: enum syntax_highlight_style
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class idc_global_t in module ida_expr:

class idc_global_t(builtins.object)
 |  Proxy of C++ idc_global_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idc_global_t
 |      __init__(self, n) -> idc_global_t
 |      
 |      @param n: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idc_global_t(...)
 |      delete_idc_global_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value

Help on class idc_value_t in module ida_expr:

class idc_value_t(builtins.object)
 |  Proxy of C++ idc_value_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=0) -> idc_value_t
 |      
 |      @param n: sval_t
 |      
 |      __init__(self, r) -> idc_value_t
 |      
 |      @param r: idc_value_t const &
 |      
 |      __init__(self, _str) -> idc_value_t
 |      
 |      @param _str: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idc_value_t(...)
 |      delete_idc_value_t(self)
 |  
 |  _create_empty_string(self, *args) -> 'void'
 |      _create_empty_string(self)
 |  
 |  c_str(self, *args) -> 'char const *'
 |      c_str(self) -> char const *
 |      VT_STR
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      See free_idcv()
 |  
 |  create_empty_string(self, *args) -> 'void'
 |      create_empty_string(self)
 |  
 |  is_convertible(self, *args) -> 'bool'
 |      is_convertible(self) -> bool
 |      Convertible types are VT_LONG, VT_FLOAT, VT_INT64, and VT_STR.
 |  
 |  is_integral(self, *args) -> 'bool'
 |      is_integral(self) -> bool
 |      Does value represent a whole number?
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |      Does value represent the integer 0?
 |  
 |  qstr(self, *args) -> 'qstring const &'
 |      qstr(self) -> qstring
 |      VT_STR
 |      qstr(self) -> qstring const &
 |  
 |  set_float(self, *args) -> 'void'
 |      set_float(self, f)
 |      
 |      @param f: fpvalue_t const &
 |  
 |  set_int64(self, *args) -> 'void'
 |      set_int64(self, v)
 |      
 |      @param v: int64
 |  
 |  set_long(self, *args) -> 'void'
 |      set_long(self, v)
 |      
 |      @param v: sval_t
 |  
 |  set_pvoid(self, *args) -> 'void'
 |      set_pvoid(self, p)
 |      
 |      @param p: void *
 |  
 |  set_string(self, *args) -> 'void'
 |      set_string(self, _str, len)
 |      
 |      @param _str: char const *
 |      @param len: size_t
 |      
 |      set_string(self, _str)
 |      
 |      @param _str: char const *
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, v)
 |      Set this = r and v = this.
 |      
 |      @param v: (C++: idc_value_t &)
 |  
 |  u_str(self, *args) -> 'uchar const *'
 |      u_str(self) -> uchar const *
 |      VT_STR
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      e
 |  
 |  funcidx
 |      funcidx
 |  
 |  i64
 |      i64
 |  
 |  num
 |      num
 |  
 |  obj
 |      obj
 |  
 |  pvoid
 |      pvoid
 |  
 |  reserve
 |      reserve
 |  
 |  str
 |  
 |  thisown
 |      The membership flag
 |  
 |  vtype
 |      vtype

Help on class idc_values_t in module ida_expr:

class idc_values_t(builtins.object)
 |  Proxy of C++ qvector< idc_value_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'idc_value_t const &'
 |      __getitem__(self, i) -> idc_value_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idc_values_t
 |      __init__(self, x) -> idc_values_t
 |      
 |      @param x: qvector< idc_value_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: idc_value_t const &
 |  
 |  __swig_destroy__ = delete_idc_values_t(...)
 |      delete_idc_values_t(self)
 |  
 |  at(self, *args) -> 'idc_value_t const &'
 |      at(self, _idx) -> idc_value_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< idc_value_t >::const_iterator'
 |      begin(self) -> idc_value_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< idc_value_t >::const_iterator'
 |      end(self) -> idc_value_t
 |  
 |  erase(self, *args) -> 'qvector< idc_value_t >::iterator'
 |      erase(self, it) -> idc_value_t
 |      
 |      @param it: qvector< idc_value_t >::iterator
 |      
 |      erase(self, first, last) -> idc_value_t
 |      
 |      @param first: qvector< idc_value_t >::iterator
 |      @param last: qvector< idc_value_t >::iterator
 |  
 |  extract(self, *args) -> 'idc_value_t *'
 |      extract(self) -> idc_value_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=idc_value_t())
 |      
 |      @param x: idc_value_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: idc_value_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< idc_value_t >::iterator'
 |      insert(self, it, x) -> idc_value_t
 |      
 |      @param it: qvector< idc_value_t >::iterator
 |      @param x: idc_value_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'idc_value_t &'
 |      push_back(self, x)
 |      
 |      @param x: idc_value_t const &
 |      
 |      push_back(self) -> idc_value_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: idc_value_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< idc_value_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function idcv_float in module ida_expr:

idcv_float(*args) -> 'error_t'
    idcv_float(v) -> error_t
    Convert IDC variable to a floating point.
    
    @param v: (C++: idc_value_t *)

Help on function idcv_int64 in module ida_expr:

idcv_int64(*args) -> 'error_t'
    idcv_int64(v) -> error_t
    Convert IDC variable to a 64bit number.
    
    @param v: (C++: idc_value_t *)
    @return: v = 0 if impossible to convert to int64

Help on function idcv_long in module ida_expr:

idcv_long(*args) -> 'error_t'
    idcv_long(v) -> error_t
    Convert IDC variable to a long (32/64bit) number.
    
    @param v: (C++: idc_value_t *)
    @return: v = 0 if impossible to convert to long

Help on function idcv_num in module ida_expr:

idcv_num(*args) -> 'error_t'
    idcv_num(v) -> error_t
    Convert IDC variable to a long number.
    
    @param v: (C++: idc_value_t *)
    @return: * v = 0 if IDC variable = "false" string
    * v = 1 if IDC variable = "true" string
    * v = number if IDC variable is number or string containing a number
    * eTypeConflict if IDC variable = empty string

Help on function idcv_object in module ida_expr:

idcv_object(*args) -> 'error_t'
    idcv_object(v, icls=None) -> error_t
    Create an IDC object. The original value of 'v' is discarded (freed).
    
    @param v: (C++: idc_value_t *) variable to hold the object. any previous value will be cleaned
    @param icls: (C++: const idc_class_t *) ptr to the desired class. nullptr means "object" class this ptr
                 must be returned by add_idc_class() or find_idc_class()
    @return: always eOk

Help on function idcv_string in module ida_expr:

idcv_string(*args) -> 'error_t'
    idcv_string(v) -> error_t
    Convert IDC variable to a text string.
    
    @param v: (C++: idc_value_t *)

Help on function last_idcv_attr in module ida_expr:

last_idcv_attr(*args) -> 'char const *'
    last_idcv_attr(obj) -> char const *
    
    @param obj: idc_value_t const *

Help on function move_idcv in module ida_expr:

move_idcv(*args) -> 'error_t'
    move_idcv(dst, src) -> error_t
    Move 'src' to 'dst'. This function is more effective than copy_idcv since it
    never copies big amounts of data.
    
    @param dst: (C++: idc_value_t *)
    @param src: (C++: idc_value_t *)

Help on function next_idcv_attr in module ida_expr:

next_idcv_attr(*args) -> 'char const *'
    next_idcv_attr(obj, attr) -> char const *
    
    @param obj: idc_value_t const *
    @param attr: char const *

Help on function prev_idcv_attr in module ida_expr:

prev_idcv_attr(*args) -> 'char const *'
    prev_idcv_attr(obj, attr) -> char const *
    
    @param obj: idc_value_t const *
    @param attr: char const *

Help on function print_idcv in module ida_expr:

print_idcv(*args) -> 'qstring *'
    print_idcv(v, name=None, indent=0) -> str
    Get text representation of idc_value_t.
    
    @param v: (C++: const idc_value_t &) idc_value_t const &
    @param name: (C++: const char *) char const *
    @param indent: (C++: int)

Help on function py_add_idc_func in module ida_expr:

py_add_idc_func(*args) -> 'bool'
    py_add_idc_func(name, fp_ptr, args, defvals, flags) -> bool
    
    @param name: char const *
    @param fp_ptr: size_t
    @param args: char const *
    @param defvals: idc_values_t const &
    @param flags: int

Help on function py_get_call_idc_func in module ida_expr:

py_get_call_idc_func(*args) -> 'size_t'
    py_get_call_idc_func() -> size_t

Help on function pyw_convert_defvals in module ida_expr:

pyw_convert_defvals(*args) -> 'bool'
    pyw_convert_defvals(out, py_seq) -> bool
    
    @param out: idc_values_t *
    @param py_seq: PyObject *

Help on function pyw_register_idc_func in module ida_expr:

pyw_register_idc_func(*args) -> 'size_t'
    pyw_register_idc_func(name, args, py_fp) -> size_t
    
    @param name: char const *
    @param args: char const *
    @param py_fp: PyObject *

Help on function pyw_unregister_idc_func in module ida_expr:

pyw_unregister_idc_func(*args) -> 'bool'
    pyw_unregister_idc_func(ctxptr) -> bool
    
    @param ctxptr: size_t

Help on function set_header_path in module ida_expr:

set_header_path(*args) -> 'bool'
    set_header_path(path, add) -> bool
    Set or append a header path. IDA looks for the include files in the appended
    header paths, then in the ida executable directory.
    
    @param path: (C++: const char *) list of directories to add (separated by ';') may be nullptr, in
                 this case nothing is added
    @param add: (C++: bool) true: append. false: remove old paths.
    @retval true: success
    @retval false: no memory

Help on function set_idcv_attr in module ida_expr:

set_idcv_attr(*args) -> 'error_t'
    set_idcv_attr(obj, attr, value, may_use_setattr=False) -> error_t
    Set an object attribute.
    
    @param obj: (C++: idc_value_t *) variable that holds an object reference. if obj is nullptr then it
                tries to modify a global variable with the attribute name
    @param attr: (C++: const char *) attribute name
    @param value: (C++: const idc_value_t &) new attribute value
    @param may_use_setattr: (C++: bool) may call setattr functions for the class
    @return: error code, eOk on success

Help on function set_idcv_slice in module ida_expr:

set_idcv_slice(*args) -> 'error_t'
    set_idcv_slice(v, i1, i2, _in, flags=0) -> error_t
    Set slice.
    
    @param v: (C++: idc_value_t *) variable to modify (string or object)
    @param i1: (C++: uval_t) slice start index
    @param i2: (C++: uval_t) slice end index (excluded)
    @param in: (C++: const idc_value_t &) new value for the slice
    @param flags: (C++: int) IDC variable slice flags or 0
    @return: eOk on success

Help on function swap_idcvs in module ida_expr:

swap_idcvs(*args) -> 'void'
    swap_idcvs(v1, v2)
    Swap 2 variables.
    
    @param v1: (C++: idc_value_t *)
    @param v2: (C++: idc_value_t *)

Help on function throw_idc_exception in module ida_expr:

throw_idc_exception(*args) -> 'error_t'
    throw_idc_exception(r, desc) -> error_t
    Create an idc execution exception object. This helper function can be used to
    return an exception from C++ code to IDC. In other words this function can be
    called from idc_func_t() callbacks. Sample usage: if ( !ok ) return
    throw_idc_exception(r, "detailed error msg");
    
    @param r: (C++: idc_value_t *) object to hold the exception object
    @param desc: (C++: const char *) exception description
    @return: eExecThrow

Module "ida_fixup"s docstring:
"""
Functions that deal with fixup information.

A loader should setup fixup information using set_fixup()."""

Help on function calc_fixup_size in module ida_fixup:

calc_fixup_size(*args) -> 'int'
    calc_fixup_size(type) -> int
    Calculate size of fixup in bytes (the number of bytes the fixup patches)
    @retval -1: means error
    
    @param type: (C++: fixup_type_t)

Help on function contains_fixups in module ida_fixup:

contains_fixups(*args) -> 'bool'
    contains_fixups(ea, size) -> bool
    Does the specified address range contain any fixup information?
    
    @param ea: (C++: ea_t)
    @param size: (C++: asize_t)

Help on function del_fixup in module ida_fixup:

del_fixup(*args) -> 'void'
    del_fixup(source)
    Delete fixup information.
    
    @param source: (C++: ea_t)

Help on function exists_fixup in module ida_fixup:

exists_fixup(*args) -> 'bool'
    exists_fixup(source) -> bool
    Check that a fixup exists at the given address.
    
    @param source: (C++: ea_t)

Help on function find_custom_fixup in module ida_fixup:

find_custom_fixup(*args) -> 'fixup_type_t'
    find_custom_fixup(name) -> fixup_type_t
    Get id of a custom fixup handler.
    
    @param name: (C++: const char *) name of the custom fixup handler
    @return: id with FIXUP_CUSTOM bit set or 0

Help on class fixup_data_t in module ida_fixup:

class fixup_data_t(builtins.object)
 |  Proxy of C++ fixup_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fixup_data_t
 |      __init__(self, type_, flags_=0) -> fixup_data_t
 |      
 |      @param type_: fixup_type_t
 |      @param flags_: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_fixup_data_t(...)
 |      delete_fixup_data_t(self)
 |  
 |  calc_size(self, *args) -> 'int'
 |      calc_size(self) -> int
 |      calc_fixup_size()
 |  
 |  clr_extdef(self, *args) -> 'void'
 |      clr_extdef(self)
 |  
 |  clr_unused(self, *args) -> 'void'
 |      clr_unused(self)
 |  
 |  get(self, *args) -> 'bool'
 |      get(self, source) -> bool
 |      get_fixup()
 |      
 |      @param source: (C++: ea_t)
 |  
 |  get_base(self, *args) -> 'ea_t'
 |      get_base(self) -> ea_t
 |      Get base of fixup.
 |      @note: The target is calculated as `get_base() + off`.
 |      @see: FIXUPF_REL
 |  
 |  get_desc(self, *args) -> 'char const *'
 |      get_desc(self, source) -> char const *
 |      get_fixup_desc()
 |      
 |      @param source: (C++: ea_t)
 |  
 |  get_flags(self, *args) -> 'uint32'
 |      get_flags(self) -> uint32
 |      Fixup flags Fixup flags.
 |  
 |  get_handler(self, *args) -> 'fixup_handler_t const *'
 |      get_handler(self) -> fixup_handler_t const *
 |      get_fixup_handler()
 |  
 |  get_type(self, *args) -> 'fixup_type_t'
 |      get_type(self) -> fixup_type_t
 |      Fixup type Types of fixups.
 |  
 |  get_value(self, *args) -> 'uval_t'
 |      get_value(self, ea) -> uval_t
 |      get_fixup_value()
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  has_base(self, *args) -> 'bool'
 |      has_base(self) -> bool
 |      Is fixup relative?
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |      is_fixup_custom()
 |  
 |  is_extdef(self, *args) -> 'bool'
 |      is_extdef(self) -> bool
 |  
 |  is_unused(self, *args) -> 'bool'
 |      is_unused(self) -> bool
 |  
 |  patch_value(self, *args) -> 'bool'
 |      patch_value(self, ea) -> bool
 |      patch_fixup_value()
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  set(self, *args) -> 'void'
 |      set(self, source)
 |      set_fixup()
 |      
 |      @param source: (C++: ea_t)
 |  
 |  set_base(self, *args) -> 'void'
 |      set_base(self, new_base)
 |      Set base of fixup. The target should be set before a call of this function.
 |      
 |      @param new_base: (C++: ea_t)
 |  
 |  set_extdef(self, *args) -> 'void'
 |      set_extdef(self)
 |  
 |  set_sel(self, *args) -> 'void'
 |      set_sel(self, seg)
 |      
 |      @param seg: segment_t const *
 |  
 |  set_target_sel(self, *args) -> 'void'
 |      set_target_sel(self)
 |      Set selector of fixup to the target. The target should be set before a call of
 |      this function.
 |  
 |  set_type(self, *args) -> 'void'
 |      set_type(self, type_)
 |      
 |      @param type_: fixup_type_t
 |  
 |  set_type_and_flags(self, *args) -> 'void'
 |      set_type_and_flags(self, type_, flags_=0)
 |      
 |      @param type_: fixup_type_t
 |      @param flags_: uint32
 |  
 |  set_unused(self, *args) -> 'void'
 |      set_unused(self)
 |  
 |  was_created(self, *args) -> 'bool'
 |      was_created(self) -> bool
 |      Is fixup artificial?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  displacement
 |      displacement
 |  
 |  off
 |      off
 |  
 |  sel
 |      sel
 |  
 |  thisown
 |      The membership flag

Help on class fixup_info_t in module ida_fixup:

class fixup_info_t(builtins.object)
 |  Proxy of C++ fixup_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fixup_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_fixup_info_t(...)
 |      delete_fixup_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  fd
 |      fd
 |  
 |  thisown
 |      The membership flag

Help on function gen_fix_fixups in module ida_fixup:

gen_fix_fixups(*args) -> 'void'
    gen_fix_fixups(_from, to, size)
    Relocate the bytes with fixup information once more (generic function). This
    function may be called from loader_t::move_segm() if it suits the goal. If
    loader_t::move_segm is not defined then this function will be called
    automatically when moving segments or rebasing the entire program. Special
    parameter values (from = BADADDR, size = 0, to = delta) are used when the
    function is called from rebase_program(delta).
    
    @param from: (C++: ea_t)
    @param to: (C++: ea_t)
    @param size: (C++: asize_t)

Help on function get_first_fixup_ea in module ida_fixup:

get_first_fixup_ea(*args) -> 'ea_t'
    get_first_fixup_ea() -> ea_t
    Get the first address with fixup information
    
    @return: the first address with fixup information, or BADADDR

Help on function get_fixup in module ida_fixup:

get_fixup(*args) -> 'bool'
    get_fixup(fd, source) -> bool
    Get fixup information.
    
    @param fd: (C++: fixup_data_t *)
    @param source: (C++: ea_t)

Help on function get_fixup_desc in module ida_fixup:

get_fixup_desc(*args) -> 'fixup_data_t const &'
    get_fixup_desc(source, fd) -> str
    Get FIXUP description comment.
    
    @param source: (C++: ea_t)
    @param fd: (C++: const fixup_data_t &) fixup_data_t const &

Help on function get_fixup_handler in module ida_fixup:

get_fixup_handler(*args) -> 'fixup_handler_t const *'
    get_fixup_handler(type) -> fixup_handler_t const *
    Get handler of standard or custom fixup.
    
    @param type: (C++: fixup_type_t)

Help on function get_fixup_value in module ida_fixup:

get_fixup_value(*args) -> 'uval_t'
    get_fixup_value(ea, type) -> uval_t
    Get the operand value. This function get fixup bytes from data or an instruction
    at `ea' and convert them to the operand value (maybe partially). It is opposite
    in meaning to the `patch_fixup_value()`. For example, FIXUP_HI8 read a byte at
    `ea' and shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low 26
    bits of the insn at `ea' and shifts it left by 2 bits. This function is mainly
    used to get a relocation addend.
    
    @param ea: (C++: ea_t) address to get fixup bytes from, the size of the fixup bytes depends
               on the fixup type.
    @see: fixup_handler_t::size
    @param type: (C++: fixup_type_t) fixup type
    @retval operand: value

Help on function get_fixups in module ida_fixup:

get_fixups(*args) -> 'bool'
    get_fixups(out, ea, size) -> bool
    
    @param out: fixups_t *
    @param ea: ea_t
    @param size: asize_t

Help on function get_next_fixup_ea in module ida_fixup:

get_next_fixup_ea(*args) -> 'ea_t'
    get_next_fixup_ea(ea) -> ea_t
    Find next address with fixup information
    
    @param ea: (C++: ea_t) current address
    @return: the next address with fixup information, or BADADDR

Help on function get_prev_fixup_ea in module ida_fixup:

get_prev_fixup_ea(*args) -> 'ea_t'
    get_prev_fixup_ea(ea) -> ea_t
    Find previous address with fixup information
    
    @param ea: (C++: ea_t) current address
    @return: the previous address with fixup information, or BADADDR

Help on function handle_fixups_in_macro in module ida_fixup:

handle_fixups_in_macro(*args) -> 'bool'
    handle_fixups_in_macro(ri, ea, other, macro_reft_and_flags) -> bool
    Handle two fixups in a macro. We often combine two instruction that load parts
    of a value into one macro instruction. For example:
    ARM:   ADRP  X0, #var@PAGE
    ADD   X0, X0, #var@PAGEOFF  --> ADRL X0, var
    MIPS:  lui   $v0, %hi(var)
    addiu $v0, $v0, %lo(var)    --> la   $v0, var
    When applying the fixups that fall inside such a macro, we should convert them
    to one refinfo. This function does exactly that. It should be called from the
    apply() callback of a custom fixup.
    
    @param ri: (C++: refinfo_t *)
    @param ea: (C++: ea_t)
    @param other: (C++: fixup_type_t)
    @param macro_reft_and_flags: (C++: uint32)
    @return: success ('false' means that RI was not changed)

Help on function is_fixup_custom in module ida_fixup:

is_fixup_custom(*args) -> 'bool'
    is_fixup_custom(type) -> bool
    Is fixup processed by processor module?
    
    @param type: (C++: fixup_type_t)

Help on function patch_fixup_value in module ida_fixup:

patch_fixup_value(*args) -> 'bool'
    patch_fixup_value(ea, fd) -> bool
    Patch the fixup bytes. This function updates data or an instruction at `ea' to
    the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea' to the high byte
    of `fd->off', or AArch64's custom fixup BRANCH26 updates low 26 bits of the insn
    at `ea' to the value of `fd->off' shifted right by 2.
    
    @param ea: (C++: ea_t) address where data are changed, the size of the changed data depends
               on the fixup type.
    @see: fixup_handler_t::size
    @param fd: (C++: const fixup_data_t &) fixup data
    @retval false: the fixup bytes do not fit (e.g. `fd->off' is greater than
                   0xFFFFFFC for BRANCH26). The database is changed even in this
                   case.

Help on function set_fixup in module ida_fixup:

set_fixup(*args) -> 'void'
    set_fixup(source, fd)
    Set fixup information. You should fill fixup_data_t and call this function and
    the kernel will remember information in the database.
    
    @param source: (C++: ea_t) the fixup source address, i.e. the address modified by the fixup
    @param fd: (C++: const fixup_data_t &) fixup data

Module "ida_fpro"s docstring:
"""
System independent counterparts of FILE* related functions from Clib.

You should not use C standard I/O functions in your modules. The reason: Each
module compiled with Borland (and statically linked to Borland's library) will
host a copy of the FILE * information.

So, if you open a file in the plugin and pass the handle to the kernel, the
kernel will not be able to use it.

If you really need to use the standard functions, define
USE_STANDARD_FILE_FUNCTIONS. In this case do not mix them with q... functions."""

Help on class qfile_t in module ida_fpro:

class qfile_t(builtins.object)
 |  A helper class to work with FILE related functions.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, rhs) -> qfile_t
 |      
 |      @param rhs: qfile_t const &
 |      
 |      __init__(self, pycapsule=None) -> qfile_t
 |      
 |      @param pycapsule: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qfile_t(...)
 |      delete_qfile_t(self)
 |  
 |  close(self, *args) -> 'void'
 |      close(self)
 |      Closes the file
 |  
 |  filename(self, *args) -> 'PyObject *'
 |      filename(self) -> PyObject *
 |  
 |  flush(self, *args) -> 'int'
 |      flush(self) -> int
 |  
 |  get_byte(self, *args) -> 'PyObject *'
 |      get_byte(self) -> PyObject *
 |      Reads a single byte from the file. Returns None if EOF or the read byte
 |  
 |  get_fp(self, *args) -> 'FILE *'
 |      get_fp(self) -> FILE *
 |  
 |  gets(self, *args) -> 'PyObject *'
 |      gets(self, size) -> PyObject *
 |      Reads a line from the input file. Returns the read line or None
 |      
 |      @param size: int
 |  
 |  open(self, *args) -> 'bool'
 |      open(self, filename, mode) -> bool
 |      Opens a file
 |      
 |      @param filename: the file name
 |      @param mode: The mode string, ala fopen() style
 |      @return: Boolean
 |  
 |  opened(self, *args) -> 'bool'
 |      opened(self) -> bool
 |      Checks if the file is opened or not
 |  
 |  put_byte(self, *args) -> 'int'
 |      put_byte(self, chr) -> int
 |      Writes a single byte to the file
 |      
 |      @param chr: int
 |  
 |  puts(self, *args) -> 'int'
 |      puts(self, str) -> int
 |      
 |      @param str: char const *
 |  
 |  read(self, *args) -> 'PyObject *'
 |      read(self, size) -> PyObject *
 |      Reads from the file. Returns the buffer or None
 |      
 |      @param size: int
 |  
 |  readbytes(self, *args) -> 'PyObject *'
 |      readbytes(self, size, big_endian) -> PyObject *
 |      Similar to read() but it respect the endianness
 |      
 |      @param size: int
 |      @param big_endian: bool
 |  
 |  seek(self, *args) -> 'int'
 |      seek(self, offset, whence=SEEK_SET) -> int
 |      Set input source position
 |      
 |      @param offset: int64
 |      @param whence: int
 |      @return: the new position (not 0 as fseek!)
 |  
 |  size(self, *args) -> 'int64'
 |      size(self) -> int64
 |  
 |  tell(self, *args) -> 'int64'
 |      tell(self) -> int64
 |      Returns the current position
 |  
 |  write(self, *args) -> 'int'
 |      write(self, py_buf) -> int
 |      Writes to the file. Returns 0 or the number of bytes written
 |      
 |      @param py_buf: PyObject *
 |  
 |  writebytes(self, *args) -> 'int'
 |      writebytes(self, py_buf, big_endian) -> int
 |      Similar to write() but it respect the endianness
 |      
 |      @param py_buf: PyObject *
 |      @param big_endian: bool
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  from_capsule(*args) -> 'qfile_t *'
 |      from_capsule(pycapsule) -> qfile_t
 |      
 |      @param pycapsule: PyObject *
 |  
 |  from_fp(*args) -> 'qfile_t *'
 |      from_fp(fp) -> qfile_t
 |      
 |      @param fp: FILE *
 |  
 |  tmpfile(*args) -> 'qfile_t *'
 |      tmpfile() -> qfile_t
 |      A static method to construct an instance using a temporary file
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __idc_cvt_id__
 |      __idc_cvt_id__
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function qfile_t_from_capsule in module ida_fpro:

qfile_t_from_capsule(*args) -> 'qfile_t *'
    qfile_t_from_capsule(pycapsule) -> qfile_t
    
    @param pycapsule: PyObject *

Help on function qfile_t_from_fp in module ida_fpro:

qfile_t_from_fp(*args) -> 'qfile_t *'
    qfile_t_from_fp(fp) -> qfile_t
    
    @param fp: FILE *

Help on function qfile_t_tmpfile in module ida_fpro:

qfile_t_tmpfile(*args) -> 'qfile_t *'
    qfile_t_tmpfile() -> qfile_t

Module "ida_frame"s docstring:
"""
Routines to manipulate function stack frames, stack variables, register
variables and local labels.

The frame is represented as a structure:
+------------------------------------------------+
  | function arguments                             |
  +------------------------------------------------+
  | return address (isn't stored in func_t)        |
  +------------------------------------------------+
  | saved registers (SI, DI, etc - func_t::frregs) |
  +------------------------------------------------+ <- typical BP
  |                                                |  |
  |                                                |  | func_t::fpd
  |                                                |  |
  |                                                | <- real BP
  | local variables (func_t::frsize)               |
  |                                                |
  |                                                |
  +------------------------------------------------+ <- SP

To access the structure of a function frame, use:
* get_struc() (use func_t::frame as structure ID)
* get_frame(const func_t *pfn)
* get_frame(ea_t ea)"""

Help on function add_auto_stkpnt in module ida_frame:

add_auto_stkpnt(*args) -> 'bool'
    add_auto_stkpnt(pfn, ea, delta) -> bool
    Add automatic SP register change point.
    
    @param pfn: (C++: func_t *) pointer to function. may be nullptr.
    @param ea: (C++: ea_t) linear address where SP changes. usually this is the end of the
               instruction which modifies the stack pointer ( insn_t::ea+
               insn_t::size)
    @param delta: (C++: sval_t) difference between old and new values of SP
    @return: success

Help on function add_frame in module ida_frame:

add_frame(*args) -> 'bool'
    add_frame(pfn, frsize, frregs, argsize) -> bool
    Add function frame.
    
    @param pfn: (C++: func_t *) pointer to function structure
    @param frsize: (C++: sval_t) size of function local variables
    @param frregs: (C++: ushort) size of saved registers
    @param argsize: (C++: asize_t) size of function arguments range which will be purged upon
                    return. this parameter is used for __stdcall and __pascal
                    calling conventions. for other calling conventions please pass
                    0.
    @retval 1: ok
    @retval 0: failed (no function, frame already exists)

Help on function add_regvar in module ida_frame:

add_regvar(*args) -> 'int'
    add_regvar(pfn, ea1, ea2, canon, user, cmt) -> int
    Define a register variable.
    
    @param pfn: (C++: func_t *) function in which the definition will be created
    @param ea1: (C++: ea_t) ,ea2: range of addresses within the function where the definition will
                    be used
    @param canon: (C++: const char *) name of a general register
    @param canon: (C++: const char *) name of a general register
    @param user: (C++: const char *) user-defined name for the register
    @param cmt: (C++: const char *) comment for the definition
    @return: Register variable error codes

Help on function add_user_stkpnt in module ida_frame:

add_user_stkpnt(*args) -> 'bool'
    add_user_stkpnt(ea, delta) -> bool
    Add user-defined SP register change point.
    
    @param ea: (C++: ea_t) linear address where SP changes
    @param delta: (C++: sval_t) difference between old and new values of SP
    @return: success

Help on function build_stkvar_name in module ida_frame:

build_stkvar_name(*args) -> 'qstring *'
    build_stkvar_name(pfn, v) -> str
    Build automatic stack variable name.
    
    @param pfn: (C++: const func_t *) pointer to function (can't be nullptr!)
    @param v: (C++: sval_t) value of variable offset
    @return: length of stack variable name or -1

Help on function build_stkvar_xrefs in module ida_frame:

build_stkvar_xrefs(*args) -> 'void'
    build_stkvar_xrefs(out, pfn, mptr)
    Fill 'out' with a list of all the xrefs made from function 'pfn', to the
    argument or variable 'mptr' in 'pfn's stack frame.
    
    @param out: (C++: xreflist_t *) the list of xrefs to fill.
    @param pfn: (C++: func_t *) the function to scan.
    @param mptr: (C++: const member_t *) the argument/variable in pfn's stack frame.

Help on function calc_stkvar_struc_offset in module ida_frame:

calc_stkvar_struc_offset(*args) -> 'ea_t'
    calc_stkvar_struc_offset(pfn, insn, n) -> ea_t
    Calculate offset of stack variable in the frame structure.
    
    @param pfn: (C++: func_t *) pointer to function (can't be nullptr!)
    @param insn: (C++: const insn_t &) the instruction
    @param n: (C++: int) number of operand: (0..UA_MAXOP-1) -1 if error, return BADADDR
    @return: BADADDR if some error (issue a warning if stack frame is bad)

Help on function define_stkvar in module ida_frame:

define_stkvar(*args) -> 'bool'
    define_stkvar(pfn, name, off, flags, ti, nbytes) -> bool
    Define/redefine a stack variable.
    
    @param pfn: (C++: func_t *) pointer to function
    @param name: (C++: const char *) variable name, nullptr means autogenerate a name
    @param off: (C++: sval_t) offset of the stack variable in the frame. negative values denote
                local variables, positive - function arguments.
    @param flags: (C++: flags_t) variable type flags (byte_flag() for a byte variable, for example)
    @param ti: (C++: const opinfo_t *) additional type information (like offsets, structs, etc)
    @param nbytes: (C++: asize_t) number of bytes occupied by the variable
    @return: success

Help on function del_frame in module ida_frame:

del_frame(*args) -> 'bool'
    del_frame(pfn) -> bool
    Delete a function frame.
    
    @param pfn: (C++: func_t *) pointer to function structure
    @return: success

Help on function del_regvar in module ida_frame:

del_regvar(*args) -> 'int'
    del_regvar(pfn, ea1, ea2, canon) -> int
    Delete a register variable definition.
    
    @param pfn: (C++: func_t *) function in question
    @param ea1: (C++: ea_t) ,ea2: range of addresses within the function where the definition
                    holds
    @param canon: (C++: const char *) name of a general register
    @param canon: (C++: const char *) name of a general register
    @return: Register variable error codes

Help on function del_stkpnt in module ida_frame:

del_stkpnt(*args) -> 'bool'
    del_stkpnt(pfn, ea) -> bool
    Delete SP register change point.
    
    @param pfn: (C++: func_t *) pointer to function. may be nullptr.
    @param ea: (C++: ea_t) linear address
    @return: success

Help on function delete_unreferenced_stkvars in module ida_frame:

delete_unreferenced_stkvars(*args) -> 'int'
    delete_unreferenced_stkvars(pfn) -> int
    
    @param pfn: func_t *

Help on function delete_wrong_stkvar_ops in module ida_frame:

delete_wrong_stkvar_ops(*args) -> 'int'
    delete_wrong_stkvar_ops(pfn) -> int
    
    @param pfn: func_t *

Help on function find_regvar in module ida_frame:

find_regvar(*args) -> 'regvar_t *'
    find_regvar(pfn, ea1, ea2, canon, user) -> regvar_t
    Find a register variable definition.
    
    @param pfn: (C++: func_t *) function in question
    @param ea1: ea_t
    @param canon: (C++: const char *) name of a general register
    @param canon: (C++: const char *) name of a general register
    @param user: char const *
    
    @return: nullptr-not found, otherwise ptr to regvar_t
    find_regvar(pfn, ea, canon) -> regvar_t
    
    @param pfn: func_t *
    @param ea: ea_t
    @param canon: char const *

Help on function frame_off_args in module ida_frame:

frame_off_args(*args) -> 'ea_t'
    frame_off_args(pfn) -> ea_t
    Get starting address of arguments section.
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function frame_off_lvars in module ida_frame:

frame_off_lvars(*args) -> 'ea_t'
    frame_off_lvars(pfn) -> ea_t
    Get start address of local variables section.
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function frame_off_retaddr in module ida_frame:

frame_off_retaddr(*args) -> 'ea_t'
    frame_off_retaddr(pfn) -> ea_t
    Get starting address of return address section.
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function frame_off_savregs in module ida_frame:

frame_off_savregs(*args) -> 'ea_t'
    frame_off_savregs(pfn) -> ea_t
    Get starting address of saved registers section.
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function free_regvar in module ida_frame:

free_regvar(*args) -> 'void'
    free_regvar(v)
    
    @param v: regvar_t *

Help on function get_effective_spd in module ida_frame:

get_effective_spd(*args) -> 'sval_t'
    get_effective_spd(pfn, ea) -> sval_t
    Get effective difference between the initial and current values of ESP. This
    function returns the sp-diff used by the instruction. The difference between
    get_spd() and get_effective_spd() is present only for instructions like "pop
    [esp+N]": they modify sp and use the modified value.
    
    @param pfn: (C++: func_t *) pointer to function. may be nullptr.
    @param ea: (C++: ea_t) linear address
    @return: 0 or the difference, usually a negative number

Help on function get_frame in module ida_frame:

get_frame(*args) -> 'struc_t *'
    get_frame(pfn) -> struc_t
    Get pointer to function frame.
    
    @param pfn: func_t const *
    
    get_frame(ea) -> struc_t *
    
    @param ea: ea_t

Help on function get_frame_part in module ida_frame:

get_frame_part(*args) -> 'void'
    get_frame_part(range, pfn, part)
    Get offsets of the frame part in the frame.
    
    @param range: (C++: range_t *) pointer to the output buffer with the frame part
                  start/end(exclusive) offsets, can't be nullptr
    @param pfn: (C++: const func_t *) pointer to function structure, can't be nullptr
    @param part: (C++: frame_part_t) frame part

Help on function get_frame_retsize in module ida_frame:

get_frame_retsize(*args) -> 'int'
    get_frame_retsize(pfn) -> int
    Get size of function return address.
    
    @param pfn: (C++: const func_t *) pointer to function structure, can't be nullptr

Help on function get_frame_size in module ida_frame:

get_frame_size(*args) -> 'asize_t'
    get_frame_size(pfn) -> asize_t
    Get full size of a function frame. This function takes into account size of
    local variables + size of saved registers + size of return address + number of
    purged bytes. The purged bytes correspond to the arguments of the functions with
    __stdcall and __fastcall calling conventions.
    
    @param pfn: (C++: const func_t *) pointer to function structure, may be nullptr
    @return: size of frame in bytes or zero

Help on function get_func_by_frame in module ida_frame:

get_func_by_frame(*args) -> 'ea_t'
    get_func_by_frame(frame_id) -> ea_t
    Get function by its frame id.
    @warning: this function works only with databases created by IDA > 5.6
    
    @param frame_id: (C++: tid_t) id of the function frame
    @return: start address of the function or BADADDR

Help on function get_min_spd_ea in module ida_frame:

get_min_spd_ea(*args) -> 'ea_t'
    get_min_spd_ea(pfn) -> ea_t
    
    @param pfn: func_t *

Help on function get_sp_delta in module ida_frame:

get_sp_delta(*args) -> 'sval_t'
    get_sp_delta(pfn, ea) -> sval_t
    Get modification of SP made at the specified location
    
    @param pfn: (C++: func_t *) pointer to function. may be nullptr.
    @param ea: (C++: ea_t) linear address
    @return: 0 if the specified location doesn't contain a SP change point.
             otherwise return delta of SP modification.

Help on function get_spd in module ida_frame:

get_spd(*args) -> 'sval_t'
    get_spd(pfn, ea) -> sval_t
    Get difference between the initial and current values of ESP.
    
    @param pfn: (C++: func_t *) pointer to function. may be nullptr.
    @param ea: (C++: ea_t) linear address of an instruction
    @return: 0 or the difference, usually a negative number. returns the sp-diff
             before executing the instruction.

Help on function get_stkvar in module ida_frame:

get_stkvar(*args) -> 'PyObject *'
    get_stkvar(insn, op, v) -> (member_t, int) or None
    Get pointer to stack variable
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: reference to instruction operand
    @param v: immediate value in the operand (usually op.addr)
    @return:     - None on failure
        - tuple(member_t, actval)
          where actval: actual value used to fetch stack variable

Help on function has_regvar in module ida_frame:

has_regvar(*args) -> 'bool'
    has_regvar(pfn, ea) -> bool
    Is there a register variable definition?
    
    @param pfn: (C++: func_t *) function in question
    @param ea: (C++: ea_t) current address

Help on function is_funcarg_off in module ida_frame:

is_funcarg_off(*args) -> 'bool'
    is_funcarg_off(pfn, frameoff) -> bool
    
    @param pfn: func_t const *
    @param frameoff: uval_t

Help on function lvar_off in module ida_frame:

lvar_off(*args) -> 'sval_t'
    lvar_off(pfn, frameoff) -> sval_t
    
    @param pfn: func_t const *
    @param frameoff: uval_t

Help on function recalc_spd in module ida_frame:

recalc_spd(*args) -> 'bool'
    recalc_spd(cur_ea) -> bool
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to recalculate
    SP for the next instruction.
    
    This function will create a new automatic SP register change point if necessary.
    It should be called from the emulator (emu.cpp) when auto_state == AU_USED if
    the current instruction doesn't pass the execution flow to the next instruction.
    
    @param cur_ea: (C++: ea_t) linear address of the current instruction
    @retval 1: new stkpnt is added
    @retval 0: nothing is changed

Help on class regvar_t in module ida_frame:

class regvar_t(ida_range.range_t)
 |  Proxy of C++ regvar_t class.
 |  
 |  Method resolution order:
 |      regvar_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regvar_t
 |      __init__(self, r) -> regvar_t
 |      
 |      @param r: regvar_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regvar_t(...)
 |      delete_regvar_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: regvar_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  canon
 |      canon
 |  
 |  cmt
 |      cmt
 |  
 |  thisown
 |      The membership flag
 |  
 |  user
 |      user
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function rename_regvar in module ida_frame:

rename_regvar(*args) -> 'int'
    rename_regvar(pfn, v, user) -> int
    Rename a register variable.
    
    @param pfn: (C++: func_t *) function in question
    @param v: (C++: regvar_t *) variable to rename
    @param user: (C++: const char *) new user-defined name for the register
    @return: Register variable error codes

Help on function set_frame_size in module ida_frame:

set_frame_size(*args) -> 'bool'
    set_frame_size(pfn, frsize, frregs, argsize) -> bool
    Set size of function frame. Note: The returned size may not include all stack
    arguments. It does so only for __stdcall and __fastcall calling conventions. To
    get the entire frame size for all cases use get_struc_size(get_frame(pfn)).
    
    @param pfn: (C++: func_t *) pointer to function structure
    @param frsize: (C++: asize_t) size of function local variables
    @param frregs: (C++: ushort) size of saved registers
    @param argsize: (C++: asize_t) size of function arguments that will be purged from the stack
                    upon return
    @return: success

Help on function set_purged in module ida_frame:

set_purged(*args) -> 'bool'
    set_purged(ea, nbytes, override_old_value) -> bool
    Set the number of purged bytes for a function or data item (funcptr). This
    function will update the database and plan to reanalyze items referencing the
    specified address. It works only for processors with PR_PURGING bit in 16 and 32
    bit modes.
    
    @param ea: (C++: ea_t) address of the function of item
    @param nbytes: (C++: int) number of purged bytes
    @param override_old_value: (C++: bool) may overwrite old information about purged bytes
    @return: success

Help on function set_regvar_cmt in module ida_frame:

set_regvar_cmt(*args) -> 'int'
    set_regvar_cmt(pfn, v, cmt) -> int
    Set comment for a register variable.
    
    @param pfn: (C++: func_t *) function in question
    @param v: (C++: regvar_t *) variable to rename
    @param cmt: (C++: const char *) new comment
    @return: Register variable error codes

Help on function soff_to_fpoff in module ida_frame:

soff_to_fpoff(*args) -> 'sval_t'
    soff_to_fpoff(pfn, soff) -> sval_t
    Convert struct offsets into fp-relative offsets. This function converts the
    offsets inside the struc_t object into the frame pointer offsets (for example,
    EBP-relative).
    
    @param pfn: (C++: func_t *)
    @param soff: (C++: uval_t)

Help on class stkpnt_t in module ida_frame:

class stkpnt_t(builtins.object)
 |  Proxy of C++ stkpnt_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: stkpnt_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: stkpnt_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: stkpnt_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkpnt_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: stkpnt_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: stkpnt_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: stkpnt_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkpnt_t(...)
 |      delete_stkpnt_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: stkpnt_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  spd
 |      spd
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class stkpnts_t in module ida_frame:

class stkpnts_t(builtins.object)
 |  Proxy of C++ stkpnts_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: stkpnts_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: stkpnts_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: stkpnts_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkpnts_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: stkpnts_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: stkpnts_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: stkpnts_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkpnts_t(...)
 |      delete_stkpnts_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: stkpnts_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function update_fpd in module ida_frame:

update_fpd(*args) -> 'bool'
    update_fpd(pfn, fpd) -> bool
    Update frame pointer delta.
    
    @param pfn: (C++: func_t *) pointer to function structure
    @param fpd: (C++: asize_t) new fpd value. cannot be bigger than the local variable range size.
    @return: success

Help on class xreflist_entry_t in module ida_frame:

class xreflist_entry_t(builtins.object)
 |  Proxy of C++ xreflist_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xreflist_entry_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_xreflist_entry_t(...)
 |      delete_xreflist_entry_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: xreflist_entry_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  opnum
 |      opnum
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class xreflist_t in module ida_frame:

class xreflist_t(builtins.object)
 |  Proxy of C++ qvector< xreflist_entry_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< xreflist_entry_t > const &
 |  
 |  __getitem__(self, *args) -> 'xreflist_entry_t const &'
 |      __getitem__(self, i) -> xreflist_entry_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xreflist_t
 |      __init__(self, x) -> xreflist_t
 |      
 |      @param x: qvector< xreflist_entry_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< xreflist_entry_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: xreflist_entry_t const &
 |  
 |  __swig_destroy__ = delete_xreflist_t(...)
 |      delete_xreflist_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: xreflist_entry_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: xreflist_entry_t const &
 |  
 |  at(self, *args) -> 'xreflist_entry_t const &'
 |      at(self, _idx) -> xreflist_entry_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< xreflist_entry_t >::const_iterator'
 |      begin(self) -> xreflist_entry_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< xreflist_entry_t >::const_iterator'
 |      end(self) -> xreflist_entry_t
 |  
 |  erase(self, *args) -> 'qvector< xreflist_entry_t >::iterator'
 |      erase(self, it) -> xreflist_entry_t
 |      
 |      @param it: qvector< xreflist_entry_t >::iterator
 |      
 |      erase(self, first, last) -> xreflist_entry_t
 |      
 |      @param first: qvector< xreflist_entry_t >::iterator
 |      @param last: qvector< xreflist_entry_t >::iterator
 |  
 |  extract(self, *args) -> 'xreflist_entry_t *'
 |      extract(self) -> xreflist_entry_t
 |  
 |  find(self, *args) -> 'qvector< xreflist_entry_t >::const_iterator'
 |      find(self, x) -> xreflist_entry_t
 |      
 |      @param x: xreflist_entry_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=xreflist_entry_t())
 |      
 |      @param x: xreflist_entry_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: xreflist_entry_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: xreflist_entry_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< xreflist_entry_t >::iterator'
 |      insert(self, it, x) -> xreflist_entry_t
 |      
 |      @param it: qvector< xreflist_entry_t >::iterator
 |      @param x: xreflist_entry_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'xreflist_entry_t &'
 |      push_back(self, x)
 |      
 |      @param x: xreflist_entry_t const &
 |      
 |      push_back(self) -> xreflist_entry_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: xreflist_entry_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< xreflist_entry_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Module "ida_funcs"s docstring:
"""
Routines for working with functions within the disassembled program.

This file also contains routines for working with library signatures (e.g.
FLIRT).

Each function consists of function chunks. At least one function chunk must be
present in the function definition - the function entry chunk. Other chunks are
called function tails. There may be several of them for a function.

A function tail is a continuous range of addresses. It can be used in the
definition of one or more functions. One function using the tail is singled out
and called the tail owner. This function is considered as 'possessing' the tail.
get_func() on a tail address will return the function possessing the tail. You
can enumerate the functions using the tail by using func_parent_iterator_t.

Each function chunk in the disassembly is represented as an "range" (a range of
addresses, see range.hpp for details) with characteristics.

A function entry must start with an instruction (code) byte."""

Help on function add_func in module ida_funcs:

add_func(*args) -> 'bool'
    add_func(ea1, ea2=BADADDR) -> bool
    Add a new function. If the function end address is BADADDR, then IDA will try to
    determine the function bounds by calling find_func_bounds(...,
    FIND_FUNC_DEFINE).
    
    @param ea1: (C++: ea_t) start address
    @param ea2: (C++: ea_t) end address
    @return: success

Help on function add_func_ex in module ida_funcs:

add_func_ex(*args) -> 'bool'
    add_func_ex(pfn) -> bool
    Add a new function. If the fn->end_ea is BADADDR, then IDA will try to determine
    the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE).
    
    @param pfn: (C++: func_t *) ptr to filled function structure
    @return: success

Help on function add_regarg in module ida_funcs:

add_regarg(*args) -> 'void'
    add_regarg(pfn, reg, tif, name)
    
    @param pfn: func_t *
    @param reg: int
    @param tif: tinfo_t const &
    @param name: char const *

Help on function append_func_tail in module ida_funcs:

append_func_tail(*args) -> 'bool'
    append_func_tail(pfn, ea1, ea2) -> bool
    Append a new tail chunk to the function definition. If the tail already exists,
    then it will simply be added to the function tail list Otherwise a new tail will
    be created and its owner will be set to be our function If a new tail cannot be
    created, then this function will fail.
    
    @param pfn: (C++: func_t *) pointer to the function
    @param ea1: (C++: ea_t) start of the tail. If a tail already exists at the specified address
                it must start at 'ea1'
    @param ea2: (C++: ea_t) end of the tail. If a tail already exists at the specified address
                it must end at 'ea2'. If specified as BADADDR, IDA will determine
                the end address itself.

Help on function apply_idasgn_to in module ida_funcs:

apply_idasgn_to(*args) -> 'int'
    apply_idasgn_to(signame, ea, is_startup) -> int
    Apply a signature file to the specified address.
    
    @param signame: (C++: const char *) short name of signature file (the file name without path)
    @param ea: (C++: ea_t) address to apply the signature
    @param is_startup: (C++: bool) if set, then the signature is treated as a startup one for
                       startup signature ida doesn't rename the first function of
                       the applied module.
    @return: Library function codes

Help on function apply_startup_sig in module ida_funcs:

apply_startup_sig(*args) -> 'bool'
    apply_startup_sig(ea, startup) -> bool
    Apply a startup signature file to the specified address.
    
    @param ea: (C++: ea_t) address to apply the signature to; usually idainfo::start_ea
    @param startup: (C++: const char *) the name of the signature file without path and extension
    @return: true if successfully applied the signature

Help on function calc_func_size in module ida_funcs:

calc_func_size(*args) -> 'asize_t'
    calc_func_size(pfn) -> asize_t
    Calculate function size. This function takes into account all fragments of the
    function.
    
    @param pfn: (C++: func_t *) ptr to function structure

Help on function calc_idasgn_state in module ida_funcs:

calc_idasgn_state(*args) -> 'int'
    calc_idasgn_state(n) -> int
    Get state of a signature in the list of planned signatures
    
    @param n: (C++: int) number of signature in the list (0..get_idasgn_qty()-1)
    @return: state of signature or IDASGN_BADARG

Help on function calc_thunk_func_target in module ida_funcs:

calc_thunk_func_target(*args)
    calc_thunk_func_target(pfn) -> ea_t
    Calculate target of a thunk function.
    
    @param pfn: (C++: func_t *) pointer to function (may not be nullptr)
    @return: the target function or BADADDR

Help on function del_func in module ida_funcs:

del_func(*args) -> 'bool'
    del_func(ea) -> bool
    Delete a function.
    
    @param ea: (C++: ea_t) any address in the function entry chunk
    @return: success

Help on function del_idasgn in module ida_funcs:

del_idasgn(*args) -> 'int'
    del_idasgn(n) -> int
    Remove signature from the list of planned signatures.
    
    @param n: (C++: int) number of signature in the list (0..get_idasgn_qty()-1)
    @return: IDASGN_OK, IDASGN_BADARG, IDASGN_APPLIED

Help on class dyn_ea_array in module ida_funcs:

class dyn_ea_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< ea_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_ea_array
 |      
 |      @param _data: unsigned-ea-like-numeric-type *
 |      @param _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned-ea-like-numeric-type const &
 |  
 |  __swig_destroy__ = delete_dyn_ea_array(...)
 |      delete_dyn_ea_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      count
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class dyn_range_array in module ida_funcs:

class dyn_range_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< range_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_range_array
 |      
 |      @param _data: range_t *
 |      @param _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  __swig_destroy__ = delete_dyn_range_array(...)
 |      delete_dyn_range_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      count
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class dyn_regarg_array in module ida_funcs:

class dyn_regarg_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< regarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'regarg_t const &'
 |      __getitem__(self, i) -> regarg_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_regarg_array
 |      
 |      @param _data: regarg_t *
 |      @param _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: regarg_t const &
 |  
 |  __swig_destroy__ = delete_dyn_regarg_array(...)
 |      delete_dyn_regarg_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      count
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class dyn_regvar_array in module ida_funcs:

class dyn_regvar_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< regvar_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'regvar_t const &'
 |      __getitem__(self, i) -> regvar_t const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_regvar_array
 |      
 |      @param _data: regvar_t *
 |      @param _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: regvar_t const &
 |  
 |  __swig_destroy__ = delete_dyn_regvar_array(...)
 |      delete_dyn_regvar_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      count
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class dyn_stkpnt_array in module ida_funcs:

class dyn_stkpnt_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< stkpnt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'stkpnt_t const &'
 |      __getitem__(self, i) -> stkpnt_t const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_stkpnt_array
 |      
 |      @param _data: stkpnt_t *
 |      @param _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: stkpnt_t const &
 |  
 |  __swig_destroy__ = delete_dyn_stkpnt_array(...)
 |      delete_dyn_stkpnt_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      count
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on function f_any in module ida_funcs:

f_any(*args) -> 'bool'
    f_any(arg1, arg2) -> bool
    Helper function to accept any address.
    
    @param arg1: flags_t
    @param arg2: void *

Help on function find_func_bounds in module ida_funcs:

find_func_bounds(*args) -> 'int'
    find_func_bounds(nfn, flags) -> int
    Determine the boundaries of a new function. This function tries to find the
    start and end addresses of a new function. It calls the module with
    processor_t::func_bounds in order to fine tune the function boundaries.
    
    @param nfn: (C++: func_t *) structure to fill with information \ nfn->start_ea points to the
                start address of the new function.
    @param flags: (C++: int) Find function bounds flags
    @return: Find function bounds result codes

Help on function free_regarg in module ida_funcs:

free_regarg(*args) -> 'void'
    free_regarg(v)
    
    @param v: regarg_t *

Help on function func_contains in module ida_funcs:

func_contains(*args) -> 'bool'
    func_contains(pfn, ea) -> bool
    Does the given function contain the given address?
    
    @param pfn: (C++: func_t *)
    @param ea: (C++: ea_t)

Help on function func_does_return in module ida_funcs:

func_does_return(*args) -> 'bool'
    func_does_return(callee) -> bool
    Does the function return?. To calculate the answer, FUNC_NORET flag and
    is_noret() are consulted The latter is required for imported functions in the
    .idata section. Since in .idata we have only function pointers but not
    functions, we have to introduce a special flag for them.
    
    @param callee: (C++: ea_t)

Help on class func_item_iterator_t in module ida_funcs:

class func_item_iterator_t(builtins.object)
 |  Proxy of C++ func_item_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_item_iterator_t
 |      __init__(self, pfn, _ea=BADADDR) -> func_item_iterator_t
 |      
 |      @param pfn: func_t *
 |      @param _ea: ea_t
 |  
 |  __iter__(self)
 |      Provide an iterator on code items
 |  
 |  __next__(self, *args) -> 'bool'
 |      __next__(self, func) -> bool
 |      
 |      @param func: testf_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_item_iterator_t(...)
 |      delete_func_item_iterator_t(self)
 |  
 |  addresses(self)
 |      Provide an iterator on addresses contained within the function
 |  
 |  chunk(self, *args) -> 'range_t const &'
 |      chunk(self) -> range_t
 |  
 |  code_items(self)
 |      Provide an iterator on code items contained within the function
 |  
 |  current(self, *args) -> 'ea_t'
 |      current(self) -> ea_t
 |  
 |  data_items(self)
 |      Provide an iterator on data items contained within the function
 |  
 |  decode_preceding_insn(self, *args) -> 'bool'
 |      decode_preceding_insn(self, visited, p_farref, out) -> bool
 |      
 |      @param visited: eavec_t *
 |      @param p_farref: bool *
 |      @param out: insn_t *
 |  
 |  decode_prev_insn(self, *args) -> 'bool'
 |      decode_prev_insn(self, out) -> bool
 |      
 |      @param out: insn_t *
 |  
 |  first(self, *args) -> 'bool'
 |      first(self) -> bool
 |  
 |  head_items(self)
 |      Provide an iterator on item heads contained within the function
 |  
 |  last(self, *args) -> 'bool'
 |      last(self) -> bool
 |  
 |  next = __next__(self, *args) -> 'bool'
 |  
 |  next_addr(self, *args) -> 'bool'
 |      next_addr(self) -> bool
 |  
 |  next_code(self, *args) -> 'bool'
 |      next_code(self) -> bool
 |  
 |  next_data(self, *args) -> 'bool'
 |      next_data(self) -> bool
 |  
 |  next_head(self, *args) -> 'bool'
 |      next_head(self) -> bool
 |  
 |  next_not_tail(self, *args) -> 'bool'
 |      next_not_tail(self) -> bool
 |  
 |  not_tails(self)
 |      Provide an iterator on non-tail addresses contained within the function
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, func) -> bool
 |      
 |      @param func: testf_t *
 |  
 |  prev_addr(self, *args) -> 'bool'
 |      prev_addr(self) -> bool
 |  
 |  prev_code(self, *args) -> 'bool'
 |      prev_code(self) -> bool
 |  
 |  prev_data(self, *args) -> 'bool'
 |      prev_data(self) -> bool
 |  
 |  prev_head(self, *args) -> 'bool'
 |      prev_head(self) -> bool
 |  
 |  prev_not_tail(self, *args) -> 'bool'
 |      prev_not_tail(self) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, pfn, _ea=BADADDR) -> bool
 |      Set a function range. if pfn == nullptr then a segment range will be set.
 |      
 |      @param pfn: (C++: func_t *)
 |      @param _ea: (C++: ea_t)
 |  
 |  set_range(self, *args) -> 'bool'
 |      set_range(self, ea1, ea2) -> bool
 |      Set an arbitrary range.
 |      
 |      @param ea1: (C++: ea_t)
 |      @param ea2: (C++: ea_t)
 |  
 |  succ(self, *args) -> 'bool'
 |      succ(self, func) -> bool
 |      Similar to next(), but succ() iterates the chunks from low to high addresses,
 |      while next() iterates through chunks starting at the function entry chunk
 |      
 |      @param func: (C++: testf_t *)
 |  
 |  succ_code(self, *args) -> 'bool'
 |      succ_code(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function func_parent_iterator_set in module ida_funcs:

func_parent_iterator_set(*args) -> 'bool'
    func_parent_iterator_set(fpi, pfn) -> bool
    
    @param fpi: func_parent_iterator_t *
    @param pfn: func_t *

Help on class func_parent_iterator_t in module ida_funcs:

class func_parent_iterator_t(builtins.object)
 |  Proxy of C++ func_parent_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_parent_iterator_t
 |      __init__(self, _fnt) -> func_parent_iterator_t
 |      
 |      @param _fnt: func_t *
 |  
 |  __iter__(self)
 |      Provide an iterator on function parents
 |  
 |  __next__(self, *args) -> 'bool'
 |      __next__(self) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_parent_iterator_t(...)
 |      delete_func_parent_iterator_t(self)
 |  
 |  first(self, *args) -> 'bool'
 |      first(self) -> bool
 |  
 |  last(self, *args) -> 'bool'
 |      last(self) -> bool
 |  
 |  next = __next__(self, *args) -> 'bool'
 |  
 |  parent(self, *args) -> 'ea_t'
 |      parent(self) -> ea_t
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self) -> bool
 |  
 |  reset_fnt(self, *args) -> 'void'
 |      reset_fnt(self, _fnt)
 |      
 |      @param _fnt: func_t *
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, _fnt) -> bool
 |      
 |      @param _fnt: func_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class func_t in module ida_funcs:

class func_t(ida_range.range_t)
 |  Proxy of C++ func_t class.
 |  
 |  Method resolution order:
 |      func_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __get_points__(self, *args) -> 'dynamic_wrapped_array_t< stkpnt_t >'
 |      __get_points__(self) -> dyn_stkpnt_array
 |  
 |  __get_referers__(self, *args) -> 'dynamic_wrapped_array_t< ea_t >'
 |      __get_referers__(self) -> dyn_ea_array
 |  
 |  __get_regargs__(self, *args) -> 'dynamic_wrapped_array_t< regarg_t >'
 |      __get_regargs__(self) -> dyn_regarg_array
 |  
 |  __get_regvars__(self, *args) -> 'dynamic_wrapped_array_t< regvar_t >'
 |      __get_regvars__(self) -> dyn_regvar_array
 |  
 |  __get_tails__(self, *args) -> 'dynamic_wrapped_array_t< range_t >'
 |      __get_tails__(self) -> dyn_range_array
 |  
 |  __init__(self, *args)
 |      __init__(self, start=0, end=0, f=0) -> func_t
 |      
 |      @param start: ea_t
 |      @param end: ea_t
 |      @param f: flags_t
 |  
 |  __iter__(self)
 |      Alias for func_item_iterator_t(self).__iter__()
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_t(...)
 |      delete_func_t(self)
 |  
 |  addresses(self)
 |      Alias for func_item_iterator_t(self).addresses()
 |  
 |  analyzed_sp(self, *args) -> 'bool'
 |      analyzed_sp(self) -> bool
 |      Has SP-analysis been performed?
 |  
 |  code_items(self)
 |      Alias for func_item_iterator_t(self).code_items()
 |  
 |  data_items(self)
 |      Alias for func_item_iterator_t(self).data_items()
 |  
 |  does_return(self, *args) -> 'bool'
 |      does_return(self) -> bool
 |      Does function return?
 |  
 |  head_items(self)
 |      Alias for func_item_iterator_t(self).head_items()
 |  
 |  is_far(self, *args) -> 'bool'
 |      is_far(self) -> bool
 |      Is a far function?
 |  
 |  need_prolog_analysis(self, *args) -> 'bool'
 |      need_prolog_analysis(self) -> bool
 |      Needs prolog analysis?
 |  
 |  not_tails(self)
 |      Alias for func_item_iterator_t(self).not_tails()
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  argsize
 |      argsize
 |  
 |  color
 |      color
 |  
 |  flags
 |      flags
 |  
 |  fpd
 |      fpd
 |  
 |  frame
 |      frame
 |  
 |  frregs
 |      frregs
 |  
 |  frsize
 |      frsize
 |  
 |  owner
 |      owner
 |  
 |  pntqty
 |      pntqty
 |  
 |  points
 |      __get_points__(self) -> dyn_stkpnt_array
 |  
 |  referers
 |      __get_referers__(self) -> dyn_ea_array
 |  
 |  refqty
 |      refqty
 |  
 |  regargqty
 |      regargqty
 |  
 |  regargs
 |      __get_regargs__(self) -> dyn_regarg_array
 |  
 |  regvarqty
 |      regvarqty
 |  
 |  regvars
 |      __get_regvars__(self) -> dyn_regvar_array
 |  
 |  tailqty
 |      tailqty
 |  
 |  tails
 |      __get_tails__(self) -> dyn_range_array
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function func_t__from_ptrval__ in module ida_funcs:

func_t__from_ptrval__(*args) -> 'func_t *'
    func_t__from_ptrval__(ptrval) -> func_t
    
    @param ptrval: size_t

Help on function func_tail_iterator_set in module ida_funcs:

func_tail_iterator_set(*args) -> 'bool'
    func_tail_iterator_set(fti, pfn, ea) -> bool
    
    @param fti: func_tail_iterator_t *
    @param pfn: func_t *
    @param ea: ea_t

Help on function func_tail_iterator_set_ea in module ida_funcs:

func_tail_iterator_set_ea(*args) -> 'bool'
    func_tail_iterator_set_ea(fti, ea) -> bool
    
    @param fti: func_tail_iterator_t *
    @param ea: ea_t

Help on class func_tail_iterator_t in module ida_funcs:

class func_tail_iterator_t(builtins.object)
 |  Proxy of C++ func_tail_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_tail_iterator_t
 |      __init__(self, _pfn, ea=BADADDR) -> func_tail_iterator_t
 |      
 |      @param _pfn: func_t *
 |      @param ea: ea_t
 |  
 |  __iter__(self)
 |      Provide an iterator on function tails
 |  
 |  __next__(self, *args) -> 'bool'
 |      __next__(self) -> bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_tail_iterator_t(...)
 |      delete_func_tail_iterator_t(self)
 |  
 |  chunk(self, *args) -> 'range_t const &'
 |      chunk(self) -> range_t
 |  
 |  first(self, *args) -> 'bool'
 |      first(self) -> bool
 |  
 |  last(self, *args) -> 'bool'
 |      last(self) -> bool
 |  
 |  main(self, *args) -> 'bool'
 |      main(self) -> bool
 |  
 |  next = __next__(self, *args) -> 'bool'
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, _pfn, ea=BADADDR) -> bool
 |      
 |      @param _pfn: func_t *
 |      @param ea: ea_t
 |  
 |  set_ea(self, *args) -> 'bool'
 |      set_ea(self, ea) -> bool
 |      
 |      @param ea: ea_t
 |  
 |  set_range(self, *args) -> 'bool'
 |      set_range(self, ea1, ea2) -> bool
 |      
 |      @param ea1: ea_t
 |      @param ea2: ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function get_current_idasgn in module ida_funcs:

get_current_idasgn(*args) -> 'int'
    get_current_idasgn() -> int
    Get number of the the current signature.
    
    @return: 0..n-1

Help on function get_fchunk in module ida_funcs:

get_fchunk(*args) -> 'func_t *'
    get_fchunk(ea) -> func_t
    Get pointer to function chunk structure by address.
    
    @param ea: (C++: ea_t) any address in a function chunk
    @return: ptr to a function chunk or nullptr. This function may return a function
             entry as well as a function tail.

Help on function get_fchunk_num in module ida_funcs:

get_fchunk_num(*args) -> 'int'
    get_fchunk_num(ea) -> int
    Get ordinal number of a function chunk in the global list of function chunks.
    
    @param ea: (C++: ea_t) any address in the function chunk
    @return: number of function chunk (0..get_fchunk_qty()-1). -1 means 'no function
             chunk at the specified address'.

Help on function get_fchunk_qty in module ida_funcs:

get_fchunk_qty(*args) -> 'size_t'
    get_fchunk_qty() -> size_t
    Get total number of function chunks in the program.

Help on function get_fchunk_referer in module ida_funcs:

get_fchunk_referer(*args) -> 'ea_t'
    get_fchunk_referer(ea, idx) -> ea_t
    
    @param ea: ea_t
    @param idx: size_t

Help on function get_func in module ida_funcs:

get_func(*args) -> 'func_t *'
    get_func(ea) -> func_t
    Get pointer to function structure by address.
    
    @param ea: (C++: ea_t) any address in a function
    @return: ptr to a function or nullptr. This function returns a function entry
             chunk.

Help on function get_func_bitness in module ida_funcs:

get_func_bitness(*args) -> 'int'
    get_func_bitness(pfn) -> int
    Get function bitness (which is equal to the function segment bitness).
    pfn==nullptr => returns 0
    @retval 0: 16
    @retval 1: 32
    @retval 2: 64
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function get_func_bits in module ida_funcs:

get_func_bits(*args) -> 'int'
    get_func_bits(pfn) -> int
    Get number of bits in the function addressing.
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function get_func_bytes in module ida_funcs:

get_func_bytes(*args) -> 'int'
    get_func_bytes(pfn) -> int
    Get number of bytes in the function addressing.
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function get_func_chunknum in module ida_funcs:

get_func_chunknum(*args) -> 'int'
    get_func_chunknum(pfn, ea) -> int
    Get the containing tail chunk of 'ea'.
    @retval -1: means 'does not contain ea'
    @retval 0: means the 'pfn' itself contains ea
    @retval >0: the number of the containing function tail chunk
    
    @param pfn: (C++: func_t *)
    @param ea: (C++: ea_t)

Help on function get_func_cmt in module ida_funcs:

get_func_cmt(*args) -> 'qstring *'
    get_func_cmt(pfn, repeatable) -> str
    Get function comment.
    
    @param pfn: (C++: const func_t *) ptr to function structure
    @param repeatable: (C++: bool) get repeatable comment?
    @return: size of comment or -1 In fact this function works with function chunks
             too.

Help on function get_func_name in module ida_funcs:

get_func_name(*args) -> 'qstring *'
    get_func_name(ea) -> str
    Get function name.
    
    @param ea: (C++: ea_t) any address in the function
    @return: length of the function name

Help on function get_func_num in module ida_funcs:

get_func_num(*args) -> 'int'
    get_func_num(ea) -> int
    Get ordinal number of a function.
    
    @param ea: (C++: ea_t) any address in the function
    @return: number of function (0..get_func_qty()-1). -1 means 'no function at the
             specified address'.

Help on function get_func_qty in module ida_funcs:

get_func_qty(*args) -> 'size_t'
    get_func_qty() -> size_t
    Get total number of functions in the program.

Help on function get_func_ranges in module ida_funcs:

get_func_ranges(*args) -> 'ea_t'
    get_func_ranges(ranges, pfn) -> ea_t
    Get function ranges.
    
    @param ranges: (C++: rangeset_t *) buffer to receive the range info
    @param pfn: (C++: func_t *) ptr to function structure
    @return: end address of the last function range (BADADDR-error)

Help on function get_idasgn_desc in module ida_funcs:

get_idasgn_desc(*args) -> 'PyObject *'
    get_idasgn_desc(n) -> (str, str)
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries)
    
    See also: get_idasgn_desc_with_matches
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs)

Help on function get_idasgn_desc_with_matches in module ida_funcs:

get_idasgn_desc_with_matches(*args) -> 'PyObject *'
    get_idasgn_desc_with_matches(n) -> (str, str, int)
    Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries, number of matches)
    
    @param n: number of signature in the list (0..get_idasgn_qty()-1)
    @return: None on failure or tuple(signame, optlibs, nmatches)

Help on function get_idasgn_qty in module ida_funcs:

get_idasgn_qty(*args) -> 'int'
    get_idasgn_qty() -> int
    Get number of signatures in the list of planned and applied signatures.
    
    @return: 0..n

Help on function get_idasgn_title in module ida_funcs:

get_idasgn_title(*args) -> 'qstring *'
    get_idasgn_title(name) -> str
    Get full description of the signature by its short name.
    
    @param name: (C++: const char *) short name of a signature
    @return: size of signature description or -1

Help on function get_next_fchunk in module ida_funcs:

get_next_fchunk(*args) -> 'func_t *'
    get_next_fchunk(ea) -> func_t
    Get pointer to the next function chunk in the global list.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function chunk or nullptr if next function chunk doesn't exist

Help on function get_next_func in module ida_funcs:

get_next_func(*args) -> 'func_t *'
    get_next_func(ea) -> func_t
    Get pointer to the next function.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function or nullptr if next function doesn't exist

Help on function get_next_func_addr in module ida_funcs:

get_next_func_addr(*args) -> 'ea_t'
    get_next_func_addr(pfn, ea) -> ea_t
    
    @param pfn: func_t *
    @param ea: ea_t

Help on function get_prev_fchunk in module ida_funcs:

get_prev_fchunk(*args) -> 'func_t *'
    get_prev_fchunk(ea) -> func_t
    Get pointer to the previous function chunk in the global list.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function chunk or nullptr if previous function chunk doesn't
             exist

Help on function get_prev_func in module ida_funcs:

get_prev_func(*args) -> 'func_t *'
    get_prev_func(ea) -> func_t
    Get pointer to the previous function.
    
    @param ea: (C++: ea_t) any address in the program
    @return: ptr to function or nullptr if previous function doesn't exist

Help on function get_prev_func_addr in module ida_funcs:

get_prev_func_addr(*args) -> 'ea_t'
    get_prev_func_addr(pfn, ea) -> ea_t
    
    @param pfn: func_t *
    @param ea: ea_t

Help on function getn_fchunk in module ida_funcs:

getn_fchunk(*args) -> 'func_t *'
    getn_fchunk(n) -> func_t
    Get pointer to function chunk structure by number.
    
    @param n: (C++: int) number of function chunk, is in range 0..get_fchunk_qty()-1
    @return: ptr to a function chunk or nullptr. This function may return a function
             entry as well as a function tail.

Help on function getn_func in module ida_funcs:

getn_func(*args) -> 'func_t *'
    getn_func(n) -> func_t
    Get pointer to function structure by number.
    
    @param n: (C++: size_t) number of function, is in range 0..get_func_qty()-1
    @return: ptr to a function or nullptr. This function returns a function entry
             chunk.

Help on function is_finally_visible_func in module ida_funcs:

is_finally_visible_func(*args) -> 'bool'
    is_finally_visible_func(pfn) -> bool
    Is the function visible (event after considering SCF_SHHID_FUNC)?
    
    @param pfn: (C++: func_t *)

Help on function is_func_entry in module ida_funcs:

is_func_entry(*args) -> 'bool'
    is_func_entry(pfn) -> bool
    Does function describe a function entry chunk?
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function is_func_locked in module ida_funcs:

is_func_locked(*args) -> 'bool'
    is_func_locked(pfn) -> bool
    Is the function pointer locked?
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function is_func_tail in module ida_funcs:

is_func_tail(*args) -> 'bool'
    is_func_tail(pfn) -> bool
    Does function describe a function tail chunk?
    
    @param pfn: (C++: const func_t *) func_t const *

Help on function is_same_func in module ida_funcs:

is_same_func(*args) -> 'bool'
    is_same_func(ea1, ea2) -> bool
    Do two addresses belong to the same function?
    
    @param ea1: (C++: ea_t)
    @param ea2: (C++: ea_t)

Help on function is_visible_func in module ida_funcs:

is_visible_func(*args) -> 'bool'
    is_visible_func(pfn) -> bool
    Is the function visible (not hidden)?
    
    @param pfn: (C++: func_t *)

Help on class lock_func in module ida_funcs:

class lock_func(builtins.object)
 |  Proxy of C++ lock_func class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _pfn) -> lock_func
 |      
 |      @param _pfn: func_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lock_func(...)
 |      delete_lock_func(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function lock_func_range in module ida_funcs:

lock_func_range(*args) -> 'void'
    lock_func_range(pfn, lock)
    Lock function pointer Locked pointers are guaranteed to remain valid until they
    are unlocked. Ranges with locked pointers cannot be deleted or moved.
    
    @param pfn: (C++: const func_t *) func_t const *
    @param lock: (C++: bool)

Help on function plan_to_apply_idasgn in module ida_funcs:

plan_to_apply_idasgn(*args) -> 'int'
    plan_to_apply_idasgn(fname) -> int
    Add a signature file to the list of planned signature files.
    
    @param fname: (C++: const char *) file name. should not contain directory part.
    @return: 0 if failed, otherwise number of planned (and applied) signatures

Help on function read_regargs in module ida_funcs:

read_regargs(*args) -> 'void'
    read_regargs(pfn)
    
    @param pfn: func_t *

Help on function reanalyze_function in module ida_funcs:

reanalyze_function(*args) -> 'void'
    reanalyze_function(pfn, ea1=0, ea2=BADADDR, analyze_parents=False)
    Reanalyze a function. This function plans to analyzes all chunks of the given
    function. Optional parameters (ea1, ea2) may be used to narrow the analyzed
    range.
    
    @param pfn: (C++: func_t *) pointer to a function
    @param ea1: (C++: ea_t) start of the range to analyze
    @param ea2: (C++: ea_t) end of range to analyze
    @param analyze_parents: (C++: bool) meaningful only if pfn points to a function tail. if
                            true, all tail parents will be reanalyzed. if false,
                            only the given tail will be reanalyzed.

Help on function reanalyze_noret_flag in module ida_funcs:

reanalyze_noret_flag(*args) -> 'bool'
    reanalyze_noret_flag(ea) -> bool
    Plan to reanalyze noret flag. This function does not remove FUNC_NORET if it is
    already present. It just plans to reanalysis.
    
    @param ea: (C++: ea_t)

Help on class regarg_t in module ida_funcs:

class regarg_t(builtins.object)
 |  Proxy of C++ regarg_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regarg_t
 |      __init__(self, r) -> regarg_t
 |      
 |      @param r: regarg_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regarg_t(...)
 |      delete_regarg_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: regarg_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  reg
 |      reg
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type

Help on function remove_func_tail in module ida_funcs:

remove_func_tail(*args) -> 'bool'
    remove_func_tail(pfn, tail_ea) -> bool
    Remove a function tail. If the tail belongs only to one function, it will be
    completely removed. Otherwise if the function was the tail owner, the first
    function using this tail becomes the owner of the tail.
    
    @param pfn: (C++: func_t *) pointer to the function
    @param tail_ea: (C++: ea_t) any address inside the tail to remove

Help on function set_func_cmt in module ida_funcs:

set_func_cmt(*args) -> 'bool'
    set_func_cmt(pfn, cmt, repeatable) -> bool
    Set function comment. This function works with function chunks too.
    
    @param pfn: (C++: const func_t *) ptr to function structure
    @param cmt: (C++: const char *) comment string, may be multiline (with '
    '). Use empty str ("") to delete comment
    @param repeatable: (C++: bool) set repeatable comment?

Help on function set_func_end in module ida_funcs:

set_func_end(*args) -> 'bool'
    set_func_end(ea, newend) -> bool
    Move function chunk end address.
    
    @param ea: (C++: ea_t) any address in the function
    @param newend: (C++: ea_t) new end address of the function
    @return: success

Help on function set_func_name_if_jumpfunc in module ida_funcs:

set_func_name_if_jumpfunc(*args) -> 'int'
    set_func_name_if_jumpfunc(pfn, oldname) -> int
    Give a meaningful name to function if it consists of only 'jump' instruction.
    
    @param pfn: (C++: func_t *) pointer to function (may be nullptr)
    @param oldname: (C++: const char *) old name of function. if old name was in "j_..." form, then we
                    may discard it and set a new name. if oldname is not known, you
                    may pass nullptr.
    @return: success

Help on function set_func_start in module ida_funcs:

set_func_start(*args) -> 'int'
    set_func_start(ea, newstart) -> int
    Move function chunk start address.
    
    @param ea: (C++: ea_t) any address in the function
    @param newstart: (C++: ea_t) new end address of the function
    @return: Function move result codes

Help on function set_noret_insn in module ida_funcs:

set_noret_insn(*args) -> 'bool'
    set_noret_insn(insn_ea, noret) -> bool
    Signal a non-returning instruction. This function can be used by the processor
    module to tell the kernel about non-returning instructions (like call exit). The
    kernel will perform the global function analysis and find out if the function
    returns at all. This analysis will be done at the first call to
    func_does_return()
    
    @param insn_ea: (C++: ea_t)
    @param noret: (C++: bool)
    @return: true if the instruction 'noret' flag has been changed

Help on function set_tail_owner in module ida_funcs:

set_tail_owner(*args) -> 'bool'
    set_tail_owner(fnt, new_owner) -> bool
    Set a new owner of a function tail. The new owner function must be already
    referring to the tail (after append_func_tail).
    
    @param fnt: (C++: func_t *) pointer to the function tail
    @param new_owner: (C++: ea_t) the entry point of the new owner function

Help on function set_visible_func in module ida_funcs:

set_visible_func(*args) -> 'void'
    set_visible_func(pfn, visible)
    Set visibility of function.
    
    @param pfn: (C++: func_t *)
    @param visible: (C++: bool)

Help on function try_to_add_libfunc in module ida_funcs:

try_to_add_libfunc(*args) -> 'int'
    try_to_add_libfunc(ea) -> int
    Apply the currently loaded signature file to the specified address. If a library
    function is found, then create a function and name it accordingly.
    
    @param ea: (C++: ea_t) any address in the program
    @return: Library function codes

Help on function update_func in module ida_funcs:

update_func(*args) -> 'bool'
    update_func(pfn) -> bool
    Update information about a function in the database (func_t). You must not
    change the function start and end addresses using this function. Use
    set_func_start() and set_func_end() for it.
    
    @param pfn: (C++: func_t *) ptr to function structure
    @return: success

Module "ida_gdl"s docstring:
"""
Low level graph drawing operations."""

Help on class BasicBlock in module ida_gdl:

class BasicBlock(builtins.object)
 |  Basic block class. It is returned by the Flowchart class
 |  
 |  Methods defined here:
 |  
 |  __init__(self, id, bb, fc)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  preds(self)
 |      Iterates the predecessors list
 |  
 |  succs(self)
 |      Iterates the successors list
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class FlowChart in module ida_gdl:

class FlowChart(builtins.object)
 |  Flowchart class used to determine basic blocks.
 |  Check ex_gdl_qflow_chart.py for sample usage.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, index)
 |      Returns a basic block
 |      
 |      @return: BasicBlock
 |  
 |  __init__(self, f=None, bounds=None, flags=0)
 |      Constructor
 |      @param f: A func_t type, use get_func(ea) to get a reference
 |      @param bounds: A tuple of the form (start, end). Used if "f" is None
 |      @param flags: one of the FC_xxxx flags.
 |  
 |  __iter__(self)
 |  
 |  _getitem(self, index)
 |  
 |  refresh(self)
 |      Refreshes the flow chart
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  size

Help on class cancellable_graph_t in module ida_gdl:

class cancellable_graph_t(gdl_graph_t)
 |  Proxy of C++ cancellable_graph_t class.
 |  
 |  Method resolution order:
 |      cancellable_graph_t
 |      gdl_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cancellable_graph_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cancellable_graph_t(...)
 |      delete_cancellable_graph_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cancelled
 |      cancelled
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from gdl_graph_t:
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |      
 |      @param node: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |      
 |      @param node: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from gdl_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function display_gdl in module ida_gdl:

display_gdl(*args) -> 'int'
    display_gdl(fname) -> int
    Display GDL file by calling wingraph32. The exact name of the grapher is taken
    from the configuration file and set up by setup_graph_subsystem(). The path
    should point to a temporary file: when wingraph32 succeeds showing the graph,
    the input file will be deleted.
    
    @param fname: (C++: const char *) char const *
    @return: error code from os, 0 if ok

Help on class gdl_graph_t in module ida_gdl:

class gdl_graph_t(builtins.object)
 |  Proxy of C++ gdl_graph_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> gdl_graph_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_gdl_graph_t(...)
 |      delete_gdl_graph_t(self)
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |      
 |      @param node: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |      
 |      @param node: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function gen_complex_call_chart in module ida_gdl:

gen_complex_call_chart(*args) -> 'bool'
    gen_complex_call_chart(filename, wait, title, ea1, ea2, flags, recursion_depth=-1) -> bool
    Build and display a complex xref graph.
    
    @param filename: (C++: const char *) output file name. the file extension is not used. maybe
                     nullptr.
    @param wait: (C++: const char *) message to display during graph building
    @param title: (C++: const char *) graph title
    @param ea1: (C++: ea_t) ,ea2: address range
    @param flags: (C++: int) combination of Call chart building flags and Flow graph building
                  flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is
                  specified, the function will return false.
    @param flags: (C++: int) combination of Call chart building flags and Flow graph building
                  flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is
                  specified, the function will return false.
    @param recursion_depth: (C++: int32) optional limit of recursion
    @return: success. if fails, a warning message is displayed on the screen

Help on function gen_flow_graph in module ida_gdl:

gen_flow_graph(*args) -> 'bool'
    gen_flow_graph(filename, title, pfn, ea1, ea2, gflags) -> bool
    Build and display a flow graph.
    
    @param filename: (C++: const char *) output file name. the file extension is not used. maybe
                     nullptr.
    @param title: (C++: const char *) graph title
    @param pfn: (C++: func_t *) function to graph
    @param ea1: (C++: ea_t) ,ea2: if pfn == nullptr, then the address range
    @param gflags: (C++: int) combination of Flow graph building flags. if none of
                   CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the
                   function will return false
    @param gflags: (C++: int) combination of Flow graph building flags. if none of
                   CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the
                   function will return false
    @return: success. if fails, a warning message is displayed on the screen

Help on function gen_gdl in module ida_gdl:

gen_gdl(*args) -> 'void'
    gen_gdl(g, fname)
    Create GDL file for graph.
    
    @param g: (C++: const gdl_graph_t *) gdl_graph_t const *
    @param fname: (C++: const char *) char const *

Help on function gen_simple_call_chart in module ida_gdl:

gen_simple_call_chart(*args) -> 'bool'
    gen_simple_call_chart(filename, wait, title, gflags) -> bool
    Build and display a simple function call graph.
    
    @param filename: (C++: const char *) output file name. the file extension is not used. maybe
                     nullptr.
    @param wait: (C++: const char *) message to display during graph building
    @param title: (C++: const char *) graph title
    @param gflags: (C++: int) combination of CHART_NOLIBFUNCS and Flow graph building flags. if
                   none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is
                   specified, the function will return false.
    @return: success. if fails, a warning message is displayed on the screen

Help on function is_noret_block in module ida_gdl:

is_noret_block(*args) -> 'bool'
    is_noret_block(btype) -> bool
    Does this block never return?
    
    @param btype: (C++: fc_block_type_t) enum fc_block_type_t

Help on function is_ret_block in module ida_gdl:

is_ret_block(*args) -> 'bool'
    is_ret_block(btype) -> bool
    Does this block return?
    
    @param btype: (C++: fc_block_type_t) enum fc_block_type_t

Help on class node_iterator in module ida_gdl:

class node_iterator(builtins.object)
 |  Proxy of C++ node_iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, n) -> bool
 |      
 |      @param n: node_iterator const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _g, n) -> node_iterator
 |      
 |      @param _g: gdl_graph_t const *
 |      @param n: int
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, n) -> bool
 |      
 |      @param n: node_iterator const &
 |  
 |  __ref__(self, *args) -> 'int'
 |      __ref__(self) -> int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_node_iterator(...)
 |      delete_node_iterator(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qbasic_block_t in module ida_gdl:

class qbasic_block_t(ida_range.range_t)
 |  Proxy of C++ qbasic_block_t class.
 |  
 |  Method resolution order:
 |      qbasic_block_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qbasic_block_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qbasic_block_t(...)
 |      delete_qbasic_block_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on class qflow_chart_t in module ida_gdl:

class qflow_chart_t(cancellable_graph_t)
 |  Proxy of C++ qflow_chart_t class.
 |  
 |  Method resolution order:
 |      qflow_chart_t
 |      cancellable_graph_t
 |      gdl_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'qbasic_block_t *'
 |      __getitem__(self, n) -> qbasic_block_t
 |      
 |      @param n: int
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qflow_chart_t
 |      __init__(self, _title, _pfn, _ea1, _ea2, _flags) -> qflow_chart_t
 |      
 |      @param _title: char const *
 |      @param _pfn: func_t *
 |      @param _ea1: ea_t
 |      @param _ea2: ea_t
 |      @param _flags: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qflow_chart_t(...)
 |      delete_qflow_chart_t(self)
 |  
 |  append_to_flowchart(self, *args) -> 'void'
 |      append_to_flowchart(self, ea1, ea2)
 |      
 |      @param ea1: ea_t
 |      @param ea2: ea_t
 |  
 |  calc_block_type(self, *args) -> 'fc_block_type_t'
 |      calc_block_type(self, blknum) -> fc_block_type_t
 |      
 |      @param blknum: size_t
 |  
 |  create(self, *args) -> 'void'
 |      create(self, _title, _pfn, _ea1, _ea2, _flags)
 |      
 |      @param _title: char const *
 |      @param _pfn: func_t *
 |      @param _ea1: ea_t
 |      @param _ea2: ea_t
 |      @param _flags: int
 |      
 |      create(self, _title, ranges, _flags)
 |      
 |      @param _title: char const *
 |      @param ranges: rangevec_t const &
 |      @param _flags: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  is_noret_block(self, *args) -> 'bool'
 |      is_noret_block(self, blknum) -> bool
 |      
 |      @param blknum: size_t
 |  
 |  is_ret_block(self, *args) -> 'bool'
 |      is_ret_block(self, blknum) -> bool
 |      
 |      @param blknum: size_t
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |      
 |      @param node: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |      
 |      @param node: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  print_names(self, *args) -> 'bool'
 |      print_names(self) -> bool
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  refresh(self, *args) -> 'void'
 |      refresh(self)
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bounds
 |      bounds
 |  
 |  flags
 |      flags
 |  
 |  nproper
 |      nproper
 |  
 |  pfn
 |      pfn
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      title
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cancellable_graph_t:
 |  
 |  __disown__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cancellable_graph_t:
 |  
 |  cancelled
 |      cancelled
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from gdl_graph_t:
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from gdl_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Module "ida_graph"s docstring:
"""
Graph view management."""

Help on class GraphViewer in module ida_graph:

class GraphViewer(ida_kernwin.CustomIDAMemo)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Method resolution order:
 |      GraphViewer
 |      ida_kernwin.CustomIDAMemo
 |      ida_kernwin.View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  AddCommand(self, title, shortcut)
 |  
 |  AddEdge(self, src_node, dest_node)
 |      Creates an edge between two given node ids
 |  
 |  AddNode(self, obj)
 |      Creates a node associated with the given object and returns the node id
 |  
 |  Clear(self)
 |      Clears all the nodes and edges
 |  
 |  Close(self)
 |      Closes the graph.
 |      It is possible to call Show() again (which will recreate the graph)
 |  
 |  Count(self)
 |      Returns the node count
 |  
 |  OnCommand(self, cmd_id)
 |  
 |  OnPopup(self, widget, popup_handle)
 |  
 |  OnRefresh(self)
 |      Event called when the graph is refreshed or first created.
 |      From this event you are supposed to create nodes and edges.
 |      This callback is mandatory.
 |      
 |      @note: ***It is important to clear previous nodes before adding nodes.***
 |      @return: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
 |  
 |  Select(self, node_id)
 |      Selects a node on the graph
 |  
 |  Show(self)
 |      Shows an existing graph or creates a new one
 |      
 |      @return: Boolean
 |  
 |  __getitem__(self, idx)
 |      Returns a reference to the object associated with this node id
 |  
 |  __init__(self, title, close_open=False)
 |      Constructs the GraphView object.
 |      Please do not remove or rename the private fields
 |      
 |      @param title: The title of the graph window
 |      @param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
 |  
 |  __iter__(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  UI_Hooks_Trampoline = <class 'ida_graph.GraphViewer.UI_Hooks_Trampolin...
 |      Proxy of C++ UI_Hooks class.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_kernwin.CustomIDAMemo:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |      A view is activated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |      Click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |      View closed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |      Cursor position changed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |      Double click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |      A view is deactivated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |      Key down event
 |      
 |      @param view: (TWidget *)
 |      @param key: (int)
 |      @param state: (::view_event_state_t)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |      The location for the view has changed (can be either the place_t, the
 |      renderer_info_t, or both.)
 |      
 |      @param view: (TWidget *)
 |      @param now: (const lochist_entry_t *)
 |      @param was: (const lochist_entry_t *)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |      The mouse moved on the view
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |      The user moved the mouse over (or out of) a node or an edge. This is only
 |      relevant in a graph view.
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |      A view's renderer has changed.
 |      
 |      @param view: (TWidget *)
 |      @param rt: (tcc_renderer_type_t)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from ida_kernwin.CustomIDAMemo:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_kernwin.View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |      A view is being created.
 |      
 |      @param view: (TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_kernwin.View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class TPointDouble in module ida_graph:

class TPointDouble(builtins.object)
 |  Proxy of C++ TPointDouble class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: TPointDouble const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> TPointDouble
 |      __init__(self, a, b) -> TPointDouble
 |      
 |      @param a: double
 |      @param b: double
 |      
 |      __init__(self, r) -> TPointDouble
 |      
 |      @param r: point_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: TPointDouble const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_TPointDouble(...)
 |      delete_TPointDouble(self)
 |  
 |  add(self, *args) -> 'void'
 |      add(self, r)
 |      
 |      @param r: TPointDouble const &
 |  
 |  negate(self, *args) -> 'void'
 |      negate(self)
 |  
 |  sub(self, *args) -> 'void'
 |      sub(self, r)
 |      
 |      @param r: TPointDouble const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  y
 |      y
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class abstract_graph_t in module ida_graph:

class abstract_graph_t(ida_gdl.gdl_graph_t)
 |  Proxy of C++ abstract_graph_t class.
 |  
 |  Method resolution order:
 |      abstract_graph_t
 |      ida_gdl.gdl_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> abstract_graph_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_abstract_graph_t(...)
 |      delete_abstract_graph_t(self)
 |  
 |  create_circle_layout(self, *args) -> 'bool'
 |      create_circle_layout(self, p, radius) -> bool
 |      
 |      @param p: point_t
 |      @param radius: int
 |  
 |  create_tree_layout(self, *args) -> 'bool'
 |      create_tree_layout(self) -> bool
 |  
 |  get_edge(self, *args) -> 'edge_info_t *'
 |      get_edge(self, e) -> edge_info_t
 |      
 |      @param e: edge_t
 |  
 |  grcall(self, *args) -> 'ssize_t'
 |      grcall(self, code) -> ssize_t
 |      
 |      @param code: int
 |  
 |  nrect(self, *args) -> 'rect_t'
 |      nrect(self, n) -> rect_t
 |      
 |      @param n: int
 |  
 |  set_callback(self, *args) -> 'void'
 |      set_callback(self, _callback, _ud)
 |      
 |      @param _callback: hook_cb_t *
 |      @param _ud: void *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  callback_ud
 |      callback_ud
 |  
 |  circle_center
 |      circle_center
 |  
 |  circle_radius
 |      circle_radius
 |  
 |  current_layout
 |      current_layout
 |  
 |  rect_edges_made
 |      rect_edges_made
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      title
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_gdl.gdl_graph_t:
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |      
 |      @param node: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |      
 |      @param node: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_gdl.gdl_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function calc_dist in module ida_graph:

calc_dist(*args) -> 'double'
    calc_dist(p, q) -> double
    Calculate distance between p and q.
    
    @param p: (C++: point_t)
    @param q: (C++: point_t)

Help on function clr_node_info in module ida_graph:

clr_node_info(*args) -> 'void'
    clr_node_info(gid, node, flags)
    Clear node info for the given node.
    
    @param gid: (C++: graph_id_t) id of desired graph
    @param node: (C++: int) node number
    @param flags: (C++: uint32) combination of Node info flags, identifying which fields of
                  node_info_t will be cleared

Help on function create_disasm_graph in module ida_graph:

create_disasm_graph(*args) -> 'mutable_graph_t *'
    create_disasm_graph(ea) -> mutable_graph_t
    Create a graph using an arbitrary set of ranges.
    
    @param ea: ea_t
    
    create_disasm_graph(ranges) -> mutable_graph_t
    
    @param ranges: rangevec_t const &

Help on function create_graph_viewer in module ida_graph:

create_graph_viewer(*args) -> 'graph_viewer_t *'
    create_graph_viewer(title, id, callback, ud, title_height, parent=None) -> graph_viewer_t *
    Create a custom graph viewer.
    
    @param title: (C++: const char *) the widget title
    @param id: (C++: uval_t) graph id
    @param callback: (C++: hook_cb_t *) callback to handle graph notifications (graph_notification_t)
    @param ud: (C++: void *) user data passed to callback
    @param title_height: (C++: int) node title height
    @param parent: (C++: TWidget *) the parent widget of the graph viewer
    @return: new viewer

Help on function create_mutable_graph in module ida_graph:

create_mutable_graph(*args) -> 'mutable_graph_t *'
    create_mutable_graph(id) -> mutable_graph_t
    Create a new empty graph with given id.
    
    @param id: (C++: uval_t)

Help on function create_user_graph_place in module ida_graph:

create_user_graph_place(*args) -> 'user_graph_place_t *'
    create_user_graph_place(node, lnnum) -> user_graph_place_t
    Get a copy of a user_graph_place_t (returns a pointer to static storage)
    
    @param node: (C++: int)
    @param lnnum: (C++: int)

Help on function del_node_info in module ida_graph:

del_node_info(*args) -> 'void'
    del_node_info(gid, node)
    Delete the node_info_t for the given node.
    
    @param gid: (C++: graph_id_t)
    @param node: (C++: int)

Help on function delete_mutable_graph in module ida_graph:

delete_mutable_graph(*args) -> 'void'
    delete_mutable_graph(g)
    Delete graph object.
    @warning: use this only if you are dealing with mutable_graph_t instances that
              have not been used together with a graph_viewer_t. If you have called
              set_viewer_graph() with your graph, the graph's lifecycle will be
              managed by the viewer, and you shouldn't interfere with it
    
    @param g: (C++: mutable_graph_t *)

Help on class edge_info_t in module ida_graph:

class edge_info_t(builtins.object)
 |  Proxy of C++ edge_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_info_t(...)
 |      delete_edge_info_t(self)
 |  
 |  reverse_layout(self, *args) -> 'void'
 |      reverse_layout(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  color
 |      color
 |  
 |  dstoff
 |      dstoff
 |  
 |  layout
 |      layout
 |  
 |  srcoff
 |      srcoff
 |  
 |  thisown
 |      The membership flag
 |  
 |  width
 |      width

Help on class edge_infos_wrapper_t in module ida_graph:

class edge_infos_wrapper_t(builtins.object)
 |  Proxy of C++ edge_infos_wrapper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ptr
 |      ptr
 |  
 |  thisown
 |      The membership flag

Help on class edge_layout_point_t in module ida_graph:

class edge_layout_point_t(builtins.object)
 |  Proxy of C++ edge_layout_point_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: edge_layout_point_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_layout_point_t
 |      __init__(self, _e, _pidx) -> edge_layout_point_t
 |      
 |      @param _e: edge_t const &
 |      @param _pidx: int
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: edge_layout_point_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_layout_point_t(...)
 |      delete_edge_layout_point_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: edge_layout_point_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      e
 |  
 |  pidx
 |      pidx
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class edge_segment_t in module ida_graph:

class edge_segment_t(builtins.object)
 |  Proxy of C++ edge_segment_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_segment_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: edge_segment_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_segment_t(...)
 |      delete_edge_segment_t(self)
 |  
 |  length(self, *args) -> 'size_t'
 |      length(self) -> size_t
 |  
 |  toright(self, *args) -> 'bool'
 |      toright(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  e
 |      e
 |  
 |  nseg
 |      nseg
 |  
 |  thisown
 |      The membership flag
 |  
 |  x0
 |      x0
 |  
 |  x1
 |      x1

Help on class edge_t in module ida_graph:

class edge_t(builtins.object)
 |  Proxy of C++ edge_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, y) -> bool
 |      
 |      @param y: edge_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> edge_t
 |      __init__(self, x, y) -> edge_t
 |      
 |      @param x: int
 |      @param y: int
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, y) -> bool
 |      
 |      @param y: edge_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, y) -> bool
 |      
 |      @param y: edge_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_edge_t(...)
 |      delete_edge_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dst
 |      dst
 |  
 |  src
 |      src
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function get_graph_viewer in module ida_graph:

get_graph_viewer(*args) -> 'graph_viewer_t *'
    get_graph_viewer(parent) -> graph_viewer_t *
    Get custom graph viewer for given form.
    
    @param parent: (C++: TWidget *)

Help on function get_node_info in module ida_graph:

get_node_info(*args) -> 'bool'
    get_node_info(out, gid, node) -> bool
    Get node info.
    
    @param out: (C++: node_info_t *) result
    @param gid: (C++: graph_id_t) id of desired graph
    @param node: (C++: int) node number
    @return: success

Help on function get_viewer_graph in module ida_graph:

get_viewer_graph(*args) -> 'mutable_graph_t *'
    get_viewer_graph(gv) -> mutable_graph_t
    Get graph object for given custom graph viewer.
    
    @param gv: (C++: graph_viewer_t *)

Help on class graph_item_t in module ida_graph:

class graph_item_t(builtins.object)
 |  Proxy of C++ graph_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_item_t(...)
 |      delete_graph_item_t(self)
 |  
 |  is_edge(self, *args) -> 'bool'
 |      is_edge(self) -> bool
 |  
 |  is_node(self, *args) -> 'bool'
 |      is_node(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  b
 |      b
 |  
 |  e
 |      e
 |  
 |  elp
 |      elp
 |  
 |  n
 |      n
 |  
 |  p
 |      p
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type

Help on class graph_node_visitor_t in module ida_graph:

class graph_node_visitor_t(builtins.object)
 |  Proxy of C++ graph_node_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_node_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_node_visitor_t(...)
 |      delete_graph_node_visitor_t(self)
 |  
 |  is_forbidden_edge(self, *args) -> 'bool'
 |      is_forbidden_edge(self, arg0, arg1) -> bool
 |      Should the edge between 'n' and 'm' be ignored?
 |      
 |      @param arg0: int
 |      @param arg1: int
 |  
 |  is_visited(self, *args) -> 'bool'
 |      is_visited(self, n) -> bool
 |      Have we already visited the given node?
 |      
 |      @param n: (C++: int)
 |  
 |  reinit(self, *args) -> 'void'
 |      reinit(self)
 |      Reset visited nodes.
 |  
 |  set_visited(self, *args) -> 'void'
 |      set_visited(self, n)
 |      Mark node as visited.
 |      
 |      @param n: (C++: int)
 |  
 |  visit_node(self, *args) -> 'int'
 |      visit_node(self, arg0) -> int
 |      Implements action to take when a node is visited.
 |      
 |      @param arg0: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class graph_path_visitor_t in module ida_graph:

class graph_path_visitor_t(builtins.object)
 |  Proxy of C++ graph_path_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_path_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_path_visitor_t(...)
 |      delete_graph_path_visitor_t(self)
 |  
 |  walk_backward(self, *args) -> 'int'
 |      walk_backward(self, arg0) -> int
 |      
 |      @param arg0: int
 |  
 |  walk_forward(self, *args) -> 'int'
 |      walk_forward(self, arg0) -> int
 |      
 |      @param arg0: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  path
 |      path
 |  
 |  prune
 |      prune
 |  
 |  thisown
 |      The membership flag

Help on class graph_visitor_t in module ida_graph:

class graph_visitor_t(builtins.object)
 |  Proxy of C++ graph_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_visitor_t(...)
 |      delete_graph_visitor_t(self)
 |  
 |  visit_edge(self, *args) -> 'int'
 |      visit_edge(self, arg2, arg3) -> int
 |      
 |      @param arg2: edge_t
 |      @param arg3: edge_info_t *
 |  
 |  visit_node(self, *args) -> 'int'
 |      visit_node(self, arg2, arg3) -> int
 |      
 |      @param arg2: int
 |      @param arg3: rect_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class group_crinfo_t in module ida_graph:

class group_crinfo_t(builtins.object)
 |  Proxy of C++ group_crinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> group_crinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_group_crinfo_t(...)
 |      delete_group_crinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nodes
 |      nodes
 |  
 |  text
 |      text
 |  
 |  thisown
 |      The membership flag

Help on class interval_t in module ida_graph:

class interval_t(builtins.object)
 |  Proxy of C++ interval_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: interval_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> interval_t
 |      __init__(self, y0, y1) -> interval_t
 |      
 |      @param y0: int
 |      @param y1: int
 |      
 |      __init__(self, s) -> interval_t
 |      
 |      @param s: edge_segment_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: interval_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_interval_t(...)
 |      delete_interval_t(self)
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, x) -> bool
 |      
 |      @param x: int
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      
 |      @param r: interval_t const &
 |  
 |  length(self, *args) -> 'int'
 |      length(self) -> int
 |  
 |  make_union(self, *args) -> 'void'
 |      make_union(self, r)
 |      
 |      @param r: interval_t const &
 |  
 |  move_by(self, *args) -> 'void'
 |      move_by(self, shift)
 |      
 |      @param shift: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x0
 |      x0
 |  
 |  x1
 |      x1
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mutable_graph_t in module ida_graph:

class mutable_graph_t(abstract_graph_t)
 |  Proxy of C++ mutable_graph_t class.
 |  
 |  Method resolution order:
 |      mutable_graph_t
 |      abstract_graph_t
 |      ida_gdl.gdl_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> abstract_graph_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mutable_graph_t(...)
 |      delete_mutable_graph_t(self)
 |  
 |  add_edge(self, *args) -> 'bool'
 |      add_edge(self, i, j, ei) -> bool
 |      
 |      @param i: int
 |      @param j: int
 |      @param ei: edge_info_t const *
 |  
 |  add_node(self, *args) -> 'int'
 |      add_node(self, r) -> int
 |      Add a node, possibly with a specific geometry
 |      
 |      @param r: (C++: const rect_t *) the node geometry (can be nullptr)
 |      @return: the new node
 |  
 |  calc_group_ea(self, *args) -> 'ea_t'
 |      calc_group_ea(self, arg2) -> ea_t
 |      
 |      @param arg2: intvec_t const &
 |  
 |  change_group_visibility(self, *args) -> 'bool'
 |      change_group_visibility(self, group, expand) -> bool
 |      Expand/collapse a group node
 |      
 |      @param group: (C++: int) the group node
 |      @param expand: (C++: bool) whether to expand or collapse
 |      @return: success
 |  
 |  create_digraph_layout(self, *args) -> 'bool'
 |      create_digraph_layout(self) -> bool
 |  
 |  create_group(self, *args) -> 'int'
 |      create_group(self, nodes) -> int
 |      Create a new group node, that will contain all the nodes in 'nodes'.
 |      
 |      @param nodes: (C++: const intvec_t &) the nodes that will be part of the group
 |      @return: the group node, or -1 in case of error
 |  
 |  del_custom_layout(self, *args) -> 'void'
 |      del_custom_layout(self)
 |  
 |  del_edge(self, *args) -> 'bool'
 |      del_edge(self, i, j) -> bool
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  del_node(self, *args) -> 'ssize_t'
 |      del_node(self, n) -> ssize_t
 |      Delete a node
 |      
 |      @param n: (C++: int) the node to delete
 |      @return: the number of deleted edges
 |  
 |  delete_group(self, *args) -> 'bool'
 |      delete_group(self, group) -> bool
 |      Delete a group node.
 |      
 |      This deletes the group node only; it does not delete nodes that are part of the
 |      group.
 |      
 |      @param group: (C++: int) the group node
 |      @return: success
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the graph (visually) empty?
 |      
 |      @return: true if there are no visible nodes
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      Is the node visible?
 |      
 |      @param node: (C++: int) the node number
 |      @return: success
 |  
 |  get_custom_layout(self, *args) -> 'bool'
 |      get_custom_layout(self) -> bool
 |  
 |  get_first_subgraph_node(self, *args) -> 'int'
 |      get_first_subgraph_node(self, group) -> int
 |      
 |      @param group: int
 |  
 |  get_graph_groups(self, *args) -> 'bool'
 |      get_graph_groups(self) -> bool
 |  
 |  get_next_subgraph_node(self, *args) -> 'int'
 |      get_next_subgraph_node(self, group, current) -> int
 |      
 |      @param group: int
 |      @param current: int
 |  
 |  get_node_group(self, *args) -> 'int'
 |      get_node_group(self, node) -> int
 |      
 |      @param node: int
 |  
 |  get_node_representative(self, *args) -> 'int'
 |      get_node_representative(self, node) -> int
 |      Get the node that currently visually represents 'node'. This will find the
 |      "closest" parent group node that's visible, by attempting to walk up the group
 |      nodes that contain 'node', and will stop when it finds a node that is currently
 |      visible.
 |      
 |      See also get_group_node()
 |      
 |      @param node: (C++: int) the node
 |      @return: the node that represents 'node', or 'node' if it's not part of any
 |               group
 |  
 |  is_collapsed_node(self, *args) -> 'bool'
 |      is_collapsed_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_deleted_node(self, *args) -> 'bool'
 |      is_deleted_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_displayable_node(self, *args) -> 'bool'
 |      is_displayable_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_dot_node(self, *args) -> 'bool'
 |      is_dot_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_group_node(self, *args) -> 'bool'
 |      is_group_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_simple_node(self, *args) -> 'bool'
 |      is_simple_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_subgraph_node(self, *args) -> 'bool'
 |      is_subgraph_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_uncollapsed_node(self, *args) -> 'bool'
 |      is_uncollapsed_node(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  is_user_graph(self, *args) -> 'bool'
 |      is_user_graph(self) -> bool
 |  
 |  is_visible_node(self, *args) -> 'bool'
 |      is_visible_node(self, node) -> bool
 |      Is the node currently visible?
 |      
 |      An invisible node is a node that's part of a group that's currently collapsed.
 |      
 |      @param node: (C++: int) the node
 |      @return: success
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |      Get the number of visible nodes (the list can be retrieved using gdl.hpp's
 |      node_iterator)
 |      
 |      See also size()
 |      
 |      @return: the number of visible nodes
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, b) -> int
 |      
 |      @param b: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, b) -> int
 |      
 |      @param b: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, b, i) -> int
 |      
 |      @param b: int
 |      @param i: int
 |  
 |  predset(self, *args) -> 'intvec_t const &'
 |      predset(self, b) -> intvec_t const &
 |      
 |      @param b: int
 |  
 |  redo_layout(self, *args) -> 'bool'
 |      redo_layout(self) -> bool
 |      Recompute the layout, according to the value of 'current_layout'.
 |      
 |      @return: success
 |  
 |  refresh(self, *args) -> 'bool'
 |      refresh(self) -> bool
 |      Refresh the graph
 |      
 |      A graph needs refreshing when it's "backing data". E.g., if the number (or
 |      contents) of the objects in the above example, change.
 |      
 |      Let's say the user's plugin ends up finding a 5th piece of scattered data. It
 |      should then add it to its internal list of known objects, and tell IDA that the
 |      graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
 |      * discard all its internal rendering information,
 |      * call mutable_graph_t::refresh() on the graph so that the user's plugin has a
 |      chance to "sync" the number of nodes & edges that this graph contains, to the
 |      information that the plugin has collected so far
 |      * re-create internal rendering information, and
 |      * repaint the view
 |      
 |      @return: success
 |  
 |  replace_edge(self, *args) -> 'bool'
 |      replace_edge(self, i, j, x, y) -> bool
 |      
 |      @param i: int
 |      @param j: int
 |      @param x: int
 |      @param y: int
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, n)
 |      Resize the graph to 'n' nodes
 |      
 |      @param n: (C++: int) the new size
 |  
 |  set_custom_layout(self, *args) -> 'void'
 |      set_custom_layout(self)
 |  
 |  set_deleted_node(self, *args) -> 'void'
 |      set_deleted_node(self, node)
 |      
 |      @param node: int
 |  
 |  set_edge(self, *args) -> 'bool'
 |      set_edge(self, e, ei) -> bool
 |      
 |      @param e: edge_t
 |      @param ei: edge_info_t const *
 |  
 |  set_graph_groups(self, *args) -> 'void'
 |      set_graph_groups(self)
 |  
 |  set_node_group(self, *args) -> 'void'
 |      set_node_group(self, node, group)
 |      
 |      @param node: int
 |      @param group: int
 |  
 |  set_nrect(self, *args) -> 'bool'
 |      set_nrect(self, n, r) -> bool
 |      
 |      @param n: int
 |      @param r: rect_t const &
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |      Get the total number of nodes (including group nodes, and including hidden
 |      nodes.)
 |      
 |      See also node_qty()
 |      
 |      @return: the total number of nodes in the graph
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, b, i) -> int
 |      
 |      @param b: int
 |      @param i: int
 |  
 |  succset(self, *args) -> 'intvec_t const &'
 |      succset(self, b) -> intvec_t const &
 |      
 |      @param b: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  belongs
 |      belongs
 |  
 |  edges
 |      edges
 |  
 |  gid
 |      gid
 |  
 |  node_flags
 |      node_flags
 |  
 |  nodes
 |      nodes
 |  
 |  org_preds
 |      org_preds
 |  
 |  org_succs
 |      org_succs
 |  
 |  preds
 |      preds
 |  
 |  succs
 |      succs
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from abstract_graph_t:
 |  
 |  __disown__(self)
 |  
 |  create_circle_layout(self, *args) -> 'bool'
 |      create_circle_layout(self, p, radius) -> bool
 |      
 |      @param p: point_t
 |      @param radius: int
 |  
 |  create_tree_layout(self, *args) -> 'bool'
 |      create_tree_layout(self) -> bool
 |  
 |  get_edge(self, *args) -> 'edge_info_t *'
 |      get_edge(self, e) -> edge_info_t
 |      
 |      @param e: edge_t
 |  
 |  grcall(self, *args) -> 'ssize_t'
 |      grcall(self, code) -> ssize_t
 |      
 |      @param code: int
 |  
 |  nrect(self, *args) -> 'rect_t'
 |      nrect(self, n) -> rect_t
 |      
 |      @param n: int
 |  
 |  set_callback(self, *args) -> 'void'
 |      set_callback(self, _callback, _ud)
 |      
 |      @param _callback: hook_cb_t *
 |      @param _ud: void *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from abstract_graph_t:
 |  
 |  callback_ud
 |      callback_ud
 |  
 |  circle_center
 |      circle_center
 |  
 |  circle_radius
 |      circle_radius
 |  
 |  current_layout
 |      current_layout
 |  
 |  rect_edges_made
 |      rect_edges_made
 |  
 |  title
 |      title
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_gdl.gdl_graph_t:
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_gdl.gdl_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class node_info_t in module ida_graph:

class node_info_t(builtins.object)
 |  Proxy of C++ node_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_node_info_t(...)
 |      delete_node_info_t(self)
 |  
 |  get_flags_for_valid(self, *args) -> 'uint32'
 |      get_flags_for_valid(self) -> uint32
 |      Get combination of Node info flags describing which attributes are valid.
 |  
 |  valid_bg_color(self, *args) -> 'bool'
 |      valid_bg_color(self) -> bool
 |      Has valid bg_color?
 |  
 |  valid_ea(self, *args) -> 'bool'
 |      valid_ea(self) -> bool
 |      Has valid ea?
 |  
 |  valid_flags(self, *args) -> 'bool'
 |      valid_flags(self) -> bool
 |      Has valid flags?
 |  
 |  valid_frame_color(self, *args) -> 'bool'
 |      valid_frame_color(self) -> bool
 |      Has valid frame_color?
 |  
 |  valid_text(self, *args) -> 'bool'
 |      valid_text(self) -> bool
 |      Has non-empty text?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bg_color
 |      bg_color
 |  
 |  ea
 |      ea
 |  
 |  flags
 |      flags
 |  
 |  frame_color
 |      frame_color
 |  
 |  text
 |      text
 |  
 |  thisown
 |      The membership flag

Help on class node_layout_t in module ida_graph:

class node_layout_t(builtins.object)
 |  Proxy of C++ qvector< rect_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< rect_t > const &
 |  
 |  __getitem__(self, *args) -> 'rect_t const &'
 |      __getitem__(self, i) -> rect_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_layout_t
 |      __init__(self, x) -> node_layout_t
 |      
 |      @param x: qvector< rect_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< rect_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: rect_t const &
 |  
 |  __swig_destroy__ = delete_node_layout_t(...)
 |      delete_node_layout_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: rect_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: rect_t const &
 |  
 |  at(self, *args) -> 'rect_t const &'
 |      at(self, _idx) -> rect_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< rect_t >::const_iterator'
 |      begin(self) -> rect_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< rect_t >::const_iterator'
 |      end(self) -> rect_t
 |  
 |  erase(self, *args) -> 'qvector< rect_t >::iterator'
 |      erase(self, it) -> rect_t
 |      
 |      @param it: qvector< rect_t >::iterator
 |      
 |      erase(self, first, last) -> rect_t
 |      
 |      @param first: qvector< rect_t >::iterator
 |      @param last: qvector< rect_t >::iterator
 |  
 |  extract(self, *args) -> 'rect_t *'
 |      extract(self) -> rect_t
 |  
 |  find(self, *args) -> 'qvector< rect_t >::const_iterator'
 |      find(self, x) -> rect_t
 |      
 |      @param x: rect_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=rect_t())
 |      
 |      @param x: rect_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: rect_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: rect_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< rect_t >::iterator'
 |      insert(self, it, x) -> rect_t
 |      
 |      @param it: qvector< rect_t >::iterator
 |      @param x: rect_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'rect_t &'
 |      push_back(self, x)
 |      
 |      @param x: rect_t const &
 |      
 |      push_back(self) -> rect_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: rect_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< rect_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class node_ordering_t in module ida_graph:

class node_ordering_t(builtins.object)
 |  Proxy of C++ node_ordering_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> node_ordering_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_node_ordering_t(...)
 |      delete_node_ordering_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  clr(self, *args) -> 'bool'
 |      clr(self, _node) -> bool
 |      
 |      @param _node: int
 |  
 |  node(self, *args) -> 'int'
 |      node(self, _order) -> int
 |      
 |      @param _order: size_t
 |  
 |  order(self, *args) -> 'int'
 |      order(self, _node) -> int
 |      
 |      @param _node: int
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, n)
 |      
 |      @param n: int
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _node, num)
 |      
 |      @param _node: int
 |      @param num: int
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class point_t in module ida_graph:

class point_t(builtins.object)
 |  Proxy of C++ point_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: point_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> point_t
 |      __init__(self, _x, _y) -> point_t
 |      
 |      @param _x: int
 |      @param _y: int
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: point_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_point_t(...)
 |      delete_point_t(self)
 |  
 |  add(self, *args) -> 'point_t &'
 |      add(self, r) -> point_t
 |      
 |      @param r: point_t const &
 |  
 |  negate(self, *args) -> 'void'
 |      negate(self)
 |  
 |  sub(self, *args) -> 'point_t &'
 |      sub(self, r) -> point_t
 |      
 |      @param r: point_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  y
 |      y
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class pointseq_t in module ida_graph:

class pointseq_t(pointvec_t)
 |  Proxy of C++ pointseq_t class.
 |  
 |  Method resolution order:
 |      pointseq_t
 |      pointvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pointseq_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_pointseq_t(...)
 |      delete_pointseq_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pointvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< point_t > const &
 |  
 |  __getitem__(self, *args) -> 'point_t const &'
 |      __getitem__(self, i) -> point_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< point_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: point_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: point_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: point_t const &
 |  
 |  at(self, *args) -> 'point_t const &'
 |      at(self, _idx) -> point_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< point_t >::const_iterator'
 |      begin(self) -> point_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< point_t >::const_iterator'
 |      end(self) -> point_t
 |  
 |  erase(self, *args) -> 'qvector< point_t >::iterator'
 |      erase(self, it) -> point_t
 |      
 |      @param it: qvector< point_t >::iterator
 |      
 |      erase(self, first, last) -> point_t
 |      
 |      @param first: qvector< point_t >::iterator
 |      @param last: qvector< point_t >::iterator
 |  
 |  extract(self, *args) -> 'point_t *'
 |      extract(self) -> point_t
 |  
 |  find(self, *args) -> 'qvector< point_t >::const_iterator'
 |      find(self, x) -> point_t
 |      
 |      @param x: point_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=point_t())
 |      
 |      @param x: point_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: point_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: point_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< point_t >::iterator'
 |      insert(self, it, x) -> point_t
 |      
 |      @param it: qvector< point_t >::iterator
 |      @param x: point_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'point_t &'
 |      push_back(self, x)
 |      
 |      @param x: point_t const &
 |      
 |      push_back(self) -> point_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: point_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< point_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pointvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pointvec_t:
 |  
 |  __hash__ = None

Help on class pointvec_t in module ida_graph:

class pointvec_t(builtins.object)
 |  Proxy of C++ qvector< point_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< point_t > const &
 |  
 |  __getitem__(self, *args) -> 'point_t const &'
 |      __getitem__(self, i) -> point_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> pointvec_t
 |      __init__(self, x) -> pointvec_t
 |      
 |      @param x: qvector< point_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< point_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: point_t const &
 |  
 |  __swig_destroy__ = delete_pointvec_t(...)
 |      delete_pointvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: point_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: point_t const &
 |  
 |  at(self, *args) -> 'point_t const &'
 |      at(self, _idx) -> point_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< point_t >::const_iterator'
 |      begin(self) -> point_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< point_t >::const_iterator'
 |      end(self) -> point_t
 |  
 |  erase(self, *args) -> 'qvector< point_t >::iterator'
 |      erase(self, it) -> point_t
 |      
 |      @param it: qvector< point_t >::iterator
 |      
 |      erase(self, first, last) -> point_t
 |      
 |      @param first: qvector< point_t >::iterator
 |      @param last: qvector< point_t >::iterator
 |  
 |  extract(self, *args) -> 'point_t *'
 |      extract(self) -> point_t
 |  
 |  find(self, *args) -> 'qvector< point_t >::const_iterator'
 |      find(self, x) -> point_t
 |      
 |      @param x: point_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=point_t())
 |      
 |      @param x: point_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: point_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: point_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< point_t >::iterator'
 |      insert(self, it, x) -> point_t
 |      
 |      @param it: qvector< point_t >::iterator
 |      @param x: point_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'point_t &'
 |      push_back(self, x)
 |      
 |      @param x: point_t const &
 |      
 |      push_back(self) -> point_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: point_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< point_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function pyg_close in module ida_graph:

pyg_close(*args) -> 'void'
    pyg_close(_self)
    
    @param self: PyObject *

Help on function pyg_select_node in module ida_graph:

pyg_select_node(*args) -> 'void'
    pyg_select_node(_self, nid)
    
    @param self: PyObject *
    @param nid: int

Help on function pyg_show in module ida_graph:

pyg_show(*args) -> 'bool'
    pyg_show(_self) -> bool
    
    @param self: PyObject *

Help on class rect_t in module ida_graph:

class rect_t(builtins.object)
 |  Proxy of C++ rect_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: rect_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rect_t
 |      __init__(self, l, t, r, b) -> rect_t
 |      
 |      @param l: int
 |      @param t: int
 |      @param r: int
 |      @param b: int
 |      
 |      __init__(self, p0, p1) -> rect_t
 |      
 |      @param p0: point_t const &
 |      @param p1: point_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: rect_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rect_t(...)
 |      delete_rect_t(self)
 |  
 |  area(self, *args) -> 'int'
 |      area(self) -> int
 |  
 |  bottomright(self, *args) -> 'point_t'
 |      bottomright(self) -> point_t
 |  
 |  center(self, *args) -> 'point_t'
 |      center(self) -> point_t
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, p) -> bool
 |      
 |      @param p: point_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, delta)
 |      
 |      @param delta: int
 |  
 |  height(self, *args) -> 'int'
 |      height(self) -> int
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      
 |      @param r: rect_t const &
 |  
 |  is_intersection_empty(self, *args) -> 'bool'
 |      is_intersection_empty(self, r) -> bool
 |      
 |      @param r: rect_t const &
 |  
 |  make_union(self, *args) -> 'void'
 |      make_union(self, r)
 |      
 |      @param r: rect_t const &
 |  
 |  move_by(self, *args) -> 'void'
 |      move_by(self, p)
 |      
 |      @param p: point_t const &
 |  
 |  move_to(self, *args) -> 'void'
 |      move_to(self, p)
 |      
 |      @param p: point_t const &
 |  
 |  topleft(self, *args) -> 'point_t'
 |      topleft(self) -> point_t
 |  
 |  width(self, *args) -> 'int'
 |      width(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bottom
 |      bottom
 |  
 |  left
 |      left
 |  
 |  right
 |      right
 |  
 |  thisown
 |      The membership flag
 |  
 |  top
 |      top
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function refresh_viewer in module ida_graph:

refresh_viewer(*args) -> 'void'
    refresh_viewer(gv)
    Redraw the graph in the given view.
    
    @param gv: (C++: graph_viewer_t *)

Help on class row_info_t in module ida_graph:

class row_info_t(builtins.object)
 |  Proxy of C++ row_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> row_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_row_info_t(...)
 |      delete_row_info_t(self)
 |  
 |  height(self, *args) -> 'int'
 |      height(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bottom
 |      bottom
 |  
 |  nodes
 |      nodes
 |  
 |  thisown
 |      The membership flag
 |  
 |  top
 |      top

Help on class screen_graph_selection_base_t in module ida_graph:

class screen_graph_selection_base_t(builtins.object)
 |  Proxy of C++ qvector< selection_item_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< selection_item_t > const &
 |  
 |  __getitem__(self, *args) -> 'selection_item_t const &'
 |      __getitem__(self, i) -> selection_item_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> screen_graph_selection_base_t
 |      __init__(self, x) -> screen_graph_selection_base_t
 |      
 |      @param x: qvector< selection_item_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< selection_item_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: selection_item_t const &
 |  
 |  __swig_destroy__ = delete_screen_graph_selection_base_t(...)
 |      delete_screen_graph_selection_base_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: selection_item_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: selection_item_t const &
 |  
 |  at(self, *args) -> 'selection_item_t const &'
 |      at(self, _idx) -> selection_item_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      begin(self) -> selection_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      end(self) -> selection_item_t
 |  
 |  erase(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      erase(self, it) -> selection_item_t
 |      
 |      @param it: qvector< selection_item_t >::iterator
 |      
 |      erase(self, first, last) -> selection_item_t
 |      
 |      @param first: qvector< selection_item_t >::iterator
 |      @param last: qvector< selection_item_t >::iterator
 |  
 |  extract(self, *args) -> 'selection_item_t *'
 |      extract(self) -> selection_item_t
 |  
 |  find(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      find(self, x) -> selection_item_t
 |      
 |      @param x: selection_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=selection_item_t())
 |      
 |      @param x: selection_item_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: selection_item_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: selection_item_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      insert(self, it, x) -> selection_item_t
 |      
 |      @param it: qvector< selection_item_t >::iterator
 |      @param x: selection_item_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'selection_item_t &'
 |      push_back(self, x)
 |      
 |      @param x: selection_item_t const &
 |      
 |      push_back(self) -> selection_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: selection_item_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< selection_item_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class screen_graph_selection_t in module ida_graph:

class screen_graph_selection_t(screen_graph_selection_base_t)
 |  Proxy of C++ screen_graph_selection_t class.
 |  
 |  Method resolution order:
 |      screen_graph_selection_t
 |      screen_graph_selection_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> screen_graph_selection_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_screen_graph_selection_t(...)
 |      delete_screen_graph_selection_t(self)
 |  
 |  add(self, *args) -> 'void'
 |      add(self, s)
 |      
 |      @param s: screen_graph_selection_t const &
 |  
 |  add_node(self, *args) -> 'void'
 |      add_node(self, node)
 |      
 |      @param node: int
 |  
 |  add_point(self, *args) -> 'void'
 |      add_point(self, e, idx)
 |      
 |      @param e: edge_t
 |      @param idx: int
 |  
 |  del_node(self, *args) -> 'void'
 |      del_node(self, node)
 |      
 |      @param node: int
 |  
 |  del_point(self, *args) -> 'void'
 |      del_point(self, e, idx)
 |      
 |      @param e: edge_t
 |      @param idx: int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, item) -> bool
 |      
 |      @param item: selection_item_t const &
 |  
 |  items_count(self, *args) -> 'size_t'
 |      items_count(self, look_for_nodes) -> size_t
 |      
 |      @param look_for_nodes: bool
 |  
 |  nodes_count(self, *args) -> 'size_t'
 |      nodes_count(self) -> size_t
 |  
 |  points_count(self, *args) -> 'size_t'
 |      points_count(self) -> size_t
 |  
 |  sub(self, *args) -> 'void'
 |      sub(self, s)
 |      
 |      @param s: screen_graph_selection_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from screen_graph_selection_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< selection_item_t > const &
 |  
 |  __getitem__(self, *args) -> 'selection_item_t const &'
 |      __getitem__(self, i) -> selection_item_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< selection_item_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: selection_item_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: selection_item_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: selection_item_t const &
 |  
 |  at(self, *args) -> 'selection_item_t const &'
 |      at(self, _idx) -> selection_item_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      begin(self) -> selection_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      end(self) -> selection_item_t
 |  
 |  erase(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      erase(self, it) -> selection_item_t
 |      
 |      @param it: qvector< selection_item_t >::iterator
 |      
 |      erase(self, first, last) -> selection_item_t
 |      
 |      @param first: qvector< selection_item_t >::iterator
 |      @param last: qvector< selection_item_t >::iterator
 |  
 |  extract(self, *args) -> 'selection_item_t *'
 |      extract(self) -> selection_item_t
 |  
 |  find(self, *args) -> 'qvector< selection_item_t >::const_iterator'
 |      find(self, x) -> selection_item_t
 |      
 |      @param x: selection_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=selection_item_t())
 |      
 |      @param x: selection_item_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: selection_item_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< selection_item_t >::iterator'
 |      insert(self, it, x) -> selection_item_t
 |      
 |      @param it: qvector< selection_item_t >::iterator
 |      @param x: selection_item_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'selection_item_t &'
 |      push_back(self, x)
 |      
 |      @param x: selection_item_t const &
 |      
 |      push_back(self) -> selection_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: selection_item_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< selection_item_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from screen_graph_selection_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from screen_graph_selection_base_t:
 |  
 |  __hash__ = None

Help on class selection_item_t in module ida_graph:

class selection_item_t(builtins.object)
 |  Proxy of C++ selection_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: selection_item_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> selection_item_t
 |      __init__(self, n) -> selection_item_t
 |      
 |      @param n: int
 |      
 |      __init__(self, _elp) -> selection_item_t
 |      
 |      @param _elp: edge_layout_point_t &
 |      
 |      __init__(self, e, idx) -> selection_item_t
 |      
 |      @param e: edge_t
 |      @param idx: int
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: selection_item_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: selection_item_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_selection_item_t(...)
 |      delete_selection_item_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: selection_item_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  elp
 |      elp
 |  
 |  is_node
 |      is_node
 |  
 |  node
 |      node
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function set_node_info in module ida_graph:

set_node_info(*args) -> 'void'
    set_node_info(gid, node, ni, flags)
    Set node info.
    
    @param gid: (C++: graph_id_t) id of desired graph
    @param node: (C++: int) node number
    @param ni: (C++: const node_info_t &) node info to use
    @param flags: (C++: uint32) combination of Node info flags, identifying which fields of 'ni'
                  will be used

Help on function set_viewer_graph in module ida_graph:

set_viewer_graph(*args) -> 'void'
    set_viewer_graph(gv, g)
    Set the underlying graph object for the given viewer.
    
    @param gv: (C++: graph_viewer_t *)
    @param g: (C++: mutable_graph_t *)

Help on class user_graph_place_t in module ida_graph:

class user_graph_place_t(builtins.object)
 |  Proxy of C++ user_graph_place_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_graph_place_t(...)
 |      delete_user_graph_place_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  node
 |      node
 |  
 |  thisown
 |      The membership flag

Help on function viewer_attach_menu_item in module ida_graph:

viewer_attach_menu_item(*args) -> 'bool'
    viewer_attach_menu_item(g, name) -> bool
    Attach a previously-registered action to the view's context menu. See
    kernwin.hpp for how to register actions.
    
    @param g: (C++: graph_viewer_t *) graph viewer
    @param name: (C++: const char *) action name
    @return: success

Help on function viewer_center_on in module ida_graph:

viewer_center_on(*args) -> 'void'
    viewer_center_on(gv, node)
    Center the graph view on the given node.
    
    @param gv: (C++: graph_viewer_t *)
    @param node: (C++: int)

Help on function viewer_create_groups in module ida_graph:

viewer_create_groups(*args) -> 'bool'
    viewer_create_groups(gv, out_group_nodes, gi) -> bool
    This will perform an operation similar to what happens when a user manually
    selects a set of nodes, right-clicks and selects "Create group". This is a
    wrapper around mutable_graph_t::create_group that will, in essence:
    * clone the current graph
    * for each group_crinfo_t, attempt creating group in that new graph
    * if all were successful, animate to that new graph.
    @note: this accepts parameters that allow creating of multiple groups at once;
           which means only one graph animation will be triggered.
    
    @param gv: (C++: graph_viewer_t *)
    @param out_group_nodes: (C++: intvec_t *)
    @param gi: (C++: const groups_crinfos_t &) groups_crinfos_t const &

Help on function viewer_del_node_info in module ida_graph:

viewer_del_node_info(*args) -> 'void'
    viewer_del_node_info(gv, n)
    Delete node info for node in given viewer (see del_node_info())
    
    @param gv: (C++: graph_viewer_t *)
    @param n: (C++: int)

Help on function viewer_delete_groups in module ida_graph:

viewer_delete_groups(*args) -> 'bool'
    viewer_delete_groups(gv, groups, new_current=-1) -> bool
    Wrapper around mutable_graph_t::delete_group. This function will:
    * clone the current graph
    * attempt deleting the groups in that new graph
    * if successful, animate to that new graph.
    
    @param gv: (C++: graph_viewer_t *)
    @param groups: (C++: const intvec_t &) intvec_t const &
    @param new_current: (C++: int)

Help on function viewer_fit_window in module ida_graph:

viewer_fit_window(*args) -> 'void'
    viewer_fit_window(gv)
    Fit graph viewer to its parent form.
    
    @param gv: (C++: graph_viewer_t *)

Help on function viewer_get_curnode in module ida_graph:

viewer_get_curnode(*args) -> 'int'
    viewer_get_curnode(gv) -> int
    Get number of currently selected node (-1 if none)
    
    @param gv: (C++: graph_viewer_t *)

Help on function viewer_get_gli in module ida_graph:

viewer_get_gli(*args) -> 'bool'
    viewer_get_gli(out, gv, flags=0) -> bool
    Get location info for given graph view If flags contains GLICTL_CENTER, then the
    gli that will be retrieved, will be the one at the center of the view. Otherwise
    it will be the top-left.
    
    @param out: (C++: graph_location_info_t *)
    @param gv: (C++: graph_viewer_t *)
    @param flags: (C++: uint32)

Help on function viewer_get_node_info in module ida_graph:

viewer_get_node_info(*args) -> 'bool'
    viewer_get_node_info(gv, out, n) -> bool
    Get node info for node in given viewer (see get_node_info())
    
    @param gv: (C++: graph_viewer_t *)
    @param out: (C++: node_info_t *)
    @param n: (C++: int)

Help on function viewer_get_selection in module ida_graph:

viewer_get_selection(*args) -> 'bool'
    viewer_get_selection(gv, sgs) -> bool
    Get currently selected items for graph viewer.
    
    @param gv: (C++: graph_viewer_t *)
    @param sgs: (C++: screen_graph_selection_t *)

Help on function viewer_set_gli in module ida_graph:

viewer_set_gli(*args) -> 'void'
    viewer_set_gli(gv, gli, flags=0)
    Set location info for given graph view If flags contains GLICTL_CENTER, then the
    gli will be set to be the center of the view. Otherwise it will be the top-left.
    
    @param gv: (C++: graph_viewer_t *)
    @param gli: (C++: const graph_location_info_t *) graph_location_info_t const *
    @param flags: (C++: uint32)

Help on function viewer_set_groups_visibility in module ida_graph:

viewer_set_groups_visibility(*args) -> 'bool'
    viewer_set_groups_visibility(gv, groups, expand, new_current=-1) -> bool
    Wrapper around mutable_graph_t::change_visibility. This function will:
    * clone the current graph
    * attempt changing visibility of the groups in that new graph
    * if successful, animate to that new graph.
    
    @param gv: (C++: graph_viewer_t *)
    @param groups: (C++: const intvec_t &) intvec_t const &
    @param expand: (C++: bool)
    @param new_current: (C++: int)

Help on function viewer_set_node_info in module ida_graph:

viewer_set_node_info(*args) -> 'void'
    viewer_set_node_info(gv, n, ni, flags)
    Set node info for node in given viewer (see set_node_info())
    
    @param gv: (C++: graph_viewer_t *)
    @param n: (C++: int)
    @param ni: (C++: const node_info_t &) node_info_t const &
    @param flags: (C++: uint32)

Help on function viewer_set_titlebar_height in module ida_graph:

viewer_set_titlebar_height(*args) -> 'int'
    viewer_set_titlebar_height(gv, height) -> int
    Set height of node title bars (grcode_set_titlebar_height)
    
    @param gv: (C++: graph_viewer_t *)
    @param height: (C++: int)

Module "ida_hexrays"s docstring:
"""
"""

Help on class DecompilationFailure in module ida_hexrays:

class DecompilationFailure(builtins.Exception)
 |  Raised on a decompilation error.
 |  
 |  The associated hexrays_failure_t object is stored in the
 |  'info' member of this exception.
 |  
 |  Method resolution order:
 |      DecompilationFailure
 |      builtins.Exception
 |      builtins.BaseException
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, info)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.Exception:
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.BaseException:
 |  
 |  __delattr__(self, name, /)
 |      Implement delattr(self, name).
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __reduce__(...)
 |      helper for pickle
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __setattr__(self, name, value, /)
 |      Implement setattr(self, name, value).
 |  
 |  __setstate__(...)
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  with_traceback(...)
 |      Exception.with_traceback(tb) --
 |      set self.__traceback__ to tb and return self.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from builtins.BaseException:
 |  
 |  __cause__
 |      exception cause
 |  
 |  __context__
 |      exception context
 |  
 |  __dict__
 |  
 |  __suppress_context__
 |  
 |  __traceback__
 |  
 |  args

Help on class Hexrays_Hooks in module ida_hexrays:

class Hexrays_Hooks(builtins.object)
 |  Proxy of C++ Hexrays_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> Hexrays_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_Hexrays_Hooks(...)
 |      delete_Hexrays_Hooks(self)
 |  
 |  build_callinfo(self, *args) -> 'PyObject *'
 |      build_callinfo(self, blk, type) -> PyObject *
 |      Analyzing a call instruction.
 |      
 |      @param blk: (mblock_t *) blk->tail is the call.
 |      @param type: (tinfo_t *) buffer for the output type.
 |  
 |  close_pseudocode(self, *args) -> 'int'
 |      close_pseudocode(self, vu) -> int
 |      Pseudocode view is being closed.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  cmt_changed(self, *args) -> 'int'
 |      cmt_changed(self, cfunc, loc, cmt) -> int
 |      Comment got changed.
 |      
 |      @param cfunc: (cfunc_t *)
 |      @param loc: (const treeloc_t *)
 |      @param cmt: (const char *)
 |  
 |  combine(self, *args) -> 'int'
 |      combine(self, blk, insn) -> int
 |      Trying to combine instructions of basic block.
 |      
 |      @param blk: (mblock_t *)
 |      @param insn: (minsn_t *) Should return: 1 if combined the current instruction
 |                   with a preceding one
 |  
 |  create_hint(self, *args) -> 'PyObject *'
 |      create_hint(self, vu) -> PyObject *
 |      Create a hint for the current item.
 |      @see: ui_get_custom_viewer_hint
 |      
 |      @param vu: (vdui_t *)
 |      @retval 0: continue collecting hints with other subscribers
 |      @retval 1: stop collecting hints
 |  
 |  curpos(self, *args) -> 'int'
 |      curpos(self, vu) -> int
 |      Current cursor position has been changed. (for example, by left-clicking or
 |      using keyboard)
 |      
 |      @param vu: (vdui_t *)
 |  
 |  double_click(self, *args) -> 'int'
 |      double_click(self, vu, shift_state) -> int
 |      Mouse double click.
 |      
 |      @param vu: (vdui_t *)
 |      @param shift_state: (int) Should return: 1 if the event has been handled
 |  
 |  flowchart(self, *args) -> 'int'
 |      flowchart(self, fc) -> int
 |      Flowchart has been generated.
 |      
 |      @param fc: (qflow_chart_t *)
 |  
 |  func_printed(self, *args) -> 'int'
 |      func_printed(self, cfunc) -> int
 |      Function text has been generated. Plugins may modify the text in cfunc_t::sv.
 |      The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store
 |      pointers to ctree items.
 |      
 |      @param cfunc: (cfunc_t *)
 |  
 |  glbopt(self, *args) -> 'int'
 |      glbopt(self, mba) -> int
 |      Global optimization has been finished. If microcode is modified, MERR_LOOP must
 |      be returned. It will cause a complete restart of the optimization.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  interr(self, *args) -> 'int'
 |      interr(self, errcode) -> int
 |      Internal error has occurred.
 |      
 |      @param errcode: (int )
 |  
 |  keyboard(self, *args) -> 'int'
 |      keyboard(self, vu, key_code, shift_state) -> int
 |      Keyboard has been hit.
 |      
 |      @param vu: (vdui_t *)
 |      @param key_code: (int) VK_...
 |      @param shift_state: (int) Should return: 1 if the event has been handled
 |  
 |  locopt(self, *args) -> 'int'
 |      locopt(self, mba) -> int
 |      Basic block level optimization has been finished.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  lvar_cmt_changed(self, *args) -> 'int'
 |      lvar_cmt_changed(self, vu, v, cmt) -> int
 |      Local variable comment got changed.
 |      
 |      @param vu: (vdui_t *)
 |      @param v: (lvar_t *)
 |      @param cmt: (const char *) Please note that it is possible to read/write user
 |                  settings for lvars directly from the idb.
 |  
 |  lvar_mapping_changed(self, *args) -> 'int'
 |      lvar_mapping_changed(self, vu, frm, to) -> int
 |      Local variable mapping got changed.
 |      
 |      @param vu: (vdui_t *)
 |      @param from: lvar_t *
 |      @param to: (lvar_t *) Please note that it is possible to read/write user
 |                 settings for lvars directly from the idb.
 |  
 |  lvar_name_changed(self, *args) -> 'int'
 |      lvar_name_changed(self, vu, v, name, is_user_name) -> int
 |      Local variable got renamed.
 |      
 |      @param vu: (vdui_t *)
 |      @param v: (lvar_t *)
 |      @param name: (const char *)
 |      @param is_user_name: (bool) Please note that it is possible to read/write user
 |                           settings for lvars directly from the idb.
 |  
 |  lvar_type_changed(self, *args) -> 'int'
 |      lvar_type_changed(self, vu, v, tinfo) -> int
 |      Local variable type got changed.
 |      
 |      @param vu: (vdui_t *)
 |      @param v: (lvar_t *)
 |      @param tinfo: (const tinfo_t *) Please note that it is possible to read/write
 |                    user settings for lvars directly from the idb.
 |  
 |  maturity(self, *args) -> 'int'
 |      maturity(self, cfunc, new_maturity) -> int
 |      Ctree maturity level is being changed.
 |      
 |      @param cfunc: (cfunc_t *)
 |      @param new_maturity: (ctree_maturity_t)
 |  
 |  microcode(self, *args) -> 'int'
 |      microcode(self, mba) -> int
 |      Microcode has been generated.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  open_pseudocode(self, *args) -> 'int'
 |      open_pseudocode(self, vu) -> int
 |      New pseudocode view has been opened.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  populating_popup(self, *args) -> 'int'
 |      populating_popup(self, widget, popup_handle, vu) -> int
 |      Populating popup menu. We can add menu items now.
 |      
 |      @param widget: (TWidget *)
 |      @param popup_handle: (TPopupMenu *)
 |      @param vu: (vdui_t *)
 |  
 |  prealloc(self, *args) -> 'int'
 |      prealloc(self, mba) -> int
 |      Local variables: preallocation step begins.
 |      
 |      @param mba: (mba_t *) This event may occur several times. Should return: 1 if
 |                  modified microcode Negative values are Microcode error codes error
 |                  codes
 |  
 |  preoptimized(self, *args) -> 'int'
 |      preoptimized(self, mba) -> int
 |      Microcode has been preoptimized.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  print_func(self, *args) -> 'int'
 |      print_func(self, cfunc, vp) -> int
 |      Printing ctree and generating text.
 |      
 |      @param cfunc: (cfunc_t *)
 |      @param vp: (vc_printer_t *) Returns: 1 if text has been generated by the plugin
 |                 It is forbidden to modify ctree at this event.
 |  
 |  prolog(self, *args) -> 'int'
 |      prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
 |      Prolog analysis has been finished.
 |      
 |      @param mba: (mba_t *)
 |      @param fc: (qflow_chart_t *)
 |      @param reachable_blocks: (bitset_t *)
 |      @param decomp_flags: (int) return Microcode error codes code
 |  
 |  refresh_pseudocode(self, *args) -> 'int'
 |      refresh_pseudocode(self, vu) -> int
 |      Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is
 |      forbidden in this event.
 |      
 |      @param vu: (vdui_t *) See also hxe_text_ready, which happens earlier
 |  
 |  resolve_stkaddrs(self, *args) -> 'int'
 |      resolve_stkaddrs(self, mba) -> int
 |      The optimizer is about to resolve stack addresses.
 |      
 |      @param mba: (mba_t *)
 |  
 |  right_click(self, *args) -> 'int'
 |      right_click(self, vu) -> int
 |      Mouse right click. Use hxe_populating_popup instead, in case you want to add
 |      items in the popup menu.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  stkpnts(self, *args) -> 'int'
 |      stkpnts(self, mba, _sps) -> int
 |      SP change points have been calculated.
 |      
 |      @param mba: (mba_t *)
 |      @param stkpnts: (stkpnts_t *) return Microcode error codes code
 |  
 |  structural(self, *args) -> 'int'
 |      structural(self, ct) -> int
 |      Structural analysis has been finished.
 |      
 |      @param ct: (control_graph_t *)
 |  
 |  switch_pseudocode(self, *args) -> 'int'
 |      switch_pseudocode(self, vu) -> int
 |      Existing pseudocode view has been reloaded with a new function. Its text has not
 |      been refreshed yet, only cfunc and mba pointers are ready.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  text_ready(self, *args) -> 'int'
 |      text_ready(self, vu) -> int
 |      Decompiled text is ready.
 |      
 |      @param vu: (vdui_t *) This event can be used to modify the output text (sv).
 |                 Obsolete. Please use hxe_func_printed instead.
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __cbhooks_t in module ida_hexrays:

class __cbhooks_t(Hexrays_Hooks)
 |  Proxy of C++ Hexrays_Hooks class.
 |  
 |  Method resolution order:
 |      __cbhooks_t
 |      Hexrays_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, callback)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> Hexrays_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  close_pseudocode(self, *args)
 |      close_pseudocode(self, vu) -> int
 |      Pseudocode view is being closed.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  create_hint(self, *args)
 |      create_hint(self, vu) -> PyObject *
 |      Create a hint for the current item.
 |      @see: ui_get_custom_viewer_hint
 |      
 |      @param vu: (vdui_t *)
 |      @retval 0: continue collecting hints with other subscribers
 |      @retval 1: stop collecting hints
 |  
 |  curpos(self, *args)
 |      curpos(self, vu) -> int
 |      Current cursor position has been changed. (for example, by left-clicking or
 |      using keyboard)
 |      
 |      @param vu: (vdui_t *)
 |  
 |  double_click(self, *args)
 |      double_click(self, vu, shift_state) -> int
 |      Mouse double click.
 |      
 |      @param vu: (vdui_t *)
 |      @param shift_state: (int) Should return: 1 if the event has been handled
 |  
 |  func_printed(self, *args)
 |      func_printed(self, cfunc) -> int
 |      Function text has been generated. Plugins may modify the text in cfunc_t::sv.
 |      The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store
 |      pointers to ctree items.
 |      
 |      @param cfunc: (cfunc_t *)
 |  
 |  interr(self, *args)
 |      interr(self, errcode) -> int
 |      Internal error has occurred.
 |      
 |      @param errcode: (int )
 |  
 |  keyboard(self, *args)
 |      keyboard(self, vu, key_code, shift_state) -> int
 |      Keyboard has been hit.
 |      
 |      @param vu: (vdui_t *)
 |      @param key_code: (int) VK_...
 |      @param shift_state: (int) Should return: 1 if the event has been handled
 |  
 |  maturity(self, *args)
 |      maturity(self, cfunc, new_maturity) -> int
 |      Ctree maturity level is being changed.
 |      
 |      @param cfunc: (cfunc_t *)
 |      @param new_maturity: (ctree_maturity_t)
 |  
 |  open_pseudocode(self, *args)
 |      open_pseudocode(self, vu) -> int
 |      New pseudocode view has been opened.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  populating_popup(self, *args)
 |      populating_popup(self, widget, popup_handle, vu) -> int
 |      Populating popup menu. We can add menu items now.
 |      
 |      @param widget: (TWidget *)
 |      @param popup_handle: (TPopupMenu *)
 |      @param vu: (vdui_t *)
 |  
 |  print_func(self, *args)
 |      print_func(self, cfunc, vp) -> int
 |      Printing ctree and generating text.
 |      
 |      @param cfunc: (cfunc_t *)
 |      @param vp: (vc_printer_t *) Returns: 1 if text has been generated by the plugin
 |                 It is forbidden to modify ctree at this event.
 |  
 |  refresh_pseudocode(self, *args)
 |      refresh_pseudocode(self, vu) -> int
 |      Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is
 |      forbidden in this event.
 |      
 |      @param vu: (vdui_t *) See also hxe_text_ready, which happens earlier
 |  
 |  right_click(self, *args)
 |      right_click(self, vu) -> int
 |      Mouse right click. Use hxe_populating_popup instead, in case you want to add
 |      items in the popup menu.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  switch_pseudocode(self, *args)
 |      switch_pseudocode(self, vu) -> int
 |      Existing pseudocode view has been reloaded with a new function. Its text has not
 |      been refreshed yet, only cfunc and mba pointers are ready.
 |      
 |      @param vu: (vdui_t *)
 |  
 |  text_ready(self, *args)
 |      text_ready(self, vu) -> int
 |      Decompiled text is ready.
 |      
 |      @param vu: (vdui_t *) This event can be used to modify the output text (sv).
 |                 Obsolete. Please use hxe_func_printed instead.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  instances = []
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from Hexrays_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_Hexrays_Hooks(...)
 |      delete_Hexrays_Hooks(self)
 |  
 |  build_callinfo(self, *args) -> 'PyObject *'
 |      build_callinfo(self, blk, type) -> PyObject *
 |      Analyzing a call instruction.
 |      
 |      @param blk: (mblock_t *) blk->tail is the call.
 |      @param type: (tinfo_t *) buffer for the output type.
 |  
 |  cmt_changed(self, *args) -> 'int'
 |      cmt_changed(self, cfunc, loc, cmt) -> int
 |      Comment got changed.
 |      
 |      @param cfunc: (cfunc_t *)
 |      @param loc: (const treeloc_t *)
 |      @param cmt: (const char *)
 |  
 |  combine(self, *args) -> 'int'
 |      combine(self, blk, insn) -> int
 |      Trying to combine instructions of basic block.
 |      
 |      @param blk: (mblock_t *)
 |      @param insn: (minsn_t *) Should return: 1 if combined the current instruction
 |                   with a preceding one
 |  
 |  flowchart(self, *args) -> 'int'
 |      flowchart(self, fc) -> int
 |      Flowchart has been generated.
 |      
 |      @param fc: (qflow_chart_t *)
 |  
 |  glbopt(self, *args) -> 'int'
 |      glbopt(self, mba) -> int
 |      Global optimization has been finished. If microcode is modified, MERR_LOOP must
 |      be returned. It will cause a complete restart of the optimization.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  locopt(self, *args) -> 'int'
 |      locopt(self, mba) -> int
 |      Basic block level optimization has been finished.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  lvar_cmt_changed(self, *args) -> 'int'
 |      lvar_cmt_changed(self, vu, v, cmt) -> int
 |      Local variable comment got changed.
 |      
 |      @param vu: (vdui_t *)
 |      @param v: (lvar_t *)
 |      @param cmt: (const char *) Please note that it is possible to read/write user
 |                  settings for lvars directly from the idb.
 |  
 |  lvar_mapping_changed(self, *args) -> 'int'
 |      lvar_mapping_changed(self, vu, frm, to) -> int
 |      Local variable mapping got changed.
 |      
 |      @param vu: (vdui_t *)
 |      @param from: lvar_t *
 |      @param to: (lvar_t *) Please note that it is possible to read/write user
 |                 settings for lvars directly from the idb.
 |  
 |  lvar_name_changed(self, *args) -> 'int'
 |      lvar_name_changed(self, vu, v, name, is_user_name) -> int
 |      Local variable got renamed.
 |      
 |      @param vu: (vdui_t *)
 |      @param v: (lvar_t *)
 |      @param name: (const char *)
 |      @param is_user_name: (bool) Please note that it is possible to read/write user
 |                           settings for lvars directly from the idb.
 |  
 |  lvar_type_changed(self, *args) -> 'int'
 |      lvar_type_changed(self, vu, v, tinfo) -> int
 |      Local variable type got changed.
 |      
 |      @param vu: (vdui_t *)
 |      @param v: (lvar_t *)
 |      @param tinfo: (const tinfo_t *) Please note that it is possible to read/write
 |                    user settings for lvars directly from the idb.
 |  
 |  microcode(self, *args) -> 'int'
 |      microcode(self, mba) -> int
 |      Microcode has been generated.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  prealloc(self, *args) -> 'int'
 |      prealloc(self, mba) -> int
 |      Local variables: preallocation step begins.
 |      
 |      @param mba: (mba_t *) This event may occur several times. Should return: 1 if
 |                  modified microcode Negative values are Microcode error codes error
 |                  codes
 |  
 |  preoptimized(self, *args) -> 'int'
 |      preoptimized(self, mba) -> int
 |      Microcode has been preoptimized.
 |      
 |      @param mba: (mba_t *) return Microcode error codes code
 |  
 |  prolog(self, *args) -> 'int'
 |      prolog(self, mba, fc, reachable_blocks, decomp_flags) -> int
 |      Prolog analysis has been finished.
 |      
 |      @param mba: (mba_t *)
 |      @param fc: (qflow_chart_t *)
 |      @param reachable_blocks: (bitset_t *)
 |      @param decomp_flags: (int) return Microcode error codes code
 |  
 |  resolve_stkaddrs(self, *args) -> 'int'
 |      resolve_stkaddrs(self, mba) -> int
 |      The optimizer is about to resolve stack addresses.
 |      
 |      @param mba: (mba_t *)
 |  
 |  stkpnts(self, *args) -> 'int'
 |      stkpnts(self, mba, _sps) -> int
 |      SP change points have been calculated.
 |      
 |      @param mba: (mba_t *)
 |      @param stkpnts: (stkpnts_t *) return Microcode error codes code
 |  
 |  structural(self, *args) -> 'int'
 |      structural(self, ct) -> int
 |      Structural analysis has been finished.
 |      
 |      @param ct: (control_graph_t *)
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from Hexrays_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function _call_with_transferrable_ownership in module ida_hexrays:

_call_with_transferrable_ownership(fun, *args)
    # Object ownership

Help on function _kludge_force_declare_TPopupMenu in module ida_hexrays:

_kludge_force_declare_TPopupMenu(*args) -> 'void'
    _kludge_force_declare_TPopupMenu(arg1)
    
    Parameters
    ----------
    arg1: TPopupMenu const *

Help on function _ll_call_helper in module ida_hexrays:

_ll_call_helper(*args) -> 'cexpr_t *'
    _ll_call_helper(rettype, args, format) -> cexpr_t
    
    Parameters
    ----------
    rettype: tinfo_t const &
    args: carglist_t *
    format: char const *

Help on function _ll_create_helper in module ida_hexrays:

_ll_create_helper(*args) -> 'cexpr_t *'
    _ll_create_helper(standalone, type, format) -> cexpr_t
    
    Parameters
    ----------
    standalone: bool
    type: tinfo_t const &
    format: char const *

Help on function _ll_dereference in module ida_hexrays:

_ll_dereference(*args) -> 'cexpr_t *'
    _ll_dereference(e, ptrsize, is_flt=False) -> cexpr_t
    
    Parameters
    ----------
    e: cexpr_t *
    ptrsize: int
    is_flt: bool

Help on function _ll_lnot in module ida_hexrays:

_ll_lnot(*args) -> 'cexpr_t *'
    _ll_lnot(e) -> cexpr_t
    
    Parameters
    ----------
    e: cexpr_t *

Help on function _ll_make_num in module ida_hexrays:

_ll_make_num(*args) -> 'cexpr_t *'
    _ll_make_num(n, func=None, ea=BADADDR, opnum=0, sign=no_sign, size=0) -> cexpr_t
    
    Parameters
    ----------
    n: uint64
    func: cfunc_t *
    ea: ea_t
    opnum: int
    sign: type_sign_t
    size: int

Help on function _ll_make_ref in module ida_hexrays:

_ll_make_ref(*args) -> 'cexpr_t *'
    _ll_make_ref(e) -> cexpr_t
    
    Parameters
    ----------
    e: cexpr_t *

Help on function _ll_new_block in module ida_hexrays:

_ll_new_block(*args) -> 'cinsn_t *'
    _ll_new_block() -> cinsn_t

Help on function _map_as_dict in module ida_hexrays:

_map_as_dict(maptype, name, keytype, valuetype)
    # dictify all dict-like types

Help on function accepts_small_udts in module ida_hexrays:

accepts_small_udts(*args) -> 'bool'
    accepts_small_udts(op) -> bool
    Is the operator allowed on small structure or union?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function accepts_udts in module ida_hexrays:

accepts_udts(*args) -> 'bool'
    accepts_udts(op) -> bool
    
    @param op: enum ctype_t

Help on function arglocs_overlap in module ida_hexrays:

arglocs_overlap(*args) -> 'bool'
    arglocs_overlap(loc1, w1, loc2, w2) -> bool
    Do two arglocs overlap?
    
    @param loc1: (C++: const vdloc_t &) vdloc_t const &
    @param w1: (C++: size_t)
    @param loc2: (C++: const vdloc_t &) vdloc_t const &
    @param w2: (C++: size_t)

Help on class array_of_bitsets in module ida_hexrays:

class array_of_bitsets(builtins.object)
 |  Proxy of C++ qvector< bitset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< bitset_t > const &
 |  
 |  __getitem__(self, *args) -> 'bitset_t const &'
 |      __getitem__(self, i) -> bitset_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_bitsets
 |      __init__(self, x) -> array_of_bitsets
 |      
 |      @param x: qvector< bitset_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< bitset_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: bitset_t const &
 |  
 |  __swig_destroy__ = delete_array_of_bitsets(...)
 |      delete_array_of_bitsets(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: bitset_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: bitset_t const &
 |  
 |  at(self, *args) -> 'bitset_t const &'
 |      at(self, _idx) -> bitset_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< bitset_t >::const_iterator'
 |      begin(self) -> bitset_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< bitset_t >::const_iterator'
 |      end(self) -> bitset_t
 |  
 |  erase(self, *args) -> 'qvector< bitset_t >::iterator'
 |      erase(self, it) -> bitset_t
 |      
 |      @param it: qvector< bitset_t >::iterator
 |      
 |      erase(self, first, last) -> bitset_t
 |      
 |      @param first: qvector< bitset_t >::iterator
 |      @param last: qvector< bitset_t >::iterator
 |  
 |  extract(self, *args) -> 'bitset_t *'
 |      extract(self) -> bitset_t
 |  
 |  find(self, *args) -> 'qvector< bitset_t >::const_iterator'
 |      find(self, x) -> bitset_t
 |      
 |      @param x: bitset_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=bitset_t())
 |      
 |      @param x: bitset_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: bitset_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: bitset_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< bitset_t >::iterator'
 |      insert(self, it, x) -> bitset_t
 |      
 |      @param it: qvector< bitset_t >::iterator
 |      @param x: bitset_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'bitset_t &'
 |      push_back(self, x)
 |      
 |      @param x: bitset_t const &
 |      
 |      push_back(self) -> bitset_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: bitset_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< bitset_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class array_of_ivlsets in module ida_hexrays:

class array_of_ivlsets(builtins.object)
 |  Proxy of C++ qvector< ivlset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< ivlset_t > const &
 |  
 |  __getitem__(self, *args) -> 'ivlset_t const &'
 |      __getitem__(self, i) -> ivlset_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_ivlsets
 |      __init__(self, x) -> array_of_ivlsets
 |      
 |      @param x: qvector< ivlset_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< ivlset_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: ivlset_t const &
 |  
 |  __swig_destroy__ = delete_array_of_ivlsets(...)
 |      delete_array_of_ivlsets(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: ivlset_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: ivlset_t const &
 |  
 |  at(self, *args) -> 'ivlset_t const &'
 |      at(self, _idx) -> ivlset_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ivlset_t >::const_iterator'
 |      begin(self) -> ivlset_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ivlset_t >::const_iterator'
 |      end(self) -> ivlset_t
 |  
 |  erase(self, *args) -> 'qvector< ivlset_t >::iterator'
 |      erase(self, it) -> ivlset_t
 |      
 |      @param it: qvector< ivlset_t >::iterator
 |      
 |      erase(self, first, last) -> ivlset_t
 |      
 |      @param first: qvector< ivlset_t >::iterator
 |      @param last: qvector< ivlset_t >::iterator
 |  
 |  extract(self, *args) -> 'ivlset_t *'
 |      extract(self) -> ivlset_t
 |  
 |  find(self, *args) -> 'qvector< ivlset_t >::const_iterator'
 |      find(self, x) -> ivlset_t
 |      
 |      @param x: ivlset_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ivlset_t())
 |      
 |      @param x: ivlset_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: ivlset_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: ivlset_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< ivlset_t >::iterator'
 |      insert(self, it, x) -> ivlset_t
 |      
 |      @param it: qvector< ivlset_t >::iterator
 |      @param x: ivlset_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ivlset_t &'
 |      push_back(self, x)
 |      
 |      @param x: ivlset_t const &
 |      
 |      push_back(self) -> ivlset_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: ivlset_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< ivlset_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function asgop in module ida_hexrays:

asgop(*args) -> 'ctype_t'
    asgop(cop) -> ctype_t
    Convert plain operator into assignment operator. For example, cot_add returns
    cot_asgadd.
    
    @param cop: (C++: ctype_t) enum ctype_t

Help on function asgop_revert in module ida_hexrays:

asgop_revert(*args) -> 'ctype_t'
    asgop_revert(cop) -> ctype_t
    Convert assignment operator into plain operator. For example, cot_asgadd returns
    cot_add
    
    @param cop: (C++: ctype_t) enum ctype_t
    @return: cot_empty is the input operator is not an assignment operator.

Help on class bit_bound_t in module ida_hexrays:

class bit_bound_t(builtins.object)
 |  Proxy of C++ bit_bound_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=0, s=0) -> bit_bound_t
 |      
 |      @param n: int
 |      @param s: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bit_bound_t(...)
 |      delete_bit_bound_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  nbits
 |      nbits
 |  
 |  sbits
 |      sbits
 |  
 |  thisown
 |      The membership flag

Help on class bitset_t in module ida_hexrays:

class bitset_t(builtins.object)
 |  Proxy of C++ bitset_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bitset_t
 |      __init__(self, m) -> bitset_t
 |      
 |      @param m: bitset_t const &
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __len__ = count(self, *args) -> 'int'
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bitset_t(...)
 |      delete_bitset_t(self)
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, bit) -> bool
 |      
 |      @param bit: int
 |      
 |      add(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |      
 |      add(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  back(self, *args) -> 'int'
 |      back(self) -> int
 |  
 |  begin(self, *args) -> 'bitset_t::iterator'
 |      begin(self) -> iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: bitset_t const &
 |  
 |  copy(self, *args) -> 'bitset_t &'
 |      copy(self, m) -> bitset_t
 |      
 |      @param m: bitset_t const &
 |  
 |  count(self, *args) -> 'int'
 |      count(self) -> int
 |      count(self, bit) -> int
 |      
 |      @param bit: int
 |  
 |  cut_at(self, *args) -> 'bool'
 |      cut_at(self, maxbit) -> bool
 |      
 |      @param maxbit: int
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'bitset_t::iterator'
 |      end(self) -> iterator
 |  
 |  fill_with_ones(self, *args) -> 'void'
 |      fill_with_ones(self, maxbit)
 |      
 |      @param maxbit: int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, bit) -> bool
 |      
 |      @param bit: int
 |  
 |  has_all(self, *args) -> 'bool'
 |      has_all(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |  
 |  has_any(self, *args) -> 'bool'
 |      has_any(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, p, n=1)
 |      
 |      @param p: bitset_t::iterator &
 |      @param n: int
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  itat(self, *args) -> 'bitset_t::iterator'
 |      itat(self, n) -> iterator
 |      
 |      @param n: int
 |  
 |  itv(self, *args) -> 'int'
 |      itv(self, it) -> int
 |      
 |      @param it: bitset_t::const_iterator
 |  
 |  last(self, *args) -> 'int'
 |      last(self) -> int
 |  
 |  shift_down(self, *args) -> 'void'
 |      shift_down(self, shift)
 |      
 |      @param shift: int
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, bit) -> bool
 |      
 |      @param bit: int
 |      
 |      sub(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |      
 |      sub(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: bitset_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function block_chains_begin in module ida_hexrays:

block_chains_begin(*args) -> 'block_chains_iterator_t'
    block_chains_begin(set) -> block_chains_iterator_t
    Get iterator pointing to the beginning of block_chains_t.
    
    @param set: (C++: const block_chains_t *) block_chains_t const *

Help on function block_chains_clear in module ida_hexrays:

block_chains_clear(*args) -> 'void'
    block_chains_clear(set)
    Clear block_chains_t.
    
    @param set: (C++: block_chains_t *)

Help on function block_chains_end in module ida_hexrays:

block_chains_end(*args) -> 'block_chains_iterator_t'
    block_chains_end(set) -> block_chains_iterator_t
    Get iterator pointing to the end of block_chains_t.
    
    @param set: (C++: const block_chains_t *) block_chains_t const *

Help on function block_chains_erase in module ida_hexrays:

block_chains_erase(*args) -> 'void'
    block_chains_erase(set, p)
    Erase current element from block_chains_t.
    
    @param set: (C++: block_chains_t *)
    @param p: (C++: block_chains_iterator_t)

Help on function block_chains_find in module ida_hexrays:

block_chains_find(*args) -> 'block_chains_iterator_t'
    block_chains_find(set, val) -> block_chains_iterator_t
    Find the specified key in set block_chains_t.
    
    @param set: (C++: const block_chains_t *) block_chains_t const *
    @param val: (C++: const chain_t &) chain_t const &

Help on function block_chains_free in module ida_hexrays:

block_chains_free(*args) -> 'void'
    block_chains_free(set)
    Delete block_chains_t instance.
    
    @param set: (C++: block_chains_t *)

Help on function block_chains_get in module ida_hexrays:

block_chains_get(*args) -> 'chain_t &'
    block_chains_get(p) -> chain_t
    Get reference to the current set value.
    
    @param p: (C++: block_chains_iterator_t)

Help on function block_chains_insert in module ida_hexrays:

block_chains_insert(*args) -> 'block_chains_iterator_t'
    block_chains_insert(set, val) -> block_chains_iterator_t
    Insert new (chain_t) into set block_chains_t.
    
    @param set: (C++: block_chains_t *)
    @param val: (C++: const chain_t &) chain_t const &

Help on class block_chains_iterator_t in module ida_hexrays:

class block_chains_iterator_t(builtins.object)
 |  Proxy of C++ block_chains_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: block_chains_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: block_chains_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_block_chains_iterator_t(...)
 |      delete_block_chains_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function block_chains_new in module ida_hexrays:

block_chains_new(*args) -> 'block_chains_t *'
    block_chains_new() -> block_chains_t
    Create a new block_chains_t instance.

Help on function block_chains_next in module ida_hexrays:

block_chains_next(*args) -> 'block_chains_iterator_t'
    block_chains_next(p) -> block_chains_iterator_t
    Move to the next element.
    
    @param p: (C++: block_chains_iterator_t)

Help on function block_chains_prev in module ida_hexrays:

block_chains_prev(*args) -> 'block_chains_iterator_t'
    block_chains_prev(p) -> block_chains_iterator_t
    Move to the previous element.
    
    @param p: (C++: block_chains_iterator_t)

Help on function block_chains_size in module ida_hexrays:

block_chains_size(*args) -> 'size_t'
    block_chains_size(set) -> size_t
    Get size of block_chains_t.
    
    @param set: (C++: block_chains_t *)

Help on class block_chains_t in module ida_hexrays:

class block_chains_t(builtins.object)
 |  Proxy of C++ block_chains_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_block_chains_t(...)
 |      delete_block_chains_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  get_chain(self, *args) -> 'chain_t *'
 |      get_chain(self, k, width=1) -> chain_t
 |      
 |      @param k: voff_t const &
 |      @param width: int
 |      
 |      get_chain(self, ch) -> chain_t
 |      
 |      @param ch: chain_t const &
 |  
 |  get_reg_chain(self, *args) -> 'chain_t *'
 |      get_reg_chain(self, reg, width=1) -> chain_t
 |      
 |      @param reg: mreg_t
 |      @param width: int
 |  
 |  get_stk_chain(self, *args) -> 'chain_t *'
 |      get_stk_chain(self, off, width=1) -> chain_t
 |      
 |      @param off: sval_t
 |      @param width: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class block_chains_vec_t in module ida_hexrays:

class block_chains_vec_t(builtins.object)
 |  Proxy of C++ qvector< block_chains_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'block_chains_t const &'
 |      __getitem__(self, i) -> block_chains_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> block_chains_vec_t
 |      __init__(self, x) -> block_chains_vec_t
 |      
 |      @param x: qvector< block_chains_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: block_chains_t const &
 |  
 |  __swig_destroy__ = delete_block_chains_vec_t(...)
 |      delete_block_chains_vec_t(self)
 |  
 |  at(self, *args) -> 'block_chains_t const &'
 |      at(self, _idx) -> block_chains_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      begin(self) -> block_chains_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      end(self) -> block_chains_t
 |  
 |  erase(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      erase(self, it) -> block_chains_t
 |      
 |      @param it: qvector< block_chains_t >::iterator
 |      
 |      erase(self, first, last) -> block_chains_t
 |      
 |      @param first: qvector< block_chains_t >::iterator
 |      @param last: qvector< block_chains_t >::iterator
 |  
 |  extract(self, *args) -> 'block_chains_t *'
 |      extract(self) -> block_chains_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=block_chains_t())
 |      
 |      @param x: block_chains_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: block_chains_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      insert(self, it, x) -> block_chains_t
 |      
 |      @param it: qvector< block_chains_t >::iterator
 |      @param x: block_chains_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'block_chains_t &'
 |      push_back(self, x)
 |      
 |      @param x: block_chains_t const &
 |      
 |      push_back(self) -> block_chains_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: block_chains_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< block_chains_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function boundaries_begin in module ida_hexrays:

boundaries_begin(*args) -> 'boundaries_iterator_t'
    boundaries_begin(map) -> boundaries_iterator_t
    Get iterator pointing to the beginning of boundaries_t.
    
    @param map: (C++: const boundaries_t *) boundaries_t const *

Help on function boundaries_clear in module ida_hexrays:

boundaries_clear(*args) -> 'void'
    boundaries_clear(map)
    Clear boundaries_t.
    
    @param map: (C++: boundaries_t *)

Help on function boundaries_end in module ida_hexrays:

boundaries_end(*args) -> 'boundaries_iterator_t'
    boundaries_end(map) -> boundaries_iterator_t
    Get iterator pointing to the end of boundaries_t.
    
    @param map: (C++: const boundaries_t *) boundaries_t const *

Help on function boundaries_erase in module ida_hexrays:

boundaries_erase(*args) -> 'void'
    boundaries_erase(map, p)
    Erase current element from boundaries_t.
    
    @param map: (C++: boundaries_t *)
    @param p: (C++: boundaries_iterator_t)

Help on function boundaries_find in module ida_hexrays:

boundaries_find(*args) -> 'boundaries_iterator_t'
    boundaries_find(map, key) -> boundaries_iterator_t
    Find the specified key in boundaries_t.
    
    @param map: (C++: const boundaries_t *) boundaries_t const *
    @param key: (C++: const cinsn_t *&) cinsn_t const *

Help on function boundaries_first in module ida_hexrays:

boundaries_first(*args) -> 'cinsn_t *const &'
    boundaries_first(p) -> cinsn_t
    Get reference to the current map key.
    
    @param p: (C++: boundaries_iterator_t)

Help on function boundaries_free in module ida_hexrays:

boundaries_free(*args) -> 'void'
    boundaries_free(map)
    Delete boundaries_t instance.
    
    @param map: (C++: boundaries_t *)

Help on function boundaries_insert in module ida_hexrays:

boundaries_insert(*args) -> 'boundaries_iterator_t'
    boundaries_insert(map, key, val) -> boundaries_iterator_t
    Insert new (cinsn_t *, rangeset_t) pair into boundaries_t.
    
    @param map: (C++: boundaries_t *)
    @param key: (C++: const cinsn_t *&) cinsn_t const *
    @param val: (C++: const rangeset_t &) rangeset_t const &

Help on class boundaries_iterator_t in module ida_hexrays:

class boundaries_iterator_t(builtins.object)
 |  Proxy of C++ boundaries_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: boundaries_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boundaries_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: boundaries_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_boundaries_iterator_t(...)
 |      delete_boundaries_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function boundaries_new in module ida_hexrays:

boundaries_new(*args) -> 'boundaries_t *'
    boundaries_new() -> boundaries_t
    Create a new boundaries_t instance.

Help on function boundaries_next in module ida_hexrays:

boundaries_next(*args) -> 'boundaries_iterator_t'
    boundaries_next(p) -> boundaries_iterator_t
    Move to the next element.
    
    @param p: (C++: boundaries_iterator_t)

Help on function boundaries_prev in module ida_hexrays:

boundaries_prev(*args) -> 'boundaries_iterator_t'
    boundaries_prev(p) -> boundaries_iterator_t
    Move to the previous element.
    
    @param p: (C++: boundaries_iterator_t)

Help on function boundaries_second in module ida_hexrays:

boundaries_second(*args) -> 'rangeset_t &'
    boundaries_second(p) -> rangeset_t
    Get reference to the current map value.
    
    @param p: (C++: boundaries_iterator_t)

Help on function boundaries_size in module ida_hexrays:

boundaries_size(*args) -> 'size_t'
    boundaries_size(map) -> size_t
    Get size of boundaries_t.
    
    @param map: (C++: boundaries_t *)

Help on class boundaries_t in module ida_hexrays:

class boundaries_t(builtins.object)
 |  Proxy of C++ std::map< cinsn_t *,rangeset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = boundaries_begin(...)
 |      boundaries_begin(map) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t const *
 |  
 |  __clear = boundaries_clear(...)
 |      boundaries_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = boundaries_end(...)
 |      boundaries_end(map) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t const *
 |  
 |  __erase = boundaries_erase(...)
 |      boundaries_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |      p: boundaries_iterator_t
 |  
 |  __find = boundaries_find(...)
 |      boundaries_find(map, key) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t const *
 |      key: cinsn_t const *
 |  
 |  __first = boundaries_first(...)
 |      boundaries_first(p) -> cinsn_t
 |      
 |      Parameters
 |      ----------
 |      p: boundaries_iterator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boundaries_t
 |  
 |  __insert = boundaries_insert(...)
 |      boundaries_insert(map, key, val) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |      key: cinsn_t const *
 |      val: rangeset_t const &
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = boundaries_next(...)
 |      boundaries_next(p) -> boundaries_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: boundaries_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = boundaries_second(...)
 |      boundaries_second(p) -> rangeset_t
 |      
 |      Parameters
 |      ----------
 |      p: boundaries_iterator_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = boundaries_size(...)
 |      boundaries_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: boundaries_t *
 |  
 |  __swig_destroy__ = delete_boundaries_t(...)
 |      delete_boundaries_t(self)
 |  
 |  at(self, *args) -> 'rangeset_t &'
 |      at(self, _Keyval) -> rangeset_t
 |      
 |      @param _Keyval: cinsn_t *const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.cinsn_t'>
 |      Proxy of C++ cinsn_t class.
 |  
 |  valuetype = <class 'ida_range.rangeset_t'>
 |      Proxy of C++ rangeset_t class.

Help on function call_helper in module ida_hexrays:

call_helper(rettype, args, *rest)
    Create a helper call.

Help on class carg_t in module ida_hexrays:

class carg_t(cexpr_t)
 |  Proxy of C++ carg_t class.
 |  
 |  Method resolution order:
 |      carg_t
 |      cexpr_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: carg_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: carg_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: carg_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> carg_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: carg_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: carg_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: carg_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_carg_t(...)
 |      delete_carg_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: carg_t const &
 |  
 |  consume_cexpr(self, *args) -> 'void'
 |      consume_cexpr(self, e)
 |      
 |      @param e: cexpr_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  formal_type
 |      formal_type
 |  
 |  is_vararg
 |      is_vararg
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cexpr_t:
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_a(self, *args) -> 'carglist_t *'
 |      _get_a(self) -> carglist_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_insn(self, *args) -> 'cinsn_t *'
 |      _get_insn(self) -> cinsn_t
 |  
 |  _get_m(self, *args) -> 'int'
 |      _get_m(self) -> int
 |  
 |  _get_n(self, *args) -> 'cnumber_t *'
 |      _get_n(self) -> cnumber_t
 |  
 |  _get_obj_ea(self, *args) -> 'ea_t'
 |      _get_obj_ea(self) -> ea_t
 |  
 |  _get_ptrsize(self, *args) -> 'int'
 |      _get_ptrsize(self) -> int
 |  
 |  _get_refwidth(self, *args) -> 'int'
 |      _get_refwidth(self) -> int
 |  
 |  _get_string(self, *args) -> 'char const *'
 |      _get_string(self) -> char const *
 |  
 |  _get_x(self, *args) -> 'cexpr_t *'
 |      _get_x(self) -> cexpr_t
 |  
 |  _get_y(self, *args) -> 'cexpr_t *'
 |      _get_y(self) -> cexpr_t
 |  
 |  _get_z(self, *args) -> 'cexpr_t *'
 |      _get_z(self) -> cexpr_t
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |      
 |      Parameters
 |      ----------
 |      r: cexpr_t *
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: carglist_t *
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: fnumber_t *
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_insn(self, *args) -> 'void'
 |      _set_insn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cinsn_t *
 |  
 |  _set_m(self, *args) -> 'void'
 |      _set_m(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_n(self, *args) -> 'void'
 |      _set_n(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cnumber_t *
 |  
 |  _set_obj_ea(self, *args) -> 'void'
 |      _set_obj_ea(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: ea_t
 |  
 |  _set_ptrsize(self, *args) -> 'void'
 |      _set_ptrsize(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_refwidth(self, *args) -> 'void'
 |      _set_refwidth(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_string(self, *args) -> 'void'
 |      _set_string(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_x(self, *args) -> 'void'
 |      _set_x(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  _set_y(self, *args) -> 'void'
 |      _set_y(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  _set_z(self, *args) -> 'void'
 |      _set_z(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  assign(self, *args) -> 'cexpr_t &'
 |      assign(self, r) -> cexpr_t
 |      
 |      @param r: cexpr_t const &
 |  
 |  calc_type(self, *args) -> 'void'
 |      calc_type(self, recursive)
 |      Calculate the type of the expression. Use this function to calculate the
 |      expression type when a new expression is built
 |      
 |      @param recursive: (C++: bool) if true, types of all children expression will be calculated
 |                        before calculating our type
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |      Cleanup the expression. This function properly deletes all children and sets the
 |      item type to cot_empty.
 |  
 |  contains_comma(self, *args) -> 'bool'
 |      contains_comma(self, times=1) -> bool
 |      Does the expression contain a comma operator?
 |      
 |      @param times: (C++: int)
 |  
 |  contains_comma_or_insn_or_label(self, *args) -> 'bool'
 |      contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
 |      Does the expression contain a comma operator or an embedded statement operator
 |      or a label?
 |      
 |      @param maxcommas: (C++: int)
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, times=1) -> bool
 |      Does the expression contain an embedded statement operator?
 |      
 |      @param times: (C++: int)
 |  
 |  contains_insn_or_label(self, *args) -> 'bool'
 |      contains_insn_or_label(self) -> bool
 |      Does the expression contain an embedded statement operator or a label?
 |  
 |  contains_operator(self, *args) -> 'bool'
 |      contains_operator(self, needed_op, times=1) -> bool
 |      Check if the expression contains the specified operator.
 |      
 |      @param needed_op: (C++: ctype_t) operator code to search for
 |      @param times: (C++: int) how many times the operator code should be present
 |      @return: true if the expression has at least TIMES children with NEEDED_OP
 |  
 |  cpadone(self, *args) -> 'bool'
 |      cpadone(self) -> bool
 |      Pointer arithmetic correction done for this expression?
 |  
 |  equal_effect(self, *args) -> 'bool'
 |      equal_effect(self, r) -> bool
 |      Compare two expressions. This function tries to compare two expressions in an
 |      'intelligent' manner. For example, it knows about commutitive operators and can
 |      ignore useless casts.
 |      
 |      @param r: (C++: const cexpr_t &) the expression to compare against the current expression
 |      @return: true expressions can be considered equal
 |  
 |  find_num_op(self, *args) -> 'cexpr_t *'
 |      find_num_op(self) -> cexpr_t
 |  
 |  find_op(self, *args) -> 'cexpr_t *'
 |      find_op(self, _op) -> cexpr_t
 |      
 |      @param _op: enum ctype_t
 |  
 |  get_1num_op(self, *args) -> 'bool'
 |      get_1num_op(self, o1, o2) -> bool
 |      
 |      @param o1: cexpr_t **
 |      @param o2: cexpr_t **
 |  
 |  get_const_value(self, *args) -> 'bool'
 |      get_const_value(self) -> bool
 |      Get expression value.
 |      
 |      @return: true if the expression is a number.
 |  
 |  get_high_nbit_bound(self, *args) -> 'bit_bound_t'
 |      get_high_nbit_bound(self) -> bit_bound_t
 |      Get max number of bits that can really be used by the expression. For example, x
 |      % 16 can yield only 4 non-zero bits, higher bits are zero
 |  
 |  get_low_nbit_bound(self, *args) -> 'int'
 |      get_low_nbit_bound(self) -> int
 |      Get min number of bits that are certainly required to represent the expression.
 |      For example, constant 16 always uses 5 bits: 10000.
 |  
 |  get_ptr_or_array(self, *args) -> 'cexpr_t *'
 |      get_ptr_or_array(self) -> cexpr_t
 |      Find pointer or array child.
 |  
 |  get_type_sign(self, *args) -> 'type_sign_t'
 |      get_type_sign(self) -> type_sign_t
 |      Get expression sign.
 |  
 |  get_v(self, *args) -> 'var_ref_t *'
 |      get_v(self) -> var_ref_t
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self) -> bool
 |      Check if the expression has side effects. Calls, pre/post inc/dec, and
 |      assignments have side effects.
 |  
 |  is_call_arg_of(self, *args) -> 'bool'
 |      is_call_arg_of(self, parent) -> bool
 |      Is call argument?
 |      
 |      @param parent: (C++: const citem_t *) citem_t const *
 |      @return: true if our expression is a call argument of the specified parent
 |               expression.
 |  
 |  is_call_object_of(self, *args) -> 'bool'
 |      is_call_object_of(self, parent) -> bool
 |      Is call object?
 |      
 |      @param parent: (C++: const citem_t *) citem_t const *
 |      @return: true if our expression is the call object of the specified parent
 |               expression.
 |  
 |  is_child_of(self, *args) -> 'bool'
 |      is_child_of(self, parent) -> bool
 |      Verify if the specified item is our parent.
 |      
 |      @param parent: (C++: const citem_t *) possible parent item
 |      @return: true if the specified item is our parent
 |  
 |  is_const_value(self, *args) -> 'bool'
 |      is_const_value(self, _v) -> bool
 |      Check if the expression is a number with the specified value.
 |      
 |      @param _v: (C++: uint64)
 |  
 |  is_cstr(self, *args) -> 'bool'
 |      is_cstr(self) -> bool
 |  
 |  is_fpop(self, *args) -> 'bool'
 |      is_fpop(self) -> bool
 |  
 |  is_jumpout(self, *args) -> 'bool'
 |      is_jumpout(self) -> bool
 |  
 |  is_negative_const(self, *args) -> 'bool'
 |      is_negative_const(self) -> bool
 |      Check if the expression is a negative number.
 |  
 |  is_nice_cond(self, *args) -> 'bool'
 |      is_nice_cond(self) -> bool
 |      Is nice condition?. Nice condition is a nice expression of the boolean type.
 |  
 |  is_nice_expr(self, *args) -> 'bool'
 |      is_nice_expr(self) -> bool
 |      Is nice expression? Nice expressions do not contain comma operators, embedded
 |      statements, or labels.
 |  
 |  is_non_negative_const(self, *args) -> 'bool'
 |      is_non_negative_const(self) -> bool
 |      Check if the expression is a non-negative number.
 |  
 |  is_non_zero_const(self, *args) -> 'bool'
 |      is_non_zero_const(self) -> bool
 |      Check if the expression is a non-zero number.
 |  
 |  is_odd_lvalue(self, *args) -> 'bool'
 |      is_odd_lvalue(self) -> bool
 |  
 |  is_type_signed(self, *args) -> 'bool'
 |      is_type_signed(self) -> bool
 |      Is expression signed?
 |  
 |  is_type_unsigned(self, *args) -> 'bool'
 |      is_type_unsigned(self) -> bool
 |      Is expression unsigned?
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_zero_const(self, *args) -> 'bool'
 |      is_zero_const(self) -> bool
 |      Check if the expression is a zero.
 |  
 |  maybe_ptr(self, *args) -> 'bool'
 |      maybe_ptr(self) -> bool
 |      May the expression be a pointer?
 |  
 |  numval(self, *args) -> 'uint64'
 |      numval(self) -> uint64
 |      Get numeric value of the expression. This function can be called only on cot_num
 |      expressions!
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |      Print expression into one line.
 |      
 |      @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
 |                   variable names.
 |  
 |  put_number(self, *args) -> 'void'
 |      put_number(self, func, value, nbytes, sign=no_sign)
 |      Assign a number to the expression.
 |      
 |      @param func: (C++: cfunc_t *) current function
 |      @param value: (C++: uint64) number value
 |      @param nbytes: (C++: int) size of the number in bytes
 |      @param sign: (C++: type_sign_t) number sign
 |  
 |  requires_lvalue(self, *args) -> 'bool'
 |      requires_lvalue(self, child) -> bool
 |      Check if the expression requires an lvalue.
 |      
 |      @param child: (C++: const cexpr_t *) The function will check if this child of our expression must be an
 |                    lvalue.
 |      @return: true if child must be an lvalue.
 |  
 |  set_cpadone(self, *args) -> 'void'
 |      set_cpadone(self)
 |  
 |  set_v(self, *args) -> 'void'
 |      set_v(self, v)
 |      
 |      @param v: var_ref_t const *
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: cexpr_t &
 |  
 |  theother(self, *args) -> 'cexpr_t *'
 |      theother(self, what) -> cexpr_t
 |      
 |      @param what: cexpr_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cexpr_t:
 |  
 |  a
 |  
 |  exflags
 |      exflags
 |  
 |  fpc
 |  
 |  helper
 |  
 |  insn
 |  
 |  m
 |  
 |  n
 |  
 |  obj_ea
 |  
 |  operands
 |      return a dictionary with the operands of a cexpr_t.
 |  
 |  opname
 |  
 |  ptrsize
 |  
 |  refwidth
 |  
 |  string
 |  
 |  type
 |      type
 |  
 |  v
 |  
 |  x
 |  
 |  y
 |  
 |  z
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from cexpr_t:
 |  
 |  op_to_typename = {0: 'empty', 1: 'comma', 2: 'asg', 3: 'asgbor', 4: 'a...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: enum ctype_t
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |      Does the item contain an expression?
 |      
 |      @param e: (C++: const cexpr_t *) cexpr_t const *
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |      
 |      @param _ea: ea_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      
 |      @param sitem: citem_t const *
 |      
 |      find_parent_of(self, item) -> citem_t
 |      
 |      @param item: citem_t const *
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      cexpr
 |  
 |  cinsn
 |      cinsn
 |  
 |  ea
 |      ea
 |  
 |  index
 |      index
 |  
 |  label_num
 |      label_num
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class carglist_t in module ida_hexrays:

class carglist_t(qvector_carg_t)
 |  Proxy of C++ carglist_t class.
 |  
 |  Method resolution order:
 |      carglist_t
 |      qvector_carg_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: carglist_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: carglist_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: carglist_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> carglist_t
 |      __init__(self, ftype, fl=0) -> carglist_t
 |      
 |      @param ftype: tinfo_t const &
 |      @param fl: int
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: carglist_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: carglist_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: carglist_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_carglist_t(...)
 |      delete_carglist_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: carglist_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      flags
 |  
 |  functype
 |      functype
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_carg_t:
 |  
 |  __getitem__(self, *args) -> 'carg_t const &'
 |      __getitem__(self, i) -> carg_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: carg_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: carg_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: carg_t const &
 |  
 |  append = push_back(self, *args) -> 'carg_t &'
 |      push_back(self, x)
 |      
 |      @param x: carg_t const &
 |      
 |      push_back(self) -> carg_t
 |  
 |  at = __getitem__(self, *args) -> 'carg_t const &'
 |      __getitem__(self, i) -> carg_t
 |      
 |      @param i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      begin(self) -> carg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      end(self) -> carg_t
 |  
 |  erase(self, *args) -> 'qvector< carg_t >::iterator'
 |      erase(self, it) -> carg_t
 |      
 |      @param it: qvector< carg_t >::iterator
 |      
 |      erase(self, first, last) -> carg_t
 |      
 |      @param first: qvector< carg_t >::iterator
 |      @param last: qvector< carg_t >::iterator
 |  
 |  extract(self, *args) -> 'carg_t *'
 |      extract(self) -> carg_t
 |  
 |  find(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      find(self, x) -> carg_t
 |      
 |      @param x: carg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=carg_t())
 |      
 |      @param x: carg_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: carg_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: carg_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< carg_t >::iterator'
 |      insert(self, it, x) -> carg_t
 |      
 |      @param it: qvector< carg_t >::iterator
 |      @param x: carg_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'carg_t &'
 |      push_back(self, x)
 |      
 |      @param x: carg_t const &
 |      
 |      push_back(self) -> carg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: carg_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< carg_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_carg_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class casm_t in module ida_hexrays:

class casm_t(ida_pro.eavec_t)
 |  Proxy of C++ casm_t class.
 |  
 |  Method resolution order:
 |      casm_t
 |      ida_pro.eavec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: casm_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: casm_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: casm_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, ea) -> casm_t
 |      
 |      @param ea: ea_t
 |      
 |      __init__(self, r) -> casm_t
 |      
 |      @param r: casm_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: casm_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: casm_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: casm_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_casm_t(...)
 |      delete_casm_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: casm_t const &
 |  
 |  one_insn(self, *args) -> 'bool'
 |      one_insn(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_pro.eavec_t:
 |  
 |  __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned-ea-like-numeric-type const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: unsigned-ea-like-numeric-type const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: unsigned-ea-like-numeric-type const &
 |  
 |  append = push_back(self, *args) -> 'unsigned-ea-like-numeric-type &'
 |      push_back(self, x)
 |      
 |      @param x: unsigned-ea-like-numeric-type const &
 |      
 |      push_back(self) -> unsigned-ea-like-numeric-type &
 |  
 |  at = __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
 |      
 |      @param i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::const_iterator'
 |      begin(self) -> qvector< unsigned-ea-like-numeric-type >::iterator
 |      begin(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::const_iterator'
 |      end(self) -> qvector< unsigned-ea-like-numeric-type >::iterator
 |      end(self) -> qvector< unsigned-ea-like-numeric-type >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::iterator'
 |      erase(self, it) -> qvector< unsigned-ea-like-numeric-type >::iterator
 |      
 |      @param it: qvector< unsigned-ea-like-numeric-type >::iterator
 |      
 |      erase(self, first, last) -> qvector< unsigned-ea-like-numeric-type >::iterator
 |      
 |      @param first: qvector< unsigned-ea-like-numeric-type >::iterator
 |      @param last: qvector< unsigned-ea-like-numeric-type >::iterator
 |  
 |  extract(self, *args) -> 'unsigned-ea-like-numeric-type *'
 |      extract(self) -> unsigned-ea-like-numeric-type *
 |  
 |  find(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::const_iterator'
 |      find(self, x) -> qvector< unsigned-ea-like-numeric-type >::iterator
 |      
 |      @param x: unsigned-ea-like-numeric-type const &
 |      
 |      find(self, x) -> qvector< unsigned-ea-like-numeric-type >::const_iterator
 |      
 |      @param x: unsigned-ea-like-numeric-type const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: unsigned-ea-like-numeric-type const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: unsigned-ea-like-numeric-type *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< unsigned-ea-like-numeric-type >::iterator'
 |      insert(self, it, x) -> qvector< unsigned-ea-like-numeric-type >::iterator
 |      
 |      @param it: qvector< unsigned-ea-like-numeric-type >::iterator
 |      @param x: unsigned-ea-like-numeric-type const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'unsigned-ea-like-numeric-type &'
 |      push_back(self, x)
 |      
 |      @param x: unsigned-ea-like-numeric-type const &
 |      
 |      push_back(self) -> unsigned-ea-like-numeric-type &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: unsigned-ea-like-numeric-type const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< unsigned-ea-like-numeric-type > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_pro.eavec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class cblock_t in module ida_hexrays:

class cblock_t(cinsn_list_t)
 |  Proxy of C++ cblock_t class.
 |  
 |  Method resolution order:
 |      cblock_t
 |      cinsn_list_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cblock_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cblock_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cblock_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cblock_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cblock_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cblock_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cblock_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cblock_t(...)
 |      delete_cblock_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cblock_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cinsn_list_t:
 |  
 |  __getitem__(self, *args) -> 'cinsn_t const &'
 |      __getitem__(self, i) -> cinsn_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: cinsn_t const &
 |  
 |  at(self, index)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'cinsn_list_t_iterator'
 |      begin(self) -> cinsn_list_t_iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'cinsn_list_t_iterator'
 |      end(self) -> cinsn_list_t_iterator
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self, p)
 |      
 |      @param p: cinsn_list_t_iterator
 |  
 |  find(self, item)
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  index(self, item)
 |  
 |  insert(self, *args) -> 'cinsn_list_t_iterator'
 |      insert(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: cinsn_t const &
 |      
 |      insert(self, p, x) -> cinsn_list_t_iterator
 |      
 |      @param p: cinsn_list_t_iterator
 |      @param x: cinsn_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  pop_front(self, *args) -> 'void'
 |      pop_front(self)
 |  
 |  push_back(self, *args) -> 'cinsn_t &'
 |      push_back(self, x)
 |      
 |      @param x: cinsn_t const &
 |      
 |      push_back(self) -> cinsn_t
 |  
 |  push_front(self, *args) -> 'void'
 |      push_front(self, x)
 |      
 |      @param x: cinsn_t const &
 |  
 |  rbegin(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rbegin(self) -> qlist< cinsn_t >::reverse_iterator
 |      rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self, v) -> bool
 |      
 |      @param v: cinsn_t const &
 |  
 |  rend(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rend(self) -> qlist< cinsn_t >::reverse_iterator
 |      rend(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, x)
 |      
 |      @param x: qlist< cinsn_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cinsn_list_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class ccase_t in module ida_hexrays:

class ccase_t(cinsn_t)
 |  Proxy of C++ ccase_t class.
 |  
 |  Method resolution order:
 |      ccase_t
 |      cinsn_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ccase_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: ccase_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: ccase_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ccase_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: ccase_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: ccase_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ccase_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ccase_t(...)
 |      delete_ccase_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: ccase_t const &
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  value(self, *args) -> 'uint64 const &'
 |      value(self, i) -> uint64 const &
 |      
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      values
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cinsn_t:
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_casm(self, *args) -> 'casm_t *'
 |      _get_casm(self) -> casm_t
 |  
 |  _get_cblock(self, *args) -> 'cblock_t *'
 |      _get_cblock(self) -> cblock_t
 |  
 |  _get_cdo(self, *args) -> 'cdo_t *'
 |      _get_cdo(self) -> cdo_t
 |  
 |  _get_cexpr(self, *args) -> 'cexpr_t *'
 |      _get_cexpr(self) -> cexpr_t
 |  
 |  _get_cfor(self, *args) -> 'cfor_t *'
 |      _get_cfor(self) -> cfor_t
 |  
 |  _get_cgoto(self, *args) -> 'cgoto_t *'
 |      _get_cgoto(self) -> cgoto_t
 |  
 |  _get_cif(self, *args) -> 'cif_t *'
 |      _get_cif(self) -> cif_t
 |  
 |  _get_creturn(self, *args) -> 'creturn_t *'
 |      _get_creturn(self) -> creturn_t
 |  
 |  _get_cswitch(self, *args) -> 'cswitch_t *'
 |      _get_cswitch(self) -> cswitch_t
 |  
 |  _get_cwhile(self, *args) -> 'cwhile_t *'
 |      _get_cwhile(self) -> cwhile_t
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
 |      
 |      Parameters
 |      ----------
 |      indent: int
 |      vp: vc_printer_t &
 |      use_curly: enum use_curly_t
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |      
 |      Parameters
 |      ----------
 |      r: cinsn_t *
 |  
 |  _set_casm(self, *args) -> 'void'
 |      _set_casm(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: casm_t *
 |  
 |  _set_cblock(self, *args) -> 'void'
 |      _set_cblock(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cblock_t *
 |  
 |  _set_cdo(self, *args) -> 'void'
 |      _set_cdo(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cdo_t *
 |  
 |  _set_cexpr(self, *args) -> 'void'
 |      _set_cexpr(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  _set_cfor(self, *args) -> 'void'
 |      _set_cfor(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cfor_t *
 |  
 |  _set_cgoto(self, *args) -> 'void'
 |      _set_cgoto(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cgoto_t *
 |  
 |  _set_cif(self, *args) -> 'void'
 |      _set_cif(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cif_t *
 |  
 |  _set_creturn(self, *args) -> 'void'
 |      _set_creturn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: creturn_t *
 |  
 |  _set_cswitch(self, *args) -> 'void'
 |      _set_cswitch(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cswitch_t *
 |  
 |  _set_cwhile(self, *args) -> 'void'
 |      _set_cwhile(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cwhile_t *
 |  
 |  assign(self, *args) -> 'cinsn_t &'
 |      assign(self, r) -> cinsn_t
 |      
 |      @param r: cinsn_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |      Cleanup the statement. This function properly deletes all children and sets the
 |      item type to cit_empty.
 |  
 |  collect_free_breaks(self, *args) -> 'bool'
 |      collect_free_breaks(self, breaks) -> bool
 |      Collect free break statements. This function finds all free break statements
 |      within the current statement. A break statement is free if it does not have a
 |      loop or switch parent that that is also within the current statement.
 |      
 |      @param breaks: (C++: cinsnptrvec_t *) pointer to the variable where the vector of all found free break
 |                     statements is returned. This argument can be nullptr.
 |      @return: true if some free break statements have been found
 |  
 |  collect_free_continues(self, *args) -> 'bool'
 |      collect_free_continues(self, continues) -> bool
 |      Collect free continue statements. This function finds all free continue
 |      statements within the current statement. A continue statement is free if it does
 |      not have a loop parent that that is also within the current statement.
 |      
 |      @param continues: (C++: cinsnptrvec_t *) pointer to the variable where the vector of all found free
 |                        continue statements is returned. This argument can be nullptr.
 |      @return: true if some free continue statements have been found
 |  
 |  contains_free_break(self, *args) -> 'bool'
 |      contains_free_break(self) -> bool
 |      Check if the statement has free break statements.
 |  
 |  contains_free_continue(self, *args) -> 'bool'
 |      contains_free_continue(self) -> bool
 |      Check if the statement has free continue statements.
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, type, times=1) -> bool
 |      Check if the statement contains a statement of the specified type.
 |      
 |      @param type: (C++: ctype_t) statement opcode to look for
 |      @param times: (C++: int) how many times TYPE should be present
 |      @return: true if the statement has at least TIMES children with opcode == TYPE
 |  
 |  create_if(self, *args) -> 'cif_t &'
 |      create_if(self, cnd) -> cif_t
 |      Create a new if-statement. The current statement must be a block. The new
 |      statement will be appended to it.
 |      
 |      @param cnd: (C++: cexpr_t *) if condition. It will be deleted after being copied.
 |  
 |  is_epilog(self)
 |  
 |  is_ordinary_flow(self, *args) -> 'bool'
 |      is_ordinary_flow(self) -> bool
 |      Check if the statement passes execution to the next statement.
 |      
 |      @return: false if the statement breaks the control flow (like goto, return, etc)
 |  
 |  new_insn(self, *args) -> 'cinsn_t &'
 |      new_insn(self, insn_ea) -> cinsn_t
 |      Create a new statement. The current statement must be a block. The new statement
 |      will be appended to it.
 |      
 |      @param insn_ea: (C++: ea_t) statement address
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |      Print the statement into one line. Currently this function is not available.
 |      
 |      @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
 |                   variable names.
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: cinsn_t &
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |      Overwrite with zeroes without cleaning memory or deleting children.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from cinsn_t:
 |  
 |  insn_is_epilog(*args) -> 'bool'
 |      insn_is_epilog(insn) -> bool
 |      
 |      @param insn: cinsn_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cinsn_t:
 |  
 |  casm
 |  
 |  cblock
 |  
 |  cdo
 |  
 |  cexpr
 |  
 |  cfor
 |  
 |  cgoto
 |  
 |  cif
 |  
 |  creturn
 |  
 |  cswitch
 |  
 |  cwhile
 |  
 |  details
 |      return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
 |  
 |  opname
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from cinsn_t:
 |  
 |  op_to_typename = {70: 'empty', 71: 'block', 72: 'expr', 73: 'if', 74: ...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: enum ctype_t
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |      Does the item contain an expression?
 |      
 |      @param e: (C++: const cexpr_t *) cexpr_t const *
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |      
 |      @param _ea: ea_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      
 |      @param sitem: citem_t const *
 |      
 |      find_parent_of(self, item) -> citem_t
 |      
 |      @param item: citem_t const *
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cinsn
 |      cinsn
 |  
 |  ea
 |      ea
 |  
 |  index
 |      index
 |  
 |  label_num
 |      label_num
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class ccases_t in module ida_hexrays:

class ccases_t(qvector_ccase_t)
 |  Proxy of C++ ccases_t class.
 |  
 |  Method resolution order:
 |      ccases_t
 |      qvector_ccase_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ccases_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: ccases_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: ccases_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ccases_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: ccases_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: ccases_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ccases_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ccases_t(...)
 |      delete_ccases_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: ccases_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_ccase_t:
 |  
 |  __getitem__(self, *args) -> 'ccase_t const &'
 |      __getitem__(self, i) -> ccase_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: ccase_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: ccase_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: ccase_t const &
 |  
 |  append = push_back(self, *args) -> 'ccase_t &'
 |      push_back(self, x)
 |      
 |      @param x: ccase_t const &
 |      
 |      push_back(self) -> ccase_t
 |  
 |  at = __getitem__(self, *args) -> 'ccase_t const &'
 |      __getitem__(self, i) -> ccase_t
 |      
 |      @param i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      begin(self) -> ccase_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      end(self) -> ccase_t
 |  
 |  erase(self, *args) -> 'qvector< ccase_t >::iterator'
 |      erase(self, it) -> ccase_t
 |      
 |      @param it: qvector< ccase_t >::iterator
 |      
 |      erase(self, first, last) -> ccase_t
 |      
 |      @param first: qvector< ccase_t >::iterator
 |      @param last: qvector< ccase_t >::iterator
 |  
 |  extract(self, *args) -> 'ccase_t *'
 |      extract(self) -> ccase_t
 |  
 |  find(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      find(self, x) -> ccase_t
 |      
 |      @param x: ccase_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ccase_t())
 |      
 |      @param x: ccase_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: ccase_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: ccase_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< ccase_t >::iterator'
 |      insert(self, it, x) -> ccase_t
 |      
 |      @param it: qvector< ccase_t >::iterator
 |      @param x: ccase_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ccase_t &'
 |      push_back(self, x)
 |      
 |      @param x: ccase_t const &
 |      
 |      push_back(self) -> ccase_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: ccase_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< ccase_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_ccase_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class cdg_insn_iterator_t in module ida_hexrays:

class cdg_insn_iterator_t(builtins.object)
 |  Proxy of C++ cdg_insn_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, mba_) -> cdg_insn_iterator_t
 |      
 |      @param mba_: mba_t const *
 |      
 |      __init__(self, r) -> cdg_insn_iterator_t
 |      
 |      @param r: cdg_insn_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cdg_insn_iterator_t(...)
 |      delete_cdg_insn_iterator_t(self)
 |  
 |  dslot_with_xrefs(self, *args) -> 'bool'
 |      dslot_with_xrefs(self) -> bool
 |  
 |  has_dslot(self, *args) -> 'bool'
 |      has_dslot(self) -> bool
 |  
 |  is_severed_dslot(self, *args) -> 'bool'
 |      is_severed_dslot(self) -> bool
 |  
 |  next(self, *args) -> 'merror_t'
 |      next(self, ins) -> merror_t
 |      
 |      @param ins: insn_t *
 |  
 |  ok(self, *args) -> 'bool'
 |      ok(self) -> bool
 |  
 |  start(self, *args) -> 'void'
 |      start(self, rng)
 |      
 |      @param rng: range_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dslot
 |      dslot
 |  
 |  dslot_insn
 |      dslot_insn
 |  
 |  ea
 |      ea
 |  
 |  end
 |      end
 |  
 |  is_likely_dslot
 |      is_likely_dslot
 |  
 |  mba
 |      mba
 |  
 |  severed_branch
 |      severed_branch
 |  
 |  thisown
 |      The membership flag

Help on class cdo_t in module ida_hexrays:

class cdo_t(cloop_t)
 |  Proxy of C++ cdo_t class.
 |  
 |  Method resolution order:
 |      cdo_t
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cdo_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cdo_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cdo_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cdo_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cdo_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cdo_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cdo_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cdo_t(...)
 |      delete_cdo_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cdo_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |      
 |      @param r: cloop_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      body
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on class ceinsn_t in module ida_hexrays:

class ceinsn_t(builtins.object)
 |  Proxy of C++ ceinsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ceinsn_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ceinsn_t(...)
 |      delete_ceinsn_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr
 |  
 |  thisown
 |      The membership flag

Help on function cexpr_operands in module ida_hexrays:

cexpr_operands(self)
    return a dictionary with the operands of a cexpr_t.

Help on class cexpr_t in module ida_hexrays:

class cexpr_t(citem_t)
 |  Proxy of C++ cexpr_t class.
 |  
 |  Method resolution order:
 |      cexpr_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cexpr_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cexpr_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cexpr_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cexpr_t
 |      __init__(self, cexpr_op, _x) -> cexpr_t
 |      
 |      @param cexpr_op: enum ctype_t
 |      @param _x: cexpr_t *
 |      
 |      __init__(self, cexpr_op, _x, _y) -> cexpr_t
 |      
 |      @param cexpr_op: enum ctype_t
 |      @param _x: cexpr_t *
 |      @param _y: cexpr_t *
 |      
 |      __init__(self, cexpr_op, _x, _y, _z) -> cexpr_t
 |      
 |      @param cexpr_op: enum ctype_t
 |      @param _x: cexpr_t *
 |      @param _y: cexpr_t *
 |      @param _z: cexpr_t *
 |      
 |      __init__(self, r) -> cexpr_t
 |      
 |      @param r: cexpr_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cexpr_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cexpr_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cexpr_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cexpr_t(...)
 |      delete_cexpr_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_a(self, *args) -> 'carglist_t *'
 |      _get_a(self) -> carglist_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_insn(self, *args) -> 'cinsn_t *'
 |      _get_insn(self) -> cinsn_t
 |  
 |  _get_m(self, *args) -> 'int'
 |      _get_m(self) -> int
 |  
 |  _get_n(self, *args) -> 'cnumber_t *'
 |      _get_n(self) -> cnumber_t
 |  
 |  _get_obj_ea(self, *args) -> 'ea_t'
 |      _get_obj_ea(self) -> ea_t
 |  
 |  _get_ptrsize(self, *args) -> 'int'
 |      _get_ptrsize(self) -> int
 |  
 |  _get_refwidth(self, *args) -> 'int'
 |      _get_refwidth(self) -> int
 |  
 |  _get_string(self, *args) -> 'char const *'
 |      _get_string(self) -> char const *
 |  
 |  _get_x(self, *args) -> 'cexpr_t *'
 |      _get_x(self) -> cexpr_t
 |  
 |  _get_y(self, *args) -> 'cexpr_t *'
 |      _get_y(self) -> cexpr_t
 |  
 |  _get_z(self, *args) -> 'cexpr_t *'
 |      _get_z(self) -> cexpr_t
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |      
 |      Parameters
 |      ----------
 |      r: cexpr_t *
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: carglist_t *
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: fnumber_t *
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_insn(self, *args) -> 'void'
 |      _set_insn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cinsn_t *
 |  
 |  _set_m(self, *args) -> 'void'
 |      _set_m(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_n(self, *args) -> 'void'
 |      _set_n(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cnumber_t *
 |  
 |  _set_obj_ea(self, *args) -> 'void'
 |      _set_obj_ea(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: ea_t
 |  
 |  _set_ptrsize(self, *args) -> 'void'
 |      _set_ptrsize(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_refwidth(self, *args) -> 'void'
 |      _set_refwidth(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_string(self, *args) -> 'void'
 |      _set_string(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_x(self, *args) -> 'void'
 |      _set_x(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  _set_y(self, *args) -> 'void'
 |      _set_y(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  _set_z(self, *args) -> 'void'
 |      _set_z(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  assign(self, *args) -> 'cexpr_t &'
 |      assign(self, r) -> cexpr_t
 |      
 |      @param r: cexpr_t const &
 |  
 |  calc_type(self, *args) -> 'void'
 |      calc_type(self, recursive)
 |      Calculate the type of the expression. Use this function to calculate the
 |      expression type when a new expression is built
 |      
 |      @param recursive: (C++: bool) if true, types of all children expression will be calculated
 |                        before calculating our type
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |      Cleanup the expression. This function properly deletes all children and sets the
 |      item type to cot_empty.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cexpr_t const &
 |  
 |  contains_comma(self, *args) -> 'bool'
 |      contains_comma(self, times=1) -> bool
 |      Does the expression contain a comma operator?
 |      
 |      @param times: (C++: int)
 |  
 |  contains_comma_or_insn_or_label(self, *args) -> 'bool'
 |      contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
 |      Does the expression contain a comma operator or an embedded statement operator
 |      or a label?
 |      
 |      @param maxcommas: (C++: int)
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, times=1) -> bool
 |      Does the expression contain an embedded statement operator?
 |      
 |      @param times: (C++: int)
 |  
 |  contains_insn_or_label(self, *args) -> 'bool'
 |      contains_insn_or_label(self) -> bool
 |      Does the expression contain an embedded statement operator or a label?
 |  
 |  contains_operator(self, *args) -> 'bool'
 |      contains_operator(self, needed_op, times=1) -> bool
 |      Check if the expression contains the specified operator.
 |      
 |      @param needed_op: (C++: ctype_t) operator code to search for
 |      @param times: (C++: int) how many times the operator code should be present
 |      @return: true if the expression has at least TIMES children with NEEDED_OP
 |  
 |  cpadone(self, *args) -> 'bool'
 |      cpadone(self) -> bool
 |      Pointer arithmetic correction done for this expression?
 |  
 |  equal_effect(self, *args) -> 'bool'
 |      equal_effect(self, r) -> bool
 |      Compare two expressions. This function tries to compare two expressions in an
 |      'intelligent' manner. For example, it knows about commutitive operators and can
 |      ignore useless casts.
 |      
 |      @param r: (C++: const cexpr_t &) the expression to compare against the current expression
 |      @return: true expressions can be considered equal
 |  
 |  find_num_op(self, *args) -> 'cexpr_t *'
 |      find_num_op(self) -> cexpr_t
 |  
 |  find_op(self, *args) -> 'cexpr_t *'
 |      find_op(self, _op) -> cexpr_t
 |      
 |      @param _op: enum ctype_t
 |  
 |  get_1num_op(self, *args) -> 'bool'
 |      get_1num_op(self, o1, o2) -> bool
 |      
 |      @param o1: cexpr_t **
 |      @param o2: cexpr_t **
 |  
 |  get_const_value(self, *args) -> 'bool'
 |      get_const_value(self) -> bool
 |      Get expression value.
 |      
 |      @return: true if the expression is a number.
 |  
 |  get_high_nbit_bound(self, *args) -> 'bit_bound_t'
 |      get_high_nbit_bound(self) -> bit_bound_t
 |      Get max number of bits that can really be used by the expression. For example, x
 |      % 16 can yield only 4 non-zero bits, higher bits are zero
 |  
 |  get_low_nbit_bound(self, *args) -> 'int'
 |      get_low_nbit_bound(self) -> int
 |      Get min number of bits that are certainly required to represent the expression.
 |      For example, constant 16 always uses 5 bits: 10000.
 |  
 |  get_ptr_or_array(self, *args) -> 'cexpr_t *'
 |      get_ptr_or_array(self) -> cexpr_t
 |      Find pointer or array child.
 |  
 |  get_type_sign(self, *args) -> 'type_sign_t'
 |      get_type_sign(self) -> type_sign_t
 |      Get expression sign.
 |  
 |  get_v(self, *args) -> 'var_ref_t *'
 |      get_v(self) -> var_ref_t
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self) -> bool
 |      Check if the expression has side effects. Calls, pre/post inc/dec, and
 |      assignments have side effects.
 |  
 |  is_call_arg_of(self, *args) -> 'bool'
 |      is_call_arg_of(self, parent) -> bool
 |      Is call argument?
 |      
 |      @param parent: (C++: const citem_t *) citem_t const *
 |      @return: true if our expression is a call argument of the specified parent
 |               expression.
 |  
 |  is_call_object_of(self, *args) -> 'bool'
 |      is_call_object_of(self, parent) -> bool
 |      Is call object?
 |      
 |      @param parent: (C++: const citem_t *) citem_t const *
 |      @return: true if our expression is the call object of the specified parent
 |               expression.
 |  
 |  is_child_of(self, *args) -> 'bool'
 |      is_child_of(self, parent) -> bool
 |      Verify if the specified item is our parent.
 |      
 |      @param parent: (C++: const citem_t *) possible parent item
 |      @return: true if the specified item is our parent
 |  
 |  is_const_value(self, *args) -> 'bool'
 |      is_const_value(self, _v) -> bool
 |      Check if the expression is a number with the specified value.
 |      
 |      @param _v: (C++: uint64)
 |  
 |  is_cstr(self, *args) -> 'bool'
 |      is_cstr(self) -> bool
 |  
 |  is_fpop(self, *args) -> 'bool'
 |      is_fpop(self) -> bool
 |  
 |  is_jumpout(self, *args) -> 'bool'
 |      is_jumpout(self) -> bool
 |  
 |  is_negative_const(self, *args) -> 'bool'
 |      is_negative_const(self) -> bool
 |      Check if the expression is a negative number.
 |  
 |  is_nice_cond(self, *args) -> 'bool'
 |      is_nice_cond(self) -> bool
 |      Is nice condition?. Nice condition is a nice expression of the boolean type.
 |  
 |  is_nice_expr(self, *args) -> 'bool'
 |      is_nice_expr(self) -> bool
 |      Is nice expression? Nice expressions do not contain comma operators, embedded
 |      statements, or labels.
 |  
 |  is_non_negative_const(self, *args) -> 'bool'
 |      is_non_negative_const(self) -> bool
 |      Check if the expression is a non-negative number.
 |  
 |  is_non_zero_const(self, *args) -> 'bool'
 |      is_non_zero_const(self) -> bool
 |      Check if the expression is a non-zero number.
 |  
 |  is_odd_lvalue(self, *args) -> 'bool'
 |      is_odd_lvalue(self) -> bool
 |  
 |  is_type_signed(self, *args) -> 'bool'
 |      is_type_signed(self) -> bool
 |      Is expression signed?
 |  
 |  is_type_unsigned(self, *args) -> 'bool'
 |      is_type_unsigned(self) -> bool
 |      Is expression unsigned?
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_zero_const(self, *args) -> 'bool'
 |      is_zero_const(self) -> bool
 |      Check if the expression is a zero.
 |  
 |  maybe_ptr(self, *args) -> 'bool'
 |      maybe_ptr(self) -> bool
 |      May the expression be a pointer?
 |  
 |  numval(self, *args) -> 'uint64'
 |      numval(self) -> uint64
 |      Get numeric value of the expression. This function can be called only on cot_num
 |      expressions!
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |      Print expression into one line.
 |      
 |      @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
 |                   variable names.
 |  
 |  put_number(self, *args) -> 'void'
 |      put_number(self, func, value, nbytes, sign=no_sign)
 |      Assign a number to the expression.
 |      
 |      @param func: (C++: cfunc_t *) current function
 |      @param value: (C++: uint64) number value
 |      @param nbytes: (C++: int) size of the number in bytes
 |      @param sign: (C++: type_sign_t) number sign
 |  
 |  requires_lvalue(self, *args) -> 'bool'
 |      requires_lvalue(self, child) -> bool
 |      Check if the expression requires an lvalue.
 |      
 |      @param child: (C++: const cexpr_t *) The function will check if this child of our expression must be an
 |                    lvalue.
 |      @return: true if child must be an lvalue.
 |  
 |  set_cpadone(self, *args) -> 'void'
 |      set_cpadone(self)
 |  
 |  set_v(self, *args) -> 'void'
 |      set_v(self, v)
 |      
 |      @param v: var_ref_t const *
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: cexpr_t &
 |  
 |  theother(self, *args) -> 'cexpr_t *'
 |      theother(self, what) -> cexpr_t
 |      
 |      @param what: cexpr_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  a
 |  
 |  exflags
 |      exflags
 |  
 |  fpc
 |  
 |  helper
 |  
 |  insn
 |  
 |  m
 |  
 |  n
 |  
 |  obj_ea
 |  
 |  operands
 |      return a dictionary with the operands of a cexpr_t.
 |  
 |  opname
 |  
 |  ptrsize
 |  
 |  refwidth
 |  
 |  string
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  v
 |  
 |  x
 |  
 |  y
 |  
 |  z
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  op_to_typename = {0: 'empty', 1: 'comma', 2: 'asg', 3: 'asgbor', 4: 'a...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: enum ctype_t
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |      Does the item contain an expression?
 |      
 |      @param e: (C++: const cexpr_t *) cexpr_t const *
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |      
 |      @param _ea: ea_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      
 |      @param sitem: citem_t const *
 |      
 |      find_parent_of(self, item) -> citem_t
 |      
 |      @param item: citem_t const *
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      cexpr
 |  
 |  cinsn
 |      cinsn
 |  
 |  ea
 |      ea
 |  
 |  index
 |      index
 |  
 |  label_num
 |      label_num
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on class cfor_t in module ida_hexrays:

class cfor_t(cloop_t)
 |  Proxy of C++ cfor_t class.
 |  
 |  Method resolution order:
 |      cfor_t
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cfor_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cfor_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cfor_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cfor_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cfor_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cfor_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cfor_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cfor_t(...)
 |      delete_cfor_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cfor_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  init
 |      init
 |  
 |  step
 |      step
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |      
 |      @param r: cloop_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      body
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on class cfunc_parentee_t in module ida_hexrays:

class cfunc_parentee_t(ctree_parentee_t)
 |  Proxy of C++ cfunc_parentee_t class.
 |  
 |  Method resolution order:
 |      cfunc_parentee_t
 |      ctree_parentee_t
 |      ctree_visitor_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, f, post=False) -> cfunc_parentee_t
 |      
 |      @param f: cfunc_t *
 |      @param post: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cfunc_parentee_t(...)
 |      delete_cfunc_parentee_t(self)
 |  
 |  calc_rvalue_type(self, *args) -> 'bool'
 |      calc_rvalue_type(self, target, e) -> bool
 |      Calculate rvalue type. This function tries to determine the type of the
 |      specified item based on its context. For example, if the current expression is
 |      the right side of an assignment operator, the type of its left side will be
 |      returned. This function can be used to determine the 'best' type of the
 |      specified expression.
 |      
 |      @param target: (C++: tinfo_t *) 'best' type of the expression will be returned here
 |      @param e: (C++: const cexpr_t *) expression to determine the desired type
 |      @return: false if failed
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  func
 |      func
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_parentee_t:
 |  
 |  get_block(self, *args) -> 'cblock_t *'
 |      get_block(self) -> cblock_t
 |      Get pointer to the parent block of the currently visited item. This function
 |      should be called only when the parent is a block.
 |  
 |  recalc_parent_types(self, *args) -> 'bool'
 |      recalc_parent_types(self) -> bool
 |      Recalculate type of parent nodes. If a node type has been changed, the visitor
 |      must recalculate all parent types, otherwise the ctree becomes inconsistent. If
 |      during this recalculation a parent node is added/deleted, this function returns
 |      true. In this case the traversal must be stopped because the information about
 |      parent nodes is stale.
 |      
 |      @return: false-ok to continue the traversal, true-must stop.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_visitor_t:
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, item, parent) -> int
 |      Traverse ctree. The traversal will start at the specified item and continue
 |      until of one the visit_...() functions return a non-zero value.
 |      
 |      @param item: (C++: citem_t *) root of the ctree to traverse
 |      @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
 |      @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  apply_to_exprs(self, *args) -> 'int'
 |      apply_to_exprs(self, item, parent) -> int
 |      Traverse only expressions. The traversal will start at the specified item and
 |      continue until of one the visit_...() functions return a non-zero value.
 |      
 |      @param item: (C++: citem_t *) root of the ctree to traverse
 |      @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
 |      @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  clr_prune(self, *args) -> 'void'
 |      clr_prune(self)
 |      Do not prune children. This is an internal function, no need to call it.
 |  
 |  clr_restart(self, *args) -> 'void'
 |      clr_restart(self)
 |      Do not restart. This is an internal function, no need to call it.
 |  
 |  is_postorder(self, *args) -> 'bool'
 |      is_postorder(self) -> bool
 |      Should the leave...() functions be called?
 |  
 |  leave_expr(self, *args) -> 'int'
 |      leave_expr(self, arg0) -> int
 |      Visit an expression after having visited its children. This is a visitor
 |      function which should be overridden by a derived class to do some useful work.
 |      This visitor performs post-order traserval, i.e. an item is visited after its
 |      children.
 |      
 |      @param arg0: cexpr_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  leave_insn(self, *args) -> 'int'
 |      leave_insn(self, arg0) -> int
 |      Visit a statement after having visited its children. This is a visitor function
 |      which should be overridden by a derived class to do some useful work. This
 |      visitor performs post-order traserval, i.e. an item is visited after its
 |      children.
 |      
 |      @param arg0: cinsn_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  maintain_parents(self, *args) -> 'bool'
 |      maintain_parents(self) -> bool
 |      Should the parent information by maintained?
 |  
 |  must_prune(self, *args) -> 'bool'
 |      must_prune(self) -> bool
 |      Should the traversal skip the children of the current item?
 |  
 |  must_restart(self, *args) -> 'bool'
 |      must_restart(self) -> bool
 |      Should the traversal restart?
 |  
 |  only_insns(self, *args) -> 'bool'
 |      only_insns(self) -> bool
 |      Should all expressions be automatically pruned?
 |  
 |  parent_expr(self, *args) -> 'cexpr_t *'
 |      parent_expr(self) -> cexpr_t
 |      Get parent of the current item as an expression.
 |  
 |  parent_insn(self, *args) -> 'cinsn_t *'
 |      parent_insn(self) -> cinsn_t
 |      Get parent of the current item as a statement.
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |      Prune children. This function may be called by a visitor() to skip all children
 |      of the current item.
 |  
 |  set_restart(self, *args) -> 'void'
 |      set_restart(self)
 |      Restart the travesal. Meaningful only in apply_to_exprs()
 |  
 |  visit_expr(self, *args) -> 'int'
 |      visit_expr(self, arg0) -> int
 |      Visit an expression. This is a visitor function which should be overridden by a
 |      derived class to do some useful work. This visitor performs pre-order traserval,
 |      i.e. an item is visited before its children.
 |      
 |      @param arg0: cexpr_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  visit_insn(self, *args) -> 'int'
 |      visit_insn(self, arg0) -> int
 |      Visit a statement. This is a visitor function which should be overridden by a
 |      derived class to do some useful work. This visitor performs pre-order traserval,
 |      i.e. an item is visited before its children.
 |      
 |      @param arg0: cinsn_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctree_visitor_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      cv_flags
 |  
 |  parents
 |      parents

Help on class cfunc_t in module ida_hexrays:

class cfunc_t(builtins.object)
 |  Proxy of C++ cfunc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'qstring'
 |      __str__(self) -> qstring
 |  
 |  __swig_destroy__ = delete_cfunc_t(...)
 |      delete_cfunc_t(self)
 |  
 |  build_c_tree(self, *args) -> 'void'
 |      build_c_tree(self)
 |      Generate the function body. This function (re)generates the function body from
 |      the underlying microcode.
 |  
 |  del_orphan_cmts(self, *args) -> 'int'
 |      del_orphan_cmts(self) -> int
 |      Delete all orphan comments. The save_user_cmts() function must be called after
 |      this call.
 |  
 |  find_item_coords(self, *args) -> 'PyObject *'
 |      find_item_coords(self, item, px, py) -> bool
 |      
 |      @param item: citem_t const *
 |      @param px: int *
 |      @param py: int *
 |      
 |      find_item_coords(self, item) -> PyObject *
 |      
 |      @param item: citem_t const *
 |  
 |  find_label(self, *args) -> 'citem_t *'
 |      find_label(self, label) -> citem_t
 |      Find the label.
 |      
 |      @param label: (C++: int)
 |      @return: pointer to the ctree item with the specified label number.
 |  
 |  gather_derefs(self, *args) -> 'bool'
 |      gather_derefs(self, ci, udm=None) -> bool
 |      
 |      @param ci: ctree_item_t const &
 |      @param udm: udt_type_data_t *
 |  
 |  get_boundaries(self, *args) -> 'boundaries_t &'
 |      get_boundaries(self) -> boundaries_t
 |      Get pointer to map of instruction boundaries. This function initializes the
 |      boundary map if not done yet.
 |  
 |  get_eamap(self, *args) -> 'eamap_t &'
 |      get_eamap(self) -> eamap_t
 |      Get pointer to ea->insn map. This function initializes eamap if not done yet.
 |  
 |  get_func_type(self, *args) -> 'bool'
 |      get_func_type(self, type) -> bool
 |      Get the function type.
 |      
 |      @param type: (C++: tinfo_t *) variable where the function type is returned
 |      @return: false if failure
 |  
 |  get_line_item(self, *args) -> 'bool'
 |      get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
 |      Get ctree item for the specified cursor position.
 |      
 |      @param line: (C++: const char *) line of decompilation text (element of sv)
 |      @param x: (C++: int) x cursor coordinate in the line
 |      @param is_ctree_line: (C++: bool) does the line belong to statement area? (if not, it is
 |                            assumed to belong to the declaration area)
 |      @param phead: (C++: ctree_item_t *) ptr to the first item on the line (used to attach block comments).
 |                    May be nullptr
 |      @param pitem: (C++: ctree_item_t *) ptr to the current item. May be nullptr
 |      @param ptail: (C++: ctree_item_t *) ptr to the last item on the line (used to attach indented
 |                    comments). May be nullptr
 |      @see: vdui_t::get_current_item()
 |      @return: false if failed to get the current item
 |  
 |  get_lvars(self, *args) -> 'lvars_t *'
 |      get_lvars(self) -> lvars_t
 |      Get vector of local variables.
 |      
 |      @return: pointer to the vector of local variables. If you modify this vector,
 |               the ctree must be regenerated in order to have correct cast operators.
 |               Use build_c_tree() for that. Removing lvars should be done carefully:
 |               all references in ctree and microcode must be corrected after that.
 |  
 |  get_pseudocode(self, *args) -> 'strvec_t const &'
 |      get_pseudocode(self) -> strvec_t
 |      Get pointer to decompilation output: the pseudocode. This function generates
 |      pseudocode if not done yet.
 |  
 |  get_stkoff_delta(self, *args) -> 'sval_t'
 |      get_stkoff_delta(self) -> sval_t
 |      Get stack offset delta. The local variable stack offsets retrieved by
 |      v.location.stkoff() should be adjusted before being used as stack frame offsets
 |      in IDA.
 |      
 |      @return: the delta to apply. example: ida_stkoff = v.location.stkoff() -
 |               f->get_stkoff_delta()
 |  
 |  get_user_cmt(self, *args) -> 'char const *'
 |      get_user_cmt(self, loc, rt) -> char const *
 |      Retrieve a user defined comment.
 |      
 |      @param loc: (C++: const treeloc_t &) ctree location
 |      @param rt: (C++: cmt_retrieval_type_t) should already retrieved comments retrieved again?
 |      @return: pointer to the comment string or nullptr
 |  
 |  get_user_iflags(self, *args) -> 'int32'
 |      get_user_iflags(self, loc) -> int32
 |      Retrieve citem iflags.
 |      
 |      @param loc: (C++: const citem_locator_t &) citem locator
 |      @return: ctree item iflags bits or 0
 |  
 |  get_user_union_selection(self, *args) -> 'bool'
 |      get_user_union_selection(self, ea, path) -> bool
 |      Retrieve a user defined union field selection.
 |      
 |      @param ea: (C++: ea_t) address
 |      @param path: (C++: intvec_t *) out: path describing the union selection.
 |      @return: pointer to the path or nullptr
 |  
 |  get_warnings(self, *args) -> 'hexwarns_t &'
 |      get_warnings(self) -> hexwarns_t
 |      Get information about decompilation warnings.
 |      
 |      @return: reference to the vector of warnings
 |  
 |  has_orphan_cmts(self, *args) -> 'bool'
 |      has_orphan_cmts(self) -> bool
 |      Check if there are orphan comments.
 |  
 |  locked(self, *args) -> 'bool'
 |      locked(self) -> bool
 |  
 |  print_dcl(self, *args) -> 'void'
 |      print_dcl(self)
 |      Print function prototype.
 |  
 |  print_func(self, *args) -> 'void'
 |      print_func(self, vp)
 |      Print function text.
 |      
 |      @param vp: (C++: vc_printer_t &) printer helper class to receive the generated text.
 |  
 |  refresh_func_ctext(self, *args) -> 'void'
 |      refresh_func_ctext(self)
 |      Refresh ctext after a ctree modification. This function informs the decompiler
 |      that ctree (body) have been modified and ctext (sv) does not correspond to it
 |      anymore. It also refreshes the pseudocode windows if there is any.
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |  
 |  remove_unused_labels(self, *args) -> 'void'
 |      remove_unused_labels(self)
 |      Remove unused labels. This function checks what labels are really used by the
 |      function and removes the unused ones. You must call it after deleting a goto
 |      statement.
 |  
 |  save_user_cmts(self, *args) -> 'void'
 |      save_user_cmts(self)
 |      Save user-defined comments into the database.
 |  
 |  save_user_iflags(self, *args) -> 'void'
 |      save_user_iflags(self)
 |      Save user-defined iflags into the database.
 |  
 |  save_user_labels(self, *args) -> 'void'
 |      save_user_labels(self)
 |      Save user-defined labels into the database.
 |  
 |  save_user_numforms(self, *args) -> 'void'
 |      save_user_numforms(self)
 |      Save user-defined number formats into the database.
 |  
 |  save_user_unions(self, *args) -> 'void'
 |      save_user_unions(self)
 |      Save user-defined union field selections into the database.
 |  
 |  set_user_cmt(self, *args) -> 'void'
 |      set_user_cmt(self, loc, cmt)
 |      Set a user defined comment. This function stores the specified comment in the
 |      cfunc_t structure. The save_user_cmts() function must be called after it.
 |      
 |      @param loc: (C++: const treeloc_t &) ctree location
 |      @param cmt: (C++: const char *) new comment. if empty or nullptr, then an existing comment is
 |                  deleted.
 |  
 |  set_user_iflags(self, *args) -> 'void'
 |      set_user_iflags(self, loc, iflags)
 |      Set citem iflags.
 |      
 |      @param loc: (C++: const citem_locator_t &) citem locator
 |      @param iflags: (C++: int32) new iflags
 |  
 |  set_user_union_selection(self, *args) -> 'void'
 |      set_user_union_selection(self, ea, path)
 |      Set a union field selection. The save_user_unions() function must be called
 |      after calling this function.
 |      
 |      @param ea: (C++: ea_t) address
 |      @param path: (C++: const intvec_t &) in: path describing the union selection.
 |  
 |  verify(self, *args) -> 'void'
 |      verify(self, aul, even_without_debugger)
 |      Verify the ctree. This function verifies the ctree. If the ctree is malformed,
 |      an internal error is generated. Use it to verify the ctree after your
 |      modifications.
 |      
 |      @param aul: (C++: allow_unused_labels_t) Are unused labels acceptable?
 |      @param even_without_debugger: (C++: bool) if false and there is no debugger, the
 |                                    verification will be skipped
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argidx
 |      argidx
 |  
 |  arguments
 |  
 |  body
 |      body
 |  
 |  boundaries
 |      get_boundaries(self) -> boundaries_t
 |      Get pointer to map of instruction boundaries. This function initializes the
 |      boundary map if not done yet.
 |  
 |  eamap
 |      get_eamap(self) -> eamap_t
 |      Get pointer to ea->insn map. This function initializes eamap if not done yet.
 |  
 |  entry_ea
 |      entry_ea
 |  
 |  hdrlines
 |      hdrlines
 |  
 |  lvars
 |      get_lvars(self) -> lvars_t
 |      Get vector of local variables.
 |      
 |      @return: pointer to the vector of local variables. If you modify this vector,
 |               the ctree must be regenerated in order to have correct cast operators.
 |               Use build_c_tree() for that. Removing lvars should be done carefully:
 |               all references in ctree and microcode must be corrected after that.
 |  
 |  maturity
 |      maturity
 |  
 |  mba
 |      mba
 |  
 |  numforms
 |      numforms
 |  
 |  pseudocode
 |      get_pseudocode(self) -> strvec_t
 |      Get pointer to decompilation output: the pseudocode. This function generates
 |      pseudocode if not done yet.
 |  
 |  refcnt
 |      refcnt
 |  
 |  statebits
 |      statebits
 |  
 |  thisown
 |      The membership flag
 |  
 |  treeitems
 |      treeitems
 |  
 |  type
 |      Get the function's return type tinfo_t object.
 |  
 |  user_cmts
 |      user_cmts
 |  
 |  user_iflags
 |      user_iflags
 |  
 |  user_labels
 |      user_labels
 |  
 |  user_unions
 |      user_unions
 |  
 |  warnings
 |      get_warnings(self) -> hexwarns_t
 |      Get information about decompilation warnings.
 |      
 |      @return: reference to the vector of warnings

Help on function cfunc_type in module ida_hexrays:

cfunc_type(self)
    Get the function's return type tinfo_t object.

Help on class cfuncptr_t in module ida_hexrays:

class cfuncptr_t(builtins.object)
 |  Proxy of C++ qrefcnt_t< cfunc_t > class.
 |  
 |  Methods defined here:
 |  
 |  __deref__(self, *args) -> 'cfunc_t *'
 |      __deref__(self) -> cfunc_t
 |  
 |  __eq__ lambda self, other
 |  
 |  __init__(self, *args)
 |      __init__(self, p) -> cfuncptr_t
 |      
 |      @param p: cfunc_t *
 |      
 |      __init__(self, r) -> cfuncptr_t
 |      
 |      @param r: qrefcnt_t< cfunc_t > const &
 |  
 |  __ptrval__(self, *args) -> 'size_t'
 |      __ptrval__(self) -> size_t
 |  
 |  __ref__(self, *args) -> 'cfunc_t &'
 |      __ref__(self) -> cfunc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__ lambda self
 |  
 |  __swig_destroy__ = delete_cfuncptr_t(...)
 |      delete_cfuncptr_t(self)
 |  
 |  build_c_tree(self, *args) -> 'void'
 |      build_c_tree(self)
 |  
 |  del_orphan_cmts(self, *args) -> 'int'
 |      del_orphan_cmts(self) -> int
 |  
 |  find_item_coords(self, *args) -> 'PyObject *'
 |      find_item_coords(self, item, px, py) -> bool
 |      
 |      @param item: citem_t const *
 |      @param px: int *
 |      @param py: int *
 |      
 |      find_item_coords(self, item) -> (int, int), bool
 |      
 |      @param item: citem_t const *
 |  
 |  find_label(self, *args) -> 'citem_t *'
 |      find_label(self, label) -> citem_t
 |      
 |      @param label: int
 |  
 |  gather_derefs(self, *args) -> 'bool'
 |      gather_derefs(self, ci, udm=None) -> bool
 |      
 |      @param ci: ctree_item_t const &
 |      @param udm: udt_type_data_t *
 |  
 |  get_boundaries(self, *args) -> 'boundaries_t &'
 |      get_boundaries(self) -> boundaries_t
 |  
 |  get_eamap(self, *args) -> 'eamap_t &'
 |      get_eamap(self) -> eamap_t
 |  
 |  get_func_type(self, *args) -> 'bool'
 |      get_func_type(self, type) -> bool
 |      
 |      @param type: tinfo_t *
 |  
 |  get_line_item(self, *args) -> 'bool'
 |      get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
 |      
 |      @param line: char const *
 |      @param x: int
 |      @param is_ctree_line: bool
 |      @param phead: ctree_item_t *
 |      @param pitem: ctree_item_t *
 |      @param ptail: ctree_item_t *
 |  
 |  get_lvars(self, *args) -> 'lvars_t *'
 |      get_lvars(self) -> lvars_t
 |  
 |  get_pseudocode(self, *args) -> 'strvec_t const &'
 |      get_pseudocode(self) -> strvec_t
 |  
 |  get_stkoff_delta(self, *args) -> 'sval_t'
 |      get_stkoff_delta(self) -> sval_t
 |  
 |  get_user_cmt(self, *args) -> 'char const *'
 |      get_user_cmt(self, loc, rt) -> char const *
 |      
 |      @param loc: treeloc_t const &
 |      @param rt: enum cmt_retrieval_type_t
 |  
 |  get_user_iflags(self, *args) -> 'int32'
 |      get_user_iflags(self, loc) -> int32
 |      
 |      @param loc: citem_locator_t const &
 |  
 |  get_user_union_selection(self, *args) -> 'bool'
 |      get_user_union_selection(self, ea, path) -> bool
 |      
 |      @param ea: ea_t
 |      @param path: intvec_t *
 |  
 |  get_warnings(self, *args) -> 'hexwarns_t &'
 |      get_warnings(self) -> hexwarns_t
 |  
 |  has_orphan_cmts(self, *args) -> 'bool'
 |      has_orphan_cmts(self) -> bool
 |  
 |  locked(self, *args) -> 'bool'
 |      locked(self) -> bool
 |  
 |  print_dcl(self, *args) -> 'void'
 |      print_dcl(self)
 |  
 |  print_func(self, *args) -> 'void'
 |      print_func(self, vp)
 |      
 |      @param vp: vc_printer_t &
 |  
 |  refresh_func_ctext(self, *args) -> 'void'
 |      refresh_func_ctext(self)
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |  
 |  remove_unused_labels(self, *args) -> 'void'
 |      remove_unused_labels(self)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  save_user_cmts(self, *args) -> 'void'
 |      save_user_cmts(self)
 |  
 |  save_user_iflags(self, *args) -> 'void'
 |      save_user_iflags(self)
 |  
 |  save_user_labels(self, *args) -> 'void'
 |      save_user_labels(self)
 |  
 |  save_user_numforms(self, *args) -> 'void'
 |      save_user_numforms(self)
 |  
 |  save_user_unions(self, *args) -> 'void'
 |      save_user_unions(self)
 |  
 |  set_user_cmt(self, *args) -> 'void'
 |      set_user_cmt(self, loc, cmt)
 |      
 |      @param loc: treeloc_t const &
 |      @param cmt: char const *
 |  
 |  set_user_iflags(self, *args) -> 'void'
 |      set_user_iflags(self, loc, iflags)
 |      
 |      @param loc: citem_locator_t const &
 |      @param iflags: int32
 |  
 |  set_user_union_selection(self, *args) -> 'void'
 |      set_user_union_selection(self, ea, path)
 |      
 |      @param ea: ea_t
 |      @param path: intvec_t const &
 |  
 |  verify(self, *args) -> 'void'
 |      verify(self, aul, even_without_debugger)
 |      
 |      @param aul: enum allow_unused_labels_t
 |      @param even_without_debugger: bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argidx
 |      argidx
 |  
 |  arguments
 |  
 |  body
 |      body
 |  
 |  boundaries
 |  
 |  eamap
 |  
 |  entry_ea
 |      entry_ea
 |  
 |  hdrlines
 |      hdrlines
 |  
 |  lvars
 |  
 |  maturity
 |      maturity
 |  
 |  mba
 |      mba
 |  
 |  numforms
 |      numforms
 |  
 |  pseudocode
 |  
 |  refcnt
 |      refcnt
 |  
 |  statebits
 |      statebits
 |  
 |  thisown
 |      The membership flag
 |  
 |  treeitems
 |      treeitems
 |  
 |  type
 |  
 |  user_cmts
 |      user_cmts
 |  
 |  user_iflags
 |      user_iflags
 |  
 |  user_labels
 |      user_labels
 |  
 |  user_unions
 |      user_unions
 |  
 |  warnings

Help on class cgoto_t in module ida_hexrays:

class cgoto_t(builtins.object)
 |  Proxy of C++ cgoto_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cgoto_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cgoto_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cgoto_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cgoto_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cgoto_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cgoto_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cgoto_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cgoto_t(...)
 |      delete_cgoto_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cgoto_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  label_num
 |      label_num
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class chain_keeper_t in module ida_hexrays:

class chain_keeper_t(builtins.object)
 |  Proxy of C++ chain_keeper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _gc) -> chain_keeper_t
 |      
 |      @param _gc: graph_chains_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chain_keeper_t(...)
 |      delete_chain_keeper_t(self)
 |  
 |  back(self, *args) -> 'block_chains_t &'
 |      back(self) -> block_chains_t
 |  
 |  for_all_chains(self, *args) -> 'int'
 |      for_all_chains(self, cv, gca) -> int
 |      
 |      @param cv: chain_visitor_t &
 |      @param gca: int
 |  
 |  front(self, *args) -> 'block_chains_t &'
 |      front(self) -> block_chains_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class chain_t in module ida_hexrays:

class chain_t(ida_pro.intvec_t)
 |  Proxy of C++ chain_t class.
 |  
 |  Method resolution order:
 |      chain_t
 |      ida_pro.intvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chain_t
 |      __init__(self, t, off, w=1, v=-1) -> chain_t
 |      
 |      @param t: mopt_t
 |      @param off: sval_t
 |      @param w: int
 |      @param v: int
 |      
 |      __init__(self, _k, w=1) -> chain_t
 |      
 |      @param _k: voff_t const &
 |      @param w: int
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: chain_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chain_t(...)
 |      delete_chain_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  append_list(self, *args) -> 'void'
 |      append_list(self, mba, list)
 |      Append the contents of the chain to the specified list of locations.
 |      
 |      @param mba: (C++: const mba_t *) mba_t const *
 |      @param list: (C++: mlist_t *)
 |  
 |  clear_varnum(self, *args) -> 'void'
 |      clear_varnum(self)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  endoff(self, *args) -> 'voff_t const'
 |      endoff(self) -> voff_t
 |  
 |  get_reg(self, *args) -> 'mreg_t'
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, r) -> bool
 |      
 |      @param r: chain_t const &
 |  
 |  is_fake(self, *args) -> 'bool'
 |      is_fake(self) -> bool
 |  
 |  is_inited(self, *args) -> 'bool'
 |      is_inited(self) -> bool
 |  
 |  is_overlapped(self, *args) -> 'bool'
 |      is_overlapped(self) -> bool
 |  
 |  is_passreg(self, *args) -> 'bool'
 |      is_passreg(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_replaced(self, *args) -> 'bool'
 |      is_replaced(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  is_term(self, *args) -> 'bool'
 |      is_term(self) -> bool
 |  
 |  key(self, *args) -> 'voff_t const &'
 |      key(self) -> voff_t
 |  
 |  overlap(self, *args) -> 'bool'
 |      overlap(self, r) -> bool
 |      
 |      @param r: chain_t const &
 |  
 |  set_inited(self, *args) -> 'void'
 |      set_inited(self, b)
 |      
 |      @param b: bool
 |  
 |  set_overlapped(self, *args) -> 'void'
 |      set_overlapped(self, b)
 |      
 |      @param b: bool
 |  
 |  set_replaced(self, *args) -> 'void'
 |      set_replaced(self, b)
 |      
 |      @param b: bool
 |  
 |  set_term(self, *args) -> 'void'
 |      set_term(self, b)
 |      
 |      @param b: bool
 |  
 |  set_value(self, *args) -> 'void'
 |      set_value(self, r)
 |      
 |      @param r: chain_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      flags
 |  
 |  thisown
 |      The membership flag
 |  
 |  varnum
 |      varnum
 |  
 |  width
 |      width
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_pro.intvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< int > const &
 |  
 |  __getitem__(self, *args) -> 'int const &'
 |      __getitem__(self, i) -> int const &
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< int > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: int const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: int const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: int const &
 |  
 |  append = push_back(self, *args) -> 'int &'
 |      push_back(self, x)
 |      
 |      @param x: int const &
 |      
 |      push_back(self) -> int &
 |  
 |  at = __getitem__(self, *args) -> 'int const &'
 |      __getitem__(self, i) -> int const &
 |      
 |      @param i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< int >::const_iterator'
 |      begin(self) -> qvector< int >::iterator
 |      begin(self) -> qvector< int >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< int >::const_iterator'
 |      end(self) -> qvector< int >::iterator
 |      end(self) -> qvector< int >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< int >::iterator'
 |      erase(self, it) -> qvector< int >::iterator
 |      
 |      @param it: qvector< int >::iterator
 |      
 |      erase(self, first, last) -> qvector< int >::iterator
 |      
 |      @param first: qvector< int >::iterator
 |      @param last: qvector< int >::iterator
 |  
 |  extract(self, *args) -> 'int *'
 |      extract(self) -> int *
 |  
 |  find(self, *args) -> 'qvector< int >::const_iterator'
 |      find(self, x) -> qvector< int >::iterator
 |      
 |      @param x: int const &
 |      
 |      find(self, x) -> qvector< int >::const_iterator
 |      
 |      @param x: int const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: int const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: int *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< int >::iterator'
 |      insert(self, it, x) -> qvector< int >::iterator
 |      
 |      @param it: qvector< int >::iterator
 |      @param x: int const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'int &'
 |      push_back(self, x)
 |      
 |      @param x: int const &
 |      
 |      push_back(self) -> int &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: int const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< int > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_pro.intvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_pro.intvec_t:
 |  
 |  __hash__ = None

Help on class chain_visitor_t in module ida_hexrays:

class chain_visitor_t(builtins.object)
 |  Proxy of C++ chain_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chain_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chain_visitor_t(...)
 |      delete_chain_visitor_t(self)
 |  
 |  visit_chain(self, *args) -> 'int'
 |      visit_chain(self, nblock, ch) -> int
 |      
 |      @param nblock: int
 |      @param ch: chain_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  parent
 |      parent
 |  
 |  thisown
 |      The membership flag

Help on function checkout_hexrays_license in module ida_hexrays:

checkout_hexrays_license(*args) -> 'bool'
    checkout_hexrays_license(silent) -> bool
    Check out a floating decompiler license. This function will display a dialog box
    if the license is not available. For non-floating licenses this function is
    effectively no-op. It is not necessary to call this function before decompiling.
    If the license was not checked out, the decompiler will automatically do it.
    This function can be used to check out a license in advance and ensure that a
    license is available.
    
    @param silent: (C++: bool) silently fail if the license cannot be checked out.
    @return: false if failed

Help on class cif_t in module ida_hexrays:

class cif_t(ceinsn_t)
 |  Proxy of C++ cif_t class.
 |  
 |  Method resolution order:
 |      cif_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cif_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cif_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cif_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cif_t
 |      __init__(self, r) -> cif_t
 |      
 |      @param r: cif_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cif_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cif_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cif_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cif_t(...)
 |      delete_cif_t(self)
 |  
 |  assign(self, *args) -> 'cif_t &'
 |      assign(self, r) -> cif_t
 |      
 |      @param r: cif_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cif_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ielse
 |      ielse
 |  
 |  ithen
 |      ithen
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on function cinsn_details in module ida_hexrays:

cinsn_details(self)
    return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.

Help on class cinsn_list_t in module ida_hexrays:

class cinsn_list_t(builtins.object)
 |  Proxy of C++ qlist< cinsn_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, x) -> bool
 |      
 |      @param x: qlist< cinsn_t > const &
 |  
 |  __getitem__(self, *args) -> 'cinsn_t const &'
 |      __getitem__(self, i) -> cinsn_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsn_list_t
 |      __init__(self, x) -> cinsn_list_t
 |      
 |      @param x: qlist< cinsn_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, x) -> bool
 |      
 |      @param x: qlist< cinsn_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: cinsn_t const &
 |  
 |  __swig_destroy__ = delete_cinsn_list_t(...)
 |      delete_cinsn_list_t(self)
 |  
 |  at(self, index)
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'cinsn_list_t_iterator'
 |      begin(self) -> cinsn_list_t_iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'cinsn_list_t_iterator'
 |      end(self) -> cinsn_list_t_iterator
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self, p)
 |      
 |      @param p: cinsn_list_t_iterator
 |  
 |  find(self, item)
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  index(self, item)
 |  
 |  insert(self, *args) -> 'cinsn_list_t_iterator'
 |      insert(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: cinsn_t const &
 |      
 |      insert(self, p, x) -> cinsn_list_t_iterator
 |      
 |      @param p: cinsn_list_t_iterator
 |      @param x: cinsn_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  pop_front(self, *args) -> 'void'
 |      pop_front(self)
 |  
 |  push_back(self, *args) -> 'cinsn_t &'
 |      push_back(self, x)
 |      
 |      @param x: cinsn_t const &
 |      
 |      push_back(self) -> cinsn_t
 |  
 |  push_front(self, *args) -> 'void'
 |      push_front(self, x)
 |      
 |      @param x: cinsn_t const &
 |  
 |  rbegin(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rbegin(self) -> qlist< cinsn_t >::reverse_iterator
 |      rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self, v) -> bool
 |      
 |      @param v: cinsn_t const &
 |  
 |  rend(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator'
 |      rend(self) -> qlist< cinsn_t >::reverse_iterator
 |      rend(self) -> qlist< cinsn_t >::const_reverse_iterator
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, x)
 |      
 |      @param x: qlist< cinsn_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class cinsn_list_t_iterator in module ida_hexrays:

class cinsn_list_t_iterator(builtins.object)
 |  Proxy of C++ cinsn_list_t_iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, x) -> bool
 |      
 |      @param x: cinsn_list_t_iterator const *
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsn_list_t_iterator
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, x) -> bool
 |      
 |      @param x: cinsn_list_t_iterator const *
 |  
 |  __next__(self, *args) -> 'void'
 |      __next__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cinsn_list_t_iterator(...)
 |      delete_cinsn_list_t_iterator(self)
 |  
 |  next = __next__(self, *args) -> 'void'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cur
 |      cur
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class cinsn_t in module ida_hexrays:

class cinsn_t(citem_t)
 |  Proxy of C++ cinsn_t class.
 |  
 |  Method resolution order:
 |      cinsn_t
 |      citem_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cinsn_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cinsn_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cinsn_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsn_t
 |      __init__(self, r) -> cinsn_t
 |      
 |      @param r: cinsn_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cinsn_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cinsn_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cinsn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cinsn_t(...)
 |      delete_cinsn_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _get_casm(self, *args) -> 'casm_t *'
 |      _get_casm(self) -> casm_t
 |  
 |  _get_cblock(self, *args) -> 'cblock_t *'
 |      _get_cblock(self) -> cblock_t
 |  
 |  _get_cdo(self, *args) -> 'cdo_t *'
 |      _get_cdo(self) -> cdo_t
 |  
 |  _get_cexpr(self, *args) -> 'cexpr_t *'
 |      _get_cexpr(self) -> cexpr_t
 |  
 |  _get_cfor(self, *args) -> 'cfor_t *'
 |      _get_cfor(self) -> cfor_t
 |  
 |  _get_cgoto(self, *args) -> 'cgoto_t *'
 |      _get_cgoto(self) -> cgoto_t
 |  
 |  _get_cif(self, *args) -> 'cif_t *'
 |      _get_cif(self) -> cif_t
 |  
 |  _get_creturn(self, *args) -> 'creturn_t *'
 |      _get_creturn(self) -> creturn_t
 |  
 |  _get_cswitch(self, *args) -> 'cswitch_t *'
 |      _get_cswitch(self) -> cswitch_t
 |  
 |  _get_cwhile(self, *args) -> 'cwhile_t *'
 |      _get_cwhile(self) -> cwhile_t
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
 |      
 |      Parameters
 |      ----------
 |      indent: int
 |      vp: vc_printer_t &
 |      use_curly: enum use_curly_t
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _replace_by(self, *args) -> 'void'
 |      _replace_by(self, r)
 |      
 |      Parameters
 |      ----------
 |      r: cinsn_t *
 |  
 |  _set_casm(self, *args) -> 'void'
 |      _set_casm(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: casm_t *
 |  
 |  _set_cblock(self, *args) -> 'void'
 |      _set_cblock(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cblock_t *
 |  
 |  _set_cdo(self, *args) -> 'void'
 |      _set_cdo(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cdo_t *
 |  
 |  _set_cexpr(self, *args) -> 'void'
 |      _set_cexpr(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cexpr_t *
 |  
 |  _set_cfor(self, *args) -> 'void'
 |      _set_cfor(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cfor_t *
 |  
 |  _set_cgoto(self, *args) -> 'void'
 |      _set_cgoto(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cgoto_t *
 |  
 |  _set_cif(self, *args) -> 'void'
 |      _set_cif(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cif_t *
 |  
 |  _set_creturn(self, *args) -> 'void'
 |      _set_creturn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: creturn_t *
 |  
 |  _set_cswitch(self, *args) -> 'void'
 |      _set_cswitch(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cswitch_t *
 |  
 |  _set_cwhile(self, *args) -> 'void'
 |      _set_cwhile(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: cwhile_t *
 |  
 |  assign(self, *args) -> 'cinsn_t &'
 |      assign(self, r) -> cinsn_t
 |      
 |      @param r: cinsn_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |      Cleanup the statement. This function properly deletes all children and sets the
 |      item type to cit_empty.
 |  
 |  collect_free_breaks(self, *args) -> 'bool'
 |      collect_free_breaks(self, breaks) -> bool
 |      Collect free break statements. This function finds all free break statements
 |      within the current statement. A break statement is free if it does not have a
 |      loop or switch parent that that is also within the current statement.
 |      
 |      @param breaks: (C++: cinsnptrvec_t *) pointer to the variable where the vector of all found free break
 |                     statements is returned. This argument can be nullptr.
 |      @return: true if some free break statements have been found
 |  
 |  collect_free_continues(self, *args) -> 'bool'
 |      collect_free_continues(self, continues) -> bool
 |      Collect free continue statements. This function finds all free continue
 |      statements within the current statement. A continue statement is free if it does
 |      not have a loop parent that that is also within the current statement.
 |      
 |      @param continues: (C++: cinsnptrvec_t *) pointer to the variable where the vector of all found free
 |                        continue statements is returned. This argument can be nullptr.
 |      @return: true if some free continue statements have been found
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cinsn_t const &
 |  
 |  contains_free_break(self, *args) -> 'bool'
 |      contains_free_break(self) -> bool
 |      Check if the statement has free break statements.
 |  
 |  contains_free_continue(self, *args) -> 'bool'
 |      contains_free_continue(self) -> bool
 |      Check if the statement has free continue statements.
 |  
 |  contains_insn(self, *args) -> 'bool'
 |      contains_insn(self, type, times=1) -> bool
 |      Check if the statement contains a statement of the specified type.
 |      
 |      @param type: (C++: ctype_t) statement opcode to look for
 |      @param times: (C++: int) how many times TYPE should be present
 |      @return: true if the statement has at least TIMES children with opcode == TYPE
 |  
 |  create_if(self, *args) -> 'cif_t &'
 |      create_if(self, cnd) -> cif_t
 |      Create a new if-statement. The current statement must be a block. The new
 |      statement will be appended to it.
 |      
 |      @param cnd: (C++: cexpr_t *) if condition. It will be deleted after being copied.
 |  
 |  is_epilog(self)
 |  
 |  is_ordinary_flow(self, *args) -> 'bool'
 |      is_ordinary_flow(self) -> bool
 |      Check if the statement passes execution to the next statement.
 |      
 |      @return: false if the statement breaks the control flow (like goto, return, etc)
 |  
 |  new_insn(self, *args) -> 'cinsn_t &'
 |      new_insn(self, insn_ea) -> cinsn_t
 |      Create a new statement. The current statement must be a block. The new statement
 |      will be appended to it.
 |      
 |      @param insn_ea: (C++: ea_t) statement address
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |      Print the statement into one line. Currently this function is not available.
 |      
 |      @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
 |                   variable names.
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: cinsn_t &
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |      Overwrite with zeroes without cleaning memory or deleting children.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  insn_is_epilog(*args) -> 'bool'
 |      insn_is_epilog(insn) -> bool
 |      
 |      @param insn: cinsn_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  casm
 |  
 |  cblock
 |  
 |  cdo
 |  
 |  cexpr
 |  
 |  cfor
 |  
 |  cgoto
 |  
 |  cif
 |  
 |  creturn
 |  
 |  cswitch
 |  
 |  cwhile
 |  
 |  details
 |      return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
 |  
 |  opname
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  op_to_typename = {70: 'empty', 71: 'block', 72: 'expr', 73: 'if', 74: ...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from citem_t:
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: enum ctype_t
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |      Does the item contain an expression?
 |      
 |      @param e: (C++: const cexpr_t *) cexpr_t const *
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |      
 |      @param _ea: ea_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      
 |      @param sitem: citem_t const *
 |      
 |      find_parent_of(self, item) -> citem_t
 |      
 |      @param item: citem_t const *
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |      Is an expression?
 |  
 |  replace_by(self, o)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from citem_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cinsn
 |      cinsn
 |  
 |  ea
 |      ea
 |  
 |  index
 |      index
 |  
 |  label_num
 |      label_num
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function cinsn_t_insn_is_epilog in module ida_hexrays:

cinsn_t_insn_is_epilog(*args) -> 'bool'
    cinsn_t_insn_is_epilog(insn) -> bool
    
    @param insn: cinsn_t const *

Help on class cinsnptrvec_t in module ida_hexrays:

class cinsnptrvec_t(builtins.object)
 |  Proxy of C++ qvector< cinsn_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< cinsn_t * > const &
 |  
 |  __getitem__(self, *args) -> 'cinsn_t *const &'
 |      __getitem__(self, i) -> cinsn_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cinsnptrvec_t
 |      __init__(self, x) -> cinsnptrvec_t
 |      
 |      @param x: qvector< cinsn_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< cinsn_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: cinsn_t *const &
 |  
 |  __swig_destroy__ = delete_cinsnptrvec_t(...)
 |      delete_cinsnptrvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: cinsn_t *const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: cinsn_t *const &
 |  
 |  append = push_back(self, *args) -> 'cinsn_t *&'
 |  
 |  at = __getitem__(self, *args) -> 'cinsn_t *const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< cinsn_t * >::const_iterator'
 |      begin(self) -> qvector< cinsn_t * >::iterator
 |      begin(self) -> qvector< cinsn_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< cinsn_t * >::const_iterator'
 |      end(self) -> qvector< cinsn_t * >::iterator
 |      end(self) -> qvector< cinsn_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< cinsn_t * >::iterator'
 |      erase(self, it) -> qvector< cinsn_t * >::iterator
 |      
 |      @param it: qvector< cinsn_t * >::iterator
 |      
 |      erase(self, first, last) -> qvector< cinsn_t * >::iterator
 |      
 |      @param first: qvector< cinsn_t * >::iterator
 |      @param last: qvector< cinsn_t * >::iterator
 |  
 |  extract(self, *args) -> 'cinsn_t **'
 |      extract(self) -> cinsn_t **
 |  
 |  find(self, *args) -> 'qvector< cinsn_t * >::const_iterator'
 |      find(self, x) -> qvector< cinsn_t * >::iterator
 |      
 |      @param x: cinsn_t *const &
 |      
 |      find(self, x) -> qvector< cinsn_t * >::const_iterator
 |      
 |      @param x: cinsn_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: cinsn_t *const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: cinsn_t **
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< cinsn_t * >::iterator'
 |      insert(self, it, x) -> qvector< cinsn_t * >::iterator
 |      
 |      @param it: qvector< cinsn_t * >::iterator
 |      @param x: cinsn_t *const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'cinsn_t *&'
 |      push_back(self, x)
 |      
 |      @param x: cinsn_t *const &
 |      
 |      push_back(self) -> cinsn_t *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: cinsn_t *const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< cinsn_t * > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class citem_cmt_t in module ida_hexrays:

class citem_cmt_t(builtins.object)
 |  Proxy of C++ citem_cmt_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> citem_cmt_t
 |      __init__(self, s) -> citem_cmt_t
 |      
 |      @param s: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'char const *'
 |      __str__(self) -> char const *
 |  
 |  __swig_destroy__ = delete_citem_cmt_t(...)
 |      delete_citem_cmt_t(self)
 |  
 |  c_str(self, *args) -> 'char const *'
 |      c_str(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  used
 |      used

Help on class citem_locator_t in module ida_hexrays:

class citem_locator_t(builtins.object)
 |  Proxy of C++ citem_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: citem_locator_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: citem_locator_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: citem_locator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea, _op) -> citem_locator_t
 |      
 |      @param _ea: ea_t
 |      @param _op: enum ctype_t
 |      
 |      __init__(self, i) -> citem_locator_t
 |      
 |      @param i: citem_t const *
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: citem_locator_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: citem_locator_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: citem_locator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_citem_locator_t(...)
 |      delete_citem_locator_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: citem_locator_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  op
 |      op
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class citem_t in module ida_hexrays:

class citem_t(builtins.object)
 |  Proxy of C++ citem_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, o=cot_empty) -> citem_t
 |      
 |      @param o: enum ctype_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_citem_t(...)
 |      delete_citem_t(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _citem_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _citem_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_op(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_op(self, *args) -> 'ctype_t'
 |      _get_op(self) -> ctype_t
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _set_op(self, *args) -> 'void'
 |      _set_op(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: enum ctype_t
 |  
 |  contains_expr(self, *args) -> 'bool'
 |      contains_expr(self, e) -> bool
 |      Does the item contain an expression?
 |      
 |      @param e: (C++: const cexpr_t *) cexpr_t const *
 |  
 |  contains_label(self, *args) -> 'bool'
 |      contains_label(self) -> bool
 |      Does the item contain a label?
 |  
 |  find_closest_addr(self, *args) -> 'citem_t *'
 |      find_closest_addr(self, _ea) -> citem_t
 |      
 |      @param _ea: ea_t
 |  
 |  find_parent_of(self, *args) -> 'citem_t *'
 |      find_parent_of(self, sitem) -> citem_t
 |      
 |      @param sitem: citem_t const *
 |      
 |      find_parent_of(self, item) -> citem_t
 |      
 |      @param item: citem_t const *
 |  
 |  is_expr(self, *args) -> 'bool'
 |      is_expr(self) -> bool
 |      Is an expression?
 |  
 |  print1(self, *args) -> 'void'
 |      print1(self, func)
 |      Print item into one line.
 |      
 |      @param func: (C++: const cfunc_t *) parent function. This argument is used to find out the referenced
 |                   variable names.
 |      @return: length of the generated text.
 |  
 |  replace_by(self, o)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Swap two citem_t.
 |      
 |      @param r: (C++: citem_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cexpr
 |      cexpr
 |  
 |  cinsn
 |      cinsn
 |  
 |  ea
 |      ea
 |  
 |  index
 |      index
 |  
 |  label_num
 |      label_num
 |  
 |  meminfo
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  op
 |      _get_op(self) -> ctype_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  to_specific_type
 |      cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function citem_to_specific_type in module ida_hexrays:

citem_to_specific_type(self)
    cast the citem_t object to its more specific type, either cexpr_t or cinsn_t.

Help on function clear_cached_cfuncs in module ida_hexrays:

clear_cached_cfuncs(*args) -> 'void'
    clear_cached_cfuncs()
    Flush all cached decompilation results.

Help on class cloop_t in module ida_hexrays:

class cloop_t(ceinsn_t)
 |  Proxy of C++ cloop_t class.
 |  
 |  Method resolution order:
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cloop_t
 |      __init__(self, b) -> cloop_t
 |      
 |      @param b: cinsn_t *
 |      
 |      __init__(self, r) -> cloop_t
 |      
 |      @param r: cloop_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cloop_t(...)
 |      delete_cloop_t(self)
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |      
 |      @param r: cloop_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  body
 |      body
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on function close_hexrays_waitbox in module ida_hexrays:

close_hexrays_waitbox(*args) -> 'void'
    close_hexrays_waitbox()
    Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_HIDE was used
    during decompilation.

Help on function close_pseudocode in module ida_hexrays:

close_pseudocode(*args) -> 'bool'
    close_pseudocode(f) -> bool
    Close pseudocode window.
    
    @param f: (C++: TWidget *) pointer to window
    @return: false if failed

Help on class cnumber_t in module ida_hexrays:

class cnumber_t(builtins.object)
 |  Proxy of C++ cnumber_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cnumber_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cnumber_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cnumber_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _opnum=0) -> cnumber_t
 |      
 |      @param _opnum: int
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cnumber_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cnumber_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cnumber_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cnumber_t(...)
 |      delete_cnumber_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, type, parent=None, nice_stroff=None)
 |      
 |      Parameters
 |      ----------
 |      type: tinfo_t const &
 |      parent: citem_t const *
 |      nice_stroff: bool *
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, v, nbytes, sign)
 |      Assign new value
 |      
 |      @param v: (C++: uint64) new value
 |      @param nbytes: (C++: int) size of the new value in bytes
 |      @param sign: (C++: type_sign_t) sign of the value
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cnumber_t const &
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, type) -> uint64
 |      Get value. This function will properly extend the number sign to 64bits
 |      depending on the type sign.
 |      
 |      @param type: (C++: const tinfo_t &) tinfo_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _value
 |      _value
 |  
 |  nf
 |      nf
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class codegen_t in module ida_hexrays:

class codegen_t(builtins.object)
 |  Proxy of C++ codegen_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_codegen_t(...)
 |      delete_codegen_t(self)
 |  
 |  analyze_prolog(self, *args) -> 'merror_t'
 |      analyze_prolog(self, fc, reachable) -> merror_t
 |      Analyze prolog/epilog of the function to decompile. If prolog is found, allocate
 |      and fill 'mba->pi' structure.
 |      
 |      @param fc: (C++: const class qflow_chart_t &) flow chart
 |      @param reachable: (C++: const class bitset_t &) bitmap of reachable blocks
 |      @return: error code
 |  
 |  emit(self, *args) -> 'minsn_t *'
 |      emit(self, code, width, l, r, d, offsize) -> minsn_t
 |      Emit one microinstruction. This variant accepts pointers to operands. It is more
 |      difficult to use but permits to create virtually any instruction. Operands may
 |      be nullptr when it makes sense.
 |      
 |      @param code: (C++: mcode_t) enum mcode_t
 |      @param width: int
 |      @param l: (C++: const mop_t *) uval_t
 |      @param r: (C++: const mop_t *) uval_t
 |      @param d: (C++: const mop_t *) uval_t
 |      @param offsize: int
 |      
 |      emit(self, code, l, r, d) -> minsn_t
 |      
 |      @param code: enum mcode_t
 |      @param l: mop_t const *
 |      @param r: mop_t const *
 |      @param d: mop_t const *
 |  
 |  emit_micro_mvm(self, *args) -> 'minsn_t *'
 |      emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t
 |      Emit one microinstruction. This variant takes a data type not a size.
 |      
 |      @param code: (C++: mcode_t) enum mcode_t
 |      @param dtype: (C++: op_dtype_t)
 |      @param l: (C++: uval_t)
 |      @param r: (C++: uval_t)
 |      @param d: (C++: uval_t)
 |      @param offsize: (C++: int)
 |  
 |  gen_micro(self, *args) -> 'merror_t'
 |      gen_micro(self) -> merror_t
 |      Generate microcode for one instruction. The instruction is in INSN
 |      
 |      @return: MERR_OK - all ok MERR_BLOCK - all ok, need to switch to new block
 |               MERR_BADBLK - delete current block and continue other error codes are
 |               fatal
 |  
 |  load_effective_address(self, *args) -> 'mreg_t'
 |      load_effective_address(self, n, flags=0) -> mreg_t
 |      Generate microcode to calculate the address of a memory operand.
 |      
 |      @param n: (C++: int) - number of INSN operand
 |      @param flags: (C++: int) - reserved for future use
 |      @return: register containing the operand address. mr_none - failed (not a memory
 |               operand)
 |  
 |  load_operand(self, *args) -> 'mreg_t'
 |      load_operand(self, opnum, flags=0) -> mreg_t
 |      Generate microcode to load one operand.
 |      
 |      @param opnum: (C++: int) number of INSN operand
 |      @param flags: (C++: int) reserved for future use
 |      @return: register containing the operand.
 |  
 |  microgen_completed(self, *args) -> 'void'
 |      microgen_completed(self)
 |      This method is called when the microcode generation is done.
 |  
 |  prepare_gen_micro(self, *args) -> 'merror_t'
 |      prepare_gen_micro(self) -> merror_t
 |      Setup internal data to handle new instruction. This method should be called
 |      before calling gen_micro(). Usually gen_micro() is called by the decompiler. You
 |      have to call this function explicitly only if you yourself call gen_micro(). The
 |      instruction is in INSN
 |      
 |      @return: MERR_OK - all ok other error codes are fatal
 |  
 |  store_operand(self, *args) -> 'bool'
 |      store_operand(self, n, mop, flags=0, outins=None) -> bool
 |      Generate microcode to store an operand. In case of success an arbitrary number
 |      of instructions can be generated (and even no instruction if the source and
 |      target are the same)
 |      
 |      @param n: (C++: int) - number of target INSN operand
 |      @param mop: (C++: const mop_t &) - operand to be stored
 |      @param flags: (C++: int) - reserved for future use
 |      @param outins: (C++: minsn_t **) - (OUT) the last generated instruction
 |      @return: success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ignore_micro
 |      ignore_micro
 |  
 |  ii
 |      ii
 |  
 |  insn
 |      insn
 |  
 |  mb
 |      mb
 |  
 |  mba
 |      mba
 |  
 |  thisown
 |      The membership flag

Help on function convert_to_user_call in module ida_hexrays:

convert_to_user_call(*args) -> 'merror_t'
    convert_to_user_call(udc, cdg) -> merror_t
    try to generate user-defined call for an instruction
    
    @param udc: (C++: const udcall_t &) udcall_t const &
    @param cdg: (C++: codegen_t &)
    @return: Microcode error codes code: MERR_OK - user-defined call generated else
             - error (MERR_INSN == inacceptable udc.tif)

Help on function create_cfunc in module ida_hexrays:

create_cfunc(*args) -> 'cfuncptr_t'
    create_cfunc(mba) -> cfuncptr_t
    Create a new cfunc_t object.
    
    @param mba: (C++: mba_t *) microcode object. After creating the cfunc object it takes the
                ownership of MBA.

Help on function create_field_name in module ida_hexrays:

create_field_name(*args) -> 'qstring'
    create_field_name(type, offset=BADADDR) -> qstring
    
    @param type: tinfo_t const &
    @param offset: uval_t

Help on function create_helper in module ida_hexrays:

create_helper(*args)
    Create a helper object..

Help on function create_typedef in module ida_hexrays:

create_typedef(*args) -> 'tinfo_t'
    create_typedef(name) -> tinfo_t
    Create a reference to an ordinal type.
    
    @param name: char const *
    
    @return: type which refers to the specified ordinal. For example, if n is 1, the
             type info which refers to ordinal type 1 is created.
    create_typedef(n) -> tinfo_t
    
    @param n: int

Help on class creturn_t in module ida_hexrays:

class creturn_t(ceinsn_t)
 |  Proxy of C++ creturn_t class.
 |  
 |  Method resolution order:
 |      creturn_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: creturn_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: creturn_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: creturn_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> creturn_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: creturn_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: creturn_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: creturn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_creturn_t(...)
 |      delete_creturn_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: creturn_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on class cswitch_t in module ida_hexrays:

class cswitch_t(ceinsn_t)
 |  Proxy of C++ cswitch_t class.
 |  
 |  Method resolution order:
 |      cswitch_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cswitch_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cswitch_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cswitch_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cswitch_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cswitch_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cswitch_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cswitch_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cswitch_t(...)
 |      delete_cswitch_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cswitch_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cases
 |      cases
 |  
 |  mvnf
 |      mvnf
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on class ctext_position_t in module ida_hexrays:

class ctext_position_t(builtins.object)
 |  Proxy of C++ ctext_position_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _lnnum=-1, _x=0, _y=0) -> ctext_position_t
 |      
 |      @param _lnnum: int
 |      @param _x: int
 |      @param _y: int
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctext_position_t(...)
 |      delete_ctext_position_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: ctext_position_t const &
 |  
 |  in_ctree(self, *args) -> 'bool'
 |      in_ctree(self, hdrlines) -> bool
 |      Is the cursor in the variable/type declaration area?
 |      
 |      @param hdrlines: (C++: int) Number of lines of the declaration area
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  y
 |      y
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ctree_anchor_t in module ida_hexrays:

class ctree_anchor_t(builtins.object)
 |  Proxy of C++ ctree_anchor_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_anchor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_anchor_t(...)
 |      delete_ctree_anchor_t(self)
 |  
 |  get_index(self, *args) -> 'int'
 |      get_index(self) -> int
 |  
 |  get_itp(self, *args) -> 'item_preciser_t'
 |      get_itp(self) -> item_preciser_t
 |  
 |  is_blkcmt_anchor(self, *args) -> 'bool'
 |      is_blkcmt_anchor(self) -> bool
 |  
 |  is_citem_anchor(self, *args) -> 'bool'
 |      is_citem_anchor(self) -> bool
 |  
 |  is_itp_anchor(self, *args) -> 'bool'
 |      is_itp_anchor(self) -> bool
 |  
 |  is_lvar_anchor(self, *args) -> 'bool'
 |      is_lvar_anchor(self) -> bool
 |  
 |  is_valid_anchor(self, *args) -> 'bool'
 |      is_valid_anchor(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value

Help on class ctree_item_t in module ida_hexrays:

class ctree_item_t(builtins.object)
 |  Proxy of C++ ctree_item_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_item_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_item_t(...)
 |      delete_ctree_item_t(self)
 |  
 |  _get_e(self, *args) -> 'cexpr_t *'
 |      _get_e(self) -> cexpr_t
 |  
 |  _get_f(self, *args) -> 'cfunc_t *'
 |      _get_f(self) -> cfunc_t
 |  
 |  _get_i(self, *args) -> 'cinsn_t *'
 |      _get_i(self) -> cinsn_t
 |  
 |  _get_it(self, *args) -> 'citem_t *'
 |      _get_it(self) -> citem_t
 |  
 |  _get_l(self, *args) -> 'lvar_t *'
 |      _get_l(self) -> lvar_t
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |      Get address of the current item. Each ctree item has an address.
 |      
 |      @return: BADADDR if failed
 |  
 |  get_label_num(self, *args) -> 'int'
 |      get_label_num(self, gln_flags) -> int
 |      Get label number of the current item.
 |      
 |      @param gln_flags: (C++: int) Combination of get_label_num control bits
 |      @return: -1 if failed or no label
 |  
 |  get_lvar(self, *args) -> 'lvar_t *'
 |      get_lvar(self) -> lvar_t
 |      Get pointer to local variable. If the current item is a local variable, this
 |      function will return pointer to its definition.
 |      
 |      @return: nullptr if failed
 |  
 |  get_memptr(self, *args) -> 'member_t *'
 |      get_memptr(self, p_sptr=None) -> member_t *
 |      Get pointer to structure member. If the current item is a structure field, this
 |      function will return pointer to its definition.
 |      
 |      @param p_sptr: (C++: struc_t **) pointer to the variable where the pointer to the parent structure
 |                     is returned. This parameter can be nullptr.
 |      @return: nullptr if failed
 |  
 |  is_citem(self, *args) -> 'bool'
 |      is_citem(self) -> bool
 |      Is the current item is a ctree item?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  citype
 |      citype
 |  
 |  e
 |  
 |  f
 |  
 |  i
 |  
 |  it
 |  
 |  l
 |  
 |  loc
 |      loc
 |  
 |  thisown
 |      The membership flag

Help on class ctree_items_t in module ida_hexrays:

class ctree_items_t(builtins.object)
 |  Proxy of C++ qvector< citem_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< citem_t * > const &
 |  
 |  __getitem__(self, *args) -> 'citem_t *const &'
 |      __getitem__(self, i) -> citem_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ctree_items_t
 |      __init__(self, x) -> ctree_items_t
 |      
 |      @param x: qvector< citem_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< citem_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: citem_t *const &
 |  
 |  __swig_destroy__ = delete_ctree_items_t(...)
 |      delete_ctree_items_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: citem_t *const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: citem_t *const &
 |  
 |  append = push_back(self, *args) -> 'citem_t *&'
 |  
 |  at = __getitem__(self, *args) -> 'citem_t *const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< citem_t * >::const_iterator'
 |      begin(self) -> qvector< citem_t * >::iterator
 |      begin(self) -> qvector< citem_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< citem_t * >::const_iterator'
 |      end(self) -> qvector< citem_t * >::iterator
 |      end(self) -> qvector< citem_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< citem_t * >::iterator'
 |      erase(self, it) -> qvector< citem_t * >::iterator
 |      
 |      @param it: qvector< citem_t * >::iterator
 |      
 |      erase(self, first, last) -> qvector< citem_t * >::iterator
 |      
 |      @param first: qvector< citem_t * >::iterator
 |      @param last: qvector< citem_t * >::iterator
 |  
 |  extract(self, *args) -> 'citem_t **'
 |      extract(self) -> citem_t **
 |  
 |  find(self, *args) -> 'qvector< citem_t * >::const_iterator'
 |      find(self, x) -> qvector< citem_t * >::iterator
 |      
 |      @param x: citem_t *const &
 |      
 |      find(self, x) -> qvector< citem_t * >::const_iterator
 |      
 |      @param x: citem_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: citem_t *const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: citem_t **
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< citem_t * >::iterator'
 |      insert(self, it, x) -> qvector< citem_t * >::iterator
 |      
 |      @param it: qvector< citem_t * >::iterator
 |      @param x: citem_t *const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'citem_t *&'
 |      push_back(self, x)
 |      
 |      @param x: citem_t *const &
 |      
 |      push_back(self) -> citem_t *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: citem_t *const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< citem_t * > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ctree_parentee_t in module ida_hexrays:

class ctree_parentee_t(ctree_visitor_t)
 |  Proxy of C++ ctree_parentee_t class.
 |  
 |  Method resolution order:
 |      ctree_parentee_t
 |      ctree_visitor_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, post=False) -> ctree_parentee_t
 |      
 |      @param post: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_parentee_t(...)
 |      delete_ctree_parentee_t(self)
 |  
 |  get_block(self, *args) -> 'cblock_t *'
 |      get_block(self) -> cblock_t
 |      Get pointer to the parent block of the currently visited item. This function
 |      should be called only when the parent is a block.
 |  
 |  recalc_parent_types(self, *args) -> 'bool'
 |      recalc_parent_types(self) -> bool
 |      Recalculate type of parent nodes. If a node type has been changed, the visitor
 |      must recalculate all parent types, otherwise the ctree becomes inconsistent. If
 |      during this recalculation a parent node is added/deleted, this function returns
 |      true. In this case the traversal must be stopped because the information about
 |      parent nodes is stale.
 |      
 |      @return: false-ok to continue the traversal, true-must stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctree_visitor_t:
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, item, parent) -> int
 |      Traverse ctree. The traversal will start at the specified item and continue
 |      until of one the visit_...() functions return a non-zero value.
 |      
 |      @param item: (C++: citem_t *) root of the ctree to traverse
 |      @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
 |      @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  apply_to_exprs(self, *args) -> 'int'
 |      apply_to_exprs(self, item, parent) -> int
 |      Traverse only expressions. The traversal will start at the specified item and
 |      continue until of one the visit_...() functions return a non-zero value.
 |      
 |      @param item: (C++: citem_t *) root of the ctree to traverse
 |      @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
 |      @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  clr_prune(self, *args) -> 'void'
 |      clr_prune(self)
 |      Do not prune children. This is an internal function, no need to call it.
 |  
 |  clr_restart(self, *args) -> 'void'
 |      clr_restart(self)
 |      Do not restart. This is an internal function, no need to call it.
 |  
 |  is_postorder(self, *args) -> 'bool'
 |      is_postorder(self) -> bool
 |      Should the leave...() functions be called?
 |  
 |  leave_expr(self, *args) -> 'int'
 |      leave_expr(self, arg0) -> int
 |      Visit an expression after having visited its children. This is a visitor
 |      function which should be overridden by a derived class to do some useful work.
 |      This visitor performs post-order traserval, i.e. an item is visited after its
 |      children.
 |      
 |      @param arg0: cexpr_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  leave_insn(self, *args) -> 'int'
 |      leave_insn(self, arg0) -> int
 |      Visit a statement after having visited its children. This is a visitor function
 |      which should be overridden by a derived class to do some useful work. This
 |      visitor performs post-order traserval, i.e. an item is visited after its
 |      children.
 |      
 |      @param arg0: cinsn_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  maintain_parents(self, *args) -> 'bool'
 |      maintain_parents(self) -> bool
 |      Should the parent information by maintained?
 |  
 |  must_prune(self, *args) -> 'bool'
 |      must_prune(self) -> bool
 |      Should the traversal skip the children of the current item?
 |  
 |  must_restart(self, *args) -> 'bool'
 |      must_restart(self) -> bool
 |      Should the traversal restart?
 |  
 |  only_insns(self, *args) -> 'bool'
 |      only_insns(self) -> bool
 |      Should all expressions be automatically pruned?
 |  
 |  parent_expr(self, *args) -> 'cexpr_t *'
 |      parent_expr(self) -> cexpr_t
 |      Get parent of the current item as an expression.
 |  
 |  parent_insn(self, *args) -> 'cinsn_t *'
 |      parent_insn(self) -> cinsn_t
 |      Get parent of the current item as a statement.
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |      Prune children. This function may be called by a visitor() to skip all children
 |      of the current item.
 |  
 |  set_restart(self, *args) -> 'void'
 |      set_restart(self)
 |      Restart the travesal. Meaningful only in apply_to_exprs()
 |  
 |  visit_expr(self, *args) -> 'int'
 |      visit_expr(self, arg0) -> int
 |      Visit an expression. This is a visitor function which should be overridden by a
 |      derived class to do some useful work. This visitor performs pre-order traserval,
 |      i.e. an item is visited before its children.
 |      
 |      @param arg0: cexpr_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  visit_insn(self, *args) -> 'int'
 |      visit_insn(self, arg0) -> int
 |      Visit a statement. This is a visitor function which should be overridden by a
 |      derived class to do some useful work. This visitor performs pre-order traserval,
 |      i.e. an item is visited before its children.
 |      
 |      @param arg0: cinsn_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctree_visitor_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      cv_flags
 |  
 |  parents
 |      parents

Help on class ctree_visitor_t in module ida_hexrays:

class ctree_visitor_t(builtins.object)
 |  Proxy of C++ ctree_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags) -> ctree_visitor_t
 |      
 |      @param _flags: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ctree_visitor_t(...)
 |      delete_ctree_visitor_t(self)
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, item, parent) -> int
 |      Traverse ctree. The traversal will start at the specified item and continue
 |      until of one the visit_...() functions return a non-zero value.
 |      
 |      @param item: (C++: citem_t *) root of the ctree to traverse
 |      @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
 |      @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  apply_to_exprs(self, *args) -> 'int'
 |      apply_to_exprs(self, item, parent) -> int
 |      Traverse only expressions. The traversal will start at the specified item and
 |      continue until of one the visit_...() functions return a non-zero value.
 |      
 |      @param item: (C++: citem_t *) root of the ctree to traverse
 |      @param parent: (C++: citem_t *) parent of the specified item. can be specified as nullptr.
 |      @return: 0 or a non-zero value returned by a visit_...() function
 |  
 |  clr_prune(self, *args) -> 'void'
 |      clr_prune(self)
 |      Do not prune children. This is an internal function, no need to call it.
 |  
 |  clr_restart(self, *args) -> 'void'
 |      clr_restart(self)
 |      Do not restart. This is an internal function, no need to call it.
 |  
 |  is_postorder(self, *args) -> 'bool'
 |      is_postorder(self) -> bool
 |      Should the leave...() functions be called?
 |  
 |  leave_expr(self, *args) -> 'int'
 |      leave_expr(self, arg0) -> int
 |      Visit an expression after having visited its children. This is a visitor
 |      function which should be overridden by a derived class to do some useful work.
 |      This visitor performs post-order traserval, i.e. an item is visited after its
 |      children.
 |      
 |      @param arg0: cexpr_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  leave_insn(self, *args) -> 'int'
 |      leave_insn(self, arg0) -> int
 |      Visit a statement after having visited its children. This is a visitor function
 |      which should be overridden by a derived class to do some useful work. This
 |      visitor performs post-order traserval, i.e. an item is visited after its
 |      children.
 |      
 |      @param arg0: cinsn_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  maintain_parents(self, *args) -> 'bool'
 |      maintain_parents(self) -> bool
 |      Should the parent information by maintained?
 |  
 |  must_prune(self, *args) -> 'bool'
 |      must_prune(self) -> bool
 |      Should the traversal skip the children of the current item?
 |  
 |  must_restart(self, *args) -> 'bool'
 |      must_restart(self) -> bool
 |      Should the traversal restart?
 |  
 |  only_insns(self, *args) -> 'bool'
 |      only_insns(self) -> bool
 |      Should all expressions be automatically pruned?
 |  
 |  parent_expr(self, *args) -> 'cexpr_t *'
 |      parent_expr(self) -> cexpr_t
 |      Get parent of the current item as an expression.
 |  
 |  parent_insn(self, *args) -> 'cinsn_t *'
 |      parent_insn(self) -> cinsn_t
 |      Get parent of the current item as a statement.
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |      Prune children. This function may be called by a visitor() to skip all children
 |      of the current item.
 |  
 |  set_restart(self, *args) -> 'void'
 |      set_restart(self)
 |      Restart the travesal. Meaningful only in apply_to_exprs()
 |  
 |  visit_expr(self, *args) -> 'int'
 |      visit_expr(self, arg0) -> int
 |      Visit an expression. This is a visitor function which should be overridden by a
 |      derived class to do some useful work. This visitor performs pre-order traserval,
 |      i.e. an item is visited before its children.
 |      
 |      @param arg0: cexpr_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  visit_insn(self, *args) -> 'int'
 |      visit_insn(self, arg0) -> int
 |      Visit a statement. This is a visitor function which should be overridden by a
 |      derived class to do some useful work. This visitor performs pre-order traserval,
 |      i.e. an item is visited before its children.
 |      
 |      @param arg0: cinsn_t *
 |      @return: 0 to continue the traversal, nonzero to stop.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cv_flags
 |      cv_flags
 |  
 |  parents
 |      parents
 |  
 |  thisown
 |      The membership flag

Help on class cwhile_t in module ida_hexrays:

class cwhile_t(cloop_t)
 |  Proxy of C++ cwhile_t class.
 |  
 |  Method resolution order:
 |      cwhile_t
 |      cloop_t
 |      ceinsn_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: cwhile_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: cwhile_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: cwhile_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cwhile_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: cwhile_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: cwhile_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: cwhile_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cwhile_t(...)
 |      delete_cwhile_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: cwhile_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from cloop_t:
 |  
 |  assign(self, *args) -> 'cloop_t &'
 |      assign(self, r) -> cloop_t
 |      
 |      @param r: cloop_t const &
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from cloop_t:
 |  
 |  body
 |      body
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ceinsn_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  expr
 |      expr

Help on function debug_hexrays_ctree in module ida_hexrays:

debug_hexrays_ctree(*args) -> 'void'
    debug_hexrays_ctree(level, msg)
    
    @param level: int
    @param msg: char const *

Help on function decompile in module ida_hexrays:

decompile(ea, hf=None, flags=0)
    # ---------------------------------------------------------------------

Help on function decompile_func in module ida_hexrays:

decompile_func(*args) -> 'cfuncptr_t'
    decompile_func(pfn, hf, decomp_flags=0) -> cfuncptr_t
    Decompile a function. Multiple decompilations of the same function return the
    same object.
    
    @param pfn: (C++: func_t *) pointer to function to decompile
    @param hf: (C++: hexrays_failure_t *) extended error information (if failed)
    @param decomp_flags: (C++: int) bitwise combination of decompile() flags... bits
    @return: pointer to the decompilation result (a reference counted pointer).
             nullptr if failed.

Help on function decompile_many in module ida_hexrays:

decompile_many(*args) -> 'bool'
    decompile_many(outfile, funcaddrs, flags) -> bool
    Batch decompilation. Decompile all or the specified functions
    
    @param outfile: (C++: const char *) name of the output file
    @param funcaddrs: (C++: const eavec_t *) list of functions to decompile. If nullptr or empty, then
                      decompile all nonlib functions
    @param flags: (C++: int) Batch decompilation bits
    @return: true if no internal error occurred and the user has not cancelled
             decompilation

Help on function dereference in module ida_hexrays:

dereference(e, ptrsize, is_float=False)
    Dereference a pointer. This function dereferences a pointer expression. It
    performs the following conversion: "ptr" => "*ptr" It can handle discrepancies
    in the pointer type and the access size.
    
    @return: dereferenced expression

Help on function dstr in module ida_hexrays:

dstr(*args) -> 'char const *'
    dstr(tif) -> char const *
    Print the specified type info. This function can be used from a debugger by
    typing "tif->dstr()"
    
    @param tif: (C++: const tinfo_t *) tinfo_t const *

Help on function dummy_ptrtype in module ida_hexrays:

dummy_ptrtype(*args) -> 'tinfo_t'
    dummy_ptrtype(ptrsize, isfp) -> tinfo_t
    Generate a dummy pointer type
    
    @param ptrsize: (C++: int) size of pointed object
    @param isfp: (C++: bool) is floating point object?

Help on function eamap_begin in module ida_hexrays:

eamap_begin(*args) -> 'eamap_iterator_t'
    eamap_begin(map) -> eamap_iterator_t
    Get iterator pointing to the beginning of eamap_t.
    
    @param map: (C++: const eamap_t *) eamap_t const *

Help on function eamap_clear in module ida_hexrays:

eamap_clear(*args) -> 'void'
    eamap_clear(map)
    Clear eamap_t.
    
    @param map: (C++: eamap_t *)

Help on function eamap_end in module ida_hexrays:

eamap_end(*args) -> 'eamap_iterator_t'
    eamap_end(map) -> eamap_iterator_t
    Get iterator pointing to the end of eamap_t.
    
    @param map: (C++: const eamap_t *) eamap_t const *

Help on function eamap_erase in module ida_hexrays:

eamap_erase(*args) -> 'void'
    eamap_erase(map, p)
    Erase current element from eamap_t.
    
    @param map: (C++: eamap_t *)
    @param p: (C++: eamap_iterator_t)

Help on function eamap_find in module ida_hexrays:

eamap_find(*args) -> 'eamap_iterator_t'
    eamap_find(map, key) -> eamap_iterator_t
    Find the specified key in eamap_t.
    
    @param map: (C++: const eamap_t *) eamap_t const *
    @param key: (C++: const ea_t &) ea_t const &

Help on function eamap_first in module ida_hexrays:

eamap_first(*args) -> 'ea_t const &'
    eamap_first(p) -> ea_t const &
    Get reference to the current map key.
    
    @param p: (C++: eamap_iterator_t)

Help on function eamap_free in module ida_hexrays:

eamap_free(*args) -> 'void'
    eamap_free(map)
    Delete eamap_t instance.
    
    @param map: (C++: eamap_t *)

Help on function eamap_insert in module ida_hexrays:

eamap_insert(*args) -> 'eamap_iterator_t'
    eamap_insert(map, key, val) -> eamap_iterator_t
    Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
    
    @param map: (C++: eamap_t *)
    @param key: (C++: const ea_t &) ea_t const &
    @param val: (C++: const cinsnptrvec_t &) cinsnptrvec_t const &

Help on class eamap_iterator_t in module ida_hexrays:

class eamap_iterator_t(builtins.object)
 |  Proxy of C++ eamap_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: eamap_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> eamap_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: eamap_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_eamap_iterator_t(...)
 |      delete_eamap_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function eamap_new in module ida_hexrays:

eamap_new(*args) -> 'eamap_t *'
    eamap_new() -> eamap_t
    Create a new eamap_t instance.

Help on function eamap_next in module ida_hexrays:

eamap_next(*args) -> 'eamap_iterator_t'
    eamap_next(p) -> eamap_iterator_t
    Move to the next element.
    
    @param p: (C++: eamap_iterator_t)

Help on function eamap_prev in module ida_hexrays:

eamap_prev(*args) -> 'eamap_iterator_t'
    eamap_prev(p) -> eamap_iterator_t
    Move to the previous element.
    
    @param p: (C++: eamap_iterator_t)

Help on function eamap_second in module ida_hexrays:

eamap_second(*args) -> 'cinsnptrvec_t &'
    eamap_second(p) -> cinsnptrvec_t
    Get reference to the current map value.
    
    @param p: (C++: eamap_iterator_t)

Help on function eamap_size in module ida_hexrays:

eamap_size(*args) -> 'size_t'
    eamap_size(map) -> size_t
    Get size of eamap_t.
    
    @param map: (C++: eamap_t *)

Help on class eamap_t in module ida_hexrays:

class eamap_t(builtins.object)
 |  Proxy of C++ std::map< ea_t,cinsnptrvec_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = eamap_begin(...)
 |      eamap_begin(map) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t const *
 |  
 |  __clear = eamap_clear(...)
 |      eamap_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = eamap_end(...)
 |      eamap_end(map) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t const *
 |  
 |  __erase = eamap_erase(...)
 |      eamap_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |      p: eamap_iterator_t
 |  
 |  __find = eamap_find(...)
 |      eamap_find(map, key) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t const *
 |      key: ea_t const &
 |  
 |  __first = eamap_first(...)
 |      eamap_first(p) -> ea_t const &
 |      
 |      Parameters
 |      ----------
 |      p: eamap_iterator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> eamap_t
 |  
 |  __insert = eamap_insert(...)
 |      eamap_insert(map, key, val) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |      key: ea_t const &
 |      val: cinsnptrvec_t const &
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = eamap_next(...)
 |      eamap_next(p) -> eamap_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: eamap_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = eamap_second(...)
 |      eamap_second(p) -> cinsnptrvec_t
 |      
 |      Parameters
 |      ----------
 |      p: eamap_iterator_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = eamap_size(...)
 |      eamap_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: eamap_t *
 |  
 |  __swig_destroy__ = delete_eamap_t(...)
 |      delete_eamap_t(self)
 |  
 |  at(self, *args) -> 'cinsnptrvec_t &'
 |      at(self, _Keyval) -> cinsnptrvec_t
 |      
 |      @param _Keyval: unsigned-ea-like-numeric-type const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'int'>
 |      int(x=0) -> integer
 |      int(x, base=10) -> integer
 |      
 |      Convert a number or string to an integer, or return 0 if no arguments
 |      are given.  If x is a number, return x.__int__().  For floating point
 |      numbers, this truncates towards zero.
 |      
 |      If x is not a number or if base is given, then x must be a string,
 |      bytes, or bytearray instance representing an integer literal in the
 |      given base.  The literal can be preceded by '+' or '-' and be surrounded
 |      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |      Base 0 means to interpret the base from the string as an integer literal.
 |      >>> int('0b100', base=0)
 |      4
 |  
 |  valuetype = <class 'ida_hexrays.cinsnptrvec_t'>
 |      Proxy of C++ qvector< cinsn_t * > class.

Help on class fnumber_t in module ida_hexrays:

class fnumber_t(builtins.object)
 |  Proxy of C++ fnumber_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: fnumber_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: fnumber_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: fnumber_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fnumber_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: fnumber_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: fnumber_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: fnumber_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_fnumber_t(...)
 |      delete_fnumber_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: fnumber_t const &
 |  
 |  dereference_const_uint16(self, *args) -> 'uint16 const *'
 |      dereference_const_uint16(self) -> uint16 const *
 |  
 |  dereference_uint16(self, *args) -> 'uint16 *'
 |      dereference_uint16(self) -> uint16 *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fnum
 |      fnum
 |  
 |  nbytes
 |      nbytes
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class gco_info_t in module ida_hexrays:

class gco_info_t(builtins.object)
 |  Proxy of C++ gco_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> gco_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_gco_info_t(...)
 |      delete_gco_info_t(self)
 |  
 |  append_to_list(self, *args) -> 'bool'
 |      append_to_list(self, list, mba) -> bool
 |      Append operand info to LIST. This function converts IDA register number or stack
 |      offset to a decompiler list.
 |      
 |      @param list: (C++: mlist_t *) list to append to
 |      @param mba: (C++: const mba_t *) microcode object
 |  
 |  cvt_to_ivl(self, *args) -> 'vivl_t'
 |      cvt_to_ivl(self) -> vivl_t
 |      Convert operand info to VIVL. The returned VIVL can be used, for example, in a
 |      call of get_valranges().
 |  
 |  is_def(self, *args) -> 'bool'
 |      is_def(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_use(self, *args) -> 'bool'
 |      is_use(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  regnum
 |      regnum
 |  
 |  size
 |      size
 |  
 |  stkoff
 |      stkoff
 |  
 |  thisown
 |      The membership flag

Help on function gen_microcode in module ida_hexrays:

gen_microcode(*args) -> 'mba_t *'
    gen_microcode(mbr, hf, retlist=None, decomp_flags=0, reqmat=MMAT_GLBOPT3) -> mba_t
    Generate microcode of an arbitrary code snippet
    
    @param mbr: (C++: const mba_ranges_t &) snippet ranges
    @param hf: (C++: hexrays_failure_t *) extended error information (if failed)
    @param retlist: (C++: const mlist_t *) list of registers the snippet returns
    @param decomp_flags: (C++: int) bitwise combination of decompile() flags... bits
    @param reqmat: (C++: mba_maturity_t) required microcode maturity
    @return: pointer to the microcode, nullptr if failed.

Help on function get_ctype_name in module ida_hexrays:

get_ctype_name(*args) -> 'char const *'
    get_ctype_name(op) -> char const *
    
    @param op: enum ctype_t

Help on function get_current_operand in module ida_hexrays:

get_current_operand(*args) -> 'bool'
    get_current_operand(out) -> bool
    Get the instruction operand under the cursor. This function determines the
    operand that is under the cursor in the active disassembly listing. If the
    operand refers to a register or stack variable, it returns true.
    
    @param out: (C++: gco_info_t *) [out]: output buffer

Help on function get_float_type in module ida_hexrays:

get_float_type(*args) -> 'tinfo_t'
    get_float_type(width) -> tinfo_t
    Get a type of a floating point value with the specified width
    
    @param width: (C++: int) width of the desired type
    @return: type info object

Help on function get_hexrays_version in module ida_hexrays:

get_hexrays_version(*args) -> 'char const *'
    get_hexrays_version() -> char const *
    Get decompiler version. The returned string is of the form
    <major>.<minor>.<revision>.<build-date>
    
    @return: pointer to version string. For example: "2.0.0.140605"

Help on function get_int_type_by_width_and_sign in module ida_hexrays:

get_int_type_by_width_and_sign(*args) -> 'tinfo_t'
    get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t
    Create a type info by width and sign. Returns a simple type (examples: int,
    short) with the given width and sign.
    
    @param srcwidth: (C++: int) size of the type in bytes
    @param sign: (C++: type_sign_t) sign of the type

Help on function get_member_type in module ida_hexrays:

get_member_type(*args) -> 'bool'
    get_member_type(mptr, type) -> bool
    Get type of a structure field. This function performs validity checks of the
    field type. Wrong types are rejected.
    
    @param mptr: (C++: const member_t *) structure field
    @param type: (C++: tinfo_t *) pointer to the variable where the type is returned. This parameter
                 can be nullptr.
    @return: false if failed

Help on function get_merror_desc in module ida_hexrays:

get_merror_desc(*args) -> 'qstring *'
    get_merror_desc(code, mba) -> str
    Get textual description of an error code
    
    @param code: (C++: merror_t) Microcode error codes
    @param mba: (C++: mba_t *) the microcode array
    @return: the error address

Help on function get_mreg_name in module ida_hexrays:

get_mreg_name(*args) -> 'qstring *'
    get_mreg_name(reg, width, ud=None) -> str
    Get the microregister name.
    
    @param reg: (C++: mreg_t) microregister number
    @param width: (C++: int) size of microregister in bytes. may be bigger than the real
                  register size.
    @param ud: (C++: void *) reserved, must be nullptr
    @return: width of the printed register. this value may be less than the WIDTH
             argument.

Help on function get_op_signness in module ida_hexrays:

get_op_signness(*args) -> 'type_sign_t'
    get_op_signness(op) -> type_sign_t
    Get operator sign. Meaningful for sign-dependent operators, like cot_sdiv.
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function get_signed_mcode in module ida_hexrays:

get_signed_mcode(*args) -> 'mcode_t'
    get_signed_mcode(code) -> mcode_t
    
    @param code: enum mcode_t

Help on function get_temp_regs in module ida_hexrays:

get_temp_regs(*args) -> 'mlist_t const &'
    get_temp_regs() -> mlist_t
    Get list of temporary registers. Tempregs are temporary registers that are used
    during code generation. They do not map to regular processor registers. They are
    used only to store temporary values during execution of one instruction.
    Tempregs may not be used to pass a value from one block to another. In other
    words, at the end of a block all tempregs must be dead.

Help on function get_type in module ida_hexrays:

get_type(*args) -> 'bool'
    get_type(id, tif, guess) -> bool
    Get a global type. Global types are types of addressable objects and
    struct/union/enum types
    
    @param id: (C++: uval_t) address or id of the object
    @param tif: (C++: tinfo_t *) buffer for the answer
    @param guess: (C++: type_source_t) what kind of types to consider
    @return: success

Help on function get_unk_type in module ida_hexrays:

get_unk_type(*args) -> 'tinfo_t'
    get_unk_type(size) -> tinfo_t
    Create a partial type info by width. Returns a partially defined type (examples:
    _DWORD, _BYTE) with the given width.
    
    @param size: (C++: int) size of the type in bytes

Help on function get_unsigned_mcode in module ida_hexrays:

get_unsigned_mcode(*args) -> 'mcode_t'
    get_unsigned_mcode(code) -> mcode_t
    
    @param code: enum mcode_t

Help on function get_widget_vdui in module ida_hexrays:

get_widget_vdui(*args) -> 'vdui_t *'
    get_widget_vdui(f) -> vdui_t
    Get the vdui_t instance associated to the TWidget
    
    @param f: (C++: TWidget *) pointer to window
    @return: a vdui_t *, or nullptr

Help on function getb_reginsn in module ida_hexrays:

getb_reginsn(*args) -> 'minsn_t *'
    getb_reginsn(ins) -> minsn_t
    
    @param ins: minsn_t *

Help on function getf_reginsn in module ida_hexrays:

getf_reginsn(*args) -> 'minsn_t *'
    getf_reginsn(ins) -> minsn_t
    
    @param ins: minsn_t *

Help on class graph_chains_t in module ida_hexrays:

class graph_chains_t(block_chains_vec_t)
 |  Proxy of C++ graph_chains_t class.
 |  
 |  Method resolution order:
 |      graph_chains_t
 |      block_chains_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_chains_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_chains_t(...)
 |      delete_graph_chains_t(self)
 |  
 |  acquire(self, *args) -> 'void'
 |      acquire(self)
 |      Lock the chains.
 |  
 |  for_all_chains(self, *args) -> 'int'
 |      for_all_chains(self, cv, gca_flags) -> int
 |      Visit all chains
 |      
 |      @param cv: (C++: chain_visitor_t &) chain visitor
 |      @param gca_flags: (C++: int) combination of GCA_ bits
 |  
 |  is_locked(self, *args) -> 'bool'
 |      is_locked(self) -> bool
 |      Are the chains locked? It is a good idea to lock the chains before using them.
 |      This ensures that they won't be recalculated and reallocated during the use. See
 |      the chain_keeper_t class for that.
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |      Unlock the chains.
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: graph_chains_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from block_chains_vec_t:
 |  
 |  __getitem__(self, *args) -> 'block_chains_t const &'
 |      __getitem__(self, i) -> block_chains_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: block_chains_t const &
 |  
 |  at(self, *args) -> 'block_chains_t const &'
 |      at(self, _idx) -> block_chains_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      begin(self) -> block_chains_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< block_chains_t >::const_iterator'
 |      end(self) -> block_chains_t
 |  
 |  erase(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      erase(self, it) -> block_chains_t
 |      
 |      @param it: qvector< block_chains_t >::iterator
 |      
 |      erase(self, first, last) -> block_chains_t
 |      
 |      @param first: qvector< block_chains_t >::iterator
 |      @param last: qvector< block_chains_t >::iterator
 |  
 |  extract(self, *args) -> 'block_chains_t *'
 |      extract(self) -> block_chains_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=block_chains_t())
 |      
 |      @param x: block_chains_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: block_chains_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< block_chains_t >::iterator'
 |      insert(self, it, x) -> block_chains_t
 |      
 |      @param it: qvector< block_chains_t >::iterator
 |      @param x: block_chains_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'block_chains_t &'
 |      push_back(self, x)
 |      
 |      @param x: block_chains_t const &
 |      
 |      push_back(self) -> block_chains_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: block_chains_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from block_chains_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function has_cached_cfunc in module ida_hexrays:

has_cached_cfunc(*args) -> 'bool'
    has_cached_cfunc(ea) -> bool
    Do we have a cached decompilation result for 'ea'?
    
    @param ea: (C++: ea_t)

Help on function has_mcode_seloff in module ida_hexrays:

has_mcode_seloff(*args) -> 'bool'
    has_mcode_seloff(op) -> bool
    
    @param op: enum mcode_t

Help on function hexrays_alloc in module ida_hexrays:

hexrays_alloc(*args) -> 'void *'
    hexrays_alloc(size) -> void *
    
    @param size: size_t

Help on class hexrays_failure_t in module ida_hexrays:

class hexrays_failure_t(builtins.object)
 |  Proxy of C++ hexrays_failure_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexrays_failure_t
 |      __init__(self, c, ea, buf=None) -> hexrays_failure_t
 |      
 |      @param c: enum merror_t
 |      @param ea: ea_t
 |      @param buf: char const *
 |      
 |      __init__(self, c, ea, buf) -> hexrays_failure_t
 |      
 |      @param c: enum merror_t
 |      @param ea: ea_t
 |      @param buf: qstring const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__ lambda self
 |  
 |  __swig_destroy__ = delete_hexrays_failure_t(...)
 |      delete_hexrays_failure_t(self)
 |  
 |  desc(self, *args) -> 'qstring'
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      code
 |  
 |  errea
 |      errea
 |  
 |  str
 |      str
 |  
 |  thisown
 |      The membership flag

Help on function hexrays_free in module ida_hexrays:

hexrays_free(*args) -> 'void'
    hexrays_free(ptr)
    
    @param ptr: void *

Help on class hexwarn_t in module ida_hexrays:

class hexwarn_t(builtins.object)
 |  Proxy of C++ hexwarn_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: hexwarn_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: hexwarn_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: hexwarn_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexwarn_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: hexwarn_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: hexwarn_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: hexwarn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_hexwarn_t(...)
 |      delete_hexwarn_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: hexwarn_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  id
 |      id
 |  
 |  text
 |      text
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class hexwarns_t in module ida_hexrays:

class hexwarns_t(builtins.object)
 |  Proxy of C++ qvector< hexwarn_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< hexwarn_t > const &
 |  
 |  __getitem__(self, *args) -> 'hexwarn_t const &'
 |      __getitem__(self, i) -> hexwarn_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> hexwarns_t
 |      __init__(self, x) -> hexwarns_t
 |      
 |      @param x: qvector< hexwarn_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< hexwarn_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: hexwarn_t const &
 |  
 |  __swig_destroy__ = delete_hexwarns_t(...)
 |      delete_hexwarns_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: hexwarn_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: hexwarn_t const &
 |  
 |  append = push_back(self, *args) -> 'hexwarn_t &'
 |  
 |  at = __getitem__(self, *args) -> 'hexwarn_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< hexwarn_t >::const_iterator'
 |      begin(self) -> hexwarn_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< hexwarn_t >::const_iterator'
 |      end(self) -> hexwarn_t
 |  
 |  erase(self, *args) -> 'qvector< hexwarn_t >::iterator'
 |      erase(self, it) -> hexwarn_t
 |      
 |      @param it: qvector< hexwarn_t >::iterator
 |      
 |      erase(self, first, last) -> hexwarn_t
 |      
 |      @param first: qvector< hexwarn_t >::iterator
 |      @param last: qvector< hexwarn_t >::iterator
 |  
 |  extract(self, *args) -> 'hexwarn_t *'
 |      extract(self) -> hexwarn_t
 |  
 |  find(self, *args) -> 'qvector< hexwarn_t >::const_iterator'
 |      find(self, x) -> hexwarn_t
 |      
 |      @param x: hexwarn_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=hexwarn_t())
 |      
 |      @param x: hexwarn_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: hexwarn_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: hexwarn_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< hexwarn_t >::iterator'
 |      insert(self, it, x) -> hexwarn_t
 |      
 |      @param it: qvector< hexwarn_t >::iterator
 |      @param x: hexwarn_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'hexwarn_t &'
 |      push_back(self, x)
 |      
 |      @param x: hexwarn_t const &
 |      
 |      push_back(self) -> hexwarn_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: hexwarn_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< hexwarn_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class history_item_t in module ida_hexrays:

class history_item_t(ctext_position_t)
 |  Proxy of C++ history_item_t class.
 |  
 |  Method resolution order:
 |      history_item_t
 |      ctext_position_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea=BADADDR, _lnnum=-1, _x=0, _y=0) -> history_item_t
 |      
 |      @param _ea: ea_t
 |      @param _lnnum: int
 |      @param _x: int
 |      @param _y: int
 |      
 |      __init__(self, _ea, p) -> history_item_t
 |      
 |      @param _ea: ea_t
 |      @param p: ctext_position_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_history_item_t(...)
 |      delete_history_item_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea
 |      ea
 |  
 |  end
 |      end
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ctext_position_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ctext_position_t const &
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: ctext_position_t const &
 |  
 |  in_ctree(self, *args) -> 'bool'
 |      in_ctree(self, hdrlines) -> bool
 |      Is the cursor in the variable/type declaration area?
 |      
 |      @param hdrlines: (C++: int) Number of lines of the declaration area
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ctext_position_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum
 |  
 |  x
 |      x
 |  
 |  y
 |      y
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ctext_position_t:
 |  
 |  __hash__ = None

Help on class history_t in module ida_hexrays:

class history_t(qvector_history_t)
 |  Proxy of C++ qstack< history_item_t > class.
 |  
 |  Method resolution order:
 |      history_t
 |      qvector_history_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> history_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_history_t(...)
 |      delete_history_t(self)
 |  
 |  append = push_back(self, *args) -> 'history_item_t &'
 |      push_back(self, x)
 |      
 |      @param x: history_item_t const &
 |      
 |      push_back(self) -> history_item_t
 |  
 |  at = __getitem__(self, *args) -> 'history_item_t const &'
 |      __getitem__(self, i) -> history_item_t
 |      
 |      @param i: size_t
 |  
 |  pop(self, *args) -> 'history_item_t'
 |      pop(self) -> history_item_t
 |  
 |  push(self, *args) -> 'void'
 |      push(self, v)
 |      
 |      @param v: history_item_t const &
 |  
 |  top(self, *args) -> 'history_item_t &'
 |      top(self) -> history_item_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_history_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< history_item_t > const &
 |  
 |  __getitem__(self, *args) -> 'history_item_t const &'
 |      __getitem__(self, i) -> history_item_t
 |      
 |      @param i: size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< history_item_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: history_item_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: history_item_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: history_item_t const &
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      begin(self) -> history_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      end(self) -> history_item_t
 |  
 |  erase(self, *args) -> 'qvector< history_item_t >::iterator'
 |      erase(self, it) -> history_item_t
 |      
 |      @param it: qvector< history_item_t >::iterator
 |      
 |      erase(self, first, last) -> history_item_t
 |      
 |      @param first: qvector< history_item_t >::iterator
 |      @param last: qvector< history_item_t >::iterator
 |  
 |  extract(self, *args) -> 'history_item_t *'
 |      extract(self) -> history_item_t
 |  
 |  find(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      find(self, x) -> history_item_t
 |      
 |      @param x: history_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=history_item_t())
 |      
 |      @param x: history_item_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: history_item_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: history_item_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< history_item_t >::iterator'
 |      insert(self, it, x) -> history_item_t
 |      
 |      @param it: qvector< history_item_t >::iterator
 |      @param x: history_item_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'history_item_t &'
 |      push_back(self, x)
 |      
 |      @param x: history_item_t const &
 |      
 |      push_back(self) -> history_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: history_item_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< history_item_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_history_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from qvector_history_t:
 |  
 |  __hash__ = None

Help on function init_hexrays_plugin in module ida_hexrays:

init_hexrays_plugin(*args) -> 'bool'
    init_hexrays_plugin(flags=0) -> bool
    Check that your plugin is compatible with hex-rays decompiler. This function
    must be called before calling any other decompiler function.
    
    @param flags: (C++: int) reserved, must be 0
    @return: true if the decompiler exists and is compatible with your plugin

Help on function install_hexrays_callback in module ida_hexrays:

install_hexrays_callback(callback)
    Deprecated. Please use Hexrays_Hooks instead
    Install handler for decompiler events.
    
    @return: false if failed

Help on function install_microcode_filter in module ida_hexrays:

install_microcode_filter(*args) -> 'bool'
    install_microcode_filter(filter, install=True) -> bool
    register/unregister non-standard microcode generator
    
    @param filter: (C++: microcode_filter_t *) - microcode generator object
    @param install: (C++: bool) - TRUE - register the object, FALSE - unregister
    @return: success

Help on function is_additive in module ida_hexrays:

is_additive(*args) -> 'bool'
    is_additive(op) -> bool
    Is additive operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_assignment in module ida_hexrays:

is_assignment(*args) -> 'bool'
    is_assignment(op) -> bool
    Is assignment operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_binary in module ida_hexrays:

is_binary(*args) -> 'bool'
    is_binary(op) -> bool
    Is binary operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_bitop in module ida_hexrays:

is_bitop(*args) -> 'bool'
    is_bitop(op) -> bool
    Is bit related operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_bool_type in module ida_hexrays:

is_bool_type(*args) -> 'bool'
    is_bool_type(type) -> bool
    Is a boolean type?
    
    @param type: (C++: const tinfo_t &) tinfo_t const &
    @return: true if the type is a boolean type

Help on function is_break_consumer in module ida_hexrays:

is_break_consumer(*args) -> 'bool'
    is_break_consumer(op) -> bool
    Does a break statement influence the specified statement code?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_commutative in module ida_hexrays:

is_commutative(*args) -> 'bool'
    is_commutative(op) -> bool
    Is commutative operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_inplace_def in module ida_hexrays:

is_inplace_def(*args) -> 'bool'
    is_inplace_def(type) -> bool
    Is struct/union/enum definition (not declaration)?
    
    @param type: (C++: const tinfo_t &) tinfo_t const &

Help on function is_kreg in module ida_hexrays:

is_kreg(*args) -> 'bool'
    is_kreg(r) -> bool
    Is a kernel register? Kernel registers are temporary registers that can be used
    freely. They may be used to store values that cross instruction or basic block
    boundaries. Kernel registers do not map to regular processor registers. See also
    mba_t::alloc_kreg()
    
    @param r: (C++: mreg_t)

Help on function is_logical in module ida_hexrays:

is_logical(*args) -> 'bool'
    is_logical(op) -> bool
    Is logical operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_loop in module ida_hexrays:

is_loop(*args) -> 'bool'
    is_loop(op) -> bool
    Is loop statement code?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_lvalue in module ida_hexrays:

is_lvalue(*args) -> 'bool'
    is_lvalue(op) -> bool
    Is Lvalue operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_may_access in module ida_hexrays:

is_may_access(*args) -> 'bool'
    is_may_access(maymust) -> bool
    
    @param maymust: maymust_t

Help on function is_mcode_addsub in module ida_hexrays:

is_mcode_addsub(*args) -> 'bool'
    is_mcode_addsub(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_call in module ida_hexrays:

is_mcode_call(*args) -> 'bool'
    is_mcode_call(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_commutative in module ida_hexrays:

is_mcode_commutative(*args) -> 'bool'
    is_mcode_commutative(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_convertible_to_jmp in module ida_hexrays:

is_mcode_convertible_to_jmp(*args) -> 'bool'
    is_mcode_convertible_to_jmp(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_convertible_to_set in module ida_hexrays:

is_mcode_convertible_to_set(*args) -> 'bool'
    is_mcode_convertible_to_set(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_divmod in module ida_hexrays:

is_mcode_divmod(*args) -> 'bool'
    is_mcode_divmod(op) -> bool
    
    @param op: enum mcode_t

Help on function is_mcode_fpu in module ida_hexrays:

is_mcode_fpu(*args) -> 'bool'
    is_mcode_fpu(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_j1 in module ida_hexrays:

is_mcode_j1(*args) -> 'bool'
    is_mcode_j1(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_jcond in module ida_hexrays:

is_mcode_jcond(*args) -> 'bool'
    is_mcode_jcond(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_propagatable in module ida_hexrays:

is_mcode_propagatable(*args) -> 'bool'
    is_mcode_propagatable(mcode) -> bool
    May opcode be propagated? Such opcodes can be used in sub-instructions (nested
    instructions) There is a handful of non-propagatable opcodes, like jumps, ret,
    nop, etc All other regular opcodes are propagatable and may appear in a nested
    instruction.
    
    @param mcode: (C++: mcode_t) enum mcode_t

Help on function is_mcode_set in module ida_hexrays:

is_mcode_set(*args) -> 'bool'
    is_mcode_set(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_set1 in module ida_hexrays:

is_mcode_set1(*args) -> 'bool'
    is_mcode_set1(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_shift in module ida_hexrays:

is_mcode_shift(*args) -> 'bool'
    is_mcode_shift(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_mcode_xdsu in module ida_hexrays:

is_mcode_xdsu(*args) -> 'bool'
    is_mcode_xdsu(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on function is_multiplicative in module ida_hexrays:

is_multiplicative(*args) -> 'bool'
    is_multiplicative(op) -> bool
    Is multiplicative operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_nonbool_type in module ida_hexrays:

is_nonbool_type(*args) -> 'bool'
    is_nonbool_type(type) -> bool
    Is definitely a non-boolean type?
    
    @param type: (C++: const tinfo_t &) tinfo_t const &
    @return: true if the type is a non-boolean type (non bool and well defined)

Help on function is_paf in module ida_hexrays:

is_paf(*args) -> 'bool'
    is_paf(t) -> bool
    Is a pointer, array, or function type?
    
    @param t: (C++: type_t)

Help on function is_prepost in module ida_hexrays:

is_prepost(*args) -> 'bool'
    is_prepost(op) -> bool
    Is pre/post increment/decrement operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_ptr_or_array in module ida_hexrays:

is_ptr_or_array(*args) -> 'bool'
    is_ptr_or_array(t) -> bool
    Is a pointer or array type?
    
    @param t: (C++: type_t)

Help on function is_relational in module ida_hexrays:

is_relational(*args) -> 'bool'
    is_relational(op) -> bool
    Is comparison operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_signed_mcode in module ida_hexrays:

is_signed_mcode(*args) -> 'bool'
    is_signed_mcode(code) -> bool
    
    @param code: enum mcode_t

Help on function is_small_udt in module ida_hexrays:

is_small_udt(*args) -> 'bool'
    is_small_udt(tif) -> bool
    Is a small structure or union?
    
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @return: true if the type is a small UDT (user defined type). Small UDTs fit
             into a register (or pair or registers) as a rule.

Help on function is_type_correct in module ida_hexrays:

is_type_correct(*args) -> 'bool'
    is_type_correct(ptr) -> bool
    Verify a type string.
    
    @param ptr: (C++: const type_t *) type_t const *
    @return: true if type string is correct

Help on function is_unary in module ida_hexrays:

is_unary(*args) -> 'bool'
    is_unary(op) -> bool
    Is unary operator?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function is_unsigned_mcode in module ida_hexrays:

is_unsigned_mcode(*args) -> 'bool'
    is_unsigned_mcode(code) -> bool
    
    @param code: enum mcode_t

Help on class iterator in module ida_hexrays:

class iterator(builtins.object)
 |  Proxy of C++ bitset_t::iterator class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, n) -> bool
 |      
 |      @param n: bitset_t::iterator const &
 |  
 |  __init__(self, *args)
 |      __init__(self, n=-1) -> iterator
 |      
 |      @param n: int
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, n) -> bool
 |      
 |      @param n: bitset_t::iterator const &
 |  
 |  __ref__(self, *args) -> 'int'
 |      __ref__(self) -> int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_iterator(...)
 |      delete_iterator(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ivl_t in module ida_hexrays:

class ivl_t(uval_ivl_t)
 |  Proxy of C++ ivl_t class.
 |  
 |  Method resolution order:
 |      ivl_t
 |      uval_ivl_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _off=0, _size=0) -> ivl_t
 |      
 |      @param _off: uval_t
 |      @param _size: uval_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ivl_t(...)
 |      delete_ivl_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: ivl_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, off2) -> bool
 |      
 |      @param off2: uval_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  extend_to_cover(self, *args) -> 'bool'
 |      extend_to_cover(self, r) -> bool
 |      
 |      @param r: ivl_t const &
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ivl) -> bool
 |      
 |      @param ivl: ivl_t const &
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      
 |      @param r: ivl_t const &
 |  
 |  overlap(self, *args) -> 'bool'
 |      overlap(self, ivl) -> bool
 |      
 |      @param ivl: ivl_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from uval_ivl_t:
 |  
 |  end(self, *args) -> 'unsigned-ea-like-numeric-type'
 |      end(self) -> unsigned-ea-like-numeric-type
 |  
 |  last(self, *args) -> 'unsigned-ea-like-numeric-type'
 |      last(self) -> unsigned-ea-like-numeric-type
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from uval_ivl_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      off
 |  
 |  size
 |      size

Help on class ivl_with_name_t in module ida_hexrays:

class ivl_with_name_t(builtins.object)
 |  Proxy of C++ ivl_with_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ivl_with_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ivl_with_name_t(...)
 |      delete_ivl_with_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ivl
 |      ivl
 |  
 |  part
 |      part
 |  
 |  thisown
 |      The membership flag
 |  
 |  whole
 |      whole

Help on class ivlset_t in module ida_hexrays:

class ivlset_t(uval_ivl_ivlset_t)
 |  Proxy of C++ ivlset_t class.
 |  
 |  Method resolution order:
 |      ivlset_t
 |      uval_ivl_ivlset_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ivlset_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: ivlset_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: ivlset_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ivlset_t
 |      __init__(self, ivl) -> ivlset_t
 |      
 |      @param ivl: ivl_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: ivlset_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: ivlset_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ivlset_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ivlset_t(...)
 |      delete_ivlset_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, ivl) -> bool
 |      
 |      @param ivl: ivl_t const &
 |      
 |      add(self, ea, size) -> bool
 |      
 |      @param ea: ea_t
 |      @param size: asize_t
 |      
 |      add(self, ivs) -> bool
 |      
 |      @param ivs: ivlset_t const &
 |  
 |  addmasked(self, *args) -> 'bool'
 |      addmasked(self, ivs, mask) -> bool
 |      
 |      @param ivs: ivlset_t const &
 |      @param mask: ivl_t const &
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: ivlset_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, off) -> bool
 |      
 |      @param off: uval_t
 |  
 |  count(self, *args) -> 'asize_t'
 |      count(self) -> asize_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, ivl, strict=False) -> bool
 |      
 |      @param ivl: ivl_t const &
 |      @param strict: bool
 |      
 |      has_common(self, ivs) -> bool
 |      
 |      @param ivs: ivlset_t const &
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ivs) -> bool
 |      
 |      @param ivs: ivlset_t const &
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, ivs) -> bool
 |      
 |      @param ivs: ivlset_t const &
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, ivl) -> bool
 |      
 |      @param ivl: ivl_t const &
 |      
 |      sub(self, ea, size) -> bool
 |      
 |      @param ea: ea_t
 |      @param size: asize_t
 |      
 |      sub(self, ivs) -> bool
 |      
 |      @param ivs: ivlset_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from uval_ivl_ivlset_t:
 |  
 |  all_values(self, *args) -> 'bool'
 |      all_values(self) -> bool
 |  
 |  begin(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator
 |  
 |  getivl(self, *args) -> 'ivl_t const &'
 |      getivl(self, idx) -> ivl_t
 |      
 |      @param idx: int
 |  
 |  lastivl(self, *args) -> 'ivl_t const &'
 |      lastivl(self) -> ivl_t
 |  
 |  nivls(self, *args) -> 'size_t'
 |      nivls(self) -> size_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  set_all_values(self, *args) -> 'void'
 |      set_all_values(self)
 |  
 |  single_value(self, *args) -> 'bool'
 |      single_value(self) -> bool
 |      single_value(self, v) -> bool
 |      
 |      @param v: unsigned-ea-like-numeric-type
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: ivlset_tpl< ivl_t,uval_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from uval_ivl_ivlset_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function jcnd2set in module ida_hexrays:

jcnd2set(*args) -> 'mcode_t'
    jcnd2set(code) -> mcode_t
    
    @param code: enum mcode_t

Help on function lexcompare in module ida_hexrays:

lexcompare(*args) -> 'int'
    lexcompare(a, b) -> int
    
    @param a: mop_t const &
    @param b: mop_t const &

Help on function lnot in module ida_hexrays:

lnot(e)
    Logically negate the specified expression. The specified expression will be
    logically negated. For example, "x == y" is converted into "x != y" by this
    function.
    
    @return: logically negated expression.

Help on function locate_lvar in module ida_hexrays:

locate_lvar(*args) -> 'bool'
    locate_lvar(out, func_ea, varname) -> bool
    Find a variable by name.
    
    @param out: (C++: lvar_locator_t *) output buffer for the variable locator
    @param func_ea: (C++: ea_t) function start address
    @param varname: (C++: const char *) variable name
    @return: success Since VARNAME is not always enough to find the variable, it may
             decompile the function.

Help on class lvar_locator_t in module ida_hexrays:

class lvar_locator_t(builtins.object)
 |  Proxy of C++ lvar_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_locator_t
 |      __init__(self, loc, ea) -> lvar_locator_t
 |      
 |      @param loc: vdloc_t const &
 |      @param ea: ea_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_locator_t(...)
 |      delete_lvar_locator_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  get_reg1(self, *args) -> 'mreg_t'
 |      get_reg1(self) -> mreg_t
 |      Get the register number of the variable.
 |  
 |  get_reg2(self, *args) -> 'mreg_t'
 |      get_reg2(self) -> mreg_t
 |      Get the number of the second register (works only for ALOC_REG2 lvars)
 |  
 |  get_scattered(self, *args) -> 'scattered_aloc_t &'
 |      get_scattered(self) -> scattered_aloc_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |      Get offset of the varialbe in the stack frame.
 |      
 |      @return: a non-negative value for stack variables. The value is an offset from
 |               the bottom of the stack frame in terms of vd-offsets. negative values
 |               mean error (not a stack variable)
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |      Is variable located on one register?
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |      Is variable located on two registers?
 |  
 |  is_reg_var(self, *args) -> 'bool'
 |      is_reg_var(self) -> bool
 |      Is variable located on register(s)?
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      Is variable scattered?
 |  
 |  is_stk_var(self, *args) -> 'bool'
 |      is_stk_var(self) -> bool
 |      Is variable located on the stack?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  defea
 |      defea
 |  
 |  location
 |      location
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function lvar_mapping_begin in module ida_hexrays:

lvar_mapping_begin(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_begin(map) -> lvar_mapping_iterator_t
    Get iterator pointing to the beginning of lvar_mapping_t.
    
    @param map: (C++: const lvar_mapping_t *) lvar_mapping_t const *

Help on function lvar_mapping_clear in module ida_hexrays:

lvar_mapping_clear(*args) -> 'void'
    lvar_mapping_clear(map)
    Clear lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)

Help on function lvar_mapping_end in module ida_hexrays:

lvar_mapping_end(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_end(map) -> lvar_mapping_iterator_t
    Get iterator pointing to the end of lvar_mapping_t.
    
    @param map: (C++: const lvar_mapping_t *) lvar_mapping_t const *

Help on function lvar_mapping_erase in module ida_hexrays:

lvar_mapping_erase(*args) -> 'void'
    lvar_mapping_erase(map, p)
    Erase current element from lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)
    @param p: (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_find in module ida_hexrays:

lvar_mapping_find(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_find(map, key) -> lvar_mapping_iterator_t
    Find the specified key in lvar_mapping_t.
    
    @param map: (C++: const lvar_mapping_t *) lvar_mapping_t const *
    @param key: (C++: const lvar_locator_t &) lvar_locator_t const &

Help on function lvar_mapping_first in module ida_hexrays:

lvar_mapping_first(*args) -> 'lvar_locator_t const &'
    lvar_mapping_first(p) -> lvar_locator_t
    Get reference to the current map key.
    
    @param p: (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_free in module ida_hexrays:

lvar_mapping_free(*args) -> 'void'
    lvar_mapping_free(map)
    Delete lvar_mapping_t instance.
    
    @param map: (C++: lvar_mapping_t *)

Help on function lvar_mapping_insert in module ida_hexrays:

lvar_mapping_insert(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t
    Insert new (lvar_locator_t, lvar_locator_t) pair into lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)
    @param key: (C++: const lvar_locator_t &) lvar_locator_t const &
    @param val: (C++: const lvar_locator_t &) lvar_locator_t const &

Help on class lvar_mapping_iterator_t in module ida_hexrays:

class lvar_mapping_iterator_t(builtins.object)
 |  Proxy of C++ lvar_mapping_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: lvar_mapping_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_mapping_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: lvar_mapping_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_mapping_iterator_t(...)
 |      delete_lvar_mapping_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function lvar_mapping_new in module ida_hexrays:

lvar_mapping_new(*args) -> 'lvar_mapping_t *'
    lvar_mapping_new() -> lvar_mapping_t
    Create a new lvar_mapping_t instance.

Help on function lvar_mapping_next in module ida_hexrays:

lvar_mapping_next(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_next(p) -> lvar_mapping_iterator_t
    Move to the next element.
    
    @param p: (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_prev in module ida_hexrays:

lvar_mapping_prev(*args) -> 'lvar_mapping_iterator_t'
    lvar_mapping_prev(p) -> lvar_mapping_iterator_t
    Move to the previous element.
    
    @param p: (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_second in module ida_hexrays:

lvar_mapping_second(*args) -> 'lvar_locator_t &'
    lvar_mapping_second(p) -> lvar_locator_t
    Get reference to the current map value.
    
    @param p: (C++: lvar_mapping_iterator_t)

Help on function lvar_mapping_size in module ida_hexrays:

lvar_mapping_size(*args) -> 'size_t'
    lvar_mapping_size(map) -> size_t
    Get size of lvar_mapping_t.
    
    @param map: (C++: lvar_mapping_t *)

Help on class lvar_mapping_t in module ida_hexrays:

class lvar_mapping_t(builtins.object)
 |  Proxy of C++ std::map< lvar_locator_t,lvar_locator_t > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_mapping_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_mapping_t(...)
 |      delete_lvar_mapping_t(self)
 |  
 |  at(self, *args) -> 'lvar_locator_t &'
 |      at(self, _Keyval) -> lvar_locator_t
 |      
 |      @param _Keyval: lvar_locator_t const &
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class lvar_ref_t in module ida_hexrays:

class lvar_ref_t(builtins.object)
 |  Proxy of C++ lvar_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, m, i, o=0) -> lvar_ref_t
 |      
 |      @param m: mba_t *
 |      @param i: int
 |      @param o: sval_t
 |      
 |      __init__(self, r) -> lvar_ref_t
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_ref_t(...)
 |      delete_lvar_ref_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: lvar_ref_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: lvar_ref_t &
 |  
 |  var(self, *args) -> 'lvar_t &'
 |      var(self) -> lvar_t
 |      Retrieve the referenced variable.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      idx
 |  
 |  mba
 |      mba
 |  
 |  off
 |      off
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lvar_saved_info_t in module ida_hexrays:

class lvar_saved_info_t(builtins.object)
 |  Proxy of C++ lvar_saved_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: lvar_saved_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_saved_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: lvar_saved_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_saved_info_t(...)
 |      delete_lvar_saved_info_t(self)
 |  
 |  clear_keep(self, *args) -> 'void'
 |      clear_keep(self)
 |  
 |  clr_forced_lvar(self, *args) -> 'void'
 |      clr_forced_lvar(self)
 |  
 |  clr_nomap_lvar(self, *args) -> 'void'
 |      clr_nomap_lvar(self)
 |  
 |  clr_noptr_lvar(self, *args) -> 'void'
 |      clr_noptr_lvar(self)
 |  
 |  clr_unused_lvar(self, *args) -> 'void'
 |      clr_unused_lvar(self)
 |  
 |  has_info(self, *args) -> 'bool'
 |      has_info(self) -> bool
 |  
 |  is_forced_lvar(self, *args) -> 'bool'
 |      is_forced_lvar(self) -> bool
 |  
 |  is_kept(self, *args) -> 'bool'
 |      is_kept(self) -> bool
 |  
 |  is_nomap_lvar(self, *args) -> 'bool'
 |      is_nomap_lvar(self) -> bool
 |  
 |  is_noptr_lvar(self, *args) -> 'bool'
 |      is_noptr_lvar(self) -> bool
 |  
 |  is_unused_lvar(self, *args) -> 'bool'
 |      is_unused_lvar(self) -> bool
 |  
 |  set_forced_lvar(self, *args) -> 'void'
 |      set_forced_lvar(self)
 |  
 |  set_keep(self, *args) -> 'void'
 |      set_keep(self)
 |  
 |  set_nomap_lvar(self, *args) -> 'void'
 |      set_nomap_lvar(self)
 |  
 |  set_noptr_lvar(self, *args) -> 'void'
 |      set_noptr_lvar(self)
 |  
 |  set_unused_lvar(self, *args) -> 'void'
 |      set_unused_lvar(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      cmt
 |  
 |  flags
 |      flags
 |  
 |  ll
 |      ll
 |  
 |  name
 |      name
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lvar_saved_infos_t in module ida_hexrays:

class lvar_saved_infos_t(builtins.object)
 |  Proxy of C++ qvector< lvar_saved_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< lvar_saved_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'lvar_saved_info_t const &'
 |      __getitem__(self, i) -> lvar_saved_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_saved_infos_t
 |      __init__(self, x) -> lvar_saved_infos_t
 |      
 |      @param x: qvector< lvar_saved_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< lvar_saved_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: lvar_saved_info_t const &
 |  
 |  __swig_destroy__ = delete_lvar_saved_infos_t(...)
 |      delete_lvar_saved_infos_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: lvar_saved_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: lvar_saved_info_t const &
 |  
 |  append = push_back(self, *args) -> 'lvar_saved_info_t &'
 |  
 |  at = __getitem__(self, *args) -> 'lvar_saved_info_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator'
 |      begin(self) -> lvar_saved_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator'
 |      end(self) -> lvar_saved_info_t
 |  
 |  erase(self, *args) -> 'qvector< lvar_saved_info_t >::iterator'
 |      erase(self, it) -> lvar_saved_info_t
 |      
 |      @param it: qvector< lvar_saved_info_t >::iterator
 |      
 |      erase(self, first, last) -> lvar_saved_info_t
 |      
 |      @param first: qvector< lvar_saved_info_t >::iterator
 |      @param last: qvector< lvar_saved_info_t >::iterator
 |  
 |  extract(self, *args) -> 'lvar_saved_info_t *'
 |      extract(self) -> lvar_saved_info_t
 |  
 |  find(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator'
 |      find(self, x) -> lvar_saved_info_t
 |      
 |      @param x: lvar_saved_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lvar_saved_info_t())
 |      
 |      @param x: lvar_saved_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: lvar_saved_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: lvar_saved_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< lvar_saved_info_t >::iterator'
 |      insert(self, it, x) -> lvar_saved_info_t
 |      
 |      @param it: qvector< lvar_saved_info_t >::iterator
 |      @param x: lvar_saved_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lvar_saved_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: lvar_saved_info_t const &
 |      
 |      push_back(self) -> lvar_saved_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: lvar_saved_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< lvar_saved_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lvar_t in module ida_hexrays:

class lvar_t(lvar_locator_t)
 |  Proxy of C++ lvar_t class.
 |  
 |  Method resolution order:
 |      lvar_t
 |      lvar_locator_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> lvar_locator_t
 |      __init__(self, loc, ea) -> lvar_locator_t
 |      
 |      @param loc: vdloc_t const &
 |      @param ea: ea_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_t(...)
 |      delete_lvar_t(self)
 |  
 |  accepts_type(self, *args) -> 'bool'
 |      accepts_type(self, t, may_change_thisarg=False) -> bool
 |      Check if the variable accept the specified type. Some types are forbidden (void,
 |      function types, wrong arrays, etc)
 |      
 |      @param t: (C++: const tinfo_t &) tinfo_t const &
 |      @param may_change_thisarg: (C++: bool)
 |  
 |  append_list(self, *args) -> 'void'
 |      append_list(self, mba, lst, pad_if_scattered=False)
 |      Append local variable to mlist.
 |      
 |      @param mba: (C++: const mba_t *) ptr to the current mba_t
 |      @param lst: (C++: mlist_t *) list to append to
 |      @param pad_if_scattered: (C++: bool) if true, append padding bytes in case of scattered lvar
 |  
 |  clear_used(self, *args) -> 'void'
 |      clear_used(self)
 |  
 |  clr_arg_var(self, *args) -> 'void'
 |      clr_arg_var(self)
 |  
 |  clr_automapped(self, *args) -> 'void'
 |      clr_automapped(self)
 |  
 |  clr_decl_unused(self, *args) -> 'void'
 |      clr_decl_unused(self)
 |  
 |  clr_dummy_arg(self, *args) -> 'void'
 |      clr_dummy_arg(self)
 |  
 |  clr_fake_var(self, *args) -> 'void'
 |      clr_fake_var(self)
 |  
 |  clr_floating_var(self, *args) -> 'void'
 |      clr_floating_var(self)
 |  
 |  clr_forced_var(self, *args) -> 'void'
 |      clr_forced_var(self)
 |  
 |  clr_mapdst_var(self, *args) -> 'void'
 |      clr_mapdst_var(self)
 |  
 |  clr_mreg_done(self, *args) -> 'void'
 |      clr_mreg_done(self)
 |  
 |  clr_noptr_var(self, *args) -> 'void'
 |      clr_noptr_var(self)
 |  
 |  clr_notarg(self, *args) -> 'void'
 |      clr_notarg(self)
 |  
 |  clr_overlapped_var(self, *args) -> 'void'
 |      clr_overlapped_var(self)
 |  
 |  clr_shared(self, *args) -> 'void'
 |      clr_shared(self)
 |  
 |  clr_spoiled_var(self, *args) -> 'void'
 |      clr_spoiled_var(self)
 |  
 |  clr_thisarg(self, *args) -> 'void'
 |      clr_thisarg(self)
 |  
 |  clr_unknown_width(self, *args) -> 'void'
 |      clr_unknown_width(self)
 |  
 |  clr_used_byref(self, *args) -> 'void'
 |      clr_used_byref(self)
 |  
 |  clr_user_info(self, *args) -> 'void'
 |      clr_user_info(self)
 |  
 |  clr_user_name(self, *args) -> 'void'
 |      clr_user_name(self)
 |  
 |  clr_user_type(self, *args) -> 'void'
 |      clr_user_type(self)
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, v) -> bool
 |      Do variables overlap?
 |      
 |      @param v: (C++: const lvar_t &) lvar_t const &
 |  
 |  has_common_bit(self, *args) -> 'bool'
 |      has_common_bit(self, loc, width2) -> bool
 |      Does the variable overlap with the specified location?
 |      
 |      @param loc: (C++: const vdloc_t &) vdloc_t const &
 |      @param width2: (C++: asize_t)
 |  
 |  has_regname(self, *args) -> 'bool'
 |      has_regname(self) -> bool
 |      Has a register name? (like _RAX)
 |  
 |  in_asm(self, *args) -> 'bool'
 |      in_asm(self) -> bool
 |      Is variable used in an instruction translated into __asm?
 |  
 |  is_aliasable(self, *args) -> 'bool'
 |      is_aliasable(self, mba) -> bool
 |      Is the variable aliasable?
 |      
 |      @param mba: (C++: const mba_t *) ptr to the current mba_t Aliasable variables may be modified
 |                  indirectly (through a pointer)
 |  
 |  is_automapped(self, *args) -> 'bool'
 |      is_automapped(self) -> bool
 |      Was the variable automatically mapped to another variable?
 |  
 |  is_decl_unused(self, *args) -> 'bool'
 |      is_decl_unused(self) -> bool
 |      Was declared as __unused by the user? See CVAR_UNUSED.
 |  
 |  is_dummy_arg(self, *args) -> 'bool'
 |      is_dummy_arg(self) -> bool
 |      Is a dummy argument (added to fill a hole in the argument list)
 |  
 |  is_forced_var(self, *args) -> 'bool'
 |      is_forced_var(self) -> bool
 |      Is a forced variable?
 |  
 |  is_noptr_var(self, *args) -> 'bool'
 |      is_noptr_var(self) -> bool
 |      Variable type should not be a pointer.
 |  
 |  is_notarg(self, *args) -> 'bool'
 |      is_notarg(self) -> bool
 |      Is a local variable? (local variable cannot be an input argument)
 |  
 |  is_shared(self, *args) -> 'bool'
 |      is_shared(self) -> bool
 |      Is lvar mapped to several chains.
 |  
 |  is_thisarg(self, *args) -> 'bool'
 |      is_thisarg(self) -> bool
 |      Is 'this' argument of a C++ member function?
 |  
 |  is_used_byref(self, *args) -> 'bool'
 |      is_used_byref(self) -> bool
 |      Was the address of the variable taken?
 |  
 |  set_arg_var(self, *args) -> 'void'
 |      set_arg_var(self)
 |  
 |  set_automapped(self, *args) -> 'void'
 |      set_automapped(self)
 |  
 |  set_decl_unused(self, *args) -> 'void'
 |      set_decl_unused(self)
 |  
 |  set_dummy_arg(self, *args) -> 'void'
 |      set_dummy_arg(self)
 |  
 |  set_fake_var(self, *args) -> 'void'
 |      set_fake_var(self)
 |  
 |  set_final_lvar_type(self, *args) -> 'void'
 |      set_final_lvar_type(self, t)
 |      Set final variable type.
 |      
 |      @param t: (C++: const tinfo_t &) tinfo_t const &
 |  
 |  set_floating_var(self, *args) -> 'void'
 |      set_floating_var(self)
 |  
 |  set_forced_var(self, *args) -> 'void'
 |      set_forced_var(self)
 |  
 |  set_lvar_type(self, *args) -> 'bool'
 |      set_lvar_type(self, t, may_fail=False) -> bool
 |      Set variable type Note: this function does not modify the idb, only the lvar
 |      instance in the memory. For permanent changes see modify_user_lvars() Also, the
 |      variable type is not considered as final by the decompiler and may be modified
 |      later by the type derivation. In some cases set_final_var_type() may work
 |      better, but it does not do persistent changes to the database neither.
 |      
 |      @param t: (C++: const tinfo_t &) new type
 |      @param may_fail: (C++: bool) if false and type is bad, interr
 |      @return: success
 |  
 |  set_mapdst_var(self, *args) -> 'void'
 |      set_mapdst_var(self)
 |  
 |  set_mreg_done(self, *args) -> 'void'
 |      set_mreg_done(self)
 |  
 |  set_non_typed(self, *args) -> 'void'
 |      set_non_typed(self)
 |  
 |  set_noptr_var(self, *args) -> 'void'
 |      set_noptr_var(self)
 |  
 |  set_notarg(self, *args) -> 'void'
 |      set_notarg(self)
 |  
 |  set_overlapped_var(self, *args) -> 'void'
 |      set_overlapped_var(self)
 |  
 |  set_shared(self, *args) -> 'void'
 |      set_shared(self)
 |  
 |  set_spoiled_var(self, *args) -> 'void'
 |      set_spoiled_var(self)
 |  
 |  set_thisarg(self, *args) -> 'void'
 |      set_thisarg(self)
 |  
 |  set_typed(self, *args) -> 'void'
 |      set_typed(self)
 |  
 |  set_unknown_width(self, *args) -> 'void'
 |      set_unknown_width(self)
 |  
 |  set_used(self, *args) -> 'void'
 |      set_used(self)
 |  
 |  set_used_byref(self, *args) -> 'void'
 |      set_used_byref(self)
 |  
 |  set_user_name(self, *args) -> 'void'
 |      set_user_name(self)
 |  
 |  set_user_type(self, *args) -> 'void'
 |      set_user_type(self)
 |  
 |  set_width(self, *args) -> 'bool'
 |      set_width(self, w, svw_flags=0) -> bool
 |      Change the variable width. We call the variable size 'width', it is represents
 |      the number of bytes. This function may change the variable type using
 |      set_lvar_type().
 |      
 |      @param w: (C++: int) new width
 |      @param svw_flags: (C++: int) combination of SVW_... bits
 |      @return: success
 |  
 |  type(self, *args) -> 'tinfo_t &'
 |      type(self) -> tinfo_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cmt
 |      cmt
 |  
 |  defblk
 |      defblk
 |  
 |  divisor
 |      divisor
 |  
 |  has_nice_name
 |      has_nice_name(self) -> bool
 |      Does the variable have a nice name?
 |  
 |  has_user_info
 |      has_user_info(self) -> bool
 |      Has any user-defined information?
 |  
 |  has_user_name
 |      has_user_name(self) -> bool
 |      Has user-defined name?
 |  
 |  has_user_type
 |      has_user_type(self) -> bool
 |      Has user-defined type?
 |  
 |  is_arg_var
 |      is_arg_var(self) -> bool
 |      Is the function argument?
 |  
 |  is_fake_var
 |      is_fake_var(self) -> bool
 |      Is fake return variable?
 |  
 |  is_floating_var
 |      is_floating_var(self) -> bool
 |      Used by a fpu insn?
 |  
 |  is_mapdst_var
 |      is_mapdst_var(self) -> bool
 |      Other variable(s) map to this var?
 |  
 |  is_overlapped_var
 |      is_overlapped_var(self) -> bool
 |      Is overlapped variable?
 |  
 |  is_result_var
 |      is_result_var(self) -> bool
 |      Is the function result?
 |  
 |  is_spoiled_var
 |      is_spoiled_var(self) -> bool
 |      Is spoiled var? (meaningful only during lvar allocation)
 |  
 |  is_unknown_width
 |      is_unknown_width(self) -> bool
 |      Do we know the width of the variable?
 |  
 |  mreg_done
 |      mreg_done(self) -> bool
 |      Have corresponding microregs been replaced by references to this variable?
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      tif
 |  
 |  typed
 |      typed(self) -> bool
 |      Has the variable a type?
 |  
 |  used
 |      used(self) -> bool
 |      Is the variable used in the code?
 |  
 |  width
 |      width
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from lvar_locator_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: lvar_locator_t const &
 |  
 |  get_reg1(self, *args) -> 'mreg_t'
 |      get_reg1(self) -> mreg_t
 |      Get the register number of the variable.
 |  
 |  get_reg2(self, *args) -> 'mreg_t'
 |      get_reg2(self) -> mreg_t
 |      Get the number of the second register (works only for ALOC_REG2 lvars)
 |  
 |  get_scattered(self, *args) -> 'scattered_aloc_t &'
 |      get_scattered(self) -> scattered_aloc_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |      Get offset of the varialbe in the stack frame.
 |      
 |      @return: a non-negative value for stack variables. The value is an offset from
 |               the bottom of the stack frame in terms of vd-offsets. negative values
 |               mean error (not a stack variable)
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |      Is variable located on one register?
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |      Is variable located on two registers?
 |  
 |  is_reg_var(self, *args) -> 'bool'
 |      is_reg_var(self) -> bool
 |      Is variable located on register(s)?
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      Is variable scattered?
 |  
 |  is_stk_var(self, *args) -> 'bool'
 |      is_stk_var(self) -> bool
 |      Is variable located on the stack?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from lvar_locator_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  defea
 |      defea
 |  
 |  location
 |      location
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from lvar_locator_t:
 |  
 |  __hash__ = None

Help on class lvar_uservec_t in module ida_hexrays:

class lvar_uservec_t(builtins.object)
 |  Proxy of C++ lvar_uservec_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvar_uservec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvar_uservec_t(...)
 |      delete_lvar_uservec_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  find_info(self, *args) -> 'lvar_saved_info_t *'
 |      find_info(self, vloc) -> lvar_saved_info_t
 |      find saved user settings for given var
 |      
 |      @param vloc: (C++: const lvar_locator_t &) lvar_locator_t const &
 |  
 |  keep_info(self, *args) -> 'void'
 |      keep_info(self, v)
 |      Preserve user settings for given var.
 |      
 |      @param v: (C++: const lvar_t &) lvar_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: lvar_uservec_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lmaps
 |      lmaps
 |  
 |  lvvec
 |      lvvec
 |  
 |  stkoff_delta
 |      stkoff_delta
 |  
 |  thisown
 |      The membership flag
 |  
 |  ulv_flags
 |      ulv_flags

Help on class lvars_t in module ida_hexrays:

class lvars_t(qvector_lvar_t)
 |  Proxy of C++ lvars_t class.
 |  
 |  Method resolution order:
 |      lvars_t
 |      qvector_lvar_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lvars_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lvars_t(...)
 |      delete_lvars_t(self)
 |  
 |  find(self, *args) -> 'lvar_t *'
 |      find(self, ll) -> lvar_t
 |      Find variable at the specified location.
 |      
 |      @param ll: (C++: const lvar_locator_t &) variable location
 |      @return: pointer to variable or nullptr
 |  
 |  find_input_lvar(self, *args) -> 'int'
 |      find_input_lvar(self, argloc, _size) -> int
 |      Find input variable at the specified location.
 |      
 |      @param argloc: (C++: const vdloc_t &) variable location
 |      @param _size: (C++: int) variable size
 |      @return: -1 if failed, otherwise the index into the variables vector.
 |  
 |  find_lvar(self, *args) -> 'int'
 |      find_lvar(self, location, width, defblk=-1) -> int
 |      Find variable at the specified location.
 |      
 |      @param location: (C++: const vdloc_t &) variable location
 |      @param width: (C++: int) variable size
 |      @param defblk: (C++: int) definition block of the lvar. -1 means any block
 |      @return: -1 if failed, otherwise the index into the variables vector.
 |  
 |  find_stkvar(self, *args) -> 'int'
 |      find_stkvar(self, spoff, width) -> int
 |      Find stack variable at the specified location.
 |      
 |      @param spoff: (C++: sval_t) offset from the minimal sp
 |      @param width: (C++: int) variable size
 |      @return: -1 if failed, otherwise the index into the variables vector.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from qvector_lvar_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< lvar_t > const &
 |  
 |  __getitem__(self, *args) -> 'lvar_t const &'
 |      __getitem__(self, i) -> lvar_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< lvar_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: lvar_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: lvar_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: lvar_t const &
 |  
 |  append = push_back(self, *args) -> 'lvar_t &'
 |      push_back(self, x)
 |      
 |      @param x: lvar_t const &
 |      
 |      push_back(self) -> lvar_t
 |  
 |  at = __getitem__(self, *args) -> 'lvar_t const &'
 |      __getitem__(self, i) -> lvar_t
 |      
 |      @param i: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      begin(self) -> lvar_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      end(self) -> lvar_t
 |  
 |  erase(self, *args) -> 'qvector< lvar_t >::iterator'
 |      erase(self, it) -> lvar_t
 |      
 |      @param it: qvector< lvar_t >::iterator
 |      
 |      erase(self, first, last) -> lvar_t
 |      
 |      @param first: qvector< lvar_t >::iterator
 |      @param last: qvector< lvar_t >::iterator
 |  
 |  extract(self, *args) -> 'lvar_t *'
 |      extract(self) -> lvar_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lvar_t())
 |      
 |      @param x: lvar_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: lvar_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: lvar_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< lvar_t >::iterator'
 |      insert(self, it, x) -> lvar_t
 |      
 |      @param it: qvector< lvar_t >::iterator
 |      @param x: lvar_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lvar_t &'
 |      push_back(self, x)
 |      
 |      @param x: lvar_t const &
 |      
 |      push_back(self) -> lvar_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: lvar_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< lvar_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from qvector_lvar_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from qvector_lvar_t:
 |  
 |  __hash__ = None

Help on function make_num in module ida_hexrays:

make_num(*args)
    Create a number expression

Help on function make_pointer in module ida_hexrays:

make_pointer(*args) -> 'tinfo_t'
    make_pointer(type) -> tinfo_t
    Create a pointer type. This function performs the following conversion: "type"
    -> "type*"
    
    @param type: (C++: const tinfo_t &) object type.
    @return: "type*". for example, if 'char' is passed as the argument,

Help on function make_ref in module ida_hexrays:

make_ref(e)
    Create a reference. This function performs the following conversion: "obj" =>
    "&obj". It can handle casts, annihilate "&*", and process other special cases.

Help on function mark_cfunc_dirty in module ida_hexrays:

mark_cfunc_dirty(*args) -> 'bool'
    mark_cfunc_dirty(ea, close_views=False) -> bool
    Flush the cached decompilation results. Erases a cache entry for the specified
    function.
    
    @param ea: (C++: ea_t) function to erase from the cache
    @param close_views: (C++: bool) close pseudocode windows that show the function
    @return: if a cache entry existed.

Help on class mba_range_iterator_t in module ida_hexrays:

class mba_range_iterator_t(builtins.object)
 |  Proxy of C++ mba_range_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mba_range_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mba_range_iterator_t(...)
 |      delete_mba_range_iterator_t(self)
 |  
 |  chunk(self, *args) -> 'range_t const &'
 |      chunk(self) -> range_t
 |  
 |  is_snippet(self, *args) -> 'bool'
 |      is_snippet(self) -> bool
 |  
 |  next(self, *args) -> 'bool'
 |      next(self) -> bool
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, mbr) -> bool
 |      
 |      @param mbr: mba_ranges_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fii
 |      fii
 |  
 |  rii
 |      rii
 |  
 |  thisown
 |      The membership flag

Help on class mba_ranges_t in module ida_hexrays:

class mba_ranges_t(builtins.object)
 |  Proxy of C++ mba_ranges_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _pfn=None) -> mba_ranges_t
 |      
 |      @param _pfn: func_t *
 |      
 |      __init__(self, r) -> mba_ranges_t
 |      
 |      @param r: rangevec_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mba_ranges_t(...)
 |      delete_mba_ranges_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |  
 |  is_snippet(self, *args) -> 'bool'
 |      is_snippet(self) -> bool
 |  
 |  start(self, *args) -> 'ea_t'
 |      start(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  pfn
 |      pfn
 |  
 |  ranges
 |      ranges
 |  
 |  thisown
 |      The membership flag

Help on class mba_t in module ida_hexrays:

class mba_t(builtins.object)
 |  Proxy of C++ mba_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mba_t(...)
 |      delete_mba_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, vp)
 |      
 |      Parameters
 |      ----------
 |      vp: vd_printer_t &
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  alloc_fict_ea(self, *args) -> 'ea_t'
 |      alloc_fict_ea(self, real_ea) -> ea_t
 |      Allocate a fictional address. This function can be used to allocate a new unique
 |      address for a new instruction, if re-using any existing address leads to
 |      conflicts. For example, if the last instruction of the function modifies R0 and
 |      falls through to the next function, it will be a tail call: LDM R0!, {R4,R7} end
 |      of the function start of another function In this case R0 generates two
 |      different lvars at the same address:
 |      * one modified by LDM
 |      * another that represents the return value from the tail call Another example: a
 |      third-party plugin makes a copy of an instruction. This may lead to the
 |      generation of two variables at the same address. Example 3: fictional addresses
 |      can be used for new instructions created while modifying the microcode. This
 |      function can be used to allocate a new unique address for a new instruction or a
 |      variable. The fictional address is selected from an unallocated address range.
 |      
 |      @param real_ea: (C++: ea_t) real instruction address (BADADDR is ok too)
 |      @return: a unique fictional address
 |  
 |  alloc_kreg(self, *args) -> 'mreg_t'
 |      alloc_kreg(self, size, check_size=True) -> mreg_t
 |      Allocate a kernel register.
 |      
 |      @param size: (C++: size_t) size of the register in bytes
 |      @param check_size: (C++: bool) if true, only the sizes that correspond to a size of a basic
 |                         type will be accepted.
 |      @return: allocated register. mr_none means failure.
 |  
 |  alloc_lvars(self, *args) -> 'void'
 |      alloc_lvars(self)
 |      Allocate local variables. Must be called only immediately after
 |      optimize_global(), with no modifications to the microcode. Converts registers,
 |      stack variables, and similar operands into mop_l. This call will not fail
 |      because all necessary checks were performed in optimize_global(). After this
 |      call the microcode reaches its final state.
 |  
 |  analyze_calls(self, *args) -> 'int'
 |      analyze_calls(self, acflags) -> int
 |      Analyze calls and determine calling conventions.
 |      
 |      @param acflags: (C++: int) permitted actions that are necessary for successful detection of
 |                      calling conventions. See Bits for analyze_calls()
 |      @return: number of calls. -1 means error.
 |  
 |  arg(self, *args) -> 'lvar_t const &'
 |      arg(self, n) -> lvar_t
 |      
 |      @param n: int
 |  
 |  argbase(self, *args) -> 'sval_t'
 |      argbase(self) -> sval_t
 |  
 |  argidx_ok(self, *args) -> 'bool'
 |      argidx_ok(self) -> bool
 |  
 |  argidx_sorted(self, *args) -> 'bool'
 |      argidx_sorted(self) -> bool
 |  
 |  bad_call_sp_detected(self, *args) -> 'bool'
 |      bad_call_sp_detected(self) -> bool
 |  
 |  build_graph(self, *args) -> 'merror_t'
 |      build_graph(self) -> merror_t
 |      Build control flow graph. This function may be called only once. It calculates
 |      the type of each basic block and the adjacency list. optimize_local() calls this
 |      function if necessary. You need to call this function only before MMAT_LOCOPT.
 |      
 |      @return: error code
 |  
 |  calc_shins_flags(self, *args) -> 'int'
 |      calc_shins_flags(self) -> int
 |  
 |  callinfo_built(self, *args) -> 'bool'
 |      callinfo_built(self) -> bool
 |  
 |  chain_varnums_ok(self, *args) -> 'bool'
 |      chain_varnums_ok(self) -> bool
 |  
 |  clr_cdtr(self, *args) -> 'void'
 |      clr_cdtr(self)
 |  
 |  clr_mba_flags(self, *args) -> 'void'
 |      clr_mba_flags(self, f)
 |      
 |      @param f: int
 |  
 |  clr_mba_flags2(self, *args) -> 'void'
 |      clr_mba_flags2(self, f)
 |      
 |      @param f: int
 |  
 |  code16_bit_removed(self, *args) -> 'bool'
 |      code16_bit_removed(self) -> bool
 |  
 |  combine_blocks(self, *args) -> 'bool'
 |      combine_blocks(self) -> bool
 |      Combine blocks. This function merges blocks constituting linear flow. It calls
 |      remove_empty_and_unreachable_blocks() as well.
 |      
 |      @return: true if changed any blocks
 |  
 |  common_stkvars_stkargs(self, *args) -> 'bool'
 |      common_stkvars_stkargs(self) -> bool
 |  
 |  copy_block(self, *args) -> 'mblock_t *'
 |      copy_block(self, blk, new_serial, cpblk_flags=3) -> mblock_t
 |      Make a copy of a block. This function makes a simple copy of the block. It does
 |      not fix the predecessor and successor lists, they must be fixed if necessary.
 |      
 |      @param blk: (C++: mblock_t *) block to copy
 |      @param new_serial: (C++: int) position of the copied block
 |      @param cpblk_flags: (C++: int) combination of Batch decompilation bits... bits
 |      @return: pointer to the new copy
 |  
 |  create_helper_call(self, *args) -> 'minsn_t *'
 |      create_helper_call(self, ea, helper, rettype=None, callargs=None, out=None) -> minsn_t
 |      Create a call of a helper function.
 |      
 |      @param ea: (C++: ea_t) The desired address of the instruction
 |      @param helper: (C++: const char *) The helper name
 |      @param rettype: (C++: const tinfo_t *) The return type (nullptr or empty type means 'void')
 |      @param callargs: (C++: const mcallargs_t *) The helper arguments (nullptr-no arguments)
 |      @param out: (C++: const mop_t *) The operand where the call result should be stored. If this argument
 |                  is not nullptr, "mov helper_call(), out" will be generated.
 |                  Otherwise "call helper()" will be generated. Note: the size of this
 |                  operand must be equal to the RETTYPE size
 |      @return: pointer to the created instruction or nullptr if error
 |  
 |  deleted_pairs(self, *args) -> 'bool'
 |      deleted_pairs(self) -> bool
 |  
 |  display_numaddrs(self, *args) -> 'bool'
 |      display_numaddrs(self) -> bool
 |  
 |  display_valnums(self, *args) -> 'bool'
 |      display_valnums(self) -> bool
 |  
 |  dump(self, *args) -> 'void'
 |      dump(self)
 |      Dump microcode to a file. The file will be created in the directory pointed by
 |      IDA_DUMPDIR envvar. Dump will be created only if IDA is run under debugger.
 |  
 |  dump_mba(self, *args) -> 'void'
 |      dump_mba(self, _verify, title)
 |      
 |      @param _verify: bool
 |      @param title: char const *
 |  
 |  find_mop(self, *args) -> 'mop_t *'
 |      find_mop(self, ctx, ea, is_dest, list) -> mop_t
 |      Find an operand in the microcode. This function tries to find the operand that
 |      matches LIST. Any operand that overlaps with LIST is considered as a match.
 |      
 |      @param ctx: (C++: op_parent_info_t *) context information for the result
 |      @param ea: (C++: ea_t) desired address of the operand
 |      @param is_dest: (C++: bool) search for destination operand? this argument may be ignored if
 |                      the exact match could not be found
 |      @param list: (C++: const mlist_t &) list of locations the correspond to the operand
 |      @return: pointer to the operand or nullptr.
 |  
 |  for_all_insns(self, *args) -> 'int'
 |      for_all_insns(self, mv) -> int
 |      Visit all instructions. This function visits all instruction and
 |      subinstructions.
 |      
 |      @param mv: (C++: minsn_visitor_t &) instruction visitor
 |      @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv) -> int
 |      Visit all operands of all instructions.
 |      
 |      @param mv: (C++: mop_visitor_t &) operand visitor
 |      @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  for_all_topinsns(self, *args) -> 'int'
 |      for_all_topinsns(self, mv) -> int
 |      Visit all top level instructions.
 |      
 |      @param mv: (C++: minsn_visitor_t &) instruction visitor
 |      @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  free_kreg(self, *args) -> 'void'
 |      free_kreg(self, reg, size)
 |      Free a kernel register. If wrong arguments are passed, this function will
 |      generate an internal error.
 |      
 |      @param reg: (C++: mreg_t) a previously allocated kernel register
 |      @param size: (C++: size_t) size of the register in bytes
 |  
 |  generated_asserts(self, *args) -> 'bool'
 |      generated_asserts(self) -> bool
 |  
 |  get_args_region(self, *args) -> 'ivl_t const &'
 |      get_args_region(self) -> ivl_t
 |  
 |  get_curfunc(self, *args) -> 'func_t *'
 |      get_curfunc(self) -> func_t *
 |  
 |  get_graph(self, *args) -> 'mbl_graph_t *'
 |      get_graph(self) -> mbl_graph_t
 |      Get control graph. Call build_graph() if you need the graph before MMAT_LOCOPT.
 |  
 |  get_ida_argloc(self, *args) -> 'argloc_t'
 |      get_ida_argloc(self, v) -> argloc_t
 |      
 |      @param v: lvar_t const &
 |  
 |  get_lvars_region(self, *args) -> 'ivl_t const &'
 |      get_lvars_region(self) -> ivl_t
 |  
 |  get_mba_flags(self, *args) -> 'int'
 |      get_mba_flags(self) -> int
 |  
 |  get_mba_flags2(self, *args) -> 'int'
 |      get_mba_flags2(self) -> int
 |  
 |  get_mblock(self, *args) -> 'mblock_t *'
 |      get_mblock(self, n) -> mblock_t
 |      
 |      @param n: int
 |  
 |  get_shadow_region(self, *args) -> 'ivl_t const &'
 |      get_shadow_region(self) -> ivl_t
 |  
 |  get_stack_region(self, *args) -> 'ivl_t'
 |      get_stack_region(self) -> ivl_t
 |  
 |  get_std_region(self, *args) -> 'ivl_t const &'
 |      get_std_region(self, idx) -> ivl_t
 |      Get information about various memory regions. We map the stack frame to the
 |      global memory, to some unused range.
 |      
 |      @param idx: (C++: memreg_index_t) enum memreg_index_t
 |  
 |  graph_insns(self, *args) -> 'bool'
 |      graph_insns(self) -> bool
 |  
 |  has_bad_sp(self, *args) -> 'bool'
 |      has_bad_sp(self) -> bool
 |  
 |  has_outlines(self, *args) -> 'bool'
 |      has_outlines(self) -> bool
 |  
 |  has_over_chains(self, *args) -> 'bool'
 |      has_over_chains(self) -> bool
 |  
 |  has_passregs(self, *args) -> 'bool'
 |      has_passregs(self) -> bool
 |  
 |  has_stack_retval(self, *args) -> 'bool'
 |      has_stack_retval(self) -> bool
 |  
 |  idaloc2vd(self, *args) -> 'vdloc_t'
 |      idaloc2vd(self, loc, width) -> vdloc_t
 |      
 |      @param loc: argloc_t const &
 |      @param width: int
 |  
 |  insert_block(self, *args) -> 'mblock_t *'
 |      insert_block(self, bblk) -> mblock_t
 |      Insert a block in the middle of the mbl array. The very first block of microcode
 |      must be empty, it is the entry block. The very last block of microcode must be
 |      BLT_STOP, it is the exit block. Therefore inserting a new block before the entry
 |      point or after the exit block is not a good idea.
 |      
 |      @param bblk: (C++: int) the new block will be inserted before BBLK
 |      @return: ptr to the new block
 |  
 |  is_cdtr(self, *args) -> 'bool'
 |      is_cdtr(self) -> bool
 |  
 |  is_ctr(self, *args) -> 'bool'
 |      is_ctr(self) -> bool
 |  
 |  is_dtr(self, *args) -> 'bool'
 |      is_dtr(self) -> bool
 |  
 |  is_pattern(self, *args) -> 'bool'
 |      is_pattern(self) -> bool
 |  
 |  is_snippet(self, *args) -> 'bool'
 |      is_snippet(self) -> bool
 |  
 |  is_stkarg(self, *args) -> 'bool'
 |      is_stkarg(self, v) -> bool
 |      
 |      @param v: lvar_t const &
 |  
 |  is_thunk(self, *args) -> 'bool'
 |      is_thunk(self) -> bool
 |  
 |  loaded_gdl(self, *args) -> 'bool'
 |      loaded_gdl(self) -> bool
 |  
 |  lvar_names_ok(self, *args) -> 'bool'
 |      lvar_names_ok(self) -> bool
 |  
 |  lvars_allocated(self, *args) -> 'bool'
 |      lvars_allocated(self) -> bool
 |  
 |  lvars_renamed(self, *args) -> 'bool'
 |      lvars_renamed(self) -> bool
 |  
 |  map_fict_ea(self, *args) -> 'ea_t'
 |      map_fict_ea(self, fict_ea) -> ea_t
 |      Resolve a fictional address. This function provides a reverse of the mapping
 |      made by alloc_fict_ea().
 |      
 |      @param fict_ea: (C++: ea_t) fictional definition address
 |      @return: the real instruction address
 |  
 |  mark_chains_dirty(self, *args) -> 'void'
 |      mark_chains_dirty(self)
 |      Mark the microcode use-def chains dirty. Call this function is any inter-block
 |      data dependencies got changed because of your modifications to the microcode.
 |      Failing to do so may cause an internal error.
 |  
 |  may_refine_rettype(self, *args) -> 'bool'
 |      may_refine_rettype(self) -> bool
 |  
 |  optimize_global(self, *args) -> 'merror_t'
 |      optimize_global(self) -> merror_t
 |      Optimize microcode globally. This function applies various optimization methods
 |      until we reach the fixed point. After that it preallocates lvars unless reqmat
 |      forbids it.
 |      
 |      @return: error code
 |  
 |  optimize_local(self, *args) -> 'int'
 |      optimize_local(self, locopt_bits) -> int
 |      Optimize each basic block locally
 |      
 |      @param locopt_bits: (C++: int) combination of Bits for optimize_local() bits
 |      @return: number of changes. 0 means nothing changed This function is called by
 |               the decompiler, usually there is no need to call it explicitly.
 |  
 |  optimized(self, *args) -> 'bool'
 |      optimized(self) -> bool
 |  
 |  precise_defeas(self, *args) -> 'bool'
 |      precise_defeas(self) -> bool
 |  
 |  propagated_asserts(self, *args) -> 'bool'
 |      propagated_asserts(self) -> bool
 |  
 |  really_alloc(self, *args) -> 'bool'
 |      really_alloc(self) -> bool
 |  
 |  regargs_is_not_aligned(self, *args) -> 'bool'
 |      regargs_is_not_aligned(self) -> bool
 |  
 |  remove_block(self, *args) -> 'bool'
 |      remove_block(self, blk) -> bool
 |      Delete a block.
 |      
 |      @param blk: (C++: mblock_t *) block to delete
 |      @return: true if at least one of the other blocks became empty or unreachable
 |  
 |  remove_empty_and_unreachable_blocks(self, *args) -> 'bool'
 |      remove_empty_and_unreachable_blocks(self) -> bool
 |      Delete all empty and unreachable blocks. Blocks marked with MBL_KEEP won't be
 |      deleted.
 |  
 |  returns_fpval(self, *args) -> 'bool'
 |      returns_fpval(self) -> bool
 |  
 |  rtype_refined(self, *args) -> 'bool'
 |      rtype_refined(self) -> bool
 |  
 |  save_snapshot(self, *args) -> 'void'
 |      save_snapshot(self, description)
 |      Create and save microcode snapshot.
 |      
 |      @param description: (C++: const char *) char const *
 |  
 |  saverest_done(self, *args) -> 'bool'
 |      saverest_done(self) -> bool
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |      Serialize mbl array into a sequence of bytes.
 |  
 |  set_maturity(self, *args) -> 'bool'
 |      set_maturity(self, mat) -> bool
 |      Set maturity level.
 |      
 |      @param mat: (C++: mba_maturity_t) new maturity level
 |      @return: true if it is time to stop analysis Plugins may use this function to
 |               skip some parts of the analysis. The maturity level cannot be
 |               decreased.
 |  
 |  set_mba_flags(self, *args) -> 'void'
 |      set_mba_flags(self, f)
 |      
 |      @param f: int
 |  
 |  set_mba_flags2(self, *args) -> 'void'
 |      set_mba_flags2(self, f)
 |      
 |      @param f: int
 |  
 |  short_display(self, *args) -> 'bool'
 |      short_display(self) -> bool
 |  
 |  should_beautify(self, *args) -> 'bool'
 |      should_beautify(self) -> bool
 |  
 |  show_reduction(self, *args) -> 'bool'
 |      show_reduction(self) -> bool
 |  
 |  stkoff_ida2vd(self, *args) -> 'sval_t'
 |      stkoff_ida2vd(self, off) -> sval_t
 |      
 |      @param off: sval_t
 |  
 |  stkoff_vd2ida(self, *args) -> 'sval_t'
 |      stkoff_vd2ida(self, off) -> sval_t
 |      
 |      @param off: sval_t
 |  
 |  term(self, *args) -> 'void'
 |      term(self)
 |  
 |  use_frame(self, *args) -> 'bool'
 |      use_frame(self) -> bool
 |  
 |  use_wingraph32(self, *args) -> 'bool'
 |      use_wingraph32(self) -> bool
 |  
 |  valranges_done(self, *args) -> 'bool'
 |      valranges_done(self) -> bool
 |  
 |  vd2idaloc(self, *args) -> 'argloc_t'
 |      vd2idaloc(self, loc, width, spd) -> argloc_t
 |      
 |      @param loc: vdloc_t const &
 |      @param width: int
 |      @param spd: sval_t
 |      
 |      vd2idaloc(self, loc, width) -> argloc_t
 |      
 |      @param loc: vdloc_t const &
 |      @param width: int
 |  
 |  verify(self, *args) -> 'void'
 |      verify(self, always)
 |      Verify microcode consistency.
 |      
 |      @param always: (C++: bool) if false, the check will be performed only if ida runs under
 |                     debugger If any inconsistency is discovered, an internal error
 |                     will be generated. We strongly recommend you to call this
 |                     function before returing control to the decompiler from your
 |                     callbacks, in the case if you modified the microcode.
 |  
 |  write_to_const_detected(self, *args) -> 'bool'
 |      write_to_const_detected(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  deserialize(*args) -> 'mba_t *'
 |      deserialize(bytes) -> mba_t
 |      Deserialize a byte sequence into mbl array.
 |      
 |      @param bytes: (C++: const uchar *) pointer to the beginning of the byte sequence.
 |      @return: new mbl array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  aliased_args
 |      aliased_args
 |  
 |  aliased_memory
 |      aliased_memory
 |  
 |  aliased_vars
 |      aliased_vars
 |  
 |  argidx
 |      argidx
 |  
 |  blocks
 |      blocks
 |  
 |  cc
 |      cc
 |  
 |  consumed_argregs
 |      consumed_argregs
 |  
 |  deprecated_idb_node
 |      deprecated_idb_node
 |  
 |  entry_ea
 |      entry_ea
 |  
 |  error_ea
 |      error_ea
 |  
 |  error_strarg
 |      error_strarg
 |  
 |  final_type
 |      final_type
 |  
 |  first_epilog_ea
 |      first_epilog_ea
 |  
 |  fpd
 |      fpd
 |  
 |  frregs
 |      frregs
 |  
 |  frsize
 |      frsize
 |  
 |  fti_flags
 |      fti_flags
 |  
 |  fullsize
 |      fullsize
 |  
 |  gotoff_stkvars
 |      gotoff_stkvars
 |  
 |  idb_node
 |  
 |  idb_spoiled
 |      idb_spoiled
 |  
 |  idb_type
 |      idb_type
 |  
 |  inargoff
 |      inargoff
 |  
 |  label
 |      label
 |  
 |  last_prolog_ea
 |      last_prolog_ea
 |  
 |  maturity
 |      maturity
 |  
 |  mbr
 |      mbr
 |  
 |  minargref
 |      minargref
 |  
 |  minstkref
 |      minstkref
 |  
 |  minstkref_ea
 |      minstkref_ea
 |  
 |  natural
 |      natural
 |  
 |  nodel_memory
 |      nodel_memory
 |  
 |  notes
 |      notes
 |  
 |  npurged
 |      npurged
 |  
 |  occurred_warns
 |      occurred_warns
 |  
 |  pfn_flags
 |      pfn_flags
 |  
 |  qty
 |      qty
 |  
 |  reqmat
 |      reqmat
 |  
 |  restricted_memory
 |      restricted_memory
 |  
 |  retsize
 |      retsize
 |  
 |  retvaridx
 |      retvaridx
 |  
 |  shadow_args
 |      shadow_args
 |  
 |  spd_adjust
 |      spd_adjust
 |  
 |  spoiled_list
 |      spoiled_list
 |  
 |  stacksize
 |      stacksize
 |  
 |  std_ivls
 |      std_ivls
 |  
 |  thisown
 |      The membership flag
 |  
 |  tmpstk_size
 |      tmpstk_size
 |  
 |  vars
 |      vars

Help on function mba_t_deserialize in module ida_hexrays:

mba_t_deserialize(*args) -> 'mba_t *'
    mba_t_deserialize(bytes) -> mba_t
    
    @param bytes: uchar const *

Help on class mbl_graph_t in module ida_hexrays:

class mbl_graph_t(simple_graph_t)
 |  Proxy of C++ mbl_graph_t class.
 |  
 |  Method resolution order:
 |      mbl_graph_t
 |      simple_graph_t
 |      ida_gdl.gdl_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> gdl_graph_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_chain_stamp(self, *args) -> 'int'
 |      get_chain_stamp(self) -> int
 |  
 |  get_du(self, *args) -> 'graph_chains_t *'
 |      get_du(self, gctype) -> graph_chains_t
 |      Get def-use chains.
 |      
 |      @param gctype: (C++: gctype_t) enum gctype_t
 |  
 |  get_mblock(self, *args) -> 'mblock_t *'
 |      get_mblock(self, n) -> mblock_t
 |      
 |      @param n: int
 |  
 |  get_ud(self, *args) -> 'graph_chains_t *'
 |      get_ud(self, gctype) -> graph_chains_t
 |      Get use-def chains.
 |      
 |      @param gctype: (C++: gctype_t) enum gctype_t
 |  
 |  is_du_chain_dirty(self, *args) -> 'bool'
 |      is_du_chain_dirty(self, gctype) -> bool
 |      Is the def-use chain of the specified kind dirty?
 |      
 |      @param gctype: (C++: gctype_t) enum gctype_t
 |  
 |  is_redefined_globally(self, *args) -> 'bool'
 |      is_redefined_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
 |      Is LIST redefined in the graph?
 |      
 |      @param list: (C++: const mlist_t &) mlist_t const &
 |      @param b1: (C++: int)
 |      @param b2: (C++: int)
 |      @param m1: (C++: const minsn_t *) minsn_t const *
 |      @param m2: (C++: const minsn_t *) minsn_t const *
 |      @param maymust: (C++: maymust_t)
 |  
 |  is_ud_chain_dirty(self, *args) -> 'bool'
 |      is_ud_chain_dirty(self, gctype) -> bool
 |      Is the use-def chain of the specified kind dirty?
 |      
 |      @param gctype: (C++: gctype_t) enum gctype_t
 |  
 |  is_used_globally(self, *args) -> 'bool'
 |      is_used_globally(self, list, b1, b2, m1, m2, maymust=MAY_ACCESS) -> bool
 |      Is LIST used in the graph?
 |      
 |      @param list: (C++: const mlist_t &) mlist_t const &
 |      @param b1: (C++: int)
 |      @param b2: (C++: int)
 |      @param m1: (C++: const minsn_t *) minsn_t const *
 |      @param m2: (C++: const minsn_t *) minsn_t const *
 |      @param maymust: (C++: maymust_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from simple_graph_t:
 |  
 |  colored_gdl_edges
 |      colored_gdl_edges
 |  
 |  title
 |      title
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_gdl.gdl_graph_t:
 |  
 |  __disown__(self)
 |  
 |  __swig_destroy__ = delete_gdl_graph_t(...)
 |      delete_gdl_graph_t(self)
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |      
 |      @param node: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |      
 |      @param node: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_gdl.gdl_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class mblock_t in module ida_hexrays:

class mblock_t(builtins.object)
 |  Proxy of C++ mblock_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mblock_t(...)
 |      delete_mblock_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, vp)
 |      
 |      Parameters
 |      ----------
 |      vp: vd_printer_t &
 |  
 |  append_def_list(self, *args) -> 'void'
 |      append_def_list(self, list, op, maymust)
 |      Append def-list of an operand. This function calculates list of locations that
 |      may or must be modified by the operand and appends it to LIST.
 |      
 |      @param list: (C++: mlist_t *) ptr to the output buffer. we will append to it.
 |      @param op: (C++: const mop_t &) operand to calculate the def list of
 |      @param maymust: (C++: maymust_t) should we calculate 'may-def' or 'must-def' list? see maymust_t
 |                      for more details.
 |  
 |  append_use_list(self, *args) -> 'void'
 |      append_use_list(self, list, op, maymust, mask=bitrange_t(0, USHRT_MAX))
 |      Append use-list of an operand. This function calculates list of locations that
 |      may or must be used by the operand and appends it to LIST.
 |      
 |      @param list: (C++: mlist_t *) ptr to the output buffer. we will append to it.
 |      @param op: (C++: const mop_t &) operand to calculate the use list of
 |      @param maymust: (C++: maymust_t) should we calculate 'may-use' or 'must-use' list? see maymust_t
 |                      for more details.
 |      @param mask: (C++: bitrange_t) if only part of the operand should be considered, a bitmask can be
 |                   used to specify which part. example: op=AX,mask=0xFF means that we
 |                   will consider only AL.
 |  
 |  build_def_list(self, *args) -> 'mlist_t'
 |      build_def_list(self, ins, maymust) -> mlist_t
 |      Build def-list of an instruction. This function calculates list of locations
 |      that may or must be modified by the instruction. Examples: "stx ebx.4, ds.2,
 |      eax.4", may-list: all aliasable memory "stx ebx.4, ds.2, eax.4", must-list:
 |      empty Since STX uses EAX for indirect access, it may modify any aliasable
 |      memory. On the other hand, we cannot tell for sure which memory cells will be
 |      modified, this is why the must-list is empty.
 |      
 |      @param ins: (C++: const minsn_t &) instruction to calculate the def list of
 |      @param maymust: (C++: maymust_t) should we calculate 'may-def' or 'must-def' list? see maymust_t
 |                      for more details.
 |      @return: the calculated def-list
 |  
 |  build_lists(self, *args) -> 'int'
 |      build_lists(self, kill_deads) -> int
 |      Build def-use lists and eliminate deads.
 |      
 |      @param kill_deads: (C++: bool) do delete dead instructions?
 |      @return: the number of eliminated instructions Better mblock_t::call
 |               make_lists_ready() rather than this function.
 |  
 |  build_use_list(self, *args) -> 'mlist_t'
 |      build_use_list(self, ins, maymust) -> mlist_t
 |      Build use-list of an instruction. This function calculates list of locations
 |      that may or must be used by the instruction. Examples: "ldx ds.2, eax.4, ebx.4",
 |      may-list: all aliasable memory "ldx ds.2, eax.4, ebx.4", must-list: empty Since
 |      LDX uses EAX for indirect access, it may access any aliasable memory. On the
 |      other hand, we cannot tell for sure which memory cells will be accessed, this is
 |      why the must-list is empty.
 |      
 |      @param ins: (C++: const minsn_t &) instruction to calculate the use list of
 |      @param maymust: (C++: maymust_t) should we calculate 'may-use' or 'must-use' list? see maymust_t
 |                      for more details.
 |      @return: the calculated use-list
 |  
 |  dump(self, *args) -> 'void'
 |      dump(self)
 |      Dump block info. This function is useful for debugging, see mba_t::dump for info
 |  
 |  dump_block(self, *args) -> 'void'
 |      dump_block(self, title)
 |      
 |      @param title: char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  find_access(self, *args) -> 'minsn_t *'
 |      find_access(self, op, parent, mend, fdflags) -> minsn_t
 |      Find the instruction that accesses the specified operand. This function search
 |      inside one block.
 |      
 |      @param op: (C++: const mop_t &) operand to search for
 |      @param parent: (C++: minsn_t **) ptr to ptr to a top level instruction. denotes the beginning of
 |                     the search range.
 |      @param mend: (C++: const minsn_t *) end instruction of the range (must be a top level insn) mend is
 |                   excluded from the range. it can be specified as nullptr. parent and
 |                   mend must belong to the same block.
 |      @param fdflags: (C++: int) combination of bits for mblock_t::find_access bits
 |      @return: the instruction that accesses the operand. this instruction may be a
 |               sub-instruction. to find out the top level instruction, check out
 |               *p_i1. nullptr means 'not found'.
 |  
 |  find_def(self, *args) -> 'minsn_t *'
 |      find_def(self, op, p_i1, i2, fdflags) -> minsn_t
 |      
 |      @param op: mop_t const &
 |      @param p_i1: minsn_t **
 |      @param i2: minsn_t const *
 |      @param fdflags: int
 |  
 |  find_first_use(self, *args) -> 'minsn_t *'
 |      find_first_use(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
 |      
 |      @param list: mlist_t *
 |      @param i1: minsn_t *
 |      @param i2: minsn_t const *
 |      @param maymust: maymust_t
 |  
 |  find_redefinition(self, *args) -> 'minsn_t *'
 |      find_redefinition(self, list, i1, i2, maymust=MAY_ACCESS) -> minsn_t
 |      
 |      @param list: mlist_t const &
 |      @param i1: minsn_t *
 |      @param i2: minsn_t const *
 |      @param maymust: maymust_t
 |  
 |  find_use(self, *args) -> 'minsn_t *'
 |      find_use(self, op, p_i1, i2, fdflags) -> minsn_t
 |      
 |      @param op: mop_t const &
 |      @param p_i1: minsn_t **
 |      @param i2: minsn_t const *
 |      @param fdflags: int
 |  
 |  for_all_insns(self, *args) -> 'int'
 |      for_all_insns(self, mv) -> int
 |      Visit all instructions. This function visits subinstructions too.
 |      
 |      @param mv: (C++: minsn_visitor_t &) instruction visitor
 |      @return: zero or the value returned by mv.visit_insn() See also
 |               mba_t::for_all_topinsns()
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv) -> int
 |      Visit all operands. This function visit subinstruction operands too.
 |      
 |      @param mv: (C++: mop_visitor_t &) operand visitor
 |      @return: zero or the value returned by mv.visit_mop()
 |  
 |  for_all_uses(self, *args) -> 'int'
 |      for_all_uses(self, list, i1, i2, mmv) -> int
 |      Visit all operands that use LIST.
 |      
 |      @param list: (C++: mlist_t *) ptr to the list of locations. it may be modified: parts that get
 |                   redefined by the instructions in [i1,i2) will be deleted.
 |      @param i1: (C++: minsn_t *) starting instruction. must be a top level insn.
 |      @param i2: (C++: minsn_t *) ending instruction (excluded). must be a top level insn.
 |      @param mmv: (C++: mlist_mop_visitor_t &) operand visitor
 |      @return: zero or the value returned by mmv.visit_mop()
 |  
 |  get_reginsn_qty(self, *args) -> 'size_t'
 |      get_reginsn_qty(self) -> size_t
 |      Calculate number of regular instructions in the block. Assertions are skipped by
 |      this function.
 |      
 |      @return: Number of non-assertion instructions in the block.
 |  
 |  get_valranges(self, *args) -> 'bool'
 |      get_valranges(self, res, vivl, vrflags) -> bool
 |      Find possible values for an instruction.
 |      
 |      @param res: (C++: valrng_t *) set of value ranges
 |      @param vivl: (C++: const vivl_t &) what to search for
 |      @param vrflags: (C++: int) combination of bits for get_valranges bits
 |      get_valranges(self, res, vivl, m, vrflags) -> bool
 |      
 |      @param res: valrng_t *
 |      @param vivl: vivl_t const &
 |      @param m: minsn_t const *
 |      @param vrflags: int
 |  
 |  insert_into_block(self, *args) -> 'minsn_t *'
 |      insert_into_block(self, nm, om) -> minsn_t
 |      Insert instruction into the doubly linked list
 |      
 |      @param nm: (C++: minsn_t *) new instruction
 |      @param om: (C++: minsn_t *) existing instruction, part of the doubly linked list if nullptr, then
 |                 the instruction will be inserted at the beginning of the list NM will
 |                 be inserted immediately after OM
 |      @return: pointer to NM
 |  
 |  is_branch(self, *args) -> 'bool'
 |      is_branch(self) -> bool
 |  
 |  is_call_block(self, *args) -> 'bool'
 |      is_call_block(self) -> bool
 |  
 |  is_nway(self, *args) -> 'bool'
 |      is_nway(self) -> bool
 |  
 |  is_redefined(self, *args) -> 'bool'
 |      is_redefined(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
 |      Is the list redefined by the specified instructions?
 |      
 |      @param list: (C++: const mlist_t &) list of locations to check.
 |      @param i1: (C++: const minsn_t *) starting instruction of the range (must be a top level insn)
 |      @param i2: (C++: const minsn_t *) end instruction of the range (must be a top level insn) i2 is
 |                 excluded from the range. it can be specified as nullptr. i1 and i2
 |                 must belong to the same block.
 |      @param maymust: (C++: maymust_t) should we search in 'may-access' or 'must-access' mode?
 |  
 |  is_rhs_redefined(self, *args) -> 'bool'
 |      is_rhs_redefined(self, ins, i1, i2) -> bool
 |      Is the right hand side of the instruction redefined the insn range? "right hand
 |      side" corresponds to the source operands of the instruction.
 |      
 |      @param ins: (C++: const minsn_t *) instruction to consider
 |      @param i1: (C++: const minsn_t *) starting instruction of the range (must be a top level insn)
 |      @param i2: (C++: const minsn_t *) end instruction of the range (must be a top level insn) i2 is
 |                 excluded from the range. it can be specified as nullptr. i1 and i2
 |                 must belong to the same block.
 |  
 |  is_simple_goto_block(self, *args) -> 'bool'
 |      is_simple_goto_block(self) -> bool
 |  
 |  is_simple_jcnd_block(self, *args) -> 'bool'
 |      is_simple_jcnd_block(self) -> bool
 |  
 |  is_unknown_call(self, *args) -> 'bool'
 |      is_unknown_call(self) -> bool
 |  
 |  is_used(self, *args) -> 'bool'
 |      is_used(self, list, i1, i2, maymust=MAY_ACCESS) -> bool
 |      Is the list used by the specified instruction range?
 |      
 |      @param list: (C++: mlist_t *) list of locations. LIST may be modified by the function: redefined
 |                   locations will be removed from it.
 |      @param i1: (C++: const minsn_t *) starting instruction of the range (must be a top level insn)
 |      @param i2: (C++: const minsn_t *) end instruction of the range (must be a top level insn) i2 is
 |                 excluded from the range. it can be specified as nullptr. i1 and i2
 |                 must belong to the same block.
 |      @param maymust: (C++: maymust_t) should we search in 'may-access' or 'must-access' mode?
 |  
 |  lists_dirty(self, *args) -> 'bool'
 |      lists_dirty(self) -> bool
 |  
 |  lists_ready(self, *args) -> 'bool'
 |      lists_ready(self) -> bool
 |  
 |  make_lists_ready(self, *args) -> 'int'
 |      make_lists_ready(self) -> int
 |  
 |  make_nop(self, *args) -> 'void'
 |      make_nop(self, m)
 |      Erase the instruction (convert it to nop) and mark the lists dirty. This is the
 |      recommended function to use because it also marks the block use-def lists dirty.
 |      
 |      @param m: (C++: minsn_t *)
 |  
 |  mark_lists_dirty(self, *args) -> 'void'
 |      mark_lists_dirty(self)
 |  
 |  needs_propagation(self, *args) -> 'bool'
 |      needs_propagation(self) -> bool
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self) -> int
 |      Get number of block predecessors.
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self) -> int
 |      Get number of block successors.
 |  
 |  optimize_block(self, *args) -> 'int'
 |      optimize_block(self) -> int
 |      Optimize a basic block. Usually there is no need to call this function
 |      explicitly because the decompiler will call it itself if optinsn_t::func or
 |      optblock_t::func return non-zero.
 |      
 |      @return: number of changes made to the block
 |  
 |  optimize_insn(self, *args) -> 'int'
 |      optimize_insn(self, m, optflags=0x0002|0x0004) -> int
 |      Optimize one instruction in the context of the block.
 |      
 |      @param m: (C++: minsn_t *) pointer to a top level instruction
 |      @param optflags: (C++: int) combination of optimization flags bits
 |      @return: number of changes made to the block This function may change other
 |               instructions in the block too. However, it will not destroy top level
 |               instructions (it may convert them to nop's). This function performs
 |               only intrablock modifications. See also minsn_t::optimize_solo()
 |  
 |  optimize_useless_jump(self, *args) -> 'int'
 |      optimize_useless_jump(self) -> int
 |      Remove a jump at the end of the block if it is useless. This function preserves
 |      any side effects when removing a useless jump. Both conditional and
 |      unconditional jumps are handled (and jtbl too). This function deletes useless
 |      jumps, not only replaces them with a nop. (please note that \optimize_insn does
 |      not handle useless jumps).
 |      
 |      @return: number of changes made to the block
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, n) -> int
 |      
 |      @param n: int
 |  
 |  preds(self)
 |      Iterates the list of predecessor blocks
 |  
 |  remove_from_block(self, *args) -> 'minsn_t *'
 |      remove_from_block(self, m) -> minsn_t
 |      Remove instruction from the doubly linked list
 |      
 |      @param m: (C++: minsn_t *) instruction to remove The removed instruction is not deleted, the
 |                caller gets its ownership
 |      @return: pointer to the next instruction
 |  
 |  request_demote64(self, *args) -> 'void'
 |      request_demote64(self)
 |  
 |  request_propagation(self, *args) -> 'void'
 |      request_propagation(self)
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, n) -> int
 |      
 |      @param n: int
 |  
 |  succs(self)
 |      Iterates the list of successor blocks
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dead_at_start
 |      dead_at_start
 |  
 |  dnu
 |      dnu
 |  
 |  end
 |      end
 |  
 |  flags
 |      flags
 |  
 |  head
 |      head
 |  
 |  maxbsp
 |      maxbsp
 |  
 |  maybdef
 |      maybdef
 |  
 |  maybuse
 |      maybuse
 |  
 |  mba
 |      mba
 |  
 |  minbargref
 |      minbargref
 |  
 |  minbstkref
 |      minbstkref
 |  
 |  mustbdef
 |      mustbdef
 |  
 |  mustbuse
 |      mustbuse
 |  
 |  nextb
 |      nextb
 |  
 |  predset
 |      predset
 |  
 |  prevb
 |      prevb
 |  
 |  serial
 |      serial
 |  
 |  start
 |      start
 |  
 |  succset
 |      succset
 |  
 |  tail
 |      tail
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type

Help on class mcallarg_t in module ida_hexrays:

class mcallarg_t(mop_t)
 |  Proxy of C++ mcallarg_t class.
 |  
 |  Method resolution order:
 |      mcallarg_t
 |      mop_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcallarg_t
 |      __init__(self, rarg) -> mcallarg_t
 |      
 |      @param rarg: mop_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mcallarg_t(...)
 |      delete_mcallarg_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |      
 |      Parameters
 |      ----------
 |      shins_flags: int
 |  
 |  copy_mop(self, *args) -> 'void'
 |      copy_mop(self, op)
 |      
 |      @param op: mop_t const &
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  make_int(self, *args) -> 'void'
 |      make_int(self, val, val_ea, opno=0)
 |      
 |      @param val: int
 |      @param val_ea: ea_t
 |      @param opno: int
 |  
 |  make_uint(self, *args) -> 'void'
 |      make_uint(self, val, val_ea, opno=0)
 |      
 |      @param val: int
 |      @param val_ea: ea_t
 |      @param opno: int
 |  
 |  set_regarg(self, *args) -> 'void'
 |      set_regarg(self, mr, sz, tif)
 |      
 |      @param mr: mreg_t
 |      @param sz: int
 |      @param tif: tinfo_t const &
 |      
 |      set_regarg(self, mr, tif)
 |      
 |      @param mr: mreg_t
 |      @param tif: tinfo_t const &
 |      
 |      set_regarg(self, mr, dt, sign=type_unsigned)
 |      
 |      @param mr: mreg_t
 |      @param dt: char
 |      @param sign: type_sign_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  argloc
 |      argloc
 |  
 |  ea
 |      ea
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from mop_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_a(self, *args) -> 'mop_addr_t *'
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args) -> 'int'
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args) -> 'mcases_t *'
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args) -> 'char const *'
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args) -> 'minsn_t *'
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args) -> 'mcallinfo_t *'
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args) -> 'ea_t'
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args) -> 'lvar_ref_t *'
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args) -> 'mnumber_t *'
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args) -> 'mop_pair_t *'
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args) -> 'mreg_t'
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args) -> 'stkvar_ref_t *'
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args) -> 'scif_t *'
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args) -> 'mopt_t'
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args) -> 'void'
 |      _make_blkref(self, blknum)
 |      
 |      Parameters
 |      ----------
 |      blknum: int
 |  
 |  _make_callinfo(self, *args) -> 'void'
 |      _make_callinfo(self, fi)
 |      
 |      Parameters
 |      ----------
 |      fi: mcallinfo_t *
 |  
 |  _make_cases(self, *args) -> 'void'
 |      _make_cases(self, _cases)
 |      
 |      Parameters
 |      ----------
 |      _cases: mcases_t *
 |  
 |  _make_gvar(self, *args) -> 'void'
 |      _make_gvar(self, ea)
 |      
 |      Parameters
 |      ----------
 |      ea: ea_t
 |  
 |  _make_insn(self, *args) -> 'void'
 |      _make_insn(self, ins)
 |      
 |      Parameters
 |      ----------
 |      ins: minsn_t *
 |  
 |  _make_lvar(self, *args) -> 'void'
 |      _make_lvar(self, mba, idx, off=0)
 |      
 |      Parameters
 |      ----------
 |      mba: mba_t *
 |      idx: int
 |      off: sval_t
 |  
 |  _make_pair(self, *args) -> 'void'
 |      _make_pair(self, _pair)
 |      
 |      Parameters
 |      ----------
 |      _pair: mop_pair_t *
 |  
 |  _make_reg(self, *args) -> 'void'
 |      _make_reg(self, reg)
 |      
 |      Parameters
 |      ----------
 |      reg: mreg_t
 |      
 |      _make_reg(self, reg, _size)
 |      
 |      Parameters
 |      ----------
 |      reg: mreg_t
 |      _size: int
 |  
 |  _make_stkvar(self, *args) -> 'void'
 |      _make_stkvar(self, mba, off)
 |      
 |      Parameters
 |      ----------
 |      mba: mba_t *
 |      off: sval_t
 |  
 |  _make_strlit(self, *args) -> 'void'
 |      _make_strlit(self, str)
 |      
 |      Parameters
 |      ----------
 |      str: char const *
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mop_addr_t *
 |  
 |  _set_b(self, *args) -> 'void'
 |      _set_b(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_c(self, *args) -> 'void'
 |      _set_c(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mcases_t *
 |  
 |  _set_cstr(self, *args) -> 'void'
 |      _set_cstr(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_d(self, *args) -> 'void'
 |      _set_d(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: minsn_t *
 |  
 |  _set_f(self, *args) -> 'void'
 |      _set_f(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mcallinfo_t *
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: fnumber_t *
 |  
 |  _set_g(self, *args) -> 'void'
 |      _set_g(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: ea_t
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_l(self, *args) -> 'void'
 |      _set_l(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: lvar_ref_t *
 |  
 |  _set_nnn(self, *args) -> 'void'
 |      _set_nnn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mnumber_t *
 |  
 |  _set_pair(self, *args) -> 'void'
 |      _set_pair(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mop_pair_t *
 |  
 |  _set_r(self, *args) -> 'void'
 |      _set_r(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mreg_t
 |  
 |  _set_s(self, *args) -> 'void'
 |      _set_s(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: stkvar_ref_t *
 |  
 |  _set_scif(self, *args) -> 'void'
 |      _set_scif(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: scif_t *
 |  
 |  _set_t(self, *args) -> 'void'
 |      _set_t(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: mopt_t
 |  
 |  apply_ld_mcode(self, *args) -> 'void'
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |      Apply a unary opcode to the operand.
 |      
 |      @param mcode: (C++: mcode_t) opcode to apply. it must accept 'l' and 'd' operands but not 'r'.
 |      @param ea: (C++: ea_t) value of minsn_t::ea for the newly created insruction
 |      @param newsize: (C++: int) new operand size Example: apply_ld_mcode(m_low) will convert op
 |                      => low(op)
 |  
 |  apply_xds(self, *args) -> 'void'
 |      apply_xds(self, ea, newsize)
 |      
 |      @param ea: ea_t
 |      @param newsize: int
 |  
 |  apply_xdu(self, *args) -> 'void'
 |      apply_xdu(self, ea, newsize)
 |      
 |      @param ea: ea_t
 |      @param newsize: int
 |  
 |  assign(self, *args) -> 'mop_t &'
 |      assign(self, rop) -> mop_t
 |      
 |      @param rop: mop_t const &
 |  
 |  change_size(self, *args) -> 'bool'
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
 |      change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4)
 |      -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1
 |      
 |      @param nsize: (C++: int) new operand size
 |      @param sideff: (C++: side_effect_t) may modify the database because of the size change?
 |      @return: success
 |  
 |  create_from_insn(self, *args) -> 'void'
 |      create_from_insn(self, m)
 |      Create operand from an instruction. This function creates a nested instruction
 |      that can be used as an operand. Example: if m="add x,y,z", our operand will be
 |      (t=mop_d,d=m). The destination operand of 'add' (z) is lost.
 |      
 |      @param m: (C++: const minsn_t *) instruction to embed into operand. may not be nullptr.
 |  
 |  create_from_ivlset(self, *args) -> 'bool'
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |      Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our
 |      operand will be (t=mop_v, g=&glbvar, size=4)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param ivs: (C++: const ivlset_t &) set of memory intervals
 |      @param fullsize: (C++: sval_t) mba->fullsize
 |      @return: success
 |  
 |  create_from_mlist(self, *args) -> 'bool'
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |      Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our
 |      operand will be (t=mop_r, r=R0, size=4)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param lst: (C++: const mlist_t &) list of locations
 |      @param fullsize: (C++: sval_t) mba->fullsize
 |      @return: success
 |  
 |  create_from_scattered_vdloc(self, *args) -> 'void'
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |      Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4,
 |      EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4,
 |      EDX.4})
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param name: (C++: const char *) name of the operand, if available
 |      @param type: (C++: tinfo_t) type of the operand, must be present
 |      @param loc: (C++: const vdloc_t &) a scattered location
 |      @return: success
 |  
 |  create_from_vdloc(self, *args) -> 'void'
 |      create_from_vdloc(self, mba, loc, _size)
 |      Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0),
 |      our operand will be (t=mop_r, r=R0, size=_SIZE)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param loc: (C++: const vdloc_t &) location
 |      @param _size: (C++: int) operand size Note: this function cannot handle scattered
 |                    locations.
 |      @return: success
 |  
 |  double_size(self, *args) -> 'bool'
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |      
 |      @param sideff: enum side_effect_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args) -> 'bool'
 |      equal_mops(self, rop, eqflags) -> bool
 |      Compare operands. This is the main comparison function for operands.
 |      
 |      @param rop: (C++: const mop_t &) operand to compare with
 |      @param eqflags: (C++: int) combination of comparison bits bits
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args) -> 'void'
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |      Visit the operand and all its sub-operands. This function visits the current
 |      operand as well.
 |      
 |      @param mv: (C++: mop_visitor_t &) visitor object
 |      @param type: (C++: const tinfo_t *) operand type
 |      @param is_target: (C++: bool) is a destination operand?
 |  
 |  for_all_scattered_submops(self, *args) -> 'int'
 |      for_all_scattered_submops(self, sv) -> int
 |      Visit all sub-operands of a scattered operand. This function does not visit the
 |      current operand, only its sub-operands. All sub-operands are synthetic and are
 |      destroyed after the visitor. This function works only with scattered operands.
 |      
 |      @param sv: (C++: scif_visitor_t &) visitor object
 |  
 |  get_insn(self, *args) -> 'minsn_t *'
 |      get_insn(self, code) -> minsn_t
 |      
 |      @param code: enum mcode_t
 |  
 |  get_stkoff(self, *args) -> 'bool'
 |      get_stkoff(self, p_off) -> bool
 |      Get the referenced stack offset. This function can also handle mop_sc if it is
 |      entirely mapped into a continuous stack region.
 |      
 |      @param p_off: (C++: sval_t *) the output buffer
 |      @return: success
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off) -> member_t *
 |      Retrieve the referenced stack variable.
 |      
 |      @param p_off: (C++: uval_t *) if specified, will hold IDA stkoff after the call.
 |      @return: pointer to the stack variable
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |      Has any side effects?
 |      
 |      @param include_ldx_and_divs: (C++: bool) consider ldx/div/mod as having side effects?
 |  
 |  is01(self, *args) -> 'bool'
 |      is01(self) -> bool
 |      Are the possible values of the operand only 0 and 1? This function returns true
 |      for 0/1 constants, bit registers, the result of 'set' insns, etc.
 |  
 |  is_arglist(self, *args) -> 'bool'
 |      is_arglist(self) -> bool
 |      Is a list of arguments?
 |  
 |  is_bit_reg(self, *args) -> 'bool'
 |      is_bit_reg(self, reg) -> bool
 |      Is a bit register? This includes condition codes and eventually other bit
 |      registers
 |      
 |      @param reg: (C++: mreg_t)
 |      
 |      is_bit_reg(self) -> bool
 |  
 |  is_cc(self, *args) -> 'bool'
 |      is_cc(self) -> bool
 |      Is a condition code?
 |  
 |  is_ccflags(self, *args) -> 'bool'
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args) -> 'bool'
 |      is_constant(self, is_signed=True) -> bool
 |      Retrieve value of a constant integer operand.
 |      
 |      @param is_signed: (C++: bool) should treat the value as signed
 |      @return: true if the operand is mop_n
 |  
 |  is_equal_to(self, *args) -> 'bool'
 |      is_equal_to(self, n, is_signed=True) -> bool
 |      
 |      @param n: uint64
 |      @param is_signed: bool
 |  
 |  is_extended_from(self, *args) -> 'bool'
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |      Does the high part of the operand consist of zero or sign bytes?
 |      
 |      @param nbytes: (C++: int)
 |      @param is_signed: (C++: bool)
 |  
 |  is_glbaddr(self, *args) -> 'bool'
 |      is_glbaddr(self) -> bool
 |      Is address of the specified global memory cell?
 |      is_glbaddr(self, ea) -> bool
 |      
 |      @param ea: ea_t
 |  
 |  is_impptr_done(self, *args) -> 'bool'
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args) -> 'bool'
 |      is_insn(self) -> bool
 |      Is a sub-instruction with the specified opcode?
 |      is_insn(self, code) -> bool
 |      
 |      @param code: enum mcode_t
 |  
 |  is_kreg(self, *args) -> 'bool'
 |      is_kreg(self) -> bool
 |      Is a kernel register?
 |  
 |  is_lowaddr(self, *args) -> 'bool'
 |      is_lowaddr(self) -> bool
 |  
 |  is_mob(self, *args) -> 'bool'
 |      is_mob(self, serial) -> bool
 |      Is a block reference to the specified block?
 |      
 |      @param serial: (C++: int)
 |  
 |  is_negative_constant(self, *args) -> 'bool'
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args) -> 'bool'
 |      is_one(self) -> bool
 |  
 |  is_pcval(self, *args) -> 'bool'
 |      is_pcval(self) -> bool
 |  
 |  is_positive_constant(self, *args) -> 'bool'
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      Is the specified register of the specified size?
 |      is_reg(self, _r) -> bool
 |      
 |      @param _r: mreg_t
 |      
 |      is_reg(self, _r, _size) -> bool
 |      
 |      @param _r: mreg_t
 |      @param _size: int
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      Is a scattered operand?
 |  
 |  is_sign_extended_from(self, *args) -> 'bool'
 |      is_sign_extended_from(self, nbytes) -> bool
 |      Does the high part of the operand consist of the sign bytes?
 |      
 |      @param nbytes: (C++: int) number of bytes that were sign extended. the remaining size-
 |                     nbytes high bytes must be sign bytes Example:
 |                     is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3
 |                     bytes are certainly sign bits
 |  
 |  is_stkaddr(self, *args) -> 'bool'
 |      is_stkaddr(self) -> bool
 |      Is address of a stack variable?
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args) -> 'bool'
 |      is_zero_extended_from(self, nbytes) -> bool
 |      Does the high part of the operand consist of zero bytes?
 |      
 |      @param nbytes: (C++: int) number of bytes that were zero extended. the remaining size-
 |                     nbytes high bytes must be zero Example:
 |                     is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6
 |                     bytes are certainly zero
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, rop) -> int
 |      
 |      @param rop: mop_t const &
 |  
 |  make_blkref(self, *args) -> 'void'
 |      make_blkref(self, blknum)
 |      Create a global variable operand.
 |      
 |      @param blknum: (C++: int)
 |  
 |  make_first_half(self, *args) -> 'bool'
 |      make_first_half(self, width) -> bool
 |      Make the first part of the operand. This function does not care about the memory
 |      endianness
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_fpnum(self, *args) -> 'bool'
 |      make_fpnum(self, bytes) -> bool
 |      Create a floating point constant operand.
 |      
 |      @param bytes: (C++: const void *) pointer to the floating point value as used by the current
 |                    processor (e.g. for x86 it must be in IEEE 754)
 |      @return: success
 |  
 |  make_gvar(self, *args) -> 'void'
 |      make_gvar(self, ea)
 |      Create a global variable operand.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  make_helper(self, *args) -> 'void'
 |      make_helper(self, name)
 |      Create a helper operand. A helper operand usually keeps a built-in function name
 |      like "va_start" It is essentially just an arbitrary identifier without any
 |      additional info.
 |      
 |      @param name: (C++: const char *) char const *
 |  
 |  make_high_half(self, *args) -> 'bool'
 |      make_high_half(self, width) -> bool
 |      Make the high part of the operand. This function takes into account the memory
 |      endianness (byte sex)
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_insn(self, *args) -> 'void'
 |      make_insn(self, ins)
 |      Create a nested instruction.
 |      
 |      @param ins: (C++: minsn_t *)
 |  
 |  make_low_half(self, *args) -> 'bool'
 |      make_low_half(self, width) -> bool
 |      Make the low part of the operand. This function takes into account the memory
 |      endianness (byte sex)
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_number(self, *args) -> 'void'
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |      Create an integer constant operand.
 |      
 |      @param _value: (C++: uint64) value to store in the operand
 |      @param _size: (C++: int) size of the value in bytes (1,2,4,8)
 |      @param _ea: (C++: ea_t) address of the processor instruction that made the value
 |      @param opnum: (C++: int) operand number of the processor instruction
 |  
 |  make_reg(self, *args) -> 'void'
 |      make_reg(self, reg)
 |      
 |      @param reg: mreg_t
 |      
 |      make_reg(self, reg, _size)
 |      
 |      @param reg: mreg_t
 |      @param _size: int
 |  
 |  make_reg_pair(self, *args) -> 'void'
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |      Create pair of registers.
 |      
 |      @param loreg: (C++: int) register holding the low part of the value
 |      @param hireg: (C++: int) register holding the high part of the value
 |      @param halfsize: (C++: int) the size of each of loreg/hireg
 |  
 |  make_second_half(self, *args) -> 'bool'
 |      make_second_half(self, width) -> bool
 |      Make the second part of the operand. This function does not care about the
 |      memory endianness
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_stkvar(self, *args) -> 'void'
 |      make_stkvar(self, mba, off)
 |      
 |      @param mba: mba_t *
 |      @param off: sval_t
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |      Is it possible for the operand to use aliased memory?
 |  
 |  preserve_side_effects(self, *args) -> 'bool'
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |      Move subinstructions with side effects out of the operand. If we decide to
 |      delete an instruction operand, it is a good idea to call this function.
 |      Alternatively we should skip such operands by calling mop_t::has_side_effects()
 |      For example, if we transform: jnz x, x, @blk => goto @blk then we must call this
 |      function before deleting the X operands.
 |      
 |      @param blk: (C++: mblock_t *) current block
 |      @param top: (C++: minsn_t *) top level instruction that contains our operand
 |      @param moved_calls: (C++: bool *) pointer to the boolean that will track if all side effects
 |                          get handled correctly. must be false initially.
 |      @return: false failed to preserve a side effect, it is not safe to delete the
 |               operand true no side effects or successfully preserved them
 |  
 |  probably_floating(self, *args) -> 'bool'
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args) -> 'void'
 |      set_impptr_done(self)
 |  
 |  set_lowaddr(self, *args) -> 'void'
 |      set_lowaddr(self)
 |  
 |  set_udt(self, *args) -> 'void'
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args) -> 'void'
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args) -> 'bool'
 |      shift_mop(self, offset) -> bool
 |      Shift the operand. This function shifts only the beginning of the operand. The
 |      operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2
 |      shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) ->
 |      #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
 |      
 |      @param offset: (C++: int) shift count (the number of bytes to shift)
 |      @return: success
 |  
 |  signed_value(self, *args) -> 'int64'
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, rop)
 |      
 |      @param rop: mop_t &
 |  
 |  unsigned_value(self, *args) -> 'uint64'
 |      unsigned_value(self) -> uint64
 |  
 |  update_numop_value(self, *args) -> 'void'
 |      update_numop_value(self, val)
 |      
 |      @param val: uint64
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, is_signed) -> uint64
 |      Retrieve value of a constant integer operand. These functions can be called only
 |      for mop_n operands. See is_constant() that can be called on any operand.
 |      
 |      @param is_signed: (C++: bool)
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from mop_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      oprops
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      size
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  valnum
 |      valnum
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from mop_t:
 |  
 |  __hash__ = None

Help on class mcallargs_t in module ida_hexrays:

class mcallargs_t(builtins.object)
 |  Proxy of C++ qvector< mcallarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< mcallarg_t > const &
 |  
 |  __getitem__(self, *args) -> 'mcallarg_t const &'
 |      __getitem__(self, i) -> mcallarg_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcallargs_t
 |      __init__(self, x) -> mcallargs_t
 |      
 |      @param x: qvector< mcallarg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< mcallarg_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: mcallarg_t const &
 |  
 |  __swig_destroy__ = delete_mcallargs_t(...)
 |      delete_mcallargs_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: mcallarg_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: mcallarg_t const &
 |  
 |  at(self, *args) -> 'mcallarg_t const &'
 |      at(self, _idx) -> mcallarg_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< mcallarg_t >::const_iterator'
 |      begin(self) -> mcallarg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< mcallarg_t >::const_iterator'
 |      end(self) -> mcallarg_t
 |  
 |  erase(self, *args) -> 'qvector< mcallarg_t >::iterator'
 |      erase(self, it) -> mcallarg_t
 |      
 |      @param it: qvector< mcallarg_t >::iterator
 |      
 |      erase(self, first, last) -> mcallarg_t
 |      
 |      @param first: qvector< mcallarg_t >::iterator
 |      @param last: qvector< mcallarg_t >::iterator
 |  
 |  extract(self, *args) -> 'mcallarg_t *'
 |      extract(self) -> mcallarg_t
 |  
 |  find(self, *args) -> 'qvector< mcallarg_t >::const_iterator'
 |      find(self, x) -> mcallarg_t
 |      
 |      @param x: mcallarg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=mcallarg_t())
 |      
 |      @param x: mcallarg_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: mcallarg_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: mcallarg_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< mcallarg_t >::iterator'
 |      insert(self, it, x) -> mcallarg_t
 |      
 |      @param it: qvector< mcallarg_t >::iterator
 |      @param x: mcallarg_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'mcallarg_t &'
 |      push_back(self, x)
 |      
 |      @param x: mcallarg_t const &
 |      
 |      push_back(self) -> mcallarg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: mcallarg_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< mcallarg_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mcallinfo_t in module ida_hexrays:

class mcallinfo_t(builtins.object)
 |  Proxy of C++ mcallinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _callee=BADADDR, _sargs=0) -> mcallinfo_t
 |      
 |      @param _callee: ea_t
 |      @param _sargs: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mcallinfo_t(...)
 |      delete_mcallinfo_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, size=-1, shins_flags=0x04|0x02)
 |      
 |      Parameters
 |      ----------
 |      size: int
 |      shins_flags: int
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  get_type(self, *args) -> 'tinfo_t'
 |      get_type(self) -> tinfo_t
 |  
 |  is_vararg(self, *args) -> 'bool'
 |      is_vararg(self) -> bool
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, f) -> int
 |      
 |      @param f: mcallinfo_t const &
 |  
 |  set_type(self, *args) -> 'bool'
 |      set_type(self, type) -> bool
 |      
 |      @param type: tinfo_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  args
 |      args
 |  
 |  call_spd
 |      call_spd
 |  
 |  callee
 |      callee
 |  
 |  cc
 |      cc
 |  
 |  dead_regs
 |      dead_regs
 |  
 |  flags
 |      flags
 |  
 |  fti_attrs
 |      fti_attrs
 |  
 |  pass_regs
 |      pass_regs
 |  
 |  retregs
 |      retregs
 |  
 |  return_argloc
 |      return_argloc
 |  
 |  return_regs
 |      return_regs
 |  
 |  return_type
 |      return_type
 |  
 |  role
 |      role
 |  
 |  solid_args
 |      solid_args
 |  
 |  spoiled
 |      spoiled
 |  
 |  stkargs_top
 |      stkargs_top
 |  
 |  thisown
 |      The membership flag
 |  
 |  visible_memory
 |      visible_memory

Help on class mcases_t in module ida_hexrays:

class mcases_t(builtins.object)
 |  Proxy of C++ mcases_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: mcases_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: mcases_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: mcases_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mcases_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: mcases_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: mcases_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: mcases_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mcases_t(...)
 |      delete_mcases_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: mcases_t const &
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, s)
 |      
 |      @param s: int
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: mcases_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  targets
 |      targets
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      values
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function mcode_modifies_d in module ida_hexrays:

mcode_modifies_d(*args) -> 'bool'
    mcode_modifies_d(mcode) -> bool
    
    @param mcode: enum mcode_t

Help on class microcode_filter_t in module ida_hexrays:

class microcode_filter_t(builtins.object)
 |  Proxy of C++ microcode_filter_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> microcode_filter_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_microcode_filter_t(...)
 |      delete_microcode_filter_t(self)
 |  
 |  apply(self, *args) -> 'merror_t'
 |      apply(self, cdg) -> merror_t
 |      generate microcode for an instruction
 |      
 |      @param cdg: (C++: codegen_t &)
 |      @return: MERR_... code: MERR_OK - user-defined microcode generated, go to the
 |               next instruction MERR_INSN - not generated - the caller should try the
 |               standard way else - error
 |  
 |  match(self, *args) -> 'bool'
 |      match(self, cdg) -> bool
 |      check if the filter object is to be applied
 |      
 |      @param cdg: (C++: codegen_t &)
 |      @return: success
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class minsn_t in module ida_hexrays:

class minsn_t(builtins.object)
 |  Proxy of C++ minsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea) -> minsn_t
 |      
 |      @param _ea: ea_t
 |      
 |      __init__(self, m) -> minsn_t
 |      
 |      @param m: minsn_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, ri) -> bool
 |      
 |      @param ri: minsn_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_minsn_t(...)
 |      delete_minsn_t(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _make_nop(self, *args) -> 'void'
 |      _make_nop(self)
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _minsn_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _minsn_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |      
 |      Parameters
 |      ----------
 |      shins_flags: int
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  clr_assert(self, *args) -> 'void'
 |      clr_assert(self)
 |  
 |  clr_combinable(self, *args) -> 'void'
 |      clr_combinable(self)
 |  
 |  clr_combined(self, *args) -> 'void'
 |      clr_combined(self)
 |  
 |  clr_fpinsn(self, *args) -> 'void'
 |      clr_fpinsn(self)
 |  
 |  clr_ignlowsrc(self, *args) -> 'void'
 |      clr_ignlowsrc(self)
 |  
 |  clr_multimov(self, *args) -> 'void'
 |      clr_multimov(self)
 |  
 |  clr_noret_icall(self, *args) -> 'void'
 |      clr_noret_icall(self)
 |  
 |  clr_propagatable(self, *args) -> 'void'
 |      clr_propagatable(self)
 |  
 |  clr_tailcall(self, *args) -> 'void'
 |      clr_tailcall(self)
 |  
 |  contains_call(self, *args) -> 'bool'
 |      contains_call(self, with_helpers=False) -> bool
 |      Does the instruction contain a call?
 |      
 |      @param with_helpers: (C++: bool)
 |  
 |  contains_opcode(self, *args) -> 'bool'
 |      contains_opcode(self, mcode) -> bool
 |      Does the instruction have the specified opcode? This function searches
 |      subinstructions as well.
 |      
 |      @param mcode: (C++: mcode_t) opcode to search for.
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |      Get displayable text without tags in a static buffer.
 |  
 |  equal_insns(self, *args) -> 'bool'
 |      equal_insns(self, m, eqflags) -> bool
 |      Compare instructions. This is the main comparison function for instructions.
 |      
 |      @param m: (C++: const minsn_t &) instruction to compare with
 |      @param eqflags: (C++: int) combination of comparison bits bits
 |  
 |  find_call(self, *args) -> 'minsn_t *'
 |      find_call(self, with_helpers=False) -> minsn_t
 |      Find a call instruction. Check for the current instruction and its
 |      subinstructions.
 |      
 |      @param with_helpers: (C++: bool) consider helper calls as well?
 |  
 |  find_ins_op(self, *args) -> 'minsn_t *'
 |      find_ins_op(self, op=m_nop) -> minsn_t
 |      
 |      @param op: enum mcode_t
 |  
 |  find_num_op(self, *args) -> 'mop_t *'
 |      find_num_op(self) -> mop_t
 |  
 |  find_opcode(self, *args) -> 'minsn_t *'
 |      find_opcode(self, mcode) -> minsn_t
 |      
 |      @param mcode: enum mcode_t
 |  
 |  for_all_insns(self, *args) -> 'int'
 |      for_all_insns(self, mv) -> int
 |      Visit all instructions. This function visits the instruction itself and all its
 |      subinstructions.
 |      
 |      @param mv: (C++: minsn_visitor_t &) instruction visitor
 |      @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv) -> int
 |      Visit all instruction operands. This function visits subinstruction operands as
 |      well.
 |      
 |      @param mv: (C++: mop_visitor_t &) operand visitor
 |      @return: non-zero value returned by mv.visit_mop() or zero
 |  
 |  get_role(self, *args) -> 'funcrole_t'
 |      get_role(self) -> funcrole_t
 |      Get the function role of a call.
 |  
 |  get_split_size(self, *args) -> 'int'
 |      get_split_size(self) -> int
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |      Does the instruction have a side effect?
 |      
 |      @param include_ldx_and_divs: (C++: bool) consider ldx/div/mod as having side effects? stx is
 |                                   always considered as having side effects. Apart
 |                                   from ldx/std only call may have side effects.
 |  
 |  is_after(self, *args) -> 'bool'
 |      is_after(self, m) -> bool
 |      Is the instruction after the specified one?
 |      
 |      @param m: (C++: const minsn_t *) the instruction to compare against in the list
 |  
 |  is_alloca(self, *args) -> 'bool'
 |      is_alloca(self) -> bool
 |  
 |  is_assert(self, *args) -> 'bool'
 |      is_assert(self) -> bool
 |  
 |  is_between(self, *args) -> 'bool'
 |      is_between(self, m1, m2) -> bool
 |      Is the instruction in the specified range of instructions?
 |      
 |      @param m1: (C++: const minsn_t *) beginning of the range in the doubly linked list
 |      @param m2: (C++: const minsn_t *) end of the range in the doubly linked list (excluded, may be nullptr)
 |                 This function assumes that m1 and m2 belong to the same basic block
 |                 and they are top level instructions.
 |  
 |  is_bswap(self, *args) -> 'bool'
 |      is_bswap(self) -> bool
 |  
 |  is_cleaning_pop(self, *args) -> 'bool'
 |      is_cleaning_pop(self) -> bool
 |  
 |  is_combinable(self, *args) -> 'bool'
 |      is_combinable(self) -> bool
 |  
 |  is_combined(self, *args) -> 'bool'
 |      is_combined(self) -> bool
 |  
 |  is_extstx(self, *args) -> 'bool'
 |      is_extstx(self) -> bool
 |  
 |  is_farcall(self, *args) -> 'bool'
 |      is_farcall(self) -> bool
 |  
 |  is_fpinsn(self, *args) -> 'bool'
 |      is_fpinsn(self) -> bool
 |  
 |  is_helper(self, *args) -> 'bool'
 |      is_helper(self, name) -> bool
 |      Is a helper call with the specified name? Helper calls usually have well-known
 |      function names (see Well known function names) but they may have any other name.
 |      The decompiler does not assume any special meaning for non-well-known names.
 |      
 |      @param name: (C++: const char *) char const *
 |  
 |  is_ignlowsrc(self, *args) -> 'bool'
 |      is_ignlowsrc(self) -> bool
 |  
 |  is_inverted_jx(self, *args) -> 'bool'
 |      is_inverted_jx(self) -> bool
 |  
 |  is_like_move(self, *args) -> 'bool'
 |      is_like_move(self) -> bool
 |  
 |  is_mbarrier(self, *args) -> 'bool'
 |      is_mbarrier(self) -> bool
 |  
 |  is_memcpy(self, *args) -> 'bool'
 |      is_memcpy(self) -> bool
 |  
 |  is_memset(self, *args) -> 'bool'
 |      is_memset(self) -> bool
 |  
 |  is_mov(self, *args) -> 'bool'
 |      is_mov(self) -> bool
 |  
 |  is_multimov(self, *args) -> 'bool'
 |      is_multimov(self) -> bool
 |  
 |  is_noret_call(self, *args) -> 'bool'
 |      is_noret_call(self, flags=0) -> bool
 |      Is a non-returing call?
 |      
 |      @param flags: (C++: int) combination of NORET_... bits
 |  
 |  is_optional(self, *args) -> 'bool'
 |      is_optional(self) -> bool
 |  
 |  is_persistent(self, *args) -> 'bool'
 |      is_persistent(self) -> bool
 |  
 |  is_propagatable(self, *args) -> 'bool'
 |      is_propagatable(self) -> bool
 |  
 |  is_readflags(self, *args) -> 'bool'
 |      is_readflags(self) -> bool
 |  
 |  is_tailcall(self, *args) -> 'bool'
 |      is_tailcall(self) -> bool
 |  
 |  is_unknown_call(self, *args) -> 'bool'
 |      is_unknown_call(self) -> bool
 |      Is an unknown call? Unknown calls are calls without the argument list
 |      (mcallinfo_t). Usually the argument lists are determined by
 |      mba_t::analyze_calls(). Unknown calls exist until the MMAT_CALLS maturity level.
 |      See also mblock_t::is_call_block
 |  
 |  is_wild_match(self, *args) -> 'bool'
 |      is_wild_match(self) -> bool
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, ri) -> int
 |      
 |      @param ri: minsn_t const &
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |      Is it possible for the instruction to use aliased memory?
 |  
 |  modifies_d(self, *args) -> 'bool'
 |      modifies_d(self) -> bool
 |      Does the instruction modify its 'd' operand? Some instructions (e.g. m_stx) do
 |      not modify the 'd' operand.
 |  
 |  modifies_pair_mop(self, *args) -> 'bool'
 |      modifies_pair_mop(self) -> bool
 |  
 |  optimize_solo(self, *args) -> 'int'
 |      optimize_solo(self, optflags=0) -> int
 |      Optimize one instruction without context. This function does not have access to
 |      the instruction context (the previous and next instructions in the list, the
 |      block number, etc). It performs only basic optimizations that are available
 |      without this info.
 |      
 |      @param optflags: (C++: int) combination of optimization flags bits
 |      @return: number of changes, 0-unchanged See also mblock_t::optimize_insn()
 |  
 |  optimize_subtree(self, *args) -> 'int'
 |      optimize_subtree(self, blk, top, parent, converted_call, optflags=0x0002) -> int
 |      Optimize instruction in its context. Do not use this function, use
 |      mblock_t::optimize()
 |      
 |      @param blk: (C++: mblock_t *)
 |      @param top: (C++: minsn_t *)
 |      @param parent: (C++: minsn_t *)
 |      @param converted_call: (C++: ea_t *)
 |      @param optflags: (C++: int)
 |  
 |  replace_by(self, o)
 |  
 |  set_assert(self, *args) -> 'void'
 |      set_assert(self)
 |  
 |  set_cleaning_pop(self, *args) -> 'void'
 |      set_cleaning_pop(self)
 |  
 |  set_combinable(self, *args) -> 'void'
 |      set_combinable(self)
 |  
 |  set_extstx(self, *args) -> 'void'
 |      set_extstx(self)
 |  
 |  set_farcall(self, *args) -> 'void'
 |      set_farcall(self)
 |  
 |  set_fpinsn(self, *args) -> 'void'
 |      set_fpinsn(self)
 |  
 |  set_ignlowsrc(self, *args) -> 'void'
 |      set_ignlowsrc(self)
 |  
 |  set_inverted_jx(self, *args) -> 'void'
 |      set_inverted_jx(self)
 |  
 |  set_mbarrier(self, *args) -> 'void'
 |      set_mbarrier(self)
 |  
 |  set_multimov(self, *args) -> 'void'
 |      set_multimov(self)
 |  
 |  set_noret_icall(self, *args) -> 'void'
 |      set_noret_icall(self)
 |  
 |  set_optional(self, *args) -> 'void'
 |      set_optional(self)
 |  
 |  set_persistent(self, *args) -> 'void'
 |      set_persistent(self)
 |  
 |  set_split_size(self, *args) -> 'void'
 |      set_split_size(self, s)
 |      
 |      @param s: int
 |  
 |  set_tailcall(self, *args) -> 'void'
 |      set_tailcall(self)
 |  
 |  set_unmerged(self, *args) -> 'void'
 |      set_unmerged(self)
 |  
 |  set_wild_match(self, *args) -> 'void'
 |      set_wild_match(self)
 |  
 |  setaddr(self, *args) -> 'void'
 |      setaddr(self, new_ea)
 |      Change the instruction address. This function modifies subinstructions as well.
 |      
 |      @param new_ea: (C++: ea_t)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, m)
 |      Swap two instructions. The prev/next fields are not modified by this function
 |      because it would corrupt the doubly linked list.
 |      
 |      @param m: (C++: minsn_t &)
 |  
 |  was_noret_icall(self, *args) -> 'bool'
 |      was_noret_icall(self) -> bool
 |  
 |  was_split(self, *args) -> 'bool'
 |      was_split(self) -> bool
 |  
 |  was_unmerged(self, *args) -> 'bool'
 |      was_unmerged(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  d
 |      d
 |  
 |  ea
 |      ea
 |  
 |  iprops
 |      iprops
 |  
 |  l
 |      l
 |  
 |  meminfo
 |  
 |  next
 |      next
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  opcode
 |      opcode
 |  
 |  prev
 |      prev
 |  
 |  r
 |      r
 |  
 |  thisown
 |      The membership flag

Help on class minsn_visitor_t in module ida_hexrays:

class minsn_visitor_t(op_parent_info_t)
 |  Proxy of C++ minsn_visitor_t class.
 |  
 |  Method resolution order:
 |      minsn_visitor_t
 |      op_parent_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> minsn_visitor_t
 |      
 |      @param _mba: mba_t *
 |      @param _blk: mblock_t *
 |      @param _topins: minsn_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_minsn_visitor_t(...)
 |      delete_minsn_visitor_t(self)
 |  
 |  visit_minsn(self, *args) -> 'int'
 |      visit_minsn(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from op_parent_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      blk
 |  
 |  curins
 |      curins
 |  
 |  mba
 |      mba
 |  
 |  topins
 |      topins

Help on class mlist_mop_visitor_t in module ida_hexrays:

class mlist_mop_visitor_t(builtins.object)
 |  Proxy of C++ mlist_mop_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mlist_mop_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mlist_mop_visitor_t(...)
 |      delete_mlist_mop_visitor_t(self)
 |  
 |  visit_mop(self, *args) -> 'int'
 |      visit_mop(self, op) -> int
 |      
 |      @param op: mop_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  changed
 |      changed
 |  
 |  curins
 |      curins
 |  
 |  list
 |      list
 |  
 |  thisown
 |      The membership flag
 |  
 |  topins
 |      topins

Help on class mlist_t in module ida_hexrays:

class mlist_t(builtins.object)
 |  Proxy of C++ mlist_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: mlist_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: mlist_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: mlist_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mlist_t
 |      __init__(self, ivl) -> mlist_t
 |      
 |      @param ivl: ivl_t const &
 |      
 |      __init__(self, r, size) -> mlist_t
 |      
 |      @param r: mreg_t
 |      @param size: int
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: mlist_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: mlist_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: mlist_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mlist_t(...)
 |      delete_mlist_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, r, size) -> bool
 |      
 |      @param r: mreg_t
 |      @param size: int
 |      
 |      add(self, r) -> bool
 |      
 |      @param r: rlist_t const &
 |      
 |      add(self, ivl) -> bool
 |      
 |      @param ivl: ivl_t const &
 |      
 |      add(self, lst) -> bool
 |      
 |      @param lst: mlist_t const &
 |  
 |  addmem(self, *args) -> 'bool'
 |      addmem(self, ea, size) -> bool
 |      
 |      @param ea: ea_t
 |      @param size: asize_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: mlist_t const &
 |  
 |  count(self, *args) -> 'asize_t'
 |      count(self) -> asize_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, r) -> bool
 |      
 |      @param r: mreg_t
 |  
 |  has_all(self, *args) -> 'bool'
 |      has_all(self, r, size) -> bool
 |      
 |      @param r: mreg_t
 |      @param size: int
 |  
 |  has_any(self, *args) -> 'bool'
 |      has_any(self, r, size) -> bool
 |      
 |      @param r: mreg_t
 |      @param size: int
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, lst) -> bool
 |      
 |      @param lst: mlist_t const &
 |  
 |  has_memory(self, *args) -> 'bool'
 |      has_memory(self) -> bool
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, lst) -> bool
 |      
 |      @param lst: mlist_t const &
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, lst) -> bool
 |      
 |      @param lst: mlist_t const &
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, lst) -> bool
 |      
 |      @param lst: mlist_t const &
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, r, size) -> bool
 |      
 |      @param r: mreg_t
 |      @param size: int
 |      
 |      sub(self, ivl) -> bool
 |      
 |      @param ivl: ivl_t const &
 |      
 |      sub(self, lst) -> bool
 |      
 |      @param lst: mlist_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: mlist_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  mem
 |      mem
 |  
 |  reg
 |      reg
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mnumber_t in module ida_hexrays:

class mnumber_t(operand_locator_t)
 |  Proxy of C++ mnumber_t class.
 |  
 |  Method resolution order:
 |      mnumber_t
 |      operand_locator_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: mnumber_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: mnumber_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: mnumber_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, v, _ea=BADADDR, n=0) -> mnumber_t
 |      
 |      @param v: uint64
 |      @param _ea: ea_t
 |      @param n: int
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: mnumber_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: mnumber_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: mnumber_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mnumber_t(...)
 |      delete_mnumber_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: mnumber_t const &
 |  
 |  update_value(self, *args) -> 'void'
 |      update_value(self, val64)
 |      
 |      @param val64: uint64
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  org_value
 |      org_value
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from operand_locator_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  opnum
 |      opnum

Help on function modify_user_lvar_info in module ida_hexrays:

modify_user_lvar_info(*args) -> 'bool'
    modify_user_lvar_info(func_ea, mli_flags, info) -> bool
    Modify saved local variable settings of one variable.
    
    @param func_ea: (C++: ea_t) function start address
    @param mli_flags: (C++: uint) bits that specify which attrs defined by INFO are to be set
    @param info: (C++: const lvar_saved_info_t &) local variable info attrs
    @return: true if modified, false if invalid MLI_FLAGS passed

Help on function modify_user_lvars in module ida_hexrays:

modify_user_lvars(*args) -> 'bool'
    modify_user_lvars(entry_ea, mlv) -> bool
    Modify saved local variable settings.
    
    @param entry_ea: (C++: ea_t) function start address
    @param mlv: (C++: user_lvar_modifier_t &) local variable modifier
    @return: true if modified variables

Help on class mop_addr_t in module ida_hexrays:

class mop_addr_t(mop_t)
 |  Proxy of C++ mop_addr_t class.
 |  
 |  Method resolution order:
 |      mop_addr_t
 |      mop_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_addr_t
 |      __init__(self, ra) -> mop_addr_t
 |      
 |      @param ra: mop_addr_t const &
 |      
 |      __init__(self, ra, isz, osz) -> mop_addr_t
 |      
 |      @param ra: mop_t const &
 |      @param isz: int
 |      @param osz: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_addr_t(...)
 |      delete_mop_addr_t(self)
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, ra) -> int
 |      
 |      @param ra: mop_addr_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  insize
 |      insize
 |  
 |  outsize
 |      outsize
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from mop_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_a(self, *args) -> 'mop_addr_t *'
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args) -> 'int'
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args) -> 'mcases_t *'
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args) -> 'char const *'
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args) -> 'minsn_t *'
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args) -> 'mcallinfo_t *'
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args) -> 'ea_t'
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args) -> 'lvar_ref_t *'
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args) -> 'mnumber_t *'
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args) -> 'mop_pair_t *'
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args) -> 'mreg_t'
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args) -> 'stkvar_ref_t *'
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args) -> 'scif_t *'
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args) -> 'mopt_t'
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args) -> 'void'
 |      _make_blkref(self, blknum)
 |      
 |      Parameters
 |      ----------
 |      blknum: int
 |  
 |  _make_callinfo(self, *args) -> 'void'
 |      _make_callinfo(self, fi)
 |      
 |      Parameters
 |      ----------
 |      fi: mcallinfo_t *
 |  
 |  _make_cases(self, *args) -> 'void'
 |      _make_cases(self, _cases)
 |      
 |      Parameters
 |      ----------
 |      _cases: mcases_t *
 |  
 |  _make_gvar(self, *args) -> 'void'
 |      _make_gvar(self, ea)
 |      
 |      Parameters
 |      ----------
 |      ea: ea_t
 |  
 |  _make_insn(self, *args) -> 'void'
 |      _make_insn(self, ins)
 |      
 |      Parameters
 |      ----------
 |      ins: minsn_t *
 |  
 |  _make_lvar(self, *args) -> 'void'
 |      _make_lvar(self, mba, idx, off=0)
 |      
 |      Parameters
 |      ----------
 |      mba: mba_t *
 |      idx: int
 |      off: sval_t
 |  
 |  _make_pair(self, *args) -> 'void'
 |      _make_pair(self, _pair)
 |      
 |      Parameters
 |      ----------
 |      _pair: mop_pair_t *
 |  
 |  _make_reg(self, *args) -> 'void'
 |      _make_reg(self, reg)
 |      
 |      Parameters
 |      ----------
 |      reg: mreg_t
 |      
 |      _make_reg(self, reg, _size)
 |      
 |      Parameters
 |      ----------
 |      reg: mreg_t
 |      _size: int
 |  
 |  _make_stkvar(self, *args) -> 'void'
 |      _make_stkvar(self, mba, off)
 |      
 |      Parameters
 |      ----------
 |      mba: mba_t *
 |      off: sval_t
 |  
 |  _make_strlit(self, *args) -> 'void'
 |      _make_strlit(self, str)
 |      
 |      Parameters
 |      ----------
 |      str: char const *
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |      
 |      Parameters
 |      ----------
 |      shins_flags: int
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mop_addr_t *
 |  
 |  _set_b(self, *args) -> 'void'
 |      _set_b(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_c(self, *args) -> 'void'
 |      _set_c(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mcases_t *
 |  
 |  _set_cstr(self, *args) -> 'void'
 |      _set_cstr(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_d(self, *args) -> 'void'
 |      _set_d(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: minsn_t *
 |  
 |  _set_f(self, *args) -> 'void'
 |      _set_f(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mcallinfo_t *
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: fnumber_t *
 |  
 |  _set_g(self, *args) -> 'void'
 |      _set_g(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: ea_t
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_l(self, *args) -> 'void'
 |      _set_l(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: lvar_ref_t *
 |  
 |  _set_nnn(self, *args) -> 'void'
 |      _set_nnn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mnumber_t *
 |  
 |  _set_pair(self, *args) -> 'void'
 |      _set_pair(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mop_pair_t *
 |  
 |  _set_r(self, *args) -> 'void'
 |      _set_r(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mreg_t
 |  
 |  _set_s(self, *args) -> 'void'
 |      _set_s(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: stkvar_ref_t *
 |  
 |  _set_scif(self, *args) -> 'void'
 |      _set_scif(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: scif_t *
 |  
 |  _set_t(self, *args) -> 'void'
 |      _set_t(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: mopt_t
 |  
 |  apply_ld_mcode(self, *args) -> 'void'
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |      Apply a unary opcode to the operand.
 |      
 |      @param mcode: (C++: mcode_t) opcode to apply. it must accept 'l' and 'd' operands but not 'r'.
 |      @param ea: (C++: ea_t) value of minsn_t::ea for the newly created insruction
 |      @param newsize: (C++: int) new operand size Example: apply_ld_mcode(m_low) will convert op
 |                      => low(op)
 |  
 |  apply_xds(self, *args) -> 'void'
 |      apply_xds(self, ea, newsize)
 |      
 |      @param ea: ea_t
 |      @param newsize: int
 |  
 |  apply_xdu(self, *args) -> 'void'
 |      apply_xdu(self, ea, newsize)
 |      
 |      @param ea: ea_t
 |      @param newsize: int
 |  
 |  assign(self, *args) -> 'mop_t &'
 |      assign(self, rop) -> mop_t
 |      
 |      @param rop: mop_t const &
 |  
 |  change_size(self, *args) -> 'bool'
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
 |      change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4)
 |      -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1
 |      
 |      @param nsize: (C++: int) new operand size
 |      @param sideff: (C++: side_effect_t) may modify the database because of the size change?
 |      @return: success
 |  
 |  create_from_insn(self, *args) -> 'void'
 |      create_from_insn(self, m)
 |      Create operand from an instruction. This function creates a nested instruction
 |      that can be used as an operand. Example: if m="add x,y,z", our operand will be
 |      (t=mop_d,d=m). The destination operand of 'add' (z) is lost.
 |      
 |      @param m: (C++: const minsn_t *) instruction to embed into operand. may not be nullptr.
 |  
 |  create_from_ivlset(self, *args) -> 'bool'
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |      Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our
 |      operand will be (t=mop_v, g=&glbvar, size=4)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param ivs: (C++: const ivlset_t &) set of memory intervals
 |      @param fullsize: (C++: sval_t) mba->fullsize
 |      @return: success
 |  
 |  create_from_mlist(self, *args) -> 'bool'
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |      Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our
 |      operand will be (t=mop_r, r=R0, size=4)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param lst: (C++: const mlist_t &) list of locations
 |      @param fullsize: (C++: sval_t) mba->fullsize
 |      @return: success
 |  
 |  create_from_scattered_vdloc(self, *args) -> 'void'
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |      Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4,
 |      EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4,
 |      EDX.4})
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param name: (C++: const char *) name of the operand, if available
 |      @param type: (C++: tinfo_t) type of the operand, must be present
 |      @param loc: (C++: const vdloc_t &) a scattered location
 |      @return: success
 |  
 |  create_from_vdloc(self, *args) -> 'void'
 |      create_from_vdloc(self, mba, loc, _size)
 |      Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0),
 |      our operand will be (t=mop_r, r=R0, size=_SIZE)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param loc: (C++: const vdloc_t &) location
 |      @param _size: (C++: int) operand size Note: this function cannot handle scattered
 |                    locations.
 |      @return: success
 |  
 |  double_size(self, *args) -> 'bool'
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |      
 |      @param sideff: enum side_effect_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args) -> 'bool'
 |      equal_mops(self, rop, eqflags) -> bool
 |      Compare operands. This is the main comparison function for operands.
 |      
 |      @param rop: (C++: const mop_t &) operand to compare with
 |      @param eqflags: (C++: int) combination of comparison bits bits
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args) -> 'void'
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |      Visit the operand and all its sub-operands. This function visits the current
 |      operand as well.
 |      
 |      @param mv: (C++: mop_visitor_t &) visitor object
 |      @param type: (C++: const tinfo_t *) operand type
 |      @param is_target: (C++: bool) is a destination operand?
 |  
 |  for_all_scattered_submops(self, *args) -> 'int'
 |      for_all_scattered_submops(self, sv) -> int
 |      Visit all sub-operands of a scattered operand. This function does not visit the
 |      current operand, only its sub-operands. All sub-operands are synthetic and are
 |      destroyed after the visitor. This function works only with scattered operands.
 |      
 |      @param sv: (C++: scif_visitor_t &) visitor object
 |  
 |  get_insn(self, *args) -> 'minsn_t *'
 |      get_insn(self, code) -> minsn_t
 |      
 |      @param code: enum mcode_t
 |  
 |  get_stkoff(self, *args) -> 'bool'
 |      get_stkoff(self, p_off) -> bool
 |      Get the referenced stack offset. This function can also handle mop_sc if it is
 |      entirely mapped into a continuous stack region.
 |      
 |      @param p_off: (C++: sval_t *) the output buffer
 |      @return: success
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off) -> member_t *
 |      Retrieve the referenced stack variable.
 |      
 |      @param p_off: (C++: uval_t *) if specified, will hold IDA stkoff after the call.
 |      @return: pointer to the stack variable
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |      Has any side effects?
 |      
 |      @param include_ldx_and_divs: (C++: bool) consider ldx/div/mod as having side effects?
 |  
 |  is01(self, *args) -> 'bool'
 |      is01(self) -> bool
 |      Are the possible values of the operand only 0 and 1? This function returns true
 |      for 0/1 constants, bit registers, the result of 'set' insns, etc.
 |  
 |  is_arglist(self, *args) -> 'bool'
 |      is_arglist(self) -> bool
 |      Is a list of arguments?
 |  
 |  is_bit_reg(self, *args) -> 'bool'
 |      is_bit_reg(self, reg) -> bool
 |      Is a bit register? This includes condition codes and eventually other bit
 |      registers
 |      
 |      @param reg: (C++: mreg_t)
 |      
 |      is_bit_reg(self) -> bool
 |  
 |  is_cc(self, *args) -> 'bool'
 |      is_cc(self) -> bool
 |      Is a condition code?
 |  
 |  is_ccflags(self, *args) -> 'bool'
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args) -> 'bool'
 |      is_constant(self, is_signed=True) -> bool
 |      Retrieve value of a constant integer operand.
 |      
 |      @param is_signed: (C++: bool) should treat the value as signed
 |      @return: true if the operand is mop_n
 |  
 |  is_equal_to(self, *args) -> 'bool'
 |      is_equal_to(self, n, is_signed=True) -> bool
 |      
 |      @param n: uint64
 |      @param is_signed: bool
 |  
 |  is_extended_from(self, *args) -> 'bool'
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |      Does the high part of the operand consist of zero or sign bytes?
 |      
 |      @param nbytes: (C++: int)
 |      @param is_signed: (C++: bool)
 |  
 |  is_glbaddr(self, *args) -> 'bool'
 |      is_glbaddr(self) -> bool
 |      Is address of the specified global memory cell?
 |      is_glbaddr(self, ea) -> bool
 |      
 |      @param ea: ea_t
 |  
 |  is_impptr_done(self, *args) -> 'bool'
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args) -> 'bool'
 |      is_insn(self) -> bool
 |      Is a sub-instruction with the specified opcode?
 |      is_insn(self, code) -> bool
 |      
 |      @param code: enum mcode_t
 |  
 |  is_kreg(self, *args) -> 'bool'
 |      is_kreg(self) -> bool
 |      Is a kernel register?
 |  
 |  is_lowaddr(self, *args) -> 'bool'
 |      is_lowaddr(self) -> bool
 |  
 |  is_mob(self, *args) -> 'bool'
 |      is_mob(self, serial) -> bool
 |      Is a block reference to the specified block?
 |      
 |      @param serial: (C++: int)
 |  
 |  is_negative_constant(self, *args) -> 'bool'
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args) -> 'bool'
 |      is_one(self) -> bool
 |  
 |  is_pcval(self, *args) -> 'bool'
 |      is_pcval(self) -> bool
 |  
 |  is_positive_constant(self, *args) -> 'bool'
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      Is the specified register of the specified size?
 |      is_reg(self, _r) -> bool
 |      
 |      @param _r: mreg_t
 |      
 |      is_reg(self, _r, _size) -> bool
 |      
 |      @param _r: mreg_t
 |      @param _size: int
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      Is a scattered operand?
 |  
 |  is_sign_extended_from(self, *args) -> 'bool'
 |      is_sign_extended_from(self, nbytes) -> bool
 |      Does the high part of the operand consist of the sign bytes?
 |      
 |      @param nbytes: (C++: int) number of bytes that were sign extended. the remaining size-
 |                     nbytes high bytes must be sign bytes Example:
 |                     is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3
 |                     bytes are certainly sign bits
 |  
 |  is_stkaddr(self, *args) -> 'bool'
 |      is_stkaddr(self) -> bool
 |      Is address of a stack variable?
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args) -> 'bool'
 |      is_zero_extended_from(self, nbytes) -> bool
 |      Does the high part of the operand consist of zero bytes?
 |      
 |      @param nbytes: (C++: int) number of bytes that were zero extended. the remaining size-
 |                     nbytes high bytes must be zero Example:
 |                     is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6
 |                     bytes are certainly zero
 |  
 |  make_blkref(self, *args) -> 'void'
 |      make_blkref(self, blknum)
 |      Create a global variable operand.
 |      
 |      @param blknum: (C++: int)
 |  
 |  make_first_half(self, *args) -> 'bool'
 |      make_first_half(self, width) -> bool
 |      Make the first part of the operand. This function does not care about the memory
 |      endianness
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_fpnum(self, *args) -> 'bool'
 |      make_fpnum(self, bytes) -> bool
 |      Create a floating point constant operand.
 |      
 |      @param bytes: (C++: const void *) pointer to the floating point value as used by the current
 |                    processor (e.g. for x86 it must be in IEEE 754)
 |      @return: success
 |  
 |  make_gvar(self, *args) -> 'void'
 |      make_gvar(self, ea)
 |      Create a global variable operand.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  make_helper(self, *args) -> 'void'
 |      make_helper(self, name)
 |      Create a helper operand. A helper operand usually keeps a built-in function name
 |      like "va_start" It is essentially just an arbitrary identifier without any
 |      additional info.
 |      
 |      @param name: (C++: const char *) char const *
 |  
 |  make_high_half(self, *args) -> 'bool'
 |      make_high_half(self, width) -> bool
 |      Make the high part of the operand. This function takes into account the memory
 |      endianness (byte sex)
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_insn(self, *args) -> 'void'
 |      make_insn(self, ins)
 |      Create a nested instruction.
 |      
 |      @param ins: (C++: minsn_t *)
 |  
 |  make_low_half(self, *args) -> 'bool'
 |      make_low_half(self, width) -> bool
 |      Make the low part of the operand. This function takes into account the memory
 |      endianness (byte sex)
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_number(self, *args) -> 'void'
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |      Create an integer constant operand.
 |      
 |      @param _value: (C++: uint64) value to store in the operand
 |      @param _size: (C++: int) size of the value in bytes (1,2,4,8)
 |      @param _ea: (C++: ea_t) address of the processor instruction that made the value
 |      @param opnum: (C++: int) operand number of the processor instruction
 |  
 |  make_reg(self, *args) -> 'void'
 |      make_reg(self, reg)
 |      
 |      @param reg: mreg_t
 |      
 |      make_reg(self, reg, _size)
 |      
 |      @param reg: mreg_t
 |      @param _size: int
 |  
 |  make_reg_pair(self, *args) -> 'void'
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |      Create pair of registers.
 |      
 |      @param loreg: (C++: int) register holding the low part of the value
 |      @param hireg: (C++: int) register holding the high part of the value
 |      @param halfsize: (C++: int) the size of each of loreg/hireg
 |  
 |  make_second_half(self, *args) -> 'bool'
 |      make_second_half(self, width) -> bool
 |      Make the second part of the operand. This function does not care about the
 |      memory endianness
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_stkvar(self, *args) -> 'void'
 |      make_stkvar(self, mba, off)
 |      
 |      @param mba: mba_t *
 |      @param off: sval_t
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |      Is it possible for the operand to use aliased memory?
 |  
 |  preserve_side_effects(self, *args) -> 'bool'
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |      Move subinstructions with side effects out of the operand. If we decide to
 |      delete an instruction operand, it is a good idea to call this function.
 |      Alternatively we should skip such operands by calling mop_t::has_side_effects()
 |      For example, if we transform: jnz x, x, @blk => goto @blk then we must call this
 |      function before deleting the X operands.
 |      
 |      @param blk: (C++: mblock_t *) current block
 |      @param top: (C++: minsn_t *) top level instruction that contains our operand
 |      @param moved_calls: (C++: bool *) pointer to the boolean that will track if all side effects
 |                          get handled correctly. must be false initially.
 |      @return: false failed to preserve a side effect, it is not safe to delete the
 |               operand true no side effects or successfully preserved them
 |  
 |  probably_floating(self, *args) -> 'bool'
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args) -> 'void'
 |      set_impptr_done(self)
 |  
 |  set_lowaddr(self, *args) -> 'void'
 |      set_lowaddr(self)
 |  
 |  set_udt(self, *args) -> 'void'
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args) -> 'void'
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args) -> 'bool'
 |      shift_mop(self, offset) -> bool
 |      Shift the operand. This function shifts only the beginning of the operand. The
 |      operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2
 |      shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) ->
 |      #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
 |      
 |      @param offset: (C++: int) shift count (the number of bytes to shift)
 |      @return: success
 |  
 |  signed_value(self, *args) -> 'int64'
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, rop)
 |      
 |      @param rop: mop_t &
 |  
 |  unsigned_value(self, *args) -> 'uint64'
 |      unsigned_value(self) -> uint64
 |  
 |  update_numop_value(self, *args) -> 'void'
 |      update_numop_value(self, val)
 |      
 |      @param val: uint64
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, is_signed) -> uint64
 |      Retrieve value of a constant integer operand. These functions can be called only
 |      for mop_n operands. See is_constant() that can be called on any operand.
 |      
 |      @param is_signed: (C++: bool)
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from mop_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      oprops
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      size
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  valnum
 |      valnum
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from mop_t:
 |  
 |  __hash__ = None

Help on class mop_pair_t in module ida_hexrays:

class mop_pair_t(builtins.object)
 |  Proxy of C++ mop_pair_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_pair_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_pair_t(...)
 |      delete_mop_pair_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hop
 |      hop
 |  
 |  lop
 |      lop
 |  
 |  thisown
 |      The membership flag

Help on class mop_t in module ida_hexrays:

class mop_t(builtins.object)
 |  Proxy of C++ mop_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mop_t
 |      __init__(self, rop) -> mop_t
 |      
 |      @param rop: mop_t const &
 |      
 |      __init__(self, _r, _s) -> mop_t
 |      
 |      @param _r: mreg_t
 |      @param _s: int
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, rop) -> bool
 |      
 |      @param rop: mop_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_t(...)
 |      delete_mop_t(self)
 |  
 |  _acquire_ownership(self, v, acquire)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _ensure_cond(self, ok, cond_str)
 |  
 |  _ensure_no_obj(self, o, attr, attr_is_acquired)
 |  
 |  _ensure_no_t(self)
 |  
 |  _ensure_ownership_transferrable(self, v)
 |  
 |  _get_a(self, *args) -> 'mop_addr_t *'
 |      _get_a(self) -> mop_addr_t
 |  
 |  _get_b(self, *args) -> 'int'
 |      _get_b(self) -> int
 |  
 |  _get_c(self, *args) -> 'mcases_t *'
 |      _get_c(self) -> mcases_t
 |  
 |  _get_cstr(self, *args) -> 'char const *'
 |      _get_cstr(self) -> char const *
 |  
 |  _get_d(self, *args) -> 'minsn_t *'
 |      _get_d(self) -> minsn_t
 |  
 |  _get_f(self, *args) -> 'mcallinfo_t *'
 |      _get_f(self) -> mcallinfo_t
 |  
 |  _get_fpc(self, *args) -> 'fnumber_t *'
 |      _get_fpc(self) -> fnumber_t
 |  
 |  _get_g(self, *args) -> 'ea_t'
 |      _get_g(self) -> ea_t
 |  
 |  _get_helper(self, *args) -> 'char const *'
 |      _get_helper(self) -> char const *
 |  
 |  _get_l(self, *args) -> 'lvar_ref_t *'
 |      _get_l(self) -> lvar_ref_t
 |  
 |  _get_nnn(self, *args) -> 'mnumber_t *'
 |      _get_nnn(self) -> mnumber_t
 |  
 |  _get_pair(self, *args) -> 'mop_pair_t *'
 |      _get_pair(self) -> mop_pair_t
 |  
 |  _get_r(self, *args) -> 'mreg_t'
 |      _get_r(self) -> mreg_t
 |  
 |  _get_s(self, *args) -> 'stkvar_ref_t *'
 |      _get_s(self) -> stkvar_ref_t
 |  
 |  _get_scif(self, *args) -> 'scif_t *'
 |      _get_scif(self) -> scif_t
 |  
 |  _get_t(self, *args) -> 'mopt_t'
 |      _get_t(self) -> mopt_t
 |  
 |  _make_blkref(self, *args) -> 'void'
 |      _make_blkref(self, blknum)
 |      
 |      Parameters
 |      ----------
 |      blknum: int
 |  
 |  _make_callinfo(self, *args) -> 'void'
 |      _make_callinfo(self, fi)
 |      
 |      Parameters
 |      ----------
 |      fi: mcallinfo_t *
 |  
 |  _make_cases(self, *args) -> 'void'
 |      _make_cases(self, _cases)
 |      
 |      Parameters
 |      ----------
 |      _cases: mcases_t *
 |  
 |  _make_gvar(self, *args) -> 'void'
 |      _make_gvar(self, ea)
 |      
 |      Parameters
 |      ----------
 |      ea: ea_t
 |  
 |  _make_insn(self, *args) -> 'void'
 |      _make_insn(self, ins)
 |      
 |      Parameters
 |      ----------
 |      ins: minsn_t *
 |  
 |  _make_lvar(self, *args) -> 'void'
 |      _make_lvar(self, mba, idx, off=0)
 |      
 |      Parameters
 |      ----------
 |      mba: mba_t *
 |      idx: int
 |      off: sval_t
 |  
 |  _make_pair(self, *args) -> 'void'
 |      _make_pair(self, _pair)
 |      
 |      Parameters
 |      ----------
 |      _pair: mop_pair_t *
 |  
 |  _make_reg(self, *args) -> 'void'
 |      _make_reg(self, reg)
 |      
 |      Parameters
 |      ----------
 |      reg: mreg_t
 |      
 |      _make_reg(self, reg, _size)
 |      
 |      Parameters
 |      ----------
 |      reg: mreg_t
 |      _size: int
 |  
 |  _make_stkvar(self, *args) -> 'void'
 |      _make_stkvar(self, mba, off)
 |      
 |      Parameters
 |      ----------
 |      mba: mba_t *
 |      off: sval_t
 |  
 |  _make_strlit(self, *args) -> 'void'
 |      _make_strlit(self, str)
 |      
 |      Parameters
 |      ----------
 |      str: char const *
 |  
 |  _maybe_disown_and_deregister(self)
 |  
 |  _meminfo(self)
 |  
 |  _mop_t__dbg_get_meminfo = __dbg_get_meminfo(self, *args) -> 'qstring'
 |      __dbg_get_meminfo(self) -> qstring
 |  
 |  _mop_t__dbg_get_registered_kind = __dbg_get_registered_kind(self, *args) -> 'int'
 |      __dbg_get_registered_kind(self) -> int
 |  
 |  _obj_id(self, *args) -> 'PyObject *'
 |      _obj_id(self) -> PyObject *
 |  
 |  _own_and_register(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, shins_flags=0x04|0x02)
 |      
 |      Parameters
 |      ----------
 |      shins_flags: int
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  _set_a(self, *args) -> 'void'
 |      _set_a(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mop_addr_t *
 |  
 |  _set_b(self, *args) -> 'void'
 |      _set_b(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: int
 |  
 |  _set_c(self, *args) -> 'void'
 |      _set_c(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mcases_t *
 |  
 |  _set_cstr(self, *args) -> 'void'
 |      _set_cstr(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_d(self, *args) -> 'void'
 |      _set_d(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: minsn_t *
 |  
 |  _set_f(self, *args) -> 'void'
 |      _set_f(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mcallinfo_t *
 |  
 |  _set_fpc(self, *args) -> 'void'
 |      _set_fpc(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: fnumber_t *
 |  
 |  _set_g(self, *args) -> 'void'
 |      _set_g(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: ea_t
 |  
 |  _set_helper(self, *args) -> 'void'
 |      _set_helper(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: char const *
 |  
 |  _set_l(self, *args) -> 'void'
 |      _set_l(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: lvar_ref_t *
 |  
 |  _set_nnn(self, *args) -> 'void'
 |      _set_nnn(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mnumber_t *
 |  
 |  _set_pair(self, *args) -> 'void'
 |      _set_pair(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mop_pair_t *
 |  
 |  _set_r(self, *args) -> 'void'
 |      _set_r(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: mreg_t
 |  
 |  _set_s(self, *args) -> 'void'
 |      _set_s(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: stkvar_ref_t *
 |  
 |  _set_scif(self, *args) -> 'void'
 |      _set_scif(self, _v)
 |      
 |      Parameters
 |      ----------
 |      _v: scif_t *
 |  
 |  _set_t(self, *args) -> 'void'
 |      _set_t(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: mopt_t
 |  
 |  apply_ld_mcode(self, *args) -> 'void'
 |      apply_ld_mcode(self, mcode, ea, newsize)
 |      Apply a unary opcode to the operand.
 |      
 |      @param mcode: (C++: mcode_t) opcode to apply. it must accept 'l' and 'd' operands but not 'r'.
 |      @param ea: (C++: ea_t) value of minsn_t::ea for the newly created insruction
 |      @param newsize: (C++: int) new operand size Example: apply_ld_mcode(m_low) will convert op
 |                      => low(op)
 |  
 |  apply_xds(self, *args) -> 'void'
 |      apply_xds(self, ea, newsize)
 |      
 |      @param ea: ea_t
 |      @param newsize: int
 |  
 |  apply_xdu(self, *args) -> 'void'
 |      apply_xdu(self, ea, newsize)
 |      
 |      @param ea: ea_t
 |      @param newsize: int
 |  
 |  assign(self, *args) -> 'mop_t &'
 |      assign(self, rop) -> mop_t
 |      
 |      @param rop: mop_t const &
 |  
 |  change_size(self, *args) -> 'bool'
 |      change_size(self, nsize, sideff=WITH_SIDEFF) -> bool
 |      Change the operand size. Examples: change_size(AL.1, 2) -> AX.2
 |      change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4)
 |      -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1
 |      
 |      @param nsize: (C++: int) new operand size
 |      @param sideff: (C++: side_effect_t) may modify the database because of the size change?
 |      @return: success
 |  
 |  create_from_insn(self, *args) -> 'void'
 |      create_from_insn(self, m)
 |      Create operand from an instruction. This function creates a nested instruction
 |      that can be used as an operand. Example: if m="add x,y,z", our operand will be
 |      (t=mop_d,d=m). The destination operand of 'add' (z) is lost.
 |      
 |      @param m: (C++: const minsn_t *) instruction to embed into operand. may not be nullptr.
 |  
 |  create_from_ivlset(self, *args) -> 'bool'
 |      create_from_ivlset(self, mba, ivs, fullsize) -> bool
 |      Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our
 |      operand will be (t=mop_v, g=&glbvar, size=4)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param ivs: (C++: const ivlset_t &) set of memory intervals
 |      @param fullsize: (C++: sval_t) mba->fullsize
 |      @return: success
 |  
 |  create_from_mlist(self, *args) -> 'bool'
 |      create_from_mlist(self, mba, lst, fullsize) -> bool
 |      Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our
 |      operand will be (t=mop_r, r=R0, size=4)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param lst: (C++: const mlist_t &) list of locations
 |      @param fullsize: (C++: sval_t) mba->fullsize
 |      @return: success
 |  
 |  create_from_scattered_vdloc(self, *args) -> 'void'
 |      create_from_scattered_vdloc(self, mba, name, type, loc)
 |      Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4,
 |      EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4,
 |      EDX.4})
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param name: (C++: const char *) name of the operand, if available
 |      @param type: (C++: tinfo_t) type of the operand, must be present
 |      @param loc: (C++: const vdloc_t &) a scattered location
 |      @return: success
 |  
 |  create_from_vdloc(self, *args) -> 'void'
 |      create_from_vdloc(self, mba, loc, _size)
 |      Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0),
 |      our operand will be (t=mop_r, r=R0, size=_SIZE)
 |      
 |      @param mba: (C++: mba_t *) pointer to microcode
 |      @param loc: (C++: const vdloc_t &) location
 |      @param _size: (C++: int) operand size Note: this function cannot handle scattered
 |                    locations.
 |      @return: success
 |  
 |  double_size(self, *args) -> 'bool'
 |      double_size(self, sideff=WITH_SIDEFF) -> bool
 |      
 |      @param sideff: enum side_effect_t
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  equal_mops(self, *args) -> 'bool'
 |      equal_mops(self, rop, eqflags) -> bool
 |      Compare operands. This is the main comparison function for operands.
 |      
 |      @param rop: (C++: const mop_t &) operand to compare with
 |      @param eqflags: (C++: int) combination of comparison bits bits
 |  
 |  erase(self, *args) -> 'void'
 |      erase(self)
 |  
 |  erase_but_keep_size(self, *args) -> 'void'
 |      erase_but_keep_size(self)
 |  
 |  for_all_ops(self, *args) -> 'int'
 |      for_all_ops(self, mv, type=None, is_target=False) -> int
 |      Visit the operand and all its sub-operands. This function visits the current
 |      operand as well.
 |      
 |      @param mv: (C++: mop_visitor_t &) visitor object
 |      @param type: (C++: const tinfo_t *) operand type
 |      @param is_target: (C++: bool) is a destination operand?
 |  
 |  for_all_scattered_submops(self, *args) -> 'int'
 |      for_all_scattered_submops(self, sv) -> int
 |      Visit all sub-operands of a scattered operand. This function does not visit the
 |      current operand, only its sub-operands. All sub-operands are synthetic and are
 |      destroyed after the visitor. This function works only with scattered operands.
 |      
 |      @param sv: (C++: scif_visitor_t &) visitor object
 |  
 |  get_insn(self, *args) -> 'minsn_t *'
 |      get_insn(self, code) -> minsn_t
 |      
 |      @param code: enum mcode_t
 |  
 |  get_stkoff(self, *args) -> 'bool'
 |      get_stkoff(self, p_off) -> bool
 |      Get the referenced stack offset. This function can also handle mop_sc if it is
 |      entirely mapped into a continuous stack region.
 |      
 |      @param p_off: (C++: sval_t *) the output buffer
 |      @return: success
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off) -> member_t *
 |      Retrieve the referenced stack variable.
 |      
 |      @param p_off: (C++: uval_t *) if specified, will hold IDA stkoff after the call.
 |      @return: pointer to the stack variable
 |  
 |  has_side_effects(self, *args) -> 'bool'
 |      has_side_effects(self, include_ldx_and_divs=False) -> bool
 |      Has any side effects?
 |      
 |      @param include_ldx_and_divs: (C++: bool) consider ldx/div/mod as having side effects?
 |  
 |  is01(self, *args) -> 'bool'
 |      is01(self) -> bool
 |      Are the possible values of the operand only 0 and 1? This function returns true
 |      for 0/1 constants, bit registers, the result of 'set' insns, etc.
 |  
 |  is_arglist(self, *args) -> 'bool'
 |      is_arglist(self) -> bool
 |      Is a list of arguments?
 |  
 |  is_bit_reg(self, *args) -> 'bool'
 |      is_bit_reg(self, reg) -> bool
 |      Is a bit register? This includes condition codes and eventually other bit
 |      registers
 |      
 |      @param reg: (C++: mreg_t)
 |      
 |      is_bit_reg(self) -> bool
 |  
 |  is_cc(self, *args) -> 'bool'
 |      is_cc(self) -> bool
 |      Is a condition code?
 |  
 |  is_ccflags(self, *args) -> 'bool'
 |      is_ccflags(self) -> bool
 |  
 |  is_constant(self, *args) -> 'bool'
 |      is_constant(self, is_signed=True) -> bool
 |      Retrieve value of a constant integer operand.
 |      
 |      @param is_signed: (C++: bool) should treat the value as signed
 |      @return: true if the operand is mop_n
 |  
 |  is_equal_to(self, *args) -> 'bool'
 |      is_equal_to(self, n, is_signed=True) -> bool
 |      
 |      @param n: uint64
 |      @param is_signed: bool
 |  
 |  is_extended_from(self, *args) -> 'bool'
 |      is_extended_from(self, nbytes, is_signed) -> bool
 |      Does the high part of the operand consist of zero or sign bytes?
 |      
 |      @param nbytes: (C++: int)
 |      @param is_signed: (C++: bool)
 |  
 |  is_glbaddr(self, *args) -> 'bool'
 |      is_glbaddr(self) -> bool
 |      Is address of the specified global memory cell?
 |      is_glbaddr(self, ea) -> bool
 |      
 |      @param ea: ea_t
 |  
 |  is_impptr_done(self, *args) -> 'bool'
 |      is_impptr_done(self) -> bool
 |  
 |  is_insn(self, *args) -> 'bool'
 |      is_insn(self) -> bool
 |      Is a sub-instruction with the specified opcode?
 |      is_insn(self, code) -> bool
 |      
 |      @param code: enum mcode_t
 |  
 |  is_kreg(self, *args) -> 'bool'
 |      is_kreg(self) -> bool
 |      Is a kernel register?
 |  
 |  is_lowaddr(self, *args) -> 'bool'
 |      is_lowaddr(self) -> bool
 |  
 |  is_mob(self, *args) -> 'bool'
 |      is_mob(self, serial) -> bool
 |      Is a block reference to the specified block?
 |      
 |      @param serial: (C++: int)
 |  
 |  is_negative_constant(self, *args) -> 'bool'
 |      is_negative_constant(self) -> bool
 |  
 |  is_one(self, *args) -> 'bool'
 |      is_one(self) -> bool
 |  
 |  is_pcval(self, *args) -> 'bool'
 |      is_pcval(self) -> bool
 |  
 |  is_positive_constant(self, *args) -> 'bool'
 |      is_positive_constant(self) -> bool
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      Is the specified register of the specified size?
 |      is_reg(self, _r) -> bool
 |      
 |      @param _r: mreg_t
 |      
 |      is_reg(self, _r, _size) -> bool
 |      
 |      @param _r: mreg_t
 |      @param _size: int
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      Is a scattered operand?
 |  
 |  is_sign_extended_from(self, *args) -> 'bool'
 |      is_sign_extended_from(self, nbytes) -> bool
 |      Does the high part of the operand consist of the sign bytes?
 |      
 |      @param nbytes: (C++: int) number of bytes that were sign extended. the remaining size-
 |                     nbytes high bytes must be sign bytes Example:
 |                     is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3
 |                     bytes are certainly sign bits
 |  
 |  is_stkaddr(self, *args) -> 'bool'
 |      is_stkaddr(self) -> bool
 |      Is address of a stack variable?
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |  
 |  is_undef_val(self, *args) -> 'bool'
 |      is_undef_val(self) -> bool
 |  
 |  is_zero(self, *args) -> 'bool'
 |      is_zero(self) -> bool
 |  
 |  is_zero_extended_from(self, *args) -> 'bool'
 |      is_zero_extended_from(self, nbytes) -> bool
 |      Does the high part of the operand consist of zero bytes?
 |      
 |      @param nbytes: (C++: int) number of bytes that were zero extended. the remaining size-
 |                     nbytes high bytes must be zero Example:
 |                     is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6
 |                     bytes are certainly zero
 |  
 |  lexcompare(self, *args) -> 'int'
 |      lexcompare(self, rop) -> int
 |      
 |      @param rop: mop_t const &
 |  
 |  make_blkref(self, *args) -> 'void'
 |      make_blkref(self, blknum)
 |      Create a global variable operand.
 |      
 |      @param blknum: (C++: int)
 |  
 |  make_first_half(self, *args) -> 'bool'
 |      make_first_half(self, width) -> bool
 |      Make the first part of the operand. This function does not care about the memory
 |      endianness
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_fpnum(self, *args) -> 'bool'
 |      make_fpnum(self, bytes) -> bool
 |      Create a floating point constant operand.
 |      
 |      @param bytes: (C++: const void *) pointer to the floating point value as used by the current
 |                    processor (e.g. for x86 it must be in IEEE 754)
 |      @return: success
 |  
 |  make_gvar(self, *args) -> 'void'
 |      make_gvar(self, ea)
 |      Create a global variable operand.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  make_helper(self, *args) -> 'void'
 |      make_helper(self, name)
 |      Create a helper operand. A helper operand usually keeps a built-in function name
 |      like "va_start" It is essentially just an arbitrary identifier without any
 |      additional info.
 |      
 |      @param name: (C++: const char *) char const *
 |  
 |  make_high_half(self, *args) -> 'bool'
 |      make_high_half(self, width) -> bool
 |      Make the high part of the operand. This function takes into account the memory
 |      endianness (byte sex)
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_insn(self, *args) -> 'void'
 |      make_insn(self, ins)
 |      Create a nested instruction.
 |      
 |      @param ins: (C++: minsn_t *)
 |  
 |  make_low_half(self, *args) -> 'bool'
 |      make_low_half(self, width) -> bool
 |      Make the low part of the operand. This function takes into account the memory
 |      endianness (byte sex)
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_number(self, *args) -> 'void'
 |      make_number(self, _value, _size, _ea=BADADDR, opnum=0)
 |      Create an integer constant operand.
 |      
 |      @param _value: (C++: uint64) value to store in the operand
 |      @param _size: (C++: int) size of the value in bytes (1,2,4,8)
 |      @param _ea: (C++: ea_t) address of the processor instruction that made the value
 |      @param opnum: (C++: int) operand number of the processor instruction
 |  
 |  make_reg(self, *args) -> 'void'
 |      make_reg(self, reg)
 |      
 |      @param reg: mreg_t
 |      
 |      make_reg(self, reg, _size)
 |      
 |      @param reg: mreg_t
 |      @param _size: int
 |  
 |  make_reg_pair(self, *args) -> 'void'
 |      make_reg_pair(self, loreg, hireg, halfsize)
 |      Create pair of registers.
 |      
 |      @param loreg: (C++: int) register holding the low part of the value
 |      @param hireg: (C++: int) register holding the high part of the value
 |      @param halfsize: (C++: int) the size of each of loreg/hireg
 |  
 |  make_second_half(self, *args) -> 'bool'
 |      make_second_half(self, width) -> bool
 |      Make the second part of the operand. This function does not care about the
 |      memory endianness
 |      
 |      @param width: (C++: int) the desired size of the operand part in bytes
 |      @return: success
 |  
 |  make_stkvar(self, *args) -> 'void'
 |      make_stkvar(self, mba, off)
 |      
 |      @param mba: mba_t *
 |      @param off: sval_t
 |  
 |  may_use_aliased_memory(self, *args) -> 'bool'
 |      may_use_aliased_memory(self) -> bool
 |      Is it possible for the operand to use aliased memory?
 |  
 |  preserve_side_effects(self, *args) -> 'bool'
 |      preserve_side_effects(self, blk, top, moved_calls=None) -> bool
 |      Move subinstructions with side effects out of the operand. If we decide to
 |      delete an instruction operand, it is a good idea to call this function.
 |      Alternatively we should skip such operands by calling mop_t::has_side_effects()
 |      For example, if we transform: jnz x, x, @blk => goto @blk then we must call this
 |      function before deleting the X operands.
 |      
 |      @param blk: (C++: mblock_t *) current block
 |      @param top: (C++: minsn_t *) top level instruction that contains our operand
 |      @param moved_calls: (C++: bool *) pointer to the boolean that will track if all side effects
 |                          get handled correctly. must be false initially.
 |      @return: false failed to preserve a side effect, it is not safe to delete the
 |               operand true no side effects or successfully preserved them
 |  
 |  probably_floating(self, *args) -> 'bool'
 |      probably_floating(self) -> bool
 |  
 |  replace_by(self, o)
 |  
 |  set_impptr_done(self, *args) -> 'void'
 |      set_impptr_done(self)
 |  
 |  set_lowaddr(self, *args) -> 'void'
 |      set_lowaddr(self)
 |  
 |  set_udt(self, *args) -> 'void'
 |      set_udt(self)
 |  
 |  set_undef_val(self, *args) -> 'void'
 |      set_undef_val(self)
 |  
 |  shift_mop(self, *args) -> 'bool'
 |      shift_mop(self, offset) -> bool
 |      Shift the operand. This function shifts only the beginning of the operand. The
 |      operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2
 |      shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) ->
 |      #0.4 shift_mop(#0x12345678.4, 3) -> #12.1
 |      
 |      @param offset: (C++: int) shift count (the number of bytes to shift)
 |      @return: success
 |  
 |  signed_value(self, *args) -> 'int64'
 |      signed_value(self) -> int64
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, rop)
 |      
 |      @param rop: mop_t &
 |  
 |  unsigned_value(self, *args) -> 'uint64'
 |      unsigned_value(self) -> uint64
 |  
 |  update_numop_value(self, *args) -> 'void'
 |      update_numop_value(self, val)
 |      
 |      @param val: uint64
 |  
 |  value(self, *args) -> 'uint64'
 |      value(self, is_signed) -> uint64
 |      Retrieve value of a constant integer operand. These functions can be called only
 |      for mop_n operands. See is_constant() that can be called on any operand.
 |      
 |      @param is_signed: (C++: bool)
 |  
 |  zero(self, *args) -> 'void'
 |      zero(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a
 |  
 |  b
 |  
 |  c
 |  
 |  cstr
 |  
 |  d
 |  
 |  f
 |  
 |  fpc
 |  
 |  g
 |  
 |  helper
 |  
 |  l
 |  
 |  meminfo
 |  
 |  nnn
 |  
 |  obj_id
 |      _obj_id(self) -> PyObject *
 |  
 |  oprops
 |      oprops
 |  
 |  pair
 |  
 |  r
 |  
 |  s
 |  
 |  scif
 |  
 |  size
 |      size
 |  
 |  t
 |      _get_t(self) -> mopt_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  valnum
 |      valnum
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class mop_visitor_t in module ida_hexrays:

class mop_visitor_t(op_parent_info_t)
 |  Proxy of C++ mop_visitor_t class.
 |  
 |  Method resolution order:
 |      mop_visitor_t
 |      op_parent_info_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> mop_visitor_t
 |      
 |      @param _mba: mba_t *
 |      @param _blk: mblock_t *
 |      @param _topins: minsn_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_mop_visitor_t(...)
 |      delete_mop_visitor_t(self)
 |  
 |  visit_mop(self, *args) -> 'int'
 |      visit_mop(self, op, type, is_target) -> int
 |      
 |      @param op: mop_t *
 |      @param type: tinfo_t const *
 |      @param is_target: bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  prune
 |      prune
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from op_parent_info_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      blk
 |  
 |  curins
 |      curins
 |  
 |  mba
 |      mba
 |  
 |  topins
 |      topins

Help on class mopvec_t in module ida_hexrays:

class mopvec_t(builtins.object)
 |  Proxy of C++ qvector< mop_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< mop_t > const &
 |  
 |  __getitem__(self, *args) -> 'mop_t const &'
 |      __getitem__(self, i) -> mop_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> mopvec_t
 |      __init__(self, x) -> mopvec_t
 |      
 |      @param x: qvector< mop_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< mop_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: mop_t const &
 |  
 |  __swig_destroy__ = delete_mopvec_t(...)
 |      delete_mopvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: mop_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: mop_t const &
 |  
 |  at(self, *args) -> 'mop_t const &'
 |      at(self, _idx) -> mop_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< mop_t >::const_iterator'
 |      begin(self) -> mop_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< mop_t >::const_iterator'
 |      end(self) -> mop_t
 |  
 |  erase(self, *args) -> 'qvector< mop_t >::iterator'
 |      erase(self, it) -> mop_t
 |      
 |      @param it: qvector< mop_t >::iterator
 |      
 |      erase(self, first, last) -> mop_t
 |      
 |      @param first: qvector< mop_t >::iterator
 |      @param last: qvector< mop_t >::iterator
 |  
 |  extract(self, *args) -> 'mop_t *'
 |      extract(self) -> mop_t
 |  
 |  find(self, *args) -> 'qvector< mop_t >::const_iterator'
 |      find(self, x) -> mop_t
 |      
 |      @param x: mop_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=mop_t())
 |      
 |      @param x: mop_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: mop_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: mop_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< mop_t >::iterator'
 |      insert(self, it, x) -> mop_t
 |      
 |      @param it: qvector< mop_t >::iterator
 |      @param x: mop_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'mop_t &'
 |      push_back(self, x)
 |      
 |      @param x: mop_t const &
 |      
 |      push_back(self) -> mop_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: mop_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< mop_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function mreg2reg in module ida_hexrays:

mreg2reg(*args) -> 'int'
    mreg2reg(reg, width) -> int
    Map a microregister to a processor register.
    
    @param reg: (C++: mreg_t) microregister number
    @param width: (C++: int) size of microregister in bytes
    @return: processor register id or -1

Help on function must_mcode_close_block in module ida_hexrays:

must_mcode_close_block(*args) -> 'bool'
    must_mcode_close_block(mcode, including_calls) -> bool
    Must an instruction with the given opcode be the last one in a block? Such
    opcodes are called closing opcodes.
    
    @param mcode: (C++: mcode_t) instruction opcode
    @param including_calls: (C++: bool) should m_call/m_icall be considered as the closing
                            opcodes? If this function returns true, the opcode
                            cannot appear in the middle of a block. Calls are a
                            special case: unknown calls (is_unknown_call) are
                            considered as closing opcodes.

Help on function negate_mcode_relation in module ida_hexrays:

negate_mcode_relation(*args) -> 'mcode_t'
    negate_mcode_relation(code) -> mcode_t
    
    @param code: enum mcode_t

Help on function negated_relation in module ida_hexrays:

negated_relation(*args) -> 'ctype_t'
    negated_relation(op) -> ctype_t
    Negate a comparison operator. For example, cot_sge becomes cot_slt.
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function new_block in module ida_hexrays:

new_block()
    Create a new block-statement.

Help on class number_format_t in module ida_hexrays:

class number_format_t(builtins.object)
 |  Proxy of C++ number_format_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _opnum=0) -> number_format_t
 |      
 |      @param _opnum: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_number_format_t(...)
 |      delete_number_format_t(self)
 |  
 |  get_radix(self, *args) -> 'int'
 |      get_radix(self) -> int
 |      Get number radix
 |      
 |      @return: 2,8,10, or 16
 |  
 |  has_unmutable_type(self, *args) -> 'bool'
 |      has_unmutable_type(self) -> bool
 |  
 |  is_char(self, *args) -> 'bool'
 |      is_char(self) -> bool
 |      Is a character constant?
 |  
 |  is_dec(self, *args) -> 'bool'
 |      is_dec(self) -> bool
 |      Is a decimal number?
 |  
 |  is_enum(self, *args) -> 'bool'
 |      is_enum(self) -> bool
 |      Is a symbolic constant?
 |  
 |  is_fixed(self, *args) -> 'bool'
 |      is_fixed(self) -> bool
 |      Is number representation fixed? Fixed representation cannot be modified by the
 |      decompiler
 |  
 |  is_hex(self, *args) -> 'bool'
 |      is_hex(self) -> bool
 |      Is a hexadecimal number?
 |  
 |  is_numop(self, *args) -> 'bool'
 |      is_numop(self) -> bool
 |      Is a number?
 |  
 |  is_oct(self, *args) -> 'bool'
 |      is_oct(self) -> bool
 |      Is a octal number?
 |  
 |  is_stroff(self, *args) -> 'bool'
 |      is_stroff(self) -> bool
 |      Is a structure field offset?
 |  
 |  needs_to_be_inverted(self, *args) -> 'bool'
 |      needs_to_be_inverted(self) -> bool
 |      Does the number need to be negated or bitwise negated? Returns true if the user
 |      requested a negation but it is not done yet
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      flags
 |  
 |  opnum
 |      opnum
 |  
 |  org_nbytes
 |      org_nbytes
 |  
 |  props
 |      props
 |  
 |  serial
 |      serial
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_name
 |      type_name

Help on class op_parent_info_t in module ida_hexrays:

class op_parent_info_t(builtins.object)
 |  Proxy of C++ op_parent_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba=None, _blk=None, _topins=None) -> op_parent_info_t
 |      
 |      @param _mba: mba_t *
 |      @param _blk: mblock_t *
 |      @param _topins: minsn_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_op_parent_info_t(...)
 |      delete_op_parent_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  blk
 |      blk
 |  
 |  curins
 |      curins
 |  
 |  mba
 |      mba
 |  
 |  thisown
 |      The membership flag
 |  
 |  topins
 |      topins

Help on function op_uses_x in module ida_hexrays:

op_uses_x(*args) -> 'bool'
    op_uses_x(op) -> bool
    Does operator use the 'x' field of cexpr_t?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function op_uses_y in module ida_hexrays:

op_uses_y(*args) -> 'bool'
    op_uses_y(op) -> bool
    Does operator use the 'y' field of cexpr_t?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function op_uses_z in module ida_hexrays:

op_uses_z(*args) -> 'bool'
    op_uses_z(op) -> bool
    Does operator use the 'z' field of cexpr_t?
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function open_pseudocode in module ida_hexrays:

open_pseudocode(*args) -> 'vdui_t *'
    open_pseudocode(ea, flags) -> vdui_t
    Open pseudocode window. The specified function is decompiled and the pseudocode
    window is opened.
    
    @param ea: (C++: ea_t) function to decompile
    @param flags: (C++: int) a combination of OPF_ flags
    @return: false if failed

Help on class operand_locator_t in module ida_hexrays:

class operand_locator_t(builtins.object)
 |  Proxy of C++ operand_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: operand_locator_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: operand_locator_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: operand_locator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea, _opnum) -> operand_locator_t
 |      
 |      @param _ea: ea_t
 |      @param _opnum: int
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: operand_locator_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: operand_locator_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: operand_locator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_operand_locator_t(...)
 |      delete_operand_locator_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: operand_locator_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  opnum
 |      opnum
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class optblock_t in module ida_hexrays:

class optblock_t(builtins.object)
 |  Proxy of C++ optblock_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> optblock_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_optblock_t(...)
 |      delete_optblock_t(self)
 |  
 |  func(self, *args) -> 'int'
 |      func(self, blk) -> int
 |      Optimize a block. This function usually performs the optimizations that require
 |      analyzing the entire block and/or its neighbors. For example it can recognize
 |      patterns and perform conversions like: b0: b0: ... ... jnz x, 0, @b2 => jnz x,
 |      0, @b2 b1: b1: add x, 0, y mov x, y ... ...
 |      
 |      @param blk: (C++: mblock_t *) Basic block to optimize as a whole.
 |      @return: number of changes made to the block. See also mark_lists_dirty.
 |  
 |  install(self, *args) -> 'void'
 |      install(self)
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class optinsn_t in module ida_hexrays:

class optinsn_t(builtins.object)
 |  Proxy of C++ optinsn_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> optinsn_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_optinsn_t(...)
 |      delete_optinsn_t(self)
 |  
 |  func(self, *args) -> 'int'
 |      func(self, blk, ins, optflags) -> int
 |      Optimize an instruction.
 |      
 |      @param blk: (C++: mblock_t *) current basic block. maybe nullptr, which means that the instruction
 |                  must be optimized without context
 |      @param ins: (C++: minsn_t *) instruction to optimize; it is always a top-level instruction. the
 |                  callback may not delete the instruction but may convert it into nop
 |                  (see mblock_t::make_nop). to optimize sub-instructions, visit them
 |                  using minsn_visitor_t. sub-instructions may not be converted into
 |                  nop but can be converted to "mov x,x". for example: add x,0,x => mov
 |                  x,x this callback may change other instructions in the block, but
 |                  should do this with care, e.g. to no break the propagation algorithm
 |                  if called with OPTI_NO_LDXOPT.
 |      @param optflags: (C++: int) combination of optimization flags bits
 |      @return: number of changes made to the instruction. if after this call the
 |               instruction's use/def lists have changed, you must mark the block level
 |               lists as dirty (see mark_lists_dirty)
 |  
 |  install(self, *args) -> 'void'
 |      install(self)
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function parse_user_call in module ida_hexrays:

parse_user_call(*args) -> 'bool'
    parse_user_call(udc, decl, silent) -> bool
    Convert function type declaration into internal structure
    
    @param udc: (C++: udcall_t *) - pointer to output structure
    @param decl: (C++: const char *) - function type declaration
    @param silent: (C++: bool) - if TRUE: do not show warning in case of incorrect type
    @return: success

Help on function partial_type_num in module ida_hexrays:

partial_type_num(*args) -> 'int'
    partial_type_num(type) -> int
    Calculate number of partial subtypes.
    
    @param type: (C++: const tinfo_t &) tinfo_t const &
    @return: number of partial subtypes. The bigger is this number, the uglier is
             the type.

Help on function print_vdloc in module ida_hexrays:

print_vdloc(*args) -> 'qstring *'
    print_vdloc(loc, nbytes) -> str
    Print vdloc. Since vdloc does not always carry the size info, we pass it as
    NBYTES..
    
    @param loc: (C++: const vdloc_t &) vdloc_t const &
    @param nbytes: (C++: int)

Help on function property_op_to_typename in module ida_hexrays:

property_op_to_typename(self)

Help on class qstring_printer_t in module ida_hexrays:

class qstring_printer_t(vc_printer_t)
 |  Proxy of C++ qstring_printer_t class.
 |  
 |  Method resolution order:
 |      qstring_printer_t
 |      vc_printer_t
 |      vd_printer_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, f, tags) -> qstring_printer_t
 |      
 |      @param f: cfunc_t const *
 |      @param tags: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, indent, format) -> int
 |      
 |      Parameters
 |      ----------
 |      indent: int
 |      format: char const *
 |  
 |  get_s(self, *args) -> 'qstring'
 |      get_s(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  s
 |  
 |  thisown
 |      The membership flag
 |  
 |  with_tags
 |      with_tags
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vc_printer_t:
 |  
 |  __disown__(self)
 |  
 |  __swig_destroy__ = delete_vc_printer_t(...)
 |      delete_vc_printer_t(self)
 |  
 |  oneliner(self, *args) -> 'bool'
 |      oneliner(self) -> bool
 |      Are we generating one-line text representation?
 |      
 |      @return: true if the output will occupy one line without line breaks
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vc_printer_t:
 |  
 |  func
 |      func
 |  
 |  lastchar
 |      lastchar
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_printer_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      hdrlines
 |  
 |  tmpbuf
 |      tmpbuf

Help on function qswap in module ida_hexrays:

qswap(*args) -> 'void'
    qswap(a, b)
    
    @param a: cinsn_t &
    @param b: cinsn_t &

Help on class qvector_carg_t in module ida_hexrays:

class qvector_carg_t(builtins.object)
 |  Proxy of C++ qvector< carg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< carg_t > const &
 |  
 |  __getitem__(self, *args) -> 'carg_t const &'
 |      __getitem__(self, i) -> carg_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_carg_t
 |      __init__(self, x) -> qvector_carg_t
 |      
 |      @param x: qvector< carg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< carg_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: carg_t const &
 |  
 |  __swig_destroy__ = delete_qvector_carg_t(...)
 |      delete_qvector_carg_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: carg_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: carg_t const &
 |  
 |  append = push_back(self, *args) -> 'carg_t &'
 |  
 |  at = __getitem__(self, *args) -> 'carg_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      begin(self) -> carg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      end(self) -> carg_t
 |  
 |  erase(self, *args) -> 'qvector< carg_t >::iterator'
 |      erase(self, it) -> carg_t
 |      
 |      @param it: qvector< carg_t >::iterator
 |      
 |      erase(self, first, last) -> carg_t
 |      
 |      @param first: qvector< carg_t >::iterator
 |      @param last: qvector< carg_t >::iterator
 |  
 |  extract(self, *args) -> 'carg_t *'
 |      extract(self) -> carg_t
 |  
 |  find(self, *args) -> 'qvector< carg_t >::const_iterator'
 |      find(self, x) -> carg_t
 |      
 |      @param x: carg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=carg_t())
 |      
 |      @param x: carg_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: carg_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: carg_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< carg_t >::iterator'
 |      insert(self, it, x) -> carg_t
 |      
 |      @param it: qvector< carg_t >::iterator
 |      @param x: carg_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'carg_t &'
 |      push_back(self, x)
 |      
 |      @param x: carg_t const &
 |      
 |      push_back(self) -> carg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: carg_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< carg_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qvector_ccase_t in module ida_hexrays:

class qvector_ccase_t(builtins.object)
 |  Proxy of C++ qvector< ccase_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< ccase_t > const &
 |  
 |  __getitem__(self, *args) -> 'ccase_t const &'
 |      __getitem__(self, i) -> ccase_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_ccase_t
 |      __init__(self, x) -> qvector_ccase_t
 |      
 |      @param x: qvector< ccase_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< ccase_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: ccase_t const &
 |  
 |  __swig_destroy__ = delete_qvector_ccase_t(...)
 |      delete_qvector_ccase_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: ccase_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: ccase_t const &
 |  
 |  append = push_back(self, *args) -> 'ccase_t &'
 |  
 |  at = __getitem__(self, *args) -> 'ccase_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      begin(self) -> ccase_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      end(self) -> ccase_t
 |  
 |  erase(self, *args) -> 'qvector< ccase_t >::iterator'
 |      erase(self, it) -> ccase_t
 |      
 |      @param it: qvector< ccase_t >::iterator
 |      
 |      erase(self, first, last) -> ccase_t
 |      
 |      @param first: qvector< ccase_t >::iterator
 |      @param last: qvector< ccase_t >::iterator
 |  
 |  extract(self, *args) -> 'ccase_t *'
 |      extract(self) -> ccase_t
 |  
 |  find(self, *args) -> 'qvector< ccase_t >::const_iterator'
 |      find(self, x) -> ccase_t
 |      
 |      @param x: ccase_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ccase_t())
 |      
 |      @param x: ccase_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: ccase_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: ccase_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< ccase_t >::iterator'
 |      insert(self, it, x) -> ccase_t
 |      
 |      @param it: qvector< ccase_t >::iterator
 |      @param x: ccase_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ccase_t &'
 |      push_back(self, x)
 |      
 |      @param x: ccase_t const &
 |      
 |      push_back(self) -> ccase_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: ccase_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< ccase_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qvector_history_t in module ida_hexrays:

class qvector_history_t(builtins.object)
 |  Proxy of C++ qvector< history_item_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< history_item_t > const &
 |  
 |  __getitem__(self, *args) -> 'history_item_t const &'
 |      __getitem__(self, i) -> history_item_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_history_t
 |      __init__(self, x) -> qvector_history_t
 |      
 |      @param x: qvector< history_item_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< history_item_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: history_item_t const &
 |  
 |  __swig_destroy__ = delete_qvector_history_t(...)
 |      delete_qvector_history_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: history_item_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: history_item_t const &
 |  
 |  at(self, *args) -> 'history_item_t const &'
 |      at(self, _idx) -> history_item_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      begin(self) -> history_item_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      end(self) -> history_item_t
 |  
 |  erase(self, *args) -> 'qvector< history_item_t >::iterator'
 |      erase(self, it) -> history_item_t
 |      
 |      @param it: qvector< history_item_t >::iterator
 |      
 |      erase(self, first, last) -> history_item_t
 |      
 |      @param first: qvector< history_item_t >::iterator
 |      @param last: qvector< history_item_t >::iterator
 |  
 |  extract(self, *args) -> 'history_item_t *'
 |      extract(self) -> history_item_t
 |  
 |  find(self, *args) -> 'qvector< history_item_t >::const_iterator'
 |      find(self, x) -> history_item_t
 |      
 |      @param x: history_item_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=history_item_t())
 |      
 |      @param x: history_item_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: history_item_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: history_item_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< history_item_t >::iterator'
 |      insert(self, it, x) -> history_item_t
 |      
 |      @param it: qvector< history_item_t >::iterator
 |      @param x: history_item_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'history_item_t &'
 |      push_back(self, x)
 |      
 |      @param x: history_item_t const &
 |      
 |      push_back(self) -> history_item_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: history_item_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< history_item_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class qvector_lvar_t in module ida_hexrays:

class qvector_lvar_t(builtins.object)
 |  Proxy of C++ qvector< lvar_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< lvar_t > const &
 |  
 |  __getitem__(self, *args) -> 'lvar_t const &'
 |      __getitem__(self, i) -> lvar_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_lvar_t
 |      __init__(self, x) -> qvector_lvar_t
 |      
 |      @param x: qvector< lvar_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< lvar_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: lvar_t const &
 |  
 |  __swig_destroy__ = delete_qvector_lvar_t(...)
 |      delete_qvector_lvar_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: lvar_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: lvar_t const &
 |  
 |  append = push_back(self, *args) -> 'lvar_t &'
 |  
 |  at = __getitem__(self, *args) -> 'lvar_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      begin(self) -> lvar_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      end(self) -> lvar_t
 |  
 |  erase(self, *args) -> 'qvector< lvar_t >::iterator'
 |      erase(self, it) -> lvar_t
 |      
 |      @param it: qvector< lvar_t >::iterator
 |      
 |      erase(self, first, last) -> lvar_t
 |      
 |      @param first: qvector< lvar_t >::iterator
 |      @param last: qvector< lvar_t >::iterator
 |  
 |  extract(self, *args) -> 'lvar_t *'
 |      extract(self) -> lvar_t
 |  
 |  find(self, *args) -> 'qvector< lvar_t >::const_iterator'
 |      find(self, x) -> lvar_t
 |      
 |      @param x: lvar_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=lvar_t())
 |      
 |      @param x: lvar_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: lvar_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: lvar_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< lvar_t >::iterator'
 |      insert(self, it, x) -> lvar_t
 |      
 |      @param it: qvector< lvar_t >::iterator
 |      @param x: lvar_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'lvar_t &'
 |      push_back(self, x)
 |      
 |      @param x: lvar_t const &
 |      
 |      push_back(self) -> lvar_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: lvar_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< lvar_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function reg2mreg in module ida_hexrays:

reg2mreg(*args) -> 'mreg_t'
    reg2mreg(reg) -> mreg_t
    Map a processor register to a microregister.
    
    @param reg: (C++: int) processor register number
    @return: microregister register id or mr_none

Help on function remitem in module ida_hexrays:

remitem(*args) -> 'void'
    remitem(e)
    
    @param e: citem_t const *

Help on function remove_hexrays_callback in module ida_hexrays:

remove_hexrays_callback(callback)
    Deprecated. Please use Hexrays_Hooks instead
    Uninstall handler for decompiler events.
    
    @return: number of uninstalled handlers.

Help on function rename_lvar in module ida_hexrays:

rename_lvar(*args) -> 'bool'
    rename_lvar(func_ea, oldname, newname) -> bool
    Rename a local variable.
    
    @param func_ea: (C++: ea_t) function start address
    @param oldname: (C++: const char *) old name of the variable
    @param newname: (C++: const char *) new name of the variable
    @return: success This is a convenience function. For bulk renaming consider
             using modify_user_lvars.

Help on function restore_user_cmts in module ida_hexrays:

restore_user_cmts(*args) -> 'user_cmts_t *'
    restore_user_cmts(func_ea) -> user_cmts_t
    Restore user defined comments from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of user defined comments. The returned object must be
             deleted by the caller using delete_user_cmts()

Help on function restore_user_defined_calls in module ida_hexrays:

restore_user_defined_calls(*args) -> 'bool'
    restore_user_defined_calls(udcalls, func_ea) -> bool
    Restore user defined function calls from the database.
    
    @param udcalls: (C++: udcall_map_t *) ptr to output buffer
    @param func_ea: (C++: ea_t) entry address of the function
    @return: success

Help on function restore_user_iflags in module ida_hexrays:

restore_user_iflags(*args) -> 'user_iflags_t *'
    restore_user_iflags(func_ea) -> user_iflags_t
    Restore user defined citem iflags from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of user defined iflags. The returned object must be deleted
             by the caller using delete_user_iflags()

Help on function restore_user_labels in module ida_hexrays:

restore_user_labels(*args) -> 'user_labels_t *'
    restore_user_labels(func_ea) -> user_labels_t
    Restore user defined labels from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function, ignored if FUNC != nullptr
    @return: collection of user defined labels. The returned object must be deleted
             by the caller using delete_user_labels()

Help on function restore_user_labels2 in module ida_hexrays:

restore_user_labels2(*args) -> 'user_labels_t *'
    restore_user_labels2(func_ea, func=None) -> user_labels_t
    
    @param func_ea: ea_t
    @param func: cfunc_t const *

Help on function restore_user_lvar_settings in module ida_hexrays:

restore_user_lvar_settings(*args) -> 'bool'
    restore_user_lvar_settings(lvinf, func_ea) -> bool
    Restore user defined local variable settings in the database.
    
    @param lvinf: (C++: lvar_uservec_t *) ptr to output buffer
    @param func_ea: (C++: ea_t) entry address of the function
    @return: success

Help on function restore_user_numforms in module ida_hexrays:

restore_user_numforms(*args) -> 'user_numforms_t *'
    restore_user_numforms(func_ea) -> user_numforms_t
    Restore user defined number formats from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of user defined number formats. The returned object must be
             deleted by the caller using delete_user_numforms()

Help on function restore_user_unions in module ida_hexrays:

restore_user_unions(*args) -> 'user_unions_t *'
    restore_user_unions(func_ea) -> user_unions_t
    Restore user defined union field selections from the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @return: collection of union field selections The returned object must be
             deleted by the caller using delete_user_unions()

Help on class rlist_t in module ida_hexrays:

class rlist_t(bitset_t)
 |  Proxy of C++ rlist_t class.
 |  
 |  Method resolution order:
 |      rlist_t
 |      bitset_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rlist_t
 |      __init__(self, m) -> rlist_t
 |      
 |      @param m: rlist_t const &
 |      
 |      __init__(self, reg, width) -> rlist_t
 |      
 |      @param reg: mreg_t
 |      @param width: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rlist_t(...)
 |      delete_rlist_t(self)
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from bitset_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __len__ = count(self, *args) -> 'int'
 |      count(self) -> int
 |      count(self, bit) -> int
 |      
 |      @param bit: int
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: bitset_t const &
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, bit) -> bool
 |      
 |      @param bit: int
 |      
 |      add(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |      
 |      add(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  back(self, *args) -> 'int'
 |      back(self) -> int
 |  
 |  begin(self, *args) -> 'bitset_t::iterator'
 |      begin(self) -> iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: bitset_t const &
 |  
 |  copy(self, *args) -> 'bitset_t &'
 |      copy(self, m) -> bitset_t
 |      
 |      @param m: bitset_t const &
 |  
 |  count(self, *args) -> 'int'
 |      count(self) -> int
 |      count(self, bit) -> int
 |      
 |      @param bit: int
 |  
 |  cut_at(self, *args) -> 'bool'
 |      cut_at(self, maxbit) -> bool
 |      
 |      @param maxbit: int
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'bitset_t::iterator'
 |      end(self) -> iterator
 |  
 |  fill_with_ones(self, *args) -> 'void'
 |      fill_with_ones(self, maxbit)
 |      
 |      @param maxbit: int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, bit) -> bool
 |      
 |      @param bit: int
 |  
 |  has_all(self, *args) -> 'bool'
 |      has_all(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |  
 |  has_any(self, *args) -> 'bool'
 |      has_any(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, p, n=1)
 |      
 |      @param p: bitset_t::iterator &
 |      @param n: int
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  itat(self, *args) -> 'bitset_t::iterator'
 |      itat(self, n) -> iterator
 |      
 |      @param n: int
 |  
 |  itv(self, *args) -> 'int'
 |      itv(self, it) -> int
 |      
 |      @param it: bitset_t::const_iterator
 |  
 |  last(self, *args) -> 'int'
 |      last(self) -> int
 |  
 |  shift_down(self, *args) -> 'void'
 |      shift_down(self, shift)
 |      
 |      @param shift: int
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, bit) -> bool
 |      
 |      @param bit: int
 |      
 |      sub(self, bit, width) -> bool
 |      
 |      @param bit: int
 |      @param width: int
 |      
 |      sub(self, ml) -> bool
 |      
 |      @param ml: bitset_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: bitset_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from bitset_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from bitset_t:
 |  
 |  __hash__ = None

Help on function save_user_cmts in module ida_hexrays:

save_user_cmts(*args) -> 'void'
    save_user_cmts(func_ea, user_cmts)
    Save user defined comments into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param user_cmts: (C++: const user_cmts_t *) collection of user defined comments

Help on function save_user_defined_calls in module ida_hexrays:

save_user_defined_calls(*args) -> 'void'
    save_user_defined_calls(func_ea, udcalls)
    Save user defined local function calls into the database.
    
    @param func_ea: (C++: ea_t) entry address of the function
    @param udcalls: (C++: const udcall_map_t &) user-specified info about user defined function calls

Help on function save_user_iflags in module ida_hexrays:

save_user_iflags(*args) -> 'void'
    save_user_iflags(func_ea, iflags)
    Save user defined citem iflags into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param iflags: (C++: const user_iflags_t *) collection of user defined citem iflags

Help on function save_user_labels in module ida_hexrays:

save_user_labels(*args) -> 'void'
    save_user_labels(func_ea, user_labels)
    Save user defined labels into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function, ignored if FUNC != nullptr
    @param user_labels: (C++: const user_labels_t *) collection of user defined labels

Help on function save_user_labels2 in module ida_hexrays:

save_user_labels2(*args) -> 'void'
    save_user_labels2(func_ea, user_labels, func=None)
    
    @param func_ea: ea_t
    @param user_labels: user_labels_t const *
    @param func: cfunc_t const *

Help on function save_user_lvar_settings in module ida_hexrays:

save_user_lvar_settings(*args) -> 'void'
    save_user_lvar_settings(func_ea, lvinf)
    Save user defined local variable settings into the database.
    
    @param func_ea: (C++: ea_t) entry address of the function
    @param lvinf: (C++: const lvar_uservec_t &) user-specified info about local variables

Help on function save_user_numforms in module ida_hexrays:

save_user_numforms(*args) -> 'void'
    save_user_numforms(func_ea, numforms)
    Save user defined number formats into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param numforms: (C++: const user_numforms_t *) collection of user defined comments

Help on function save_user_unions in module ida_hexrays:

save_user_unions(*args) -> 'void'
    save_user_unions(func_ea, unions)
    Save user defined union field selections into the database.
    
    @param func_ea: (C++: ea_t) the entry address of the function
    @param unions: (C++: const user_unions_t *) collection of union field selections

Help on class scif_t in module ida_hexrays:

class scif_t(vdloc_t)
 |  Proxy of C++ scif_t class.
 |  
 |  Method resolution order:
 |      scif_t
 |      vdloc_t
 |      ida_typeinf.argloc_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _mba, tif, n=None) -> scif_t
 |      
 |      @param _mba: mba_t *
 |      @param tif: tinfo_t *
 |      @param n: qstring *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scif_t(...)
 |      delete_scif_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  mba
 |      mba
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vdloc_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, r1)
 |      
 |      Parameters
 |      ----------
 |      r1: int
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: vdloc_t const &
 |  
 |  is_aliasable(self, *args) -> 'bool'
 |      is_aliasable(self, mb, size) -> bool
 |      
 |      @param mb: mba_t const *
 |      @param size: int
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, r1)
 |      
 |      @param r1: int
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from vdloc_t:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_typeinf.argloc_t:
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: rrel_t *
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: scattered_aloc_t *
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      data: argloc_t::biggest_t
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      pdata: void *
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |      
 |      Parameters
 |      ----------
 |      _ea: ea_t
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |      
 |      Parameters
 |      ----------
 |      _reg1: int
 |      _reg2: int
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |      
 |      Parameters
 |      ----------
 |      off: sval_t
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |      Move the location to point 'delta' bytes further.
 |      
 |      @param delta: (C++: int)
 |  
 |  align_reg_high(self, *args) -> 'void'
 |      align_reg_high(self, size, _slotsize)
 |      Set register offset to align it to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  align_stkoff_high(self, *args) -> 'void'
 |      align_stkoff_high(self, size, _slotsize)
 |      Set stack offset to align to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |      Get type (Argument location types)
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |      Set register-relative location - can't be nullptr.
 |      
 |      @param p: (C++: rrel_t *)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |      Set distributed argument location.
 |      
 |      @param p: (C++: scattered_aloc_t *) scattered_aloc_t const &
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |      Get custom argloc info. Use if atype() == ALOC_CUSTOM
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |      Get the global address. Use when atype() == ALOC_STATIC
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |      Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      Get register-relative info. Use when atype() == ALOC_RREL
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |      TRUE if argloc has a stack part.
 |  
 |  in_stack(self, *args) -> 'bool'
 |      in_stack(self) -> bool
 |      TRUE if argloc is in stack entirely.
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |      See ALOC_NONE.
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |      See ALOC_CUSTOM.
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |      See ALOC_STATIC.
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |      is_scattered() || is_reg2()
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg1() || is_reg2()
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |      See ALOC_REG1.
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |      See ALOC_REG2.
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |      See ALOC_RREL.
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      See ALOC_DIST.
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |      See ALOC_STACK.
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |      Get info for the second register. Use when atype() == ALOC_REG2
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |      Get offset from the beginning of the register in bytes. Use when atype() ==
 |      ALOC_REG1
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      Get scattered argument info. Use when atype() == ALOC_DIST
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |      Set static ea location.
 |      
 |      @param _ea: (C++: ea_t)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |      Set secondary register location.
 |      
 |      @param _reg1: (C++: int)
 |      @param _reg2: (C++: int)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |      Set stack offset location.
 |      
 |      @param off: (C++: sval_t)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |      Get the stack offset. Use if atype() == ALOC_STACK
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Assign this == r and r == this.
 |      
 |      @param r: (C++: argloc_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_typeinf.argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class scif_visitor_t in module ida_hexrays:

class scif_visitor_t(builtins.object)
 |  Proxy of C++ scif_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scif_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scif_visitor_t(...)
 |      delete_scif_visitor_t(self)
 |  
 |  visit_scif_mop(self, *args) -> 'int'
 |      visit_scif_mop(self, r, off) -> int
 |      
 |      @param r: mop_t const &
 |      @param off: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function select_udt_by_offset in module ida_hexrays:

select_udt_by_offset(*args) -> 'int'
    select_udt_by_offset(udts, ops, applicator) -> int
    Select UDT
    
    @param udts: (C++: const qvector< tinfo_t > *) list of UDT tinfo_t for the selection, if nullptr or empty then
                 UDTs from the "Local types" will be used
    @param ops: (C++: const ui_stroff_ops_t &) operands
    @param applicator: (C++: ui_stroff_applicator_t &) callback will be called to apply the selection for every
                       operand

Help on function send_database in module ida_hexrays:

send_database(*args) -> 'void'
    send_database(err, silent)
    Send the database to Hex-Rays. This function sends the current database to the
    Hex-Rays server. The database is sent in the compressed form over an encrypted
    (SSL) connection.
    
    @param err: (C++: const hexrays_failure_t &) failure description object. Empty hexrays_failure_t object can be
                used if error information is not available.
    @param silent: (C++: bool) if false, a dialog box will be displayed before sending the
                   database.

Help on function set2jcnd in module ida_hexrays:

set2jcnd(*args) -> 'mcode_t'
    set2jcnd(code) -> mcode_t
    
    @param code: enum mcode_t

Help on function set_type in module ida_hexrays:

set_type(*args) -> 'bool'
    set_type(id, tif, source, force=False) -> bool
    Set a global type.
    
    @param id: (C++: uval_t) address or id of the object
    @param tif: (C++: const tinfo_t &) new type info
    @param source: (C++: type_source_t) where the type comes from
    @param force: (C++: bool) true means to set the type as is, false means to merge the new
                  type with the possibly existing old type info.
    @return: success

Help on class simple_graph_t in module ida_hexrays:

class simple_graph_t(ida_gdl.gdl_graph_t)
 |  Proxy of C++ simple_graph_t class.
 |  
 |  Method resolution order:
 |      simple_graph_t
 |      ida_gdl.gdl_graph_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      __init__(self) -> gdl_graph_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  colored_gdl_edges
 |      colored_gdl_edges
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      title
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_gdl.gdl_graph_t:
 |  
 |  __disown__(self)
 |  
 |  __swig_destroy__ = delete_gdl_graph_t(...)
 |      delete_gdl_graph_t(self)
 |  
 |  begin(self, *args) -> 'node_iterator'
 |      begin(self) -> node_iterator
 |  
 |  edge(self, *args) -> 'int'
 |      edge(self, node, i, ispred) -> int
 |      
 |      @param node: int
 |      @param i: int
 |      @param ispred: bool
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'node_iterator'
 |      end(self) -> node_iterator
 |  
 |  entry(self, *args) -> 'int'
 |      entry(self) -> int
 |  
 |  exists(self, *args) -> 'bool'
 |      exists(self, node) -> bool
 |      
 |      @param node: int
 |  
 |  exit(self, *args) -> 'int'
 |      exit(self) -> int
 |  
 |  front(self, *args) -> 'int'
 |      front(self) -> int
 |  
 |  get_edge_color(self, *args) -> 'bgcolor_t'
 |      get_edge_color(self, i, j) -> bgcolor_t
 |      
 |      @param i: int
 |      @param j: int
 |  
 |  get_node_color(self, *args) -> 'bgcolor_t'
 |      get_node_color(self, n) -> bgcolor_t
 |      
 |      @param n: int
 |  
 |  get_node_label(self, *args) -> 'char *'
 |      get_node_label(self, n) -> char *
 |      
 |      @param n: int
 |  
 |  nedge(self, *args) -> 'size_t'
 |      nedge(self, node, ispred) -> size_t
 |      
 |      @param node: int
 |      @param ispred: bool
 |  
 |  node_qty(self, *args) -> 'int'
 |      node_qty(self) -> int
 |  
 |  npred(self, *args) -> 'int'
 |      npred(self, node) -> int
 |      
 |      @param node: int
 |  
 |  nsucc(self, *args) -> 'int'
 |      nsucc(self, node) -> int
 |      
 |      @param node: int
 |  
 |  pred(self, *args) -> 'int'
 |      pred(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  print_edge(self, *args) -> 'bool'
 |      print_edge(self, fp, i, j) -> bool
 |      
 |      @param fp: FILE *
 |      @param i: int
 |      @param j: int
 |  
 |  print_graph_attributes(self, *args) -> 'void'
 |      print_graph_attributes(self, fp)
 |      
 |      @param fp: FILE *
 |  
 |  print_node(self, *args) -> 'bool'
 |      print_node(self, fp, n) -> bool
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  print_node_attributes(self, *args) -> 'void'
 |      print_node_attributes(self, fp, n)
 |      
 |      @param fp: FILE *
 |      @param n: int
 |  
 |  size(self, *args) -> 'int'
 |      size(self) -> int
 |  
 |  succ(self, *args) -> 'int'
 |      succ(self, node, i) -> int
 |      
 |      @param node: int
 |      @param i: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_gdl.gdl_graph_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class stkvar_ref_t in module ida_hexrays:

class stkvar_ref_t(builtins.object)
 |  Proxy of C++ stkvar_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, m, o) -> stkvar_ref_t
 |      
 |      @param m: mba_t *
 |      @param o: sval_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkvar_ref_t(...)
 |      delete_stkvar_ref_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: stkvar_ref_t const &
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, p_off=None) -> member_t *
 |      Retrieve the referenced stack variable.
 |      
 |      @param p_off: (C++: uval_t *) if specified, will hold IDA stkoff after the call.
 |      @return: pointer to the stack variable
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: stkvar_ref_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  mba
 |      mba
 |  
 |  off
 |      off
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function swap_mcode_relation in module ida_hexrays:

swap_mcode_relation(*args) -> 'mcode_t'
    swap_mcode_relation(code) -> mcode_t
    
    @param code: enum mcode_t

Help on function swapped_relation in module ida_hexrays:

swapped_relation(*args) -> 'ctype_t'
    swapped_relation(op) -> ctype_t
    Swap a comparison operator. For example, cot_sge becomes cot_sle.
    
    @param op: (C++: ctype_t) enum ctype_t

Help on function term_hexrays_plugin in module ida_hexrays:

term_hexrays_plugin(*args) -> 'void'
    term_hexrays_plugin()
    Stop working with hex-rays decompiler.

Help on class treeloc_t in module ida_hexrays:

class treeloc_t(builtins.object)
 |  Proxy of C++ treeloc_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: treeloc_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> treeloc_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: treeloc_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_treeloc_t(...)
 |      delete_treeloc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  itp
 |      itp
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class udc_filter_t in module ida_hexrays:

class udc_filter_t(microcode_filter_t)
 |  Proxy of C++ udc_filter_t class.
 |  
 |  Method resolution order:
 |      udc_filter_t
 |      microcode_filter_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udc_filter_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udc_filter_t(...)
 |      delete_udc_filter_t(self)
 |  
 |  apply(self, *args) -> 'merror_t'
 |      apply(self, cdg) -> merror_t
 |      generate microcode for an instruction
 |      
 |      @param cdg: (C++: codegen_t &)
 |      @return: MERR_... code: MERR_OK - user-defined microcode generated, go to the
 |               next instruction MERR_INSN - not generated - the caller should try the
 |               standard way else - error
 |  
 |  cleanup(self, *args) -> 'void'
 |      cleanup(self)
 |      Cleanup the filter This function properly clears type information associated to
 |      this filter.
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  init(self, *args) -> 'bool'
 |      init(self, decl) -> bool
 |      
 |      @param decl: char const *
 |  
 |  install(self, *args) -> 'void'
 |      install(self)
 |  
 |  match(self, *args) -> 'bool'
 |      match(self, cdg) -> bool
 |      return true if the filter object should be applied to given instruction
 |      
 |      @param cdg: (C++: codegen_t &)
 |  
 |  remove(self, *args) -> 'bool'
 |      remove(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from microcode_filter_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function udcall_map_begin in module ida_hexrays:

udcall_map_begin(*args) -> 'udcall_map_iterator_t'
    udcall_map_begin(map) -> udcall_map_iterator_t
    Get iterator pointing to the beginning of udcall_map_t.
    
    @param map: (C++: const udcall_map_t *) udcall_map_t const *

Help on function udcall_map_clear in module ida_hexrays:

udcall_map_clear(*args) -> 'void'
    udcall_map_clear(map)
    Clear udcall_map_t.
    
    @param map: (C++: udcall_map_t *)

Help on function udcall_map_end in module ida_hexrays:

udcall_map_end(*args) -> 'udcall_map_iterator_t'
    udcall_map_end(map) -> udcall_map_iterator_t
    Get iterator pointing to the end of udcall_map_t.
    
    @param map: (C++: const udcall_map_t *) udcall_map_t const *

Help on function udcall_map_erase in module ida_hexrays:

udcall_map_erase(*args) -> 'void'
    udcall_map_erase(map, p)
    Erase current element from udcall_map_t.
    
    @param map: (C++: udcall_map_t *)
    @param p: (C++: udcall_map_iterator_t)

Help on function udcall_map_find in module ida_hexrays:

udcall_map_find(*args) -> 'udcall_map_iterator_t'
    udcall_map_find(map, key) -> udcall_map_iterator_t
    Find the specified key in udcall_map_t.
    
    @param map: (C++: const udcall_map_t *) udcall_map_t const *
    @param key: (C++: const ea_t &) ea_t const &

Help on function udcall_map_first in module ida_hexrays:

udcall_map_first(*args) -> 'ea_t const &'
    udcall_map_first(p) -> ea_t const &
    Get reference to the current map key.
    
    @param p: (C++: udcall_map_iterator_t)

Help on function udcall_map_free in module ida_hexrays:

udcall_map_free(*args) -> 'void'
    udcall_map_free(map)
    Delete udcall_map_t instance.
    
    @param map: (C++: udcall_map_t *)

Help on function udcall_map_insert in module ida_hexrays:

udcall_map_insert(*args) -> 'udcall_map_iterator_t'
    udcall_map_insert(map, key, val) -> udcall_map_iterator_t
    Insert new (ea_t, udcall_t) pair into udcall_map_t.
    
    @param map: (C++: udcall_map_t *)
    @param key: (C++: const ea_t &) ea_t const &
    @param val: (C++: const udcall_t &) udcall_t const &

Help on class udcall_map_iterator_t in module ida_hexrays:

class udcall_map_iterator_t(builtins.object)
 |  Proxy of C++ udcall_map_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: udcall_map_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udcall_map_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: udcall_map_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udcall_map_iterator_t(...)
 |      delete_udcall_map_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function udcall_map_new in module ida_hexrays:

udcall_map_new(*args) -> 'udcall_map_t *'
    udcall_map_new() -> udcall_map_t *
    Create a new udcall_map_t instance.

Help on function udcall_map_next in module ida_hexrays:

udcall_map_next(*args) -> 'udcall_map_iterator_t'
    udcall_map_next(p) -> udcall_map_iterator_t
    Move to the next element.
    
    @param p: (C++: udcall_map_iterator_t)

Help on function udcall_map_prev in module ida_hexrays:

udcall_map_prev(*args) -> 'udcall_map_iterator_t'
    udcall_map_prev(p) -> udcall_map_iterator_t
    Move to the previous element.
    
    @param p: (C++: udcall_map_iterator_t)

Help on function udcall_map_second in module ida_hexrays:

udcall_map_second(*args) -> 'udcall_t &'
    udcall_map_second(p) -> udcall_t
    Get reference to the current map value.
    
    @param p: (C++: udcall_map_iterator_t)

Help on function udcall_map_size in module ida_hexrays:

udcall_map_size(*args) -> 'size_t'
    udcall_map_size(map) -> size_t
    Get size of udcall_map_t.
    
    @param map: (C++: udcall_map_t *)

Help on class udcall_t in module ida_hexrays:

class udcall_t(builtins.object)
 |  Proxy of C++ udcall_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: udcall_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: udcall_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: udcall_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udcall_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: udcall_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: udcall_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: udcall_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udcall_t(...)
 |      delete_udcall_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: udcall_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      tif
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ui_stroff_applicator_t in module ida_hexrays:

class ui_stroff_applicator_t(builtins.object)
 |  Proxy of C++ ui_stroff_applicator_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_applicator_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ui_stroff_applicator_t(...)
 |      delete_ui_stroff_applicator_t(self)
 |  
 |  apply(self, *args) -> 'bool'
 |      apply(self, opnum, path, top_tif, spath) -> bool
 |      
 |      @param opnum: (C++: size_t) operand ordinal number, see below
 |      @param path: (C++: const intvec_t &) path describing the union selection, maybe empty
 |      @param top_tif: (C++: const tinfo_t &) tinfo_t of the selected toplevel UDT
 |      @param spath: (C++: const char *) selected path
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class ui_stroff_op_t in module ida_hexrays:

class ui_stroff_op_t(builtins.object)
 |  Proxy of C++ ui_stroff_op_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ui_stroff_op_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_op_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ui_stroff_op_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ui_stroff_op_t(...)
 |      delete_ui_stroff_op_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  offset
 |      offset
 |  
 |  text
 |      text
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class ui_stroff_ops_t in module ida_hexrays:

class ui_stroff_ops_t(builtins.object)
 |  Proxy of C++ qvector< ui_stroff_op_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< ui_stroff_op_t > const &
 |  
 |  __getitem__(self, *args) -> 'ui_stroff_op_t const &'
 |      __getitem__(self, i) -> ui_stroff_op_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_stroff_ops_t
 |      __init__(self, x) -> ui_stroff_ops_t
 |      
 |      @param x: qvector< ui_stroff_op_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< ui_stroff_op_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: ui_stroff_op_t const &
 |  
 |  __swig_destroy__ = delete_ui_stroff_ops_t(...)
 |      delete_ui_stroff_ops_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: ui_stroff_op_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: ui_stroff_op_t const &
 |  
 |  append = push_back(self, *args) -> 'ui_stroff_op_t &'
 |  
 |  at = __getitem__(self, *args) -> 'ui_stroff_op_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator'
 |      begin(self) -> ui_stroff_op_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator'
 |      end(self) -> ui_stroff_op_t
 |  
 |  erase(self, *args) -> 'qvector< ui_stroff_op_t >::iterator'
 |      erase(self, it) -> ui_stroff_op_t
 |      
 |      @param it: qvector< ui_stroff_op_t >::iterator
 |      
 |      erase(self, first, last) -> ui_stroff_op_t
 |      
 |      @param first: qvector< ui_stroff_op_t >::iterator
 |      @param last: qvector< ui_stroff_op_t >::iterator
 |  
 |  extract(self, *args) -> 'ui_stroff_op_t *'
 |      extract(self) -> ui_stroff_op_t
 |  
 |  find(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator'
 |      find(self, x) -> ui_stroff_op_t
 |      
 |      @param x: ui_stroff_op_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ui_stroff_op_t())
 |      
 |      @param x: ui_stroff_op_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: ui_stroff_op_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: ui_stroff_op_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< ui_stroff_op_t >::iterator'
 |      insert(self, it, x) -> ui_stroff_op_t
 |      
 |      @param it: qvector< ui_stroff_op_t >::iterator
 |      @param x: ui_stroff_op_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ui_stroff_op_t &'
 |      push_back(self, x)
 |      
 |      @param x: ui_stroff_op_t const &
 |      
 |      push_back(self) -> ui_stroff_op_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: ui_stroff_op_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< ui_stroff_op_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_cmts_begin in module ida_hexrays:

user_cmts_begin(*args) -> 'user_cmts_iterator_t'
    user_cmts_begin(map) -> user_cmts_iterator_t
    Get iterator pointing to the beginning of user_cmts_t.
    
    @param map: (C++: const user_cmts_t *) user_cmts_t const *

Help on function user_cmts_clear in module ida_hexrays:

user_cmts_clear(*args) -> 'void'
    user_cmts_clear(map)
    Clear user_cmts_t.
    
    @param map: (C++: user_cmts_t *)

Help on function user_cmts_end in module ida_hexrays:

user_cmts_end(*args) -> 'user_cmts_iterator_t'
    user_cmts_end(map) -> user_cmts_iterator_t
    Get iterator pointing to the end of user_cmts_t.
    
    @param map: (C++: const user_cmts_t *) user_cmts_t const *

Help on function user_cmts_erase in module ida_hexrays:

user_cmts_erase(*args) -> 'void'
    user_cmts_erase(map, p)
    Erase current element from user_cmts_t.
    
    @param map: (C++: user_cmts_t *)
    @param p: (C++: user_cmts_iterator_t)

Help on function user_cmts_find in module ida_hexrays:

user_cmts_find(*args) -> 'user_cmts_iterator_t'
    user_cmts_find(map, key) -> user_cmts_iterator_t
    Find the specified key in user_cmts_t.
    
    @param map: (C++: const user_cmts_t *) user_cmts_t const *
    @param key: (C++: const treeloc_t &) treeloc_t const &

Help on function user_cmts_first in module ida_hexrays:

user_cmts_first(*args) -> 'treeloc_t const &'
    user_cmts_first(p) -> treeloc_t
    Get reference to the current map key.
    
    @param p: (C++: user_cmts_iterator_t)

Help on function user_cmts_free in module ida_hexrays:

user_cmts_free(*args) -> 'void'
    user_cmts_free(map)
    Delete user_cmts_t instance.
    
    @param map: (C++: user_cmts_t *)

Help on function user_cmts_insert in module ida_hexrays:

user_cmts_insert(*args) -> 'user_cmts_iterator_t'
    user_cmts_insert(map, key, val) -> user_cmts_iterator_t
    Insert new (treeloc_t, citem_cmt_t) pair into user_cmts_t.
    
    @param map: (C++: user_cmts_t *)
    @param key: (C++: const treeloc_t &) treeloc_t const &
    @param val: (C++: const citem_cmt_t &) citem_cmt_t const &

Help on class user_cmts_iterator_t in module ida_hexrays:

class user_cmts_iterator_t(builtins.object)
 |  Proxy of C++ user_cmts_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: user_cmts_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_cmts_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: user_cmts_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_cmts_iterator_t(...)
 |      delete_user_cmts_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_cmts_new in module ida_hexrays:

user_cmts_new(*args) -> 'user_cmts_t *'
    user_cmts_new() -> user_cmts_t
    Create a new user_cmts_t instance.

Help on function user_cmts_next in module ida_hexrays:

user_cmts_next(*args) -> 'user_cmts_iterator_t'
    user_cmts_next(p) -> user_cmts_iterator_t
    Move to the next element.
    
    @param p: (C++: user_cmts_iterator_t)

Help on function user_cmts_prev in module ida_hexrays:

user_cmts_prev(*args) -> 'user_cmts_iterator_t'
    user_cmts_prev(p) -> user_cmts_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_cmts_iterator_t)

Help on function user_cmts_second in module ida_hexrays:

user_cmts_second(*args) -> 'citem_cmt_t &'
    user_cmts_second(p) -> citem_cmt_t
    Get reference to the current map value.
    
    @param p: (C++: user_cmts_iterator_t)

Help on function user_cmts_size in module ida_hexrays:

user_cmts_size(*args) -> 'size_t'
    user_cmts_size(map) -> size_t
    Get size of user_cmts_t.
    
    @param map: (C++: user_cmts_t *)

Help on class user_cmts_t in module ida_hexrays:

class user_cmts_t(builtins.object)
 |  Proxy of C++ std::map< treeloc_t,citem_cmt_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_cmts_begin(...)
 |      user_cmts_begin(map) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t const *
 |  
 |  __clear = user_cmts_clear(...)
 |      user_cmts_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_cmts_end(...)
 |      user_cmts_end(map) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t const *
 |  
 |  __erase = user_cmts_erase(...)
 |      user_cmts_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |      p: user_cmts_iterator_t
 |  
 |  __find = user_cmts_find(...)
 |      user_cmts_find(map, key) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t const *
 |      key: treeloc_t const &
 |  
 |  __first = user_cmts_first(...)
 |      user_cmts_first(p) -> treeloc_t
 |      
 |      Parameters
 |      ----------
 |      p: user_cmts_iterator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_cmts_t
 |  
 |  __insert = user_cmts_insert(...)
 |      user_cmts_insert(map, key, val) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |      key: treeloc_t const &
 |      val: citem_cmt_t const &
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_cmts_next(...)
 |      user_cmts_next(p) -> user_cmts_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_cmts_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_cmts_second(...)
 |      user_cmts_second(p) -> citem_cmt_t
 |      
 |      Parameters
 |      ----------
 |      p: user_cmts_iterator_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_cmts_size(...)
 |      user_cmts_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_cmts_t *
 |  
 |  __swig_destroy__ = delete_user_cmts_t(...)
 |      delete_user_cmts_t(self)
 |  
 |  at(self, *args) -> 'citem_cmt_t &'
 |      at(self, _Keyval) -> citem_cmt_t
 |      
 |      @param _Keyval: treeloc_t const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.treeloc_t'>
 |      Proxy of C++ treeloc_t class.
 |  
 |  valuetype = <class 'ida_hexrays.citem_cmt_t'>
 |      Proxy of C++ citem_cmt_t class.

Help on function user_iflags_begin in module ida_hexrays:

user_iflags_begin(*args) -> 'user_iflags_iterator_t'
    user_iflags_begin(map) -> user_iflags_iterator_t
    Get iterator pointing to the beginning of user_iflags_t.
    
    @param map: (C++: const user_iflags_t *) user_iflags_t const *

Help on function user_iflags_clear in module ida_hexrays:

user_iflags_clear(*args) -> 'void'
    user_iflags_clear(map)
    Clear user_iflags_t.
    
    @param map: (C++: user_iflags_t *)

Help on function user_iflags_end in module ida_hexrays:

user_iflags_end(*args) -> 'user_iflags_iterator_t'
    user_iflags_end(map) -> user_iflags_iterator_t
    Get iterator pointing to the end of user_iflags_t.
    
    @param map: (C++: const user_iflags_t *) user_iflags_t const *

Help on function user_iflags_erase in module ida_hexrays:

user_iflags_erase(*args) -> 'void'
    user_iflags_erase(map, p)
    Erase current element from user_iflags_t.
    
    @param map: (C++: user_iflags_t *)
    @param p: (C++: user_iflags_iterator_t)

Help on function user_iflags_find in module ida_hexrays:

user_iflags_find(*args) -> 'user_iflags_iterator_t'
    user_iflags_find(map, key) -> user_iflags_iterator_t
    Find the specified key in user_iflags_t.
    
    @param map: (C++: const user_iflags_t *) user_iflags_t const *
    @param key: (C++: const citem_locator_t &) citem_locator_t const &

Help on function user_iflags_first in module ida_hexrays:

user_iflags_first(*args) -> 'citem_locator_t const &'
    user_iflags_first(p) -> citem_locator_t
    Get reference to the current map key.
    
    @param p: (C++: user_iflags_iterator_t)

Help on function user_iflags_free in module ida_hexrays:

user_iflags_free(*args) -> 'void'
    user_iflags_free(map)
    Delete user_iflags_t instance.
    
    @param map: (C++: user_iflags_t *)

Help on function user_iflags_insert in module ida_hexrays:

user_iflags_insert(*args) -> 'user_iflags_iterator_t'
    user_iflags_insert(map, key, val) -> user_iflags_iterator_t
    Insert new (citem_locator_t, int32) pair into user_iflags_t.
    
    @param map: (C++: user_iflags_t *)
    @param key: (C++: const citem_locator_t &) citem_locator_t const &
    @param val: (C++: const int32 &) int32 const &

Help on class user_iflags_iterator_t in module ida_hexrays:

class user_iflags_iterator_t(builtins.object)
 |  Proxy of C++ user_iflags_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: user_iflags_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_iflags_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: user_iflags_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_iflags_iterator_t(...)
 |      delete_user_iflags_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_iflags_new in module ida_hexrays:

user_iflags_new(*args) -> 'user_iflags_t *'
    user_iflags_new() -> user_iflags_t
    Create a new user_iflags_t instance.

Help on function user_iflags_next in module ida_hexrays:

user_iflags_next(*args) -> 'user_iflags_iterator_t'
    user_iflags_next(p) -> user_iflags_iterator_t
    Move to the next element.
    
    @param p: (C++: user_iflags_iterator_t)

Help on function user_iflags_prev in module ida_hexrays:

user_iflags_prev(*args) -> 'user_iflags_iterator_t'
    user_iflags_prev(p) -> user_iflags_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_iflags_iterator_t)

Help on function user_iflags_second in module ida_hexrays:

user_iflags_second(*args) -> 'int32 const &'
    user_iflags_second(p) -> int32 const &
    Get reference to the current map value.
    
    @param p: (C++: user_iflags_iterator_t)

Help on function user_iflags_size in module ida_hexrays:

user_iflags_size(*args) -> 'size_t'
    user_iflags_size(map) -> size_t
    Get size of user_iflags_t.
    
    @param map: (C++: user_iflags_t *)

Help on class user_iflags_t in module ida_hexrays:

class user_iflags_t(builtins.object)
 |  Proxy of C++ std::map< citem_locator_t,int32 > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_iflags_begin(...)
 |      user_iflags_begin(map) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t const *
 |  
 |  __clear = user_iflags_clear(...)
 |      user_iflags_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_iflags_end(...)
 |      user_iflags_end(map) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t const *
 |  
 |  __erase = user_iflags_erase(...)
 |      user_iflags_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |      p: user_iflags_iterator_t
 |  
 |  __find = user_iflags_find(...)
 |      user_iflags_find(map, key) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t const *
 |      key: citem_locator_t const &
 |  
 |  __first = user_iflags_first(...)
 |      user_iflags_first(p) -> citem_locator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_iflags_iterator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_iflags_t
 |  
 |  __insert = user_iflags_insert(...)
 |      user_iflags_insert(map, key, val) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |      key: citem_locator_t const &
 |      val: int32 const &
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_iflags_next(...)
 |      user_iflags_next(p) -> user_iflags_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_iflags_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_iflags_second(...)
 |      user_iflags_second(p) -> int32 const &
 |      
 |      Parameters
 |      ----------
 |      p: user_iflags_iterator_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_iflags_size(...)
 |      user_iflags_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_iflags_t *
 |  
 |  __swig_destroy__ = delete_user_iflags_t(...)
 |      delete_user_iflags_t(self)
 |  
 |  at(self, *args) -> 'int &'
 |      at(self, _Keyval) -> int &
 |      
 |      @param _Keyval: citem_locator_t const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.citem_locator_t'>
 |      Proxy of C++ citem_locator_t class.
 |  
 |  valuetype = <class 'int'>
 |      int(x=0) -> integer
 |      int(x, base=10) -> integer
 |      
 |      Convert a number or string to an integer, or return 0 if no arguments
 |      are given.  If x is a number, return x.__int__().  For floating point
 |      numbers, this truncates towards zero.
 |      
 |      If x is not a number or if base is given, then x must be a string,
 |      bytes, or bytearray instance representing an integer literal in the
 |      given base.  The literal can be preceded by '+' or '-' and be surrounded
 |      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
 |      Base 0 means to interpret the base from the string as an integer literal.
 |      >>> int('0b100', base=0)
 |      4

Help on function user_labels_begin in module ida_hexrays:

user_labels_begin(*args) -> 'user_labels_iterator_t'
    user_labels_begin(map) -> user_labels_iterator_t
    Get iterator pointing to the beginning of user_labels_t.
    
    @param map: (C++: const user_labels_t *) user_labels_t const *

Help on function user_labels_clear in module ida_hexrays:

user_labels_clear(*args) -> 'void'
    user_labels_clear(map)
    Clear user_labels_t.
    
    @param map: (C++: user_labels_t *)

Help on function user_labels_end in module ida_hexrays:

user_labels_end(*args) -> 'user_labels_iterator_t'
    user_labels_end(map) -> user_labels_iterator_t
    Get iterator pointing to the end of user_labels_t.
    
    @param map: (C++: const user_labels_t *) user_labels_t const *

Help on function user_labels_erase in module ida_hexrays:

user_labels_erase(*args) -> 'void'
    user_labels_erase(map, p)
    Erase current element from user_labels_t.
    
    @param map: (C++: user_labels_t *)
    @param p: (C++: user_labels_iterator_t)

Help on function user_labels_find in module ida_hexrays:

user_labels_find(*args) -> 'user_labels_iterator_t'
    user_labels_find(map, key) -> user_labels_iterator_t
    Find the specified key in user_labels_t.
    
    @param map: (C++: const user_labels_t *) user_labels_t const *
    @param key: (C++: const int &) int const &

Help on function user_labels_first in module ida_hexrays:

user_labels_first(*args) -> 'int const &'
    user_labels_first(p) -> int const &
    Get reference to the current map key.
    
    @param p: (C++: user_labels_iterator_t)

Help on function user_labels_free in module ida_hexrays:

user_labels_free(*args) -> 'void'
    user_labels_free(map)
    Delete user_labels_t instance.
    
    @param map: (C++: user_labels_t *)

Help on function user_labels_insert in module ida_hexrays:

user_labels_insert(*args) -> 'user_labels_iterator_t'
    user_labels_insert(map, key, val) -> user_labels_iterator_t
    Insert new (int, qstring) pair into user_labels_t.
    
    @param map: (C++: user_labels_t *)
    @param key: (C++: const int &) int const &
    @param val: (C++: const qstring &) qstring const &

Help on class user_labels_iterator_t in module ida_hexrays:

class user_labels_iterator_t(builtins.object)
 |  Proxy of C++ user_labels_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: user_labels_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_labels_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: user_labels_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_labels_iterator_t(...)
 |      delete_user_labels_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_labels_new in module ida_hexrays:

user_labels_new(*args) -> 'user_labels_t *'
    user_labels_new() -> user_labels_t
    Create a new user_labels_t instance.

Help on function user_labels_next in module ida_hexrays:

user_labels_next(*args) -> 'user_labels_iterator_t'
    user_labels_next(p) -> user_labels_iterator_t
    Move to the next element.
    
    @param p: (C++: user_labels_iterator_t)

Help on function user_labels_prev in module ida_hexrays:

user_labels_prev(*args) -> 'user_labels_iterator_t'
    user_labels_prev(p) -> user_labels_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_labels_iterator_t)

Help on function user_labels_second in module ida_hexrays:

user_labels_second(*args) -> 'qstring &'
    user_labels_second(p) -> qstring &
    Get reference to the current map value.
    
    @param p: (C++: user_labels_iterator_t)

Help on function user_labels_size in module ida_hexrays:

user_labels_size(*args) -> 'size_t'
    user_labels_size(map) -> size_t
    Get size of user_labels_t.
    
    @param map: (C++: user_labels_t *)

Help on class user_labels_t in module ida_hexrays:

class user_labels_t(builtins.object)
 |  Proxy of C++ std::map< int,qstring > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_labels_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_labels_t(...)
 |      delete_user_labels_t(self)
 |  
 |  at(self, *args) -> '_qstring< char > &'
 |      at(self, _Keyval) -> _qstring< char > &
 |      
 |      @param _Keyval: int const &
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class user_lvar_modifier_t in module ida_hexrays:

class user_lvar_modifier_t(builtins.object)
 |  Proxy of C++ user_lvar_modifier_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_lvar_modifier_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_lvar_modifier_t(...)
 |      delete_user_lvar_modifier_t(self)
 |  
 |  modify_lvars(self, *args) -> 'bool'
 |      modify_lvars(self, lvinf) -> bool
 |      Modify lvar settings. Returns: true-modified
 |      
 |      @param lvinf: (C++: lvar_uservec_t *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function user_numforms_begin in module ida_hexrays:

user_numforms_begin(*args) -> 'user_numforms_iterator_t'
    user_numforms_begin(map) -> user_numforms_iterator_t
    Get iterator pointing to the beginning of user_numforms_t.
    
    @param map: (C++: const user_numforms_t *) user_numforms_t const *

Help on function user_numforms_clear in module ida_hexrays:

user_numforms_clear(*args) -> 'void'
    user_numforms_clear(map)
    Clear user_numforms_t.
    
    @param map: (C++: user_numforms_t *)

Help on function user_numforms_end in module ida_hexrays:

user_numforms_end(*args) -> 'user_numforms_iterator_t'
    user_numforms_end(map) -> user_numforms_iterator_t
    Get iterator pointing to the end of user_numforms_t.
    
    @param map: (C++: const user_numforms_t *) user_numforms_t const *

Help on function user_numforms_erase in module ida_hexrays:

user_numforms_erase(*args) -> 'void'
    user_numforms_erase(map, p)
    Erase current element from user_numforms_t.
    
    @param map: (C++: user_numforms_t *)
    @param p: (C++: user_numforms_iterator_t)

Help on function user_numforms_find in module ida_hexrays:

user_numforms_find(*args) -> 'user_numforms_iterator_t'
    user_numforms_find(map, key) -> user_numforms_iterator_t
    Find the specified key in user_numforms_t.
    
    @param map: (C++: const user_numforms_t *) user_numforms_t const *
    @param key: (C++: const operand_locator_t &) operand_locator_t const &

Help on function user_numforms_first in module ida_hexrays:

user_numforms_first(*args) -> 'operand_locator_t const &'
    user_numforms_first(p) -> operand_locator_t
    Get reference to the current map key.
    
    @param p: (C++: user_numforms_iterator_t)

Help on function user_numforms_free in module ida_hexrays:

user_numforms_free(*args) -> 'void'
    user_numforms_free(map)
    Delete user_numforms_t instance.
    
    @param map: (C++: user_numforms_t *)

Help on function user_numforms_insert in module ida_hexrays:

user_numforms_insert(*args) -> 'user_numforms_iterator_t'
    user_numforms_insert(map, key, val) -> user_numforms_iterator_t
    Insert new (operand_locator_t, number_format_t) pair into user_numforms_t.
    
    @param map: (C++: user_numforms_t *)
    @param key: (C++: const operand_locator_t &) operand_locator_t const &
    @param val: (C++: const number_format_t &) number_format_t const &

Help on class user_numforms_iterator_t in module ida_hexrays:

class user_numforms_iterator_t(builtins.object)
 |  Proxy of C++ user_numforms_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: user_numforms_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_numforms_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: user_numforms_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_numforms_iterator_t(...)
 |      delete_user_numforms_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_numforms_new in module ida_hexrays:

user_numforms_new(*args) -> 'user_numforms_t *'
    user_numforms_new() -> user_numforms_t
    Create a new user_numforms_t instance.

Help on function user_numforms_next in module ida_hexrays:

user_numforms_next(*args) -> 'user_numforms_iterator_t'
    user_numforms_next(p) -> user_numforms_iterator_t
    Move to the next element.
    
    @param p: (C++: user_numforms_iterator_t)

Help on function user_numforms_prev in module ida_hexrays:

user_numforms_prev(*args) -> 'user_numforms_iterator_t'
    user_numforms_prev(p) -> user_numforms_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_numforms_iterator_t)

Help on function user_numforms_second in module ida_hexrays:

user_numforms_second(*args) -> 'number_format_t &'
    user_numforms_second(p) -> number_format_t
    Get reference to the current map value.
    
    @param p: (C++: user_numforms_iterator_t)

Help on function user_numforms_size in module ida_hexrays:

user_numforms_size(*args) -> 'size_t'
    user_numforms_size(map) -> size_t
    Get size of user_numforms_t.
    
    @param map: (C++: user_numforms_t *)

Help on class user_numforms_t in module ida_hexrays:

class user_numforms_t(builtins.object)
 |  Proxy of C++ std::map< operand_locator_t,number_format_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_numforms_begin(...)
 |      user_numforms_begin(map) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t const *
 |  
 |  __clear = user_numforms_clear(...)
 |      user_numforms_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_numforms_end(...)
 |      user_numforms_end(map) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t const *
 |  
 |  __erase = user_numforms_erase(...)
 |      user_numforms_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |      p: user_numforms_iterator_t
 |  
 |  __find = user_numforms_find(...)
 |      user_numforms_find(map, key) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t const *
 |      key: operand_locator_t const &
 |  
 |  __first = user_numforms_first(...)
 |      user_numforms_first(p) -> operand_locator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_numforms_iterator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_numforms_t
 |  
 |  __insert = user_numforms_insert(...)
 |      user_numforms_insert(map, key, val) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |      key: operand_locator_t const &
 |      val: number_format_t const &
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_numforms_next(...)
 |      user_numforms_next(p) -> user_numforms_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_numforms_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_numforms_second(...)
 |      user_numforms_second(p) -> number_format_t
 |      
 |      Parameters
 |      ----------
 |      p: user_numforms_iterator_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_numforms_size(...)
 |      user_numforms_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_numforms_t *
 |  
 |  __swig_destroy__ = delete_user_numforms_t(...)
 |      delete_user_numforms_t(self)
 |  
 |  at(self, *args) -> 'number_format_t &'
 |      at(self, _Keyval) -> number_format_t
 |      
 |      @param _Keyval: operand_locator_t const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = <class 'ida_hexrays.operand_locator_t'>
 |      Proxy of C++ operand_locator_t class.
 |  
 |  valuetype = <class 'ida_hexrays.number_format_t'>
 |      Proxy of C++ number_format_t class.

Help on function user_unions_begin in module ida_hexrays:

user_unions_begin(*args) -> 'user_unions_iterator_t'
    user_unions_begin(map) -> user_unions_iterator_t
    Get iterator pointing to the beginning of user_unions_t.
    
    @param map: (C++: const user_unions_t *) user_unions_t const *

Help on function user_unions_clear in module ida_hexrays:

user_unions_clear(*args) -> 'void'
    user_unions_clear(map)
    Clear user_unions_t.
    
    @param map: (C++: user_unions_t *)

Help on function user_unions_end in module ida_hexrays:

user_unions_end(*args) -> 'user_unions_iterator_t'
    user_unions_end(map) -> user_unions_iterator_t
    Get iterator pointing to the end of user_unions_t.
    
    @param map: (C++: const user_unions_t *) user_unions_t const *

Help on function user_unions_erase in module ida_hexrays:

user_unions_erase(*args) -> 'void'
    user_unions_erase(map, p)
    Erase current element from user_unions_t.
    
    @param map: (C++: user_unions_t *)
    @param p: (C++: user_unions_iterator_t)

Help on function user_unions_find in module ida_hexrays:

user_unions_find(*args) -> 'user_unions_iterator_t'
    user_unions_find(map, key) -> user_unions_iterator_t
    Find the specified key in user_unions_t.
    
    @param map: (C++: const user_unions_t *) user_unions_t const *
    @param key: (C++: const ea_t &) ea_t const &

Help on function user_unions_first in module ida_hexrays:

user_unions_first(*args) -> 'ea_t const &'
    user_unions_first(p) -> ea_t const &
    Get reference to the current map key.
    
    @param p: (C++: user_unions_iterator_t)

Help on function user_unions_free in module ida_hexrays:

user_unions_free(*args) -> 'void'
    user_unions_free(map)
    Delete user_unions_t instance.
    
    @param map: (C++: user_unions_t *)

Help on function user_unions_insert in module ida_hexrays:

user_unions_insert(*args) -> 'user_unions_iterator_t'
    user_unions_insert(map, key, val) -> user_unions_iterator_t
    Insert new (ea_t, intvec_t) pair into user_unions_t.
    
    @param map: (C++: user_unions_t *)
    @param key: (C++: const ea_t &) ea_t const &
    @param val: (C++: const intvec_t &) intvec_t const &

Help on class user_unions_iterator_t in module ida_hexrays:

class user_unions_iterator_t(builtins.object)
 |  Proxy of C++ user_unions_iterator_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, p) -> bool
 |      
 |      @param p: user_unions_iterator_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_unions_iterator_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, p) -> bool
 |      
 |      @param p: user_unions_iterator_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_unions_iterator_t(...)
 |      delete_user_unions_iterator_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function user_unions_new in module ida_hexrays:

user_unions_new(*args) -> 'user_unions_t *'
    user_unions_new() -> user_unions_t
    Create a new user_unions_t instance.

Help on function user_unions_next in module ida_hexrays:

user_unions_next(*args) -> 'user_unions_iterator_t'
    user_unions_next(p) -> user_unions_iterator_t
    Move to the next element.
    
    @param p: (C++: user_unions_iterator_t)

Help on function user_unions_prev in module ida_hexrays:

user_unions_prev(*args) -> 'user_unions_iterator_t'
    user_unions_prev(p) -> user_unions_iterator_t
    Move to the previous element.
    
    @param p: (C++: user_unions_iterator_t)

Help on function user_unions_second in module ida_hexrays:

user_unions_second(*args) -> 'intvec_t &'
    user_unions_second(p) -> intvec_t
    Get reference to the current map value.
    
    @param p: (C++: user_unions_iterator_t)

Help on function user_unions_size in module ida_hexrays:

user_unions_size(*args) -> 'size_t'
    user_unions_size(map) -> size_t
    Get size of user_unions_t.
    
    @param map: (C++: user_unions_t *)

Help on class user_unions_t in module ida_hexrays:

class user_unions_t(builtins.object)
 |  Proxy of C++ std::map< ea_t,intvec_t > class.
 |  
 |  Methods defined here:
 |  
 |  __begin = user_unions_begin(...)
 |      user_unions_begin(map) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t const *
 |  
 |  __clear = user_unions_clear(...)
 |      user_unions_clear(map)
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |  
 |  __contains__ = _map___contains__(self, key)
 |      Returns true if the specified key exists in the .
 |  
 |  __delitem__ = _map___delitem__(self, key)
 |      Removes the value associated with the provided key.
 |  
 |  __end = user_unions_end(...)
 |      user_unions_end(map) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t const *
 |  
 |  __erase = user_unions_erase(...)
 |      user_unions_erase(map, p)
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |      p: user_unions_iterator_t
 |  
 |  __find = user_unions_find(...)
 |      user_unions_find(map, key) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t const *
 |      key: ea_t const &
 |  
 |  __first = user_unions_first(...)
 |      user_unions_first(p) -> ea_t const &
 |      
 |      Parameters
 |      ----------
 |      p: user_unions_iterator_t
 |  
 |  __getitem__ = _map___getitem__(self, key)
 |      Returns the value associated with the provided key.
 |  
 |  __init__(self, *args)
 |      __init__(self) -> user_unions_t
 |  
 |  __insert = user_unions_insert(...)
 |      user_unions_insert(map, key, val) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |      key: ea_t const &
 |      val: intvec_t const &
 |  
 |  __iter__ = _map___iter__(self)
 |      Iterate over dictionary keys.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  __next = user_unions_next(...)
 |      user_unions_next(p) -> user_unions_iterator_t
 |      
 |      Parameters
 |      ----------
 |      p: user_unions_iterator_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __second = user_unions_second(...)
 |      user_unions_second(p) -> intvec_t
 |      
 |      Parameters
 |      ----------
 |      p: user_unions_iterator_t
 |  
 |  __setitem__ = _map___setitem__(self, key, value)
 |      Returns the value associated with the provided key.
 |  
 |  __size = user_unions_size(...)
 |      user_unions_size(map) -> size_t
 |      
 |      Parameters
 |      ----------
 |      map: user_unions_t *
 |  
 |  __swig_destroy__ = delete_user_unions_t(...)
 |      delete_user_unions_t(self)
 |  
 |  at(self, *args) -> 'qvector< int > &'
 |      at(self, _Keyval) -> intvec_t
 |      
 |      @param _Keyval: unsigned-ea-like-numeric-type const &
 |  
 |  begin lambda self, *args
 |  
 |  clear = _map_clear(self)
 |  
 |  copy = _map_copy(self)
 |  
 |  end lambda self, *args
 |  
 |  erase lambda self, *args
 |  
 |  find lambda self, *args
 |  
 |  first lambda self, *args
 |  
 |  get = _map_get(self, key, default=None)
 |  
 |  has_key = _map_has_key(self, key)
 |  
 |  insert lambda self, *args
 |  
 |  items = _map_items(self)
 |  
 |  iteritems = _map_iteritems(self)
 |  
 |  iterkeys = _map_iterkeys(self)
 |  
 |  itervalues = _map_itervalues(self)
 |  
 |  keys = _map_keys(self)
 |  
 |  next lambda self, *args
 |  
 |  pop = _map_pop(self, key)
 |      Sets the value associated with the provided key.
 |  
 |  popitem = _map_popitem(self)
 |      Sets the value associated with the provided key.
 |  
 |  second lambda self, *args
 |  
 |  setdefault = _map_setdefault(self, key, default=None)
 |      Sets the value associated with the provided key.
 |  
 |  size lambda self, *args
 |  
 |  values = _map_values(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  keytype = (<class 'int'>,)
 |  
 |  valuetype = <class 'ida_pro.intvec_t'>
 |      Proxy of C++ qvector< int > class.

Help on class uval_ivl_ivlset_t in module ida_hexrays:

class uval_ivl_ivlset_t(builtins.object)
 |  Proxy of C++ ivlset_tpl< ivl_t,uval_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, v) -> bool
 |      
 |      @param v: ivl_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uval_ivl_ivlset_t
 |      __init__(self, ivl) -> uval_ivl_ivlset_t
 |      
 |      @param ivl: ivl_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, v) -> bool
 |      
 |      @param v: ivl_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_uval_ivl_ivlset_t(...)
 |      delete_uval_ivl_ivlset_t(self)
 |  
 |  all_values(self, *args) -> 'bool'
 |      all_values(self) -> bool
 |  
 |  begin(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator
 |      begin(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator'
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::const_iterator
 |      end(self) -> ivlset_tpl< ivl_t,unsigned-ea-like-numeric-type >::iterator
 |  
 |  getivl(self, *args) -> 'ivl_t const &'
 |      getivl(self, idx) -> ivl_t
 |      
 |      @param idx: int
 |  
 |  lastivl(self, *args) -> 'ivl_t const &'
 |      lastivl(self) -> ivl_t
 |  
 |  nivls(self, *args) -> 'size_t'
 |      nivls(self) -> size_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  set_all_values(self, *args) -> 'void'
 |      set_all_values(self)
 |  
 |  single_value(self, *args) -> 'bool'
 |      single_value(self) -> bool
 |      single_value(self, v) -> bool
 |      
 |      @param v: unsigned-ea-like-numeric-type
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: ivlset_tpl< ivl_t,uval_t > &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class uval_ivl_t in module ida_hexrays:

class uval_ivl_t(builtins.object)
 |  Proxy of C++ ivl_tpl< uval_t > class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _off, _size) -> uval_ivl_t
 |      
 |      @param _off: unsigned-ea-like-numeric-type
 |      @param _size: unsigned-ea-like-numeric-type
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_uval_ivl_t(...)
 |      delete_uval_ivl_t(self)
 |  
 |  end(self, *args) -> 'unsigned-ea-like-numeric-type'
 |      end(self) -> unsigned-ea-like-numeric-type
 |  
 |  last(self, *args) -> 'unsigned-ea-like-numeric-type'
 |      last(self) -> unsigned-ea-like-numeric-type
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      off
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag

Help on class valrng_t in module ida_hexrays:

class valrng_t(builtins.object)
 |  Proxy of C++ valrng_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, size_=MAX_VLR_SIZE) -> valrng_t
 |      
 |      @param size_: int
 |      
 |      __init__(self, r) -> valrng_t
 |      
 |      @param r: valrng_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_valrng_t(...)
 |      delete_valrng_t(self)
 |  
 |  _deregister(self, *args) -> 'void'
 |      _deregister(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  _register(self, *args) -> 'void'
 |      _register(self)
 |  
 |  all_values(self, *args) -> 'bool'
 |      all_values(self) -> bool
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: valrng_t const &
 |  
 |  cvt_to_cmp(self, *args) -> 'bool'
 |      cvt_to_cmp(self, strict) -> bool
 |      
 |      @param strict: bool
 |  
 |  cvt_to_single_value(self, *args) -> 'bool'
 |      cvt_to_single_value(self) -> bool
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  get_size(self, *args) -> 'int'
 |      get_size(self) -> int
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, v) -> bool
 |      
 |      @param v: uvlr_t
 |  
 |  intersect_with(self, *args) -> 'bool'
 |      intersect_with(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  inverse(self, *args) -> 'void'
 |      inverse(self)
 |  
 |  is_unknown(self, *args) -> 'bool'
 |      is_unknown(self) -> bool
 |  
 |  max_svalue(self, *args) -> 'uvlr_t'
 |      max_svalue(self, size_) -> uvlr_t
 |      
 |      @param size_: int
 |      
 |      max_svalue(self) -> uvlr_t
 |  
 |  max_value(self, *args) -> 'uvlr_t'
 |      max_value(self, size_) -> uvlr_t
 |      
 |      @param size_: int
 |      
 |      max_value(self) -> uvlr_t
 |  
 |  min_svalue(self, *args) -> 'uvlr_t'
 |      min_svalue(self, size_) -> uvlr_t
 |      
 |      @param size_: int
 |      
 |      min_svalue(self) -> uvlr_t
 |  
 |  reduce_size(self, *args) -> 'bool'
 |      reduce_size(self, new_size) -> bool
 |      
 |      @param new_size: int
 |  
 |  set_all(self, *args) -> 'void'
 |      set_all(self)
 |  
 |  set_cmp(self, *args) -> 'void'
 |      set_cmp(self, cmp, _value)
 |      
 |      @param cmp: enum cmpop_t
 |      @param _value: uvlr_t
 |  
 |  set_eq(self, *args) -> 'void'
 |      set_eq(self, v)
 |      
 |      @param v: uvlr_t
 |  
 |  set_none(self, *args) -> 'void'
 |      set_none(self)
 |  
 |  set_unk(self, *args) -> 'void'
 |      set_unk(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: valrng_t &
 |  
 |  unite_with(self, *args) -> 'bool'
 |      unite_with(self, r) -> bool
 |      
 |      @param r: valrng_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class var_ref_t in module ida_hexrays:

class var_ref_t(builtins.object)
 |  Proxy of C++ var_ref_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: var_ref_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: var_ref_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: var_ref_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> var_ref_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: var_ref_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: var_ref_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: var_ref_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_var_ref_t(...)
 |      delete_var_ref_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: var_ref_t const &
 |  
 |  getv(self, *args) -> 'lvar_t &'
 |      getv(self) -> lvar_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  idx
 |      idx
 |  
 |  mba
 |      mba
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class vc_printer_t in module ida_hexrays:

class vc_printer_t(vd_printer_t)
 |  Proxy of C++ vc_printer_t class.
 |  
 |  Method resolution order:
 |      vc_printer_t
 |      vd_printer_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, f) -> vc_printer_t
 |      
 |      @param f: cfunc_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vc_printer_t(...)
 |      delete_vc_printer_t(self)
 |  
 |  oneliner(self, *args) -> 'bool'
 |      oneliner(self) -> bool
 |      Are we generating one-line text representation?
 |      
 |      @return: true if the output will occupy one line without line breaks
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  func
 |      func
 |  
 |  lastchar
 |      lastchar
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vd_printer_t:
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, indent, format) -> int
 |      
 |      Parameters
 |      ----------
 |      indent: int
 |      format: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_printer_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      hdrlines
 |  
 |  tmpbuf
 |      tmpbuf

Help on class vd_failure_t in module ida_hexrays:

class vd_failure_t(builtins.object)
 |  Proxy of C++ vd_failure_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vd_failure_t
 |      __init__(self, code, ea, buf=None) -> vd_failure_t
 |      
 |      @param code: enum merror_t
 |      @param ea: ea_t
 |      @param buf: char const *
 |      
 |      __init__(self, code, ea, buf) -> vd_failure_t
 |      
 |      @param code: enum merror_t
 |      @param ea: ea_t
 |      @param buf: qstring const &
 |      
 |      __init__(self, _hf) -> vd_failure_t
 |      
 |      @param _hf: hexrays_failure_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vd_failure_t(...)
 |      delete_vd_failure_t(self)
 |  
 |  desc(self, *args) -> 'qstring'
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hf
 |      hf
 |  
 |  thisown
 |      The membership flag

Help on class vd_interr_t in module ida_hexrays:

class vd_interr_t(vd_failure_t)
 |  Proxy of C++ vd_interr_t class.
 |  
 |  Method resolution order:
 |      vd_interr_t
 |      vd_failure_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, ea, buf) -> vd_interr_t
 |      
 |      @param ea: ea_t
 |      @param buf: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vd_interr_t(...)
 |      delete_vd_interr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from vd_failure_t:
 |  
 |  desc(self, *args) -> 'qstring'
 |      desc(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from vd_failure_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hf
 |      hf

Help on class vd_printer_t in module ida_hexrays:

class vd_printer_t(builtins.object)
 |  Proxy of C++ vd_printer_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vd_printer_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vd_printer_t(...)
 |      delete_vd_printer_t(self)
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, indent, format) -> int
 |      
 |      Parameters
 |      ----------
 |      indent: int
 |      format: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hdrlines
 |      hdrlines
 |  
 |  thisown
 |      The membership flag
 |  
 |  tmpbuf
 |      tmpbuf

Help on class vdloc_t in module ida_hexrays:

class vdloc_t(ida_typeinf.argloc_t)
 |  Proxy of C++ vdloc_t class.
 |  
 |  Method resolution order:
 |      vdloc_t
 |      ida_typeinf.argloc_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> vdloc_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: vdloc_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vdloc_t(...)
 |      delete_vdloc_t(self)
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, r1)
 |      
 |      Parameters
 |      ----------
 |      r1: int
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: vdloc_t const &
 |  
 |  is_aliasable(self, *args) -> 'bool'
 |      is_aliasable(self, mb, size) -> bool
 |      
 |      @param mb: mba_t const *
 |      @param size: int
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, r1)
 |      
 |      @param r1: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_typeinf.argloc_t:
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: rrel_t *
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: scattered_aloc_t *
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      data: argloc_t::biggest_t
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      pdata: void *
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |      
 |      Parameters
 |      ----------
 |      _ea: ea_t
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |      
 |      Parameters
 |      ----------
 |      _reg1: int
 |      _reg2: int
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |      
 |      Parameters
 |      ----------
 |      off: sval_t
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |      Move the location to point 'delta' bytes further.
 |      
 |      @param delta: (C++: int)
 |  
 |  align_reg_high(self, *args) -> 'void'
 |      align_reg_high(self, size, _slotsize)
 |      Set register offset to align it to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  align_stkoff_high(self, *args) -> 'void'
 |      align_stkoff_high(self, size, _slotsize)
 |      Set stack offset to align to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |      Get type (Argument location types)
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |      Set register-relative location - can't be nullptr.
 |      
 |      @param p: (C++: rrel_t *)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |      Set distributed argument location.
 |      
 |      @param p: (C++: scattered_aloc_t *) scattered_aloc_t const &
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |      Get custom argloc info. Use if atype() == ALOC_CUSTOM
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |      Get the global address. Use when atype() == ALOC_STATIC
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |      Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      Get register-relative info. Use when atype() == ALOC_RREL
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |      TRUE if argloc has a stack part.
 |  
 |  in_stack(self, *args) -> 'bool'
 |      in_stack(self) -> bool
 |      TRUE if argloc is in stack entirely.
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |      See ALOC_NONE.
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |      See ALOC_CUSTOM.
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |      See ALOC_STATIC.
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |      is_scattered() || is_reg2()
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg1() || is_reg2()
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |      See ALOC_REG1.
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |      See ALOC_REG2.
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |      See ALOC_RREL.
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      See ALOC_DIST.
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |      See ALOC_STACK.
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |      Get info for the second register. Use when atype() == ALOC_REG2
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |      Get offset from the beginning of the register in bytes. Use when atype() ==
 |      ALOC_REG1
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      Get scattered argument info. Use when atype() == ALOC_DIST
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |      Set static ea location.
 |      
 |      @param _ea: (C++: ea_t)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |      Set secondary register location.
 |      
 |      @param _reg1: (C++: int)
 |      @param _reg2: (C++: int)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |      Set stack offset location.
 |      
 |      @param off: (C++: sval_t)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |      Get the stack offset. Use if atype() == ALOC_STACK
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Assign this == r and r == this.
 |      
 |      @param r: (C++: argloc_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_typeinf.argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class vdui_t in module ida_hexrays:

class vdui_t(builtins.object)
 |  Proxy of C++ vdui_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vdui_t(...)
 |      delete_vdui_t(self)
 |  
 |  calc_cmt_type(self, *args) -> 'cmt_type_t'
 |      calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
 |      Check if the specified line can have a comment. Due to the coordinate system for
 |      comments: (\link{https://www.hex-rays.com/blog/coordinate-system-for-hex-rays})
 |      some function lines cannot have comments. This function checks if a comment can
 |      be attached to the specified line.
 |      
 |      @param lnnum: (C++: size_t) line number (0 based)
 |      @param cmttype: (C++: cmt_type_t) comment types to check
 |      @return: possible comment types
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Clear the pseudocode window. It deletes the current function and microcode.
 |  
 |  collapse_item(self, *args) -> 'bool'
 |      collapse_item(self, hide) -> bool
 |      Collapse/uncollapse item. This function collapses the current item.
 |      
 |      @param hide: (C++: bool)
 |      @return: false if failed.
 |  
 |  collapse_lvars(self, *args) -> 'bool'
 |      collapse_lvars(self, hide) -> bool
 |      Collapse/uncollapse local variable declarations.
 |      
 |      @param hide: (C++: bool)
 |      @return: false if failed.
 |  
 |  ctree_to_disasm(self, *args) -> 'bool'
 |      ctree_to_disasm(self) -> bool
 |      Jump to disassembly. This function jumps to the address in the disassembly
 |      window which corresponds to the current item. The current item is determined
 |      based on the current keyboard cursor position.
 |      
 |      @return: false if failed
 |  
 |  del_orphan_cmts(self, *args) -> 'bool'
 |      del_orphan_cmts(self) -> bool
 |      Delete all orphan comments. Delete all orphan comments and refresh the screen.
 |      
 |      @return: true
 |  
 |  edit_cmt(self, *args) -> 'bool'
 |      edit_cmt(self, loc) -> bool
 |      Edit an indented comment. This function displays a dialog box and allows the
 |      user to edit the comment for the specified ctree location.
 |      
 |      @param loc: (C++: const treeloc_t &) comment location
 |      @return: false if failed or cancelled
 |  
 |  edit_func_cmt(self, *args) -> 'bool'
 |      edit_func_cmt(self) -> bool
 |      Edit a function comment. This function displays a dialog box and allows the user
 |      to edit the function comment.
 |      
 |      @return: false if failed or cancelled
 |  
 |  get_current_item(self, *args) -> 'bool'
 |      get_current_item(self, idv) -> bool
 |      Get current item. This function refreshes the cpos, item, tail fields.
 |      
 |      @param idv: (C++: input_device_t) keyboard or mouse
 |      @see: cfunc_t::get_line_item()
 |      @return: false if failed
 |  
 |  get_current_label(self, *args) -> 'int'
 |      get_current_label(self) -> int
 |      Get current label. If there is a label under the cursor, return its number.
 |      
 |      @return: -1 if there is no label under the cursor. prereq: get_current_item()
 |               has been called
 |  
 |  get_number(self, *args) -> 'cnumber_t *'
 |      get_number(self) -> cnumber_t
 |      Get current number. If the current item is a number, return pointer to it.
 |      
 |      @return: nullptr if the current item is not a number This function returns non-
 |               null for the cases of a 'switch' statement Also, if the current item is
 |               a casted number, then this function will succeed.
 |  
 |  in_ctree(self, *args) -> 'bool'
 |      in_ctree(self) -> bool
 |      Is the current item a statement?
 |      
 |      @return: false if the cursor is in the local variable/type declaration area
 |      true if the cursor is in the statement area
 |  
 |  invert_bits(self, *args) -> 'bool'
 |      invert_bits(self) -> bool
 |      Bitwise negate a number. This function inverts all bits of the current number.
 |      
 |      @return: false if failed.
 |  
 |  invert_sign(self, *args) -> 'bool'
 |      invert_sign(self) -> bool
 |      Negate a number. This function negates the current number.
 |      
 |      @return: false if failed.
 |  
 |  jump_enter(self, *args) -> 'bool'
 |      jump_enter(self, idv, omflags) -> bool
 |      Process the Enter key. This function jumps to the definition of the item under
 |      the cursor. If the current item is a function, it will be decompiled. If the
 |      current item is a global data, its disassemly text will be displayed.
 |      
 |      @param idv: (C++: input_device_t) what cursor must be used, the keyboard or the mouse
 |      @param omflags: (C++: int) OM_NEWWIN: new pseudocode window will open, 0: reuse the
 |                      existing window
 |      @return: false if failed
 |  
 |  locked(self, *args) -> 'bool'
 |      locked(self) -> bool
 |      Does the pseudocode window contain valid code? We lock windows before modifying
 |      them, to avoid recursion due to the events generated by the IDA kernel.
 |      @retval true: The window is locked and may have stale info
 |  
 |  map_lvar(self, *args) -> 'bool'
 |      map_lvar(self, frm, to) -> bool
 |      Map a local variable to another. This function permanently maps one lvar to
 |      another. All occurrences of the mapped variable are replaced by the new variable
 |      
 |      @param from: (C++: lvar_t *) the variable being mapped
 |      @param to: (C++: lvar_t *) the variable to map to. if nullptr, unmaps the variable
 |      @return: false if failed
 |  
 |  refresh_cpos(self, *args) -> 'bool'
 |      refresh_cpos(self, idv) -> bool
 |      Refresh the current position. This function refreshes the cpos field.
 |      
 |      @param idv: (C++: input_device_t) keyboard or mouse
 |      @return: false if failed
 |  
 |  refresh_ctext(self, *args) -> 'void'
 |      refresh_ctext(self, activate=True)
 |      Refresh pseudocode window. This function refreshes the pseudocode window by
 |      regenerating its text from cfunc_t. Instead of this function use
 |      refresh_func_ctext(), which refreshes all pseudocode windows for the function.
 |      @see: refresh_view(), refresh_func_ctext()
 |      
 |      @param activate: (C++: bool)
 |  
 |  refresh_view(self, *args) -> 'void'
 |      refresh_view(self, redo_mba)
 |      Refresh pseudocode window. This is the highest level refresh function. It causes
 |      the most profound refresh possible and can lead to redecompilation of the
 |      current function. Please consider using refresh_ctext() if you need a more
 |      superficial refresh.
 |      
 |      @param redo_mba: (C++: bool) true means to redecompile the current function
 |      false means to rebuild ctree without regenerating microcode
 |      @see: refresh_ctext()
 |  
 |  rename_global(self, *args) -> 'bool'
 |      rename_global(self, ea) -> bool
 |      Rename global item. This function displays a dialog box and allows the user to
 |      rename a global item (data or function).
 |      
 |      @param ea: (C++: ea_t) address of the global item
 |      @return: false if failed or cancelled
 |  
 |  rename_label(self, *args) -> 'bool'
 |      rename_label(self, label) -> bool
 |      Rename a label. This function displays a dialog box and allows the user to
 |      rename a statement label.
 |      
 |      @param label: (C++: int) label number
 |      @return: false if failed or cancelled
 |  
 |  rename_lvar(self, *args) -> 'bool'
 |      rename_lvar(self, v, name, is_user_name) -> bool
 |      Rename local variable. This function permanently renames a local variable.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @param name: (C++: const char *) new variable name
 |      @param is_user_name: (C++: bool) use true to save the new name into the database. use false
 |                           to delete the saved name.
 |      @see: ::rename_lvar()
 |      @return: false if failed
 |  
 |  rename_strmem(self, *args) -> 'bool'
 |      rename_strmem(self, sptr, mptr) -> bool
 |      Rename structure field. This function displays a dialog box and allows the user
 |      to rename a structure field.
 |      
 |      @param sptr: (C++: struc_t *) pointer to structure
 |      @param mptr: (C++: member_t *) pointer to structure member
 |      @return: false if failed or cancelled
 |  
 |  set_global_type(self, *args) -> 'bool'
 |      set_global_type(self, ea) -> bool
 |      Set global item type. This function displays a dialog box and allows the user to
 |      change the type of a global item (data or function).
 |      
 |      @param ea: (C++: ea_t) address of the global item
 |      @return: false if failed or cancelled
 |  
 |  set_locked(self, *args) -> 'bool'
 |      set_locked(self, v) -> bool
 |      
 |      @param v: bool
 |  
 |  set_lvar_cmt(self, *args) -> 'bool'
 |      set_lvar_cmt(self, v, cmt) -> bool
 |      Set local variable comment. This function permanently sets a variable comment.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @param cmt: (C++: const char *) new comment
 |      @return: false if failed
 |  
 |  set_lvar_type(self, *args) -> 'bool'
 |      set_lvar_type(self, v, type) -> bool
 |      Set local variable type. This function permanently sets a local variable type
 |      and clears NOPTR flag if it was set before by function 'set_noptr_lvar'
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @param type: (C++: const tinfo_t &) new variable type
 |      @return: false if failed
 |  
 |  set_noptr_lvar(self, *args) -> 'bool'
 |      set_noptr_lvar(self, v) -> bool
 |      Inform that local variable should have a non-pointer type This function
 |      permanently sets a corresponding variable flag (NOPTR) and removes type if it
 |      was set before by function 'set_lvar_type'
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @return: false if failed
 |  
 |  set_num_enum(self, *args) -> 'bool'
 |      set_num_enum(self) -> bool
 |      Convert number to symbolic constant. This function displays a dialog box and
 |      allows the user to select a symbolic constant to represent the number.
 |      
 |      @return: false if failed or cancelled
 |  
 |  set_num_radix(self, *args) -> 'bool'
 |      set_num_radix(self, base) -> bool
 |      Change number base. This function changes the current number representation.
 |      
 |      @param base: (C++: int) number radix (10 or 16)
 |      0 means a character constant
 |      @return: false if failed
 |  
 |  set_num_stroff(self, *args) -> 'bool'
 |      set_num_stroff(self) -> bool
 |      Convert number to structure field offset. Currently not implemented.
 |      
 |      @return: false if failed or cancelled
 |  
 |  set_strmem_type(self, *args) -> 'bool'
 |      set_strmem_type(self, sptr, mptr) -> bool
 |      Set structure field type. This function displays a dialog box and allows the
 |      user to change the type of a structure field.
 |      
 |      @param sptr: (C++: struc_t *) pointer to structure
 |      @param mptr: (C++: member_t *) pointer to structure member
 |      @return: false if failed or cancelled
 |  
 |  set_valid(self, *args) -> 'void'
 |      set_valid(self, v)
 |      
 |      @param v: bool
 |  
 |  set_visible(self, *args) -> 'void'
 |      set_visible(self, v)
 |      
 |      @param v: bool
 |  
 |  split_item(self, *args) -> 'bool'
 |      split_item(self, split) -> bool
 |      Split/unsplit item. This function splits the current assignment expression.
 |      
 |      @param split: (C++: bool)
 |      @return: false if failed.
 |  
 |  switch_to(self, *args) -> 'void'
 |      switch_to(self, f, activate)
 |      Display the specified pseudocode. This function replaces the pseudocode window
 |      contents with the specified cfunc_t.
 |      
 |      @param f: (C++: cfuncptr_t) pointer to the function to display.
 |      @param activate: (C++: bool) should the pseudocode window get focus?
 |  
 |  ui_edit_lvar_cmt(self, *args) -> 'bool'
 |      ui_edit_lvar_cmt(self, v) -> bool
 |      Set local variable comment. This function displays a dialog box and allows the
 |      user to edit the comment of a local variable.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @return: false if failed or cancelled
 |  
 |  ui_map_lvar(self, *args) -> 'bool'
 |      ui_map_lvar(self, v) -> bool
 |      Map a local variable to another. This function displays a variable list and
 |      allows the user to select mapping.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @return: false if failed or cancelled
 |  
 |  ui_rename_lvar(self, *args) -> 'bool'
 |      ui_rename_lvar(self, v) -> bool
 |      Rename local variable. This function displays a dialog box and allows the user
 |      to rename a local variable.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @return: false if failed or cancelled
 |  
 |  ui_set_call_type(self, *args) -> 'bool'
 |      ui_set_call_type(self, e) -> bool
 |      Set type of a function call This function displays a dialog box and allows the
 |      user to change the type of a function call
 |      
 |      @param e: (C++: const cexpr_t *) pointer to call expression
 |      @return: false if failed or cancelled
 |  
 |  ui_set_lvar_type(self, *args) -> 'bool'
 |      ui_set_lvar_type(self, v) -> bool
 |      Set local variable type. This function displays a dialog box and allows the user
 |      to change the type of a local variable.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @return: false if failed or cancelled
 |  
 |  ui_unmap_lvar(self, *args) -> 'bool'
 |      ui_unmap_lvar(self, v) -> bool
 |      Unmap a local variable. This function displays list of variables mapped to the
 |      specified variable and allows the user to select a variable to unmap.
 |      
 |      @param v: (C++: lvar_t *) pointer to local variable
 |      @return: false if failed or cancelled
 |  
 |  valid(self, *args) -> 'bool'
 |      valid(self) -> bool
 |      Does the pseudocode window contain valid code? It can become invalid if the
 |      function type gets changed in IDA.
 |  
 |  visible(self, *args) -> 'bool'
 |      visible(self) -> bool
 |      Is the pseudocode window visible? if not, it might be invisible or destroyed
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cfunc
 |      cfunc
 |  
 |  cpos
 |      cpos
 |  
 |  ct
 |      ct
 |  
 |  flags
 |      flags
 |  
 |  head
 |      head
 |  
 |  item
 |      item
 |  
 |  last_code
 |      last_code
 |  
 |  mba
 |      mba
 |  
 |  tail
 |      tail
 |  
 |  thisown
 |      The membership flag
 |  
 |  toplevel
 |      toplevel
 |  
 |  view_idx
 |      view_idx

Help on class vivl_t in module ida_hexrays:

class vivl_t(voff_t)
 |  Proxy of C++ vivl_t class.
 |  
 |  Method resolution order:
 |      vivl_t
 |      voff_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: vivl_t const &
 |      
 |      __eq__(self, mop) -> bool
 |      
 |      @param mop: mop_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: vivl_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: vivl_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _type=mop_z, _off=-1, _size=0) -> vivl_t
 |      
 |      @param _type: mopt_t
 |      @param _off: sval_t
 |      @param _size: int
 |      
 |      __init__(self, ch) -> vivl_t
 |      
 |      @param ch: chain_t const &
 |      
 |      __init__(self, op) -> vivl_t
 |      
 |      @param op: mop_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: vivl_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: vivl_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: vivl_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_vivl_t(...)
 |      delete_vivl_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: vivl_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, voff2) -> bool
 |      Does our value interval contain the specified value offset?
 |      
 |      @param voff2: (C++: const voff_t &) voff_t const &
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |  
 |  extend_to_cover(self, *args) -> 'bool'
 |      extend_to_cover(self, r) -> bool
 |      Extend a value interval using another value interval of the same type
 |      
 |      @param r: (C++: const vivl_t &) vivl_t const &
 |      @return: success
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, r) -> bool
 |      Does our value interval include another?
 |      
 |      @param r: (C++: const vivl_t &) vivl_t const &
 |  
 |  intersect(self, *args) -> 'uval_t'
 |      intersect(self, r) -> uval_t
 |      Intersect value intervals the same type
 |      
 |      @param r: (C++: const vivl_t &) vivl_t const &
 |      @return: size of the resulting intersection
 |  
 |  overlap(self, *args) -> 'bool'
 |      overlap(self, r) -> bool
 |      Do two value intervals overlap?
 |      
 |      @param r: (C++: const vivl_t &) vivl_t const &
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _type, _off, _size=0)
 |      
 |      @param _type: mopt_t
 |      @param _off: sval_t
 |      @param _size: int
 |      
 |      set(self, voff, _size)
 |      
 |      @param voff: voff_t const &
 |      @param _size: int
 |  
 |  set_reg(self, *args) -> 'void'
 |      set_reg(self, mreg, sz=0)
 |      
 |      @param mreg: mreg_t
 |      @param sz: int
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, stkoff, sz=0)
 |      
 |      @param stkoff: sval_t
 |      @param sz: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from voff_t:
 |  
 |  add(self, *args) -> 'voff_t'
 |      add(self, width) -> voff_t
 |      
 |      @param width: int
 |  
 |  defined(self, *args) -> 'bool'
 |      defined(self) -> bool
 |  
 |  diff(self, *args) -> 'sval_t'
 |      diff(self, r) -> sval_t
 |      
 |      @param r: voff_t const &
 |  
 |  get_reg(self, *args) -> 'mreg_t'
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, delta)
 |      
 |      @param delta: sval_t
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  undef(self, *args) -> 'void'
 |      undef(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from voff_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      off
 |  
 |  type
 |      type

Help on class voff_t in module ida_hexrays:

class voff_t(builtins.object)
 |  Proxy of C++ voff_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: voff_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: voff_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: voff_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> voff_t
 |      __init__(self, _type, _off) -> voff_t
 |      
 |      @param _type: mopt_t
 |      @param _off: sval_t
 |      
 |      __init__(self, op) -> voff_t
 |      
 |      @param op: mop_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: voff_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: voff_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: voff_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_voff_t(...)
 |      delete_voff_t(self)
 |  
 |  add(self, *args) -> 'voff_t'
 |      add(self, width) -> voff_t
 |      
 |      @param width: int
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: voff_t const &
 |  
 |  defined(self, *args) -> 'bool'
 |      defined(self) -> bool
 |  
 |  diff(self, *args) -> 'sval_t'
 |      diff(self, r) -> sval_t
 |      
 |      @param r: voff_t const &
 |  
 |  get_reg(self, *args) -> 'mreg_t'
 |      get_reg(self) -> mreg_t
 |  
 |  get_stkoff(self, *args) -> 'sval_t'
 |      get_stkoff(self) -> sval_t
 |  
 |  inc(self, *args) -> 'void'
 |      inc(self, delta)
 |      
 |      @param delta: sval_t
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _type, _off)
 |      
 |      @param _type: mopt_t
 |      @param _off: sval_t
 |  
 |  set_reg(self, *args) -> 'void'
 |      set_reg(self, mreg)
 |      
 |      @param mreg: mreg_t
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, stkoff)
 |      
 |      @param stkoff: sval_t
 |  
 |  undef(self, *args) -> 'void'
 |      undef(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      off
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Module "ida_ida"s docstring:
"""
Contains the inf structure definition and some functions common to the whole IDA
project.

The inf structure is saved in the database and contains information specific to
the current program being disassembled. Initially it is filled with values from
ida.cfg.

Although it is not a good idea to change values in inf structure (because you
will overwrite values taken from ida.cfg), you are allowed to do it if you feel
it necessary."""

Help on function __make_idainfo_accessors in module ida_ida:

__make_idainfo_accessors(attr, getter_name=None, setter_name=None)

Help on function __make_idainfo_bound in module ida_ida:

__make_idainfo_bound(func, attr)

Help on function __make_idainfo_getter in module ida_ida:

__make_idainfo_getter(name)

Help on function __set_module_dynattrs in module ida_ida:

__set_module_dynattrs(modname, pdict)

Help on function __wrap_hooks_callback in module ida_ida:

__wrap_hooks_callback(klass, new_name, old_name, do_call)

Help on function calc_default_idaplace_flags in module ida_ida:

calc_default_idaplace_flags(*args) -> 'int'
    calc_default_idaplace_flags() -> int
    Get default disassembly line options.

Help on class compiler_info_t in module ida_ida:

class compiler_info_t(builtins.object)
 |  Proxy of C++ compiler_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> compiler_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_compiler_info_t(...)
 |      delete_compiler_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cm
 |      cm
 |  
 |  defalign
 |      defalign
 |  
 |  id
 |      id
 |  
 |  size_b
 |      size_b
 |  
 |  size_e
 |      size_e
 |  
 |  size_i
 |      size_i
 |  
 |  size_l
 |      size_l
 |  
 |  size_ldbl
 |      size_ldbl
 |  
 |  size_ll
 |      size_ll
 |  
 |  size_s
 |      size_s
 |  
 |  thisown
 |      The membership flag

Help on function delinf in module ida_ida:

delinf(*args) -> 'bool'
    delinf(tag) -> bool
    Undefine a program specific information
    
    @param tag: (C++: inftag_t) one of inftag_t constants
    @return: success

Help on function get_dbctx_id in module ida_ida:

get_dbctx_id(*args) -> 'ssize_t'
    get_dbctx_id() -> ssize_t
    Get the current database context ID
    
    @return: the database context ID, or -1 if no current database

Help on function get_dbctx_qty in module ida_ida:

get_dbctx_qty(*args) -> 'size_t'
    get_dbctx_qty() -> size_t
    Get number of database contexts
    
    @return: number of database contexts

Help on function getinf_str in module ida_ida:

getinf_str(*args) -> 'qstring *'
    getinf_str(tag) -> str
    Get program specific information (a non-scalar value)
    
    @param tag: (C++: inftag_t) one of inftag_t constants
    @return: number of bytes stored in the buffer (<0 - not defined)

Help on class idainfo in module ida_ida:

class idainfo(builtins.object)
 |  Proxy of C++ idainfo class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  _get_lflags(self, *args) -> 'uint32'
 |      _get_lflags(self) -> uint32
 |  
 |  _set_lflags(self, *args) -> 'void'
 |      _set_lflags(self, _f)
 |      
 |      Parameters
 |      ----------
 |      _f: uint32
 |  
 |  big_arg_align = __func(self, *args)
 |  
 |  gen_lzero = __func(self, *args)
 |  
 |  gen_null = __func(self, *args)
 |  
 |  gen_tryblks = __func(self, *args)
 |  
 |  get_abiname(self, *args) -> 'qstring'
 |      get_abiname(self) -> qstring
 |  
 |  get_demname_form = __func(self, *args)
 |  
 |  get_pack_mode = __func(self, *args)
 |  
 |  is_32bit = __func(self, *args)
 |  
 |  is_64bit = __func(self, *args)
 |  
 |  is_auto_enabled = __func(self, *args)
 |  
 |  is_be = __func(self, *args)
 |  
 |  is_dll = __func(self, *args)
 |  
 |  is_flat_off32 = __func(self, *args)
 |  
 |  is_graph_view = __func(self, *args)
 |  
 |  is_hard_float = __func(self, *args)
 |  
 |  is_kernel_mode = __func(self, *args)
 |  
 |  is_mem_aligned4 = __func(self, *args)
 |  
 |  is_snapshot = __func(self, *args)
 |  
 |  is_wide_high_byte_first = __func(self, *args)
 |  
 |  like_binary = __func(self, *args)
 |  
 |  line_pref_with_seg = __func(self, *args)
 |  
 |  loading_idc = __func(self, *args)
 |  
 |  map_stkargs = __func(self, *args)
 |  
 |  pack_stkargs = __func(self, *args)
 |  
 |  readonly_idb = __func(self, *args)
 |  
 |  set_64bit = __func(self, *args)
 |  
 |  set_auto_enabled = __func(self, *args)
 |  
 |  set_be = __func(self, *args)
 |  
 |  set_gen_lzero = __func(self, *args)
 |  
 |  set_gen_null = __func(self, *args)
 |  
 |  set_gen_tryblks = __func(self, *args)
 |  
 |  set_graph_view = __func(self, *args)
 |  
 |  set_line_pref_with_seg = __func(self, *args)
 |  
 |  set_pack_mode = __func(self, *args)
 |  
 |  set_show_auto = __func(self, *args)
 |  
 |  set_show_line_pref = __func(self, *args)
 |  
 |  set_show_void = __func(self, *args)
 |  
 |  set_wide_high_byte_first = __func(self, *args)
 |  
 |  show_auto = __func(self, *args)
 |  
 |  show_line_pref = __func(self, *args)
 |  
 |  show_void = __func(self, *args)
 |  
 |  stack_ldbl = __func(self, *args)
 |  
 |  stack_varargs = __func(self, *args)
 |  
 |  use_allasm = __func(self, *args)
 |  
 |  use_gcc_layout = __func(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  abibits
 |      abibits
 |  
 |  abiname
 |      get_abiname(self) -> qstring
 |  
 |  af
 |      af
 |  
 |  af2
 |      af2
 |  
 |  appcall_options
 |      appcall_options
 |  
 |  apptype
 |      apptype
 |  
 |  asmtype
 |      asmtype
 |  
 |  baseaddr
 |      baseaddr
 |  
 |  bin_prefix_size
 |      bin_prefix_size
 |  
 |  cc
 |      cc
 |  
 |  cmt_indent
 |      cmt_indent
 |  
 |  database_change_count
 |      database_change_count
 |  
 |  datatypes
 |      datatypes
 |  
 |  demnames
 |      demnames
 |  
 |  filetype
 |      filetype
 |  
 |  highoff
 |      highoff
 |  
 |  indent
 |      indent
 |  
 |  lenxref
 |      lenxref
 |  
 |  lflags
 |      _get_lflags(self) -> uint32
 |  
 |  listnames
 |      listnames
 |  
 |  long_demnames
 |      long_demnames
 |  
 |  lowoff
 |      lowoff
 |  
 |  main
 |      main
 |  
 |  margin
 |      margin
 |  
 |  maxEA
 |  
 |  max_autoname_len
 |      max_autoname_len
 |  
 |  max_ea
 |      max_ea
 |  
 |  maxref
 |      maxref
 |  
 |  minEA
 |  
 |  min_ea
 |      min_ea
 |  
 |  nametype
 |      nametype
 |  
 |  omax_ea
 |      omax_ea
 |  
 |  omin_ea
 |      omin_ea
 |  
 |  ostype
 |      ostype
 |  
 |  outflags
 |      outflags
 |  
 |  procName
 |  
 |  procname
 |      procname
 |  
 |  refcmtnum
 |      refcmtnum
 |  
 |  s_cmtflg
 |      s_cmtflg
 |  
 |  s_genflags
 |      s_genflags
 |  
 |  s_limiter
 |      s_limiter
 |  
 |  s_prefflag
 |      s_prefflag
 |  
 |  s_xrefflag
 |      s_xrefflag
 |  
 |  short_demnames
 |      short_demnames
 |  
 |  specsegs
 |      specsegs
 |  
 |  start_cs
 |      start_cs
 |  
 |  start_ea
 |      start_ea
 |  
 |  start_ip
 |      start_ip
 |  
 |  start_sp
 |      start_sp
 |  
 |  start_ss
 |      start_ss
 |  
 |  strlit_break
 |      strlit_break
 |  
 |  strlit_flags
 |      strlit_flags
 |  
 |  strlit_pref
 |      strlit_pref
 |  
 |  strlit_sernum
 |      strlit_sernum
 |  
 |  strlit_zeroes
 |      strlit_zeroes
 |  
 |  strtype
 |      strtype
 |  
 |  tag
 |      tag
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_xrefnum
 |      type_xrefnum
 |  
 |  version
 |      version
 |  
 |  xrefnum
 |      xrefnum

Help on function inf_big_arg_align in module ida_ida:

inf_big_arg_align(*args) -> 'bool'
    inf_big_arg_align(cc) -> bool
    
    @param cc: cm_t
    
    inf_big_arg_align() -> bool

Help on function inf_get_cmt_indent in module ida_ida:

inf_get_cmt_indent(*args) -> 'uchar'
    inf_get_cmt_indent() -> uchar

Help on function inf_set_cmt_indent in module ida_ida:

inf_set_cmt_indent(*args) -> 'bool'
    inf_set_cmt_indent(_v) -> bool
    
    @param _v: uchar

Help on function inf_gen_lzero in module ida_ida:

inf_gen_lzero(*args) -> 'bool'
    inf_gen_lzero() -> bool

Help on function inf_gen_null in module ida_ida:

inf_gen_null(*args) -> 'bool'
    inf_gen_null() -> bool

Help on function inf_gen_tryblks in module ida_ida:

inf_gen_tryblks(*args) -> 'bool'
    inf_gen_tryblks() -> bool

Help on function inf_get_demname_form in module ida_ida:

inf_get_demname_form(*args) -> 'uchar'
    inf_get_demname_form() -> uchar
    Get DEMNAM_MASK bits of #demnames.

Help on function inf_get_pack_mode in module ida_ida:

inf_get_pack_mode(*args) -> 'int'
    inf_get_pack_mode() -> int

Help on function idainfo_is_32bit in module ida_ida:

idainfo_is_32bit()

Help on function inf_is_64bit in module ida_ida:

inf_is_64bit(*args) -> 'bool'
    inf_is_64bit() -> bool

Help on function inf_is_auto_enabled in module ida_ida:

inf_is_auto_enabled(*args) -> 'bool'
    inf_is_auto_enabled() -> bool

Help on function inf_is_be in module ida_ida:

inf_is_be(*args) -> 'bool'
    inf_is_be() -> bool

Help on function inf_is_dll in module ida_ida:

inf_is_dll(*args) -> 'bool'
    inf_is_dll() -> bool

Help on function inf_is_flat_off32 in module ida_ida:

inf_is_flat_off32(*args) -> 'bool'
    inf_is_flat_off32() -> bool

Help on function inf_is_graph_view in module ida_ida:

inf_is_graph_view(*args) -> 'bool'
    inf_is_graph_view() -> bool

Help on function inf_is_hard_float in module ida_ida:

inf_is_hard_float(*args) -> 'bool'
    inf_is_hard_float() -> bool

Help on function inf_is_kernel_mode in module ida_ida:

inf_is_kernel_mode(*args) -> 'bool'
    inf_is_kernel_mode() -> bool

Help on function inf_is_mem_aligned4 in module ida_ida:

inf_is_mem_aligned4(*args) -> 'bool'
    inf_is_mem_aligned4() -> bool

Help on function inf_is_snapshot in module ida_ida:

inf_is_snapshot(*args) -> 'bool'
    inf_is_snapshot() -> bool

Help on function inf_is_wide_high_byte_first in module ida_ida:

inf_is_wide_high_byte_first(*args) -> 'bool'
    inf_is_wide_high_byte_first() -> bool

Help on function inf_like_binary in module ida_ida:

inf_like_binary(*args) -> 'bool'
    inf_like_binary() -> bool

Help on function inf_line_pref_with_seg in module ida_ida:

inf_line_pref_with_seg(*args) -> 'bool'
    inf_line_pref_with_seg() -> bool

Help on function inf_loading_idc in module ida_ida:

inf_loading_idc(*args) -> 'bool'
    inf_loading_idc() -> bool

Help on function inf_map_stkargs in module ida_ida:

inf_map_stkargs(*args) -> 'bool'
    inf_map_stkargs() -> bool

Help on function inf_pack_stkargs in module ida_ida:

inf_pack_stkargs(*args) -> 'bool'
    inf_pack_stkargs(cc) -> bool
    
    @param cc: cm_t
    
    inf_pack_stkargs() -> bool

Help on function inf_readonly_idb in module ida_ida:

inf_readonly_idb(*args) -> 'bool'
    inf_readonly_idb() -> bool

Help on function inf_set_64bit in module ida_ida:

inf_set_64bit(*args) -> 'bool'
    inf_set_64bit(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_auto_enabled in module ida_ida:

inf_set_auto_enabled(*args) -> 'bool'
    inf_set_auto_enabled(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_be in module ida_ida:

inf_set_be(*args) -> 'bool'
    inf_set_be(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_gen_lzero in module ida_ida:

inf_set_gen_lzero(*args) -> 'bool'
    inf_set_gen_lzero(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_gen_null in module ida_ida:

inf_set_gen_null(*args) -> 'bool'
    inf_set_gen_null(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_gen_tryblks in module ida_ida:

inf_set_gen_tryblks(*args) -> 'bool'
    inf_set_gen_tryblks(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_graph_view in module ida_ida:

inf_set_graph_view(*args) -> 'bool'
    inf_set_graph_view(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_line_pref_with_seg in module ida_ida:

inf_set_line_pref_with_seg(*args) -> 'bool'
    inf_set_line_pref_with_seg(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_pack_mode in module ida_ida:

inf_set_pack_mode(*args) -> 'int'
    inf_set_pack_mode(pack_mode) -> int
    
    @param pack_mode: int

Help on function inf_set_show_auto in module ida_ida:

inf_set_show_auto(*args) -> 'bool'
    inf_set_show_auto(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_line_pref in module ida_ida:

inf_set_show_line_pref(*args) -> 'bool'
    inf_set_show_line_pref(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_void in module ida_ida:

inf_set_show_void(*args) -> 'bool'
    inf_set_show_void(_v=True) -> bool
    
    @param _v: bool

Help on function <lambda> in module ida_ida:

<lambda> lambda *args

Help on function inf_set_wide_high_byte_first in module ida_ida:

inf_set_wide_high_byte_first(*args) -> 'bool'
    inf_set_wide_high_byte_first(_v=True) -> bool
    
    @param _v: bool

Help on function inf_show_auto in module ida_ida:

inf_show_auto(*args) -> 'bool'
    inf_show_auto() -> bool

Help on function inf_show_line_pref in module ida_ida:

inf_show_line_pref(*args) -> 'bool'
    inf_show_line_pref() -> bool

Help on function inf_show_void in module ida_ida:

inf_show_void(*args) -> 'bool'
    inf_show_void() -> bool

Help on function inf_stack_ldbl in module ida_ida:

inf_stack_ldbl(*args) -> 'bool'
    inf_stack_ldbl() -> bool

Help on function inf_stack_varargs in module ida_ida:

inf_stack_varargs(*args) -> 'bool'
    inf_stack_varargs() -> bool

Help on function inf_use_allasm in module ida_ida:

inf_use_allasm(*args) -> 'bool'
    inf_use_allasm() -> bool

Help on function inf_use_gcc_layout in module ida_ida:

inf_use_gcc_layout(*args) -> 'bool'
    inf_use_gcc_layout() -> bool

Help on class idbattr_info_t in module ida_ida:

class idbattr_info_t(builtins.object)
 |  Proxy of C++ idbattr_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, name, offset, width, bitmask=0, tag=0, idi_flags=0) -> idbattr_info_t
 |      
 |      @param name: char const *
 |      @param offset: uintptr_t
 |      @param width: size_t
 |      @param bitmask: uint64
 |      @param tag: uchar
 |      @param idi_flags: uint
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: idbattr_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idbattr_info_t(...)
 |      delete_idbattr_info_t(self)
 |  
 |  has_individual_node(self, *args) -> 'bool'
 |      has_individual_node(self) -> bool
 |  
 |  hashname(self, *args) -> 'char const *'
 |      hashname(self) -> char const *
 |  
 |  is_bitfield(self, *args) -> 'bool'
 |      is_bitfield(self) -> bool
 |  
 |  is_bitmap(self, *args) -> 'bool'
 |      is_bitmap(self) -> bool
 |  
 |  is_boolean(self, *args) -> 'bool'
 |      is_boolean(self) -> bool
 |  
 |  is_buf_var(self, *args) -> 'bool'
 |      is_buf_var(self) -> bool
 |  
 |  is_bytearray(self, *args) -> 'bool'
 |      is_bytearray(self) -> bool
 |  
 |  is_cstr(self, *args) -> 'bool'
 |      is_cstr(self) -> bool
 |  
 |  is_decimal(self, *args) -> 'bool'
 |      is_decimal(self) -> bool
 |  
 |  is_hash(self, *args) -> 'bool'
 |      is_hash(self) -> bool
 |  
 |  is_hexadecimal(self, *args) -> 'bool'
 |      is_hexadecimal(self) -> bool
 |  
 |  is_incremented(self, *args) -> 'bool'
 |      is_incremented(self) -> bool
 |  
 |  is_node_altval(self, *args) -> 'bool'
 |      is_node_altval(self) -> bool
 |  
 |  is_node_blob(self, *args) -> 'bool'
 |      is_node_blob(self) -> bool
 |  
 |  is_node_supval(self, *args) -> 'bool'
 |      is_node_supval(self) -> bool
 |  
 |  is_node_valobj(self, *args) -> 'bool'
 |      is_node_valobj(self) -> bool
 |  
 |  is_node_var(self, *args) -> 'bool'
 |      is_node_var(self) -> bool
 |  
 |  is_onoff(self, *args) -> 'bool'
 |      is_onoff(self) -> bool
 |  
 |  is_qstring(self, *args) -> 'bool'
 |      is_qstring(self) -> bool
 |  
 |  is_readonly_var(self, *args) -> 'bool'
 |      is_readonly_var(self) -> bool
 |  
 |  is_scalar_var(self, *args) -> 'bool'
 |      is_scalar_var(self) -> bool
 |  
 |  is_struc_field(self, *args) -> 'bool'
 |      is_struc_field(self) -> bool
 |  
 |  is_val_mapped(self, *args) -> 'bool'
 |      is_val_mapped(self) -> bool
 |  
 |  ridx(self, *args) -> 'size_t'
 |      ridx(self) -> size_t
 |  
 |  str_false(self, *args) -> 'char const *'
 |      str_false(self) -> char const *
 |  
 |  str_true(self, *args) -> 'char const *'
 |      str_true(self) -> char const *
 |  
 |  use_hlpstruc(self, *args) -> 'bool'
 |      use_hlpstruc(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bitmask
 |      bitmask
 |  
 |  idi_flags
 |      idi_flags
 |  
 |  individual_node
 |      individual_node
 |  
 |  maxsize
 |      maxsize
 |  
 |  name
 |      name
 |  
 |  offset
 |      offset
 |  
 |  tag
 |      tag
 |  
 |  thisown
 |      The membership flag
 |  
 |  vmap
 |      vmap
 |  
 |  width
 |      width

Help on class idbattr_valmap_t in module ida_ida:

class idbattr_valmap_t(builtins.object)
 |  Proxy of C++ idbattr_valmap_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idbattr_valmap_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idbattr_valmap_t(...)
 |      delete_idbattr_valmap_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  valname
 |      valname
 |  
 |  value
 |      value

Help on function inf_abi_set_by_user in module ida_ida:

inf_abi_set_by_user(*args) -> 'bool'
    inf_abi_set_by_user() -> bool

Help on function inf_allow_non_matched_ops in module ida_ida:

inf_allow_non_matched_ops(*args) -> 'bool'
    inf_allow_non_matched_ops() -> bool

Help on function inf_allow_sigmulti in module ida_ida:

inf_allow_sigmulti(*args) -> 'bool'
    inf_allow_sigmulti() -> bool

Help on function inf_append_sigcmt in module ida_ida:

inf_append_sigcmt(*args) -> 'bool'
    inf_append_sigcmt() -> bool

Help on function inf_check_manual_ops in module ida_ida:

inf_check_manual_ops(*args) -> 'bool'
    inf_check_manual_ops() -> bool

Help on function inf_check_unicode_strlits in module ida_ida:

inf_check_unicode_strlits(*args) -> 'bool'
    inf_check_unicode_strlits() -> bool

Help on function inf_coagulate_code in module ida_ida:

inf_coagulate_code(*args) -> 'bool'
    inf_coagulate_code() -> bool

Help on function inf_coagulate_data in module ida_ida:

inf_coagulate_data(*args) -> 'bool'
    inf_coagulate_data() -> bool

Help on function inf_compress_idb in module ida_ida:

inf_compress_idb(*args) -> 'bool'
    inf_compress_idb() -> bool

Help on function inf_create_all_xrefs in module ida_ida:

inf_create_all_xrefs(*args) -> 'bool'
    inf_create_all_xrefs() -> bool

Help on function inf_create_func_from_call in module ida_ida:

inf_create_func_from_call(*args) -> 'bool'
    inf_create_func_from_call() -> bool

Help on function inf_create_func_from_ptr in module ida_ida:

inf_create_func_from_ptr(*args) -> 'bool'
    inf_create_func_from_ptr() -> bool

Help on function inf_create_func_tails in module ida_ida:

inf_create_func_tails(*args) -> 'bool'
    inf_create_func_tails() -> bool

Help on function inf_create_jump_tables in module ida_ida:

inf_create_jump_tables(*args) -> 'bool'
    inf_create_jump_tables() -> bool

Help on function inf_create_off_on_dref in module ida_ida:

inf_create_off_on_dref(*args) -> 'bool'
    inf_create_off_on_dref() -> bool

Help on function inf_create_off_using_fixup in module ida_ida:

inf_create_off_using_fixup(*args) -> 'bool'
    inf_create_off_using_fixup() -> bool

Help on function inf_create_strlit_on_xref in module ida_ida:

inf_create_strlit_on_xref(*args) -> 'bool'
    inf_create_strlit_on_xref() -> bool

Help on function inf_data_offset in module ida_ida:

inf_data_offset(*args) -> 'bool'
    inf_data_offset() -> bool

Help on function inf_dbg_no_store_path in module ida_ida:

inf_dbg_no_store_path(*args) -> 'bool'
    inf_dbg_no_store_path() -> bool

Help on function inf_decode_fpp in module ida_ida:

inf_decode_fpp(*args) -> 'bool'
    inf_decode_fpp() -> bool

Help on function inf_del_no_xref_insns in module ida_ida:

inf_del_no_xref_insns(*args) -> 'bool'
    inf_del_no_xref_insns() -> bool

Help on function inf_final_pass in module ida_ida:

inf_final_pass(*args) -> 'bool'
    inf_final_pass() -> bool

Help on function inf_full_sp_ana in module ida_ida:

inf_full_sp_ana(*args) -> 'bool'
    inf_full_sp_ana() -> bool

Help on function inf_gen_assume in module ida_ida:

inf_gen_assume(*args) -> 'bool'
    inf_gen_assume() -> bool

Help on function inf_gen_org in module ida_ida:

inf_gen_org(*args) -> 'bool'
    inf_gen_org() -> bool

Help on function inf_get_abibits in module ida_ida:

inf_get_abibits(*args) -> 'uint32'
    inf_get_abibits() -> uint32

Help on function inf_get_af in module ida_ida:

inf_get_af(*args) -> 'uint32'
    inf_get_af() -> uint32

Help on function inf_get_af2 in module ida_ida:

inf_get_af2(*args) -> 'uint32'
    inf_get_af2() -> uint32

Help on function inf_get_af2_low in module ida_ida:

inf_get_af2_low(*args) -> 'ushort'
    inf_get_af2_low() -> ushort
    Get/set low 16bit half of inf.af2.

Help on function inf_get_af_high in module ida_ida:

inf_get_af_high(*args) -> 'ushort'
    inf_get_af_high() -> ushort

Help on function inf_get_af_low in module ida_ida:

inf_get_af_low(*args) -> 'ushort'
    inf_get_af_low() -> ushort
    Get/set low/high 16bit halves of inf.af.

Help on function inf_get_app_bitness in module ida_ida:

inf_get_app_bitness(*args) -> 'uint'
    inf_get_app_bitness() -> uint

Help on function inf_get_appcall_options in module ida_ida:

inf_get_appcall_options(*args) -> 'uint32'
    inf_get_appcall_options() -> uint32

Help on function inf_get_apptype in module ida_ida:

inf_get_apptype(*args) -> 'ushort'
    inf_get_apptype() -> ushort

Help on function inf_get_asmtype in module ida_ida:

inf_get_asmtype(*args) -> 'uchar'
    inf_get_asmtype() -> uchar

Help on function inf_get_baseaddr in module ida_ida:

inf_get_baseaddr(*args) -> 'uval_t'
    inf_get_baseaddr() -> uval_t

Help on function inf_get_bin_prefix_size in module ida_ida:

inf_get_bin_prefix_size(*args) -> 'short'
    inf_get_bin_prefix_size() -> short

Help on function inf_get_cc in module ida_ida:

inf_get_cc(*args) -> 'bool'
    inf_get_cc(out) -> bool
    
    @param out: compiler_info_t *

Help on function inf_get_cc_cm in module ida_ida:

inf_get_cc_cm(*args) -> 'cm_t'
    inf_get_cc_cm() -> cm_t

Help on function inf_get_cc_defalign in module ida_ida:

inf_get_cc_defalign(*args) -> 'uchar'
    inf_get_cc_defalign() -> uchar

Help on function inf_get_cc_id in module ida_ida:

inf_get_cc_id(*args) -> 'comp_t'
    inf_get_cc_id() -> comp_t

Help on function inf_get_cc_size_b in module ida_ida:

inf_get_cc_size_b(*args) -> 'uchar'
    inf_get_cc_size_b() -> uchar

Help on function inf_get_cc_size_e in module ida_ida:

inf_get_cc_size_e(*args) -> 'uchar'
    inf_get_cc_size_e() -> uchar

Help on function inf_get_cc_size_i in module ida_ida:

inf_get_cc_size_i(*args) -> 'uchar'
    inf_get_cc_size_i() -> uchar

Help on function inf_get_cc_size_l in module ida_ida:

inf_get_cc_size_l(*args) -> 'uchar'
    inf_get_cc_size_l() -> uchar

Help on function inf_get_cc_size_ldbl in module ida_ida:

inf_get_cc_size_ldbl(*args) -> 'uchar'
    inf_get_cc_size_ldbl() -> uchar

Help on function inf_get_cc_size_ll in module ida_ida:

inf_get_cc_size_ll(*args) -> 'uchar'
    inf_get_cc_size_ll() -> uchar

Help on function inf_get_cc_size_s in module ida_ida:

inf_get_cc_size_s(*args) -> 'uchar'
    inf_get_cc_size_s() -> uchar

Help on function inf_get_cmtflg in module ida_ida:

inf_get_cmtflg(*args) -> 'uchar'
    inf_get_cmtflg() -> uchar

Help on function inf_get_database_change_count in module ida_ida:

inf_get_database_change_count(*args) -> 'uint32'
    inf_get_database_change_count() -> uint32

Help on function inf_get_datatypes in module ida_ida:

inf_get_datatypes(*args) -> 'uval_t'
    inf_get_datatypes() -> uval_t

Help on function inf_get_demnames in module ida_ida:

inf_get_demnames(*args) -> 'uchar'
    inf_get_demnames() -> uchar

Help on function inf_get_filetype in module ida_ida:

inf_get_filetype(*args) -> 'filetype_t'
    inf_get_filetype() -> filetype_t

Help on function inf_get_genflags in module ida_ida:

inf_get_genflags(*args) -> 'ushort'
    inf_get_genflags() -> ushort

Help on function inf_get_highoff in module ida_ida:

inf_get_highoff(*args) -> 'ea_t'
    inf_get_highoff() -> ea_t

Help on function inf_get_indent in module ida_ida:

inf_get_indent(*args) -> 'uchar'
    inf_get_indent() -> uchar

Help on function inf_get_lenxref in module ida_ida:

inf_get_lenxref(*args) -> 'ushort'
    inf_get_lenxref() -> ushort

Help on function inf_get_lflags in module ida_ida:

inf_get_lflags(*args) -> 'uint32'
    inf_get_lflags() -> uint32

Help on function inf_get_limiter in module ida_ida:

inf_get_limiter(*args) -> 'uchar'
    inf_get_limiter() -> uchar

Help on function inf_get_listnames in module ida_ida:

inf_get_listnames(*args) -> 'uchar'
    inf_get_listnames() -> uchar

Help on function inf_get_long_demnames in module ida_ida:

inf_get_long_demnames(*args) -> 'uint32'
    inf_get_long_demnames() -> uint32

Help on function inf_get_lowoff in module ida_ida:

inf_get_lowoff(*args) -> 'ea_t'
    inf_get_lowoff() -> ea_t

Help on function inf_get_main in module ida_ida:

inf_get_main(*args) -> 'ea_t'
    inf_get_main() -> ea_t

Help on function inf_get_margin in module ida_ida:

inf_get_margin(*args) -> 'ushort'
    inf_get_margin() -> ushort

Help on function inf_get_max_autoname_len in module ida_ida:

inf_get_max_autoname_len(*args) -> 'ushort'
    inf_get_max_autoname_len() -> ushort

Help on function inf_get_max_ea in module ida_ida:

inf_get_max_ea(*args) -> 'ea_t'
    inf_get_max_ea() -> ea_t

Help on function inf_get_maxref in module ida_ida:

inf_get_maxref(*args) -> 'uval_t'
    inf_get_maxref() -> uval_t

Help on function inf_get_min_ea in module ida_ida:

inf_get_min_ea(*args) -> 'ea_t'
    inf_get_min_ea() -> ea_t

Help on function inf_get_nametype in module ida_ida:

inf_get_nametype(*args) -> 'char'
    inf_get_nametype() -> char

Help on function inf_get_netdelta in module ida_ida:

inf_get_netdelta(*args) -> 'sval_t'
    inf_get_netdelta() -> sval_t

Help on function inf_get_omax_ea in module ida_ida:

inf_get_omax_ea(*args) -> 'ea_t'
    inf_get_omax_ea() -> ea_t

Help on function inf_get_omin_ea in module ida_ida:

inf_get_omin_ea(*args) -> 'ea_t'
    inf_get_omin_ea() -> ea_t

Help on function inf_get_ostype in module ida_ida:

inf_get_ostype(*args) -> 'ushort'
    inf_get_ostype() -> ushort

Help on function inf_get_outflags in module ida_ida:

inf_get_outflags(*args) -> 'uint32'
    inf_get_outflags() -> uint32

Help on function inf_get_prefflag in module ida_ida:

inf_get_prefflag(*args) -> 'uchar'
    inf_get_prefflag() -> uchar

Help on function inf_get_privrange in module ida_ida:

inf_get_privrange(*args) -> 'range_t'
    inf_get_privrange(out) -> bool
    
    @param out: range_t *
    
    inf_get_privrange() -> range_t

Help on function inf_get_privrange_end_ea in module ida_ida:

inf_get_privrange_end_ea(*args) -> 'ea_t'
    inf_get_privrange_end_ea() -> ea_t

Help on function inf_get_privrange_start_ea in module ida_ida:

inf_get_privrange_start_ea(*args) -> 'ea_t'
    inf_get_privrange_start_ea() -> ea_t

Help on function inf_get_procname in module ida_ida:

inf_get_procname(*args) -> 'size_t'
    inf_get_procname() -> str

Help on function inf_get_refcmtnum in module ida_ida:

inf_get_refcmtnum(*args) -> 'uchar'
    inf_get_refcmtnum() -> uchar

Help on function inf_get_short_demnames in module ida_ida:

inf_get_short_demnames(*args) -> 'uint32'
    inf_get_short_demnames() -> uint32

Help on function inf_get_specsegs in module ida_ida:

inf_get_specsegs(*args) -> 'uchar'
    inf_get_specsegs() -> uchar

Help on function inf_get_start_cs in module ida_ida:

inf_get_start_cs(*args) -> 'sel_t'
    inf_get_start_cs() -> sel_t

Help on function inf_get_start_ea in module ida_ida:

inf_get_start_ea(*args) -> 'ea_t'
    inf_get_start_ea() -> ea_t

Help on function inf_get_start_ip in module ida_ida:

inf_get_start_ip(*args) -> 'ea_t'
    inf_get_start_ip() -> ea_t

Help on function inf_get_start_sp in module ida_ida:

inf_get_start_sp(*args) -> 'ea_t'
    inf_get_start_sp() -> ea_t

Help on function inf_get_start_ss in module ida_ida:

inf_get_start_ss(*args) -> 'sel_t'
    inf_get_start_ss() -> sel_t

Help on function inf_get_strlit_break in module ida_ida:

inf_get_strlit_break(*args) -> 'uchar'
    inf_get_strlit_break() -> uchar

Help on function inf_get_strlit_flags in module ida_ida:

inf_get_strlit_flags(*args) -> 'uchar'
    inf_get_strlit_flags() -> uchar

Help on function inf_get_strlit_pref in module ida_ida:

inf_get_strlit_pref(*args) -> 'size_t'
    inf_get_strlit_pref() -> str

Help on function inf_get_strlit_sernum in module ida_ida:

inf_get_strlit_sernum(*args) -> 'uval_t'
    inf_get_strlit_sernum() -> uval_t

Help on function inf_get_strlit_zeroes in module ida_ida:

inf_get_strlit_zeroes(*args) -> 'char'
    inf_get_strlit_zeroes() -> char

Help on function inf_get_strtype in module ida_ida:

inf_get_strtype(*args) -> 'int32'
    inf_get_strtype() -> int32

Help on function inf_get_type_xrefnum in module ida_ida:

inf_get_type_xrefnum(*args) -> 'uchar'
    inf_get_type_xrefnum() -> uchar

Help on function inf_get_version in module ida_ida:

inf_get_version(*args) -> 'ushort'
    inf_get_version() -> ushort

Help on function inf_get_xrefflag in module ida_ida:

inf_get_xrefflag(*args) -> 'uchar'
    inf_get_xrefflag() -> uchar

Help on function inf_get_xrefnum in module ida_ida:

inf_get_xrefnum(*args) -> 'uchar'
    inf_get_xrefnum() -> uchar

Help on function inf_guess_func_type in module ida_ida:

inf_guess_func_type(*args) -> 'bool'
    inf_guess_func_type() -> bool

Help on function inf_handle_eh in module ida_ida:

inf_handle_eh(*args) -> 'bool'
    inf_handle_eh() -> bool

Help on function inf_handle_rtti in module ida_ida:

inf_handle_rtti(*args) -> 'bool'
    inf_handle_rtti() -> bool

Help on function inf_hide_comments in module ida_ida:

inf_hide_comments(*args) -> 'bool'
    inf_hide_comments() -> bool

Help on function inf_hide_libfuncs in module ida_ida:

inf_hide_libfuncs(*args) -> 'bool'
    inf_hide_libfuncs() -> bool

Help on function inf_huge_arg_align in module ida_ida:

inf_huge_arg_align(*args) -> 'bool'
    inf_huge_arg_align() -> bool

Help on function inf_inc_database_change_count in module ida_ida:

inf_inc_database_change_count(*args) -> 'void'
    inf_inc_database_change_count(cnt=1)
    
    @param cnt: int

Help on function inf_is_16bit in module ida_ida:

inf_is_16bit(*args) -> 'bool'
    inf_is_16bit() -> bool

Help on function inf_is_32bit_exactly in module ida_ida:

inf_is_32bit_exactly(*args) -> 'bool'
    inf_is_32bit_exactly() -> bool

Help on function inf_is_32bit_or_higher in module ida_ida:

inf_is_32bit_or_higher(*args) -> 'bool'
    inf_is_32bit_or_higher() -> bool

Help on function inf_is_limiter_empty in module ida_ida:

inf_is_limiter_empty(*args) -> 'bool'
    inf_is_limiter_empty() -> bool

Help on function inf_is_limiter_thick in module ida_ida:

inf_is_limiter_thick(*args) -> 'bool'
    inf_is_limiter_thick() -> bool

Help on function inf_is_limiter_thin in module ida_ida:

inf_is_limiter_thin(*args) -> 'bool'
    inf_is_limiter_thin() -> bool

Help on function inf_macros_enabled in module ida_ida:

inf_macros_enabled(*args) -> 'bool'
    inf_macros_enabled() -> bool

Help on function inf_mark_code in module ida_ida:

inf_mark_code(*args) -> 'bool'
    inf_mark_code() -> bool

Help on function inf_no_store_user_info in module ida_ida:

inf_no_store_user_info(*args) -> 'bool'
    inf_no_store_user_info() -> bool

Help on function inf_noflow_to_data in module ida_ida:

inf_noflow_to_data(*args) -> 'bool'
    inf_noflow_to_data() -> bool

Help on function inf_noret_ana in module ida_ida:

inf_noret_ana(*args) -> 'bool'
    inf_noret_ana() -> bool

Help on function inf_op_offset in module ida_ida:

inf_op_offset(*args) -> 'bool'
    inf_op_offset() -> bool

Help on function inf_pack_idb in module ida_ida:

inf_pack_idb(*args) -> 'bool'
    inf_pack_idb() -> bool

Help on function inf_postinc_strlit_sernum in module ida_ida:

inf_postinc_strlit_sernum(*args) -> 'uval_t'
    inf_postinc_strlit_sernum(cnt=1) -> uval_t
    
    @param cnt: uval_t

Help on function inf_prefix_show_funcoff in module ida_ida:

inf_prefix_show_funcoff(*args) -> 'bool'
    inf_prefix_show_funcoff() -> bool

Help on function inf_prefix_show_segaddr in module ida_ida:

inf_prefix_show_segaddr(*args) -> 'bool'
    inf_prefix_show_segaddr() -> bool

Help on function inf_prefix_show_stack in module ida_ida:

inf_prefix_show_stack(*args) -> 'bool'
    inf_prefix_show_stack() -> bool

Help on function inf_prefix_truncate_opcode_bytes in module ida_ida:

inf_prefix_truncate_opcode_bytes(*args) -> 'bool'
    inf_prefix_truncate_opcode_bytes() -> bool

Help on function inf_propagate_regargs in module ida_ida:

inf_propagate_regargs(*args) -> 'bool'
    inf_propagate_regargs() -> bool

Help on function inf_propagate_stkargs in module ida_ida:

inf_propagate_stkargs(*args) -> 'bool'
    inf_propagate_stkargs() -> bool

Help on function inf_rename_jumpfunc in module ida_ida:

inf_rename_jumpfunc(*args) -> 'bool'
    inf_rename_jumpfunc() -> bool

Help on function inf_rename_nullsub in module ida_ida:

inf_rename_nullsub(*args) -> 'bool'
    inf_rename_nullsub() -> bool

Help on function inf_set_32bit in module ida_ida:

inf_set_32bit(*args) -> 'bool'
    inf_set_32bit(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_abi_set_by_user in module ida_ida:

inf_set_abi_set_by_user(*args) -> 'bool'
    inf_set_abi_set_by_user(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_abibits in module ida_ida:

inf_set_abibits(*args) -> 'bool'
    inf_set_abibits(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_af in module ida_ida:

inf_set_af(*args) -> 'bool'
    inf_set_af(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_af2 in module ida_ida:

inf_set_af2(*args) -> 'bool'
    inf_set_af2(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_af2_low in module ida_ida:

inf_set_af2_low(*args) -> 'void'
    inf_set_af2_low(saf)
    
    @param saf: ushort

Help on function inf_set_af_high in module ida_ida:

inf_set_af_high(*args) -> 'void'
    inf_set_af_high(saf2)
    
    @param saf2: ushort

Help on function inf_set_af_low in module ida_ida:

inf_set_af_low(*args) -> 'void'
    inf_set_af_low(saf)
    
    @param saf: ushort

Help on function inf_set_allow_non_matched_ops in module ida_ida:

inf_set_allow_non_matched_ops(*args) -> 'bool'
    inf_set_allow_non_matched_ops(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_allow_sigmulti in module ida_ida:

inf_set_allow_sigmulti(*args) -> 'bool'
    inf_set_allow_sigmulti(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_appcall_options in module ida_ida:

inf_set_appcall_options(*args) -> 'bool'
    inf_set_appcall_options(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_append_sigcmt in module ida_ida:

inf_set_append_sigcmt(*args) -> 'bool'
    inf_set_append_sigcmt(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_apptype in module ida_ida:

inf_set_apptype(*args) -> 'bool'
    inf_set_apptype(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_asmtype in module ida_ida:

inf_set_asmtype(*args) -> 'bool'
    inf_set_asmtype(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_baseaddr in module ida_ida:

inf_set_baseaddr(*args) -> 'bool'
    inf_set_baseaddr(_v) -> bool
    
    @param _v: uval_t

Help on function inf_set_big_arg_align in module ida_ida:

inf_set_big_arg_align(*args) -> 'bool'
    inf_set_big_arg_align(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_bin_prefix_size in module ida_ida:

inf_set_bin_prefix_size(*args) -> 'bool'
    inf_set_bin_prefix_size(_v) -> bool
    
    @param _v: short

Help on function inf_set_cc in module ida_ida:

inf_set_cc(*args) -> 'bool'
    inf_set_cc(_v) -> bool
    
    @param _v: compiler_info_t const &

Help on function inf_set_cc_cm in module ida_ida:

inf_set_cc_cm(*args) -> 'bool'
    inf_set_cc_cm(_v) -> bool
    
    @param _v: cm_t

Help on function inf_set_cc_defalign in module ida_ida:

inf_set_cc_defalign(*args) -> 'bool'
    inf_set_cc_defalign(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_id in module ida_ida:

inf_set_cc_id(*args) -> 'bool'
    inf_set_cc_id(_v) -> bool
    
    @param _v: comp_t

Help on function inf_set_cc_size_b in module ida_ida:

inf_set_cc_size_b(*args) -> 'bool'
    inf_set_cc_size_b(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_size_e in module ida_ida:

inf_set_cc_size_e(*args) -> 'bool'
    inf_set_cc_size_e(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_size_i in module ida_ida:

inf_set_cc_size_i(*args) -> 'bool'
    inf_set_cc_size_i(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_size_l in module ida_ida:

inf_set_cc_size_l(*args) -> 'bool'
    inf_set_cc_size_l(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_size_ldbl in module ida_ida:

inf_set_cc_size_ldbl(*args) -> 'bool'
    inf_set_cc_size_ldbl(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_size_ll in module ida_ida:

inf_set_cc_size_ll(*args) -> 'bool'
    inf_set_cc_size_ll(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_cc_size_s in module ida_ida:

inf_set_cc_size_s(*args) -> 'bool'
    inf_set_cc_size_s(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_check_manual_ops in module ida_ida:

inf_set_check_manual_ops(*args) -> 'bool'
    inf_set_check_manual_ops(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_check_unicode_strlits in module ida_ida:

inf_set_check_unicode_strlits(*args) -> 'bool'
    inf_set_check_unicode_strlits(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_cmtflg in module ida_ida:

inf_set_cmtflg(*args) -> 'bool'
    inf_set_cmtflg(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_coagulate_code in module ida_ida:

inf_set_coagulate_code(*args) -> 'bool'
    inf_set_coagulate_code(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_coagulate_data in module ida_ida:

inf_set_coagulate_data(*args) -> 'bool'
    inf_set_coagulate_data(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_compress_idb in module ida_ida:

inf_set_compress_idb(*args) -> 'bool'
    inf_set_compress_idb(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_all_xrefs in module ida_ida:

inf_set_create_all_xrefs(*args) -> 'bool'
    inf_set_create_all_xrefs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_func_from_call in module ida_ida:

inf_set_create_func_from_call(*args) -> 'bool'
    inf_set_create_func_from_call(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_func_from_ptr in module ida_ida:

inf_set_create_func_from_ptr(*args) -> 'bool'
    inf_set_create_func_from_ptr(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_func_tails in module ida_ida:

inf_set_create_func_tails(*args) -> 'bool'
    inf_set_create_func_tails(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_jump_tables in module ida_ida:

inf_set_create_jump_tables(*args) -> 'bool'
    inf_set_create_jump_tables(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_off_on_dref in module ida_ida:

inf_set_create_off_on_dref(*args) -> 'bool'
    inf_set_create_off_on_dref(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_off_using_fixup in module ida_ida:

inf_set_create_off_using_fixup(*args) -> 'bool'
    inf_set_create_off_using_fixup(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_create_strlit_on_xref in module ida_ida:

inf_set_create_strlit_on_xref(*args) -> 'bool'
    inf_set_create_strlit_on_xref(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_data_offset in module ida_ida:

inf_set_data_offset(*args) -> 'bool'
    inf_set_data_offset(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_database_change_count in module ida_ida:

inf_set_database_change_count(*args) -> 'bool'
    inf_set_database_change_count(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_datatypes in module ida_ida:

inf_set_datatypes(*args) -> 'bool'
    inf_set_datatypes(_v) -> bool
    
    @param _v: uval_t

Help on function inf_set_dbg_no_store_path in module ida_ida:

inf_set_dbg_no_store_path(*args) -> 'bool'
    inf_set_dbg_no_store_path(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_decode_fpp in module ida_ida:

inf_set_decode_fpp(*args) -> 'bool'
    inf_set_decode_fpp(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_del_no_xref_insns in module ida_ida:

inf_set_del_no_xref_insns(*args) -> 'bool'
    inf_set_del_no_xref_insns(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_demnames in module ida_ida:

inf_set_demnames(*args) -> 'bool'
    inf_set_demnames(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_dll in module ida_ida:

inf_set_dll(*args) -> 'bool'
    inf_set_dll(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_filetype in module ida_ida:

inf_set_filetype(*args) -> 'bool'
    inf_set_filetype(_v) -> bool
    
    @param _v: enum filetype_t

Help on function inf_set_final_pass in module ida_ida:

inf_set_final_pass(*args) -> 'bool'
    inf_set_final_pass(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_flat_off32 in module ida_ida:

inf_set_flat_off32(*args) -> 'bool'
    inf_set_flat_off32(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_full_sp_ana in module ida_ida:

inf_set_full_sp_ana(*args) -> 'bool'
    inf_set_full_sp_ana(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_gen_assume in module ida_ida:

inf_set_gen_assume(*args) -> 'bool'
    inf_set_gen_assume(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_gen_org in module ida_ida:

inf_set_gen_org(*args) -> 'bool'
    inf_set_gen_org(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_genflags in module ida_ida:

inf_set_genflags(*args) -> 'bool'
    inf_set_genflags(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_guess_func_type in module ida_ida:

inf_set_guess_func_type(*args) -> 'bool'
    inf_set_guess_func_type(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_handle_eh in module ida_ida:

inf_set_handle_eh(*args) -> 'bool'
    inf_set_handle_eh(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_handle_rtti in module ida_ida:

inf_set_handle_rtti(*args) -> 'bool'
    inf_set_handle_rtti(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_hard_float in module ida_ida:

inf_set_hard_float(*args) -> 'bool'
    inf_set_hard_float(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_hide_comments in module ida_ida:

inf_set_hide_comments(*args) -> 'bool'
    inf_set_hide_comments(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_hide_libfuncs in module ida_ida:

inf_set_hide_libfuncs(*args) -> 'bool'
    inf_set_hide_libfuncs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_highoff in module ida_ida:

inf_set_highoff(*args) -> 'bool'
    inf_set_highoff(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_huge_arg_align in module ida_ida:

inf_set_huge_arg_align(*args) -> 'bool'
    inf_set_huge_arg_align(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_indent in module ida_ida:

inf_set_indent(*args) -> 'bool'
    inf_set_indent(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_kernel_mode in module ida_ida:

inf_set_kernel_mode(*args) -> 'bool'
    inf_set_kernel_mode(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_lenxref in module ida_ida:

inf_set_lenxref(*args) -> 'bool'
    inf_set_lenxref(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_lflags in module ida_ida:

inf_set_lflags(*args) -> 'bool'
    inf_set_lflags(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_limiter in module ida_ida:

inf_set_limiter(*args) -> 'bool'
    inf_set_limiter(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_limiter_empty in module ida_ida:

inf_set_limiter_empty(*args) -> 'bool'
    inf_set_limiter_empty(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_limiter_thick in module ida_ida:

inf_set_limiter_thick(*args) -> 'bool'
    inf_set_limiter_thick(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_limiter_thin in module ida_ida:

inf_set_limiter_thin(*args) -> 'bool'
    inf_set_limiter_thin(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_listnames in module ida_ida:

inf_set_listnames(*args) -> 'bool'
    inf_set_listnames(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_loading_idc in module ida_ida:

inf_set_loading_idc(*args) -> 'bool'
    inf_set_loading_idc(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_long_demnames in module ida_ida:

inf_set_long_demnames(*args) -> 'bool'
    inf_set_long_demnames(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_lowoff in module ida_ida:

inf_set_lowoff(*args) -> 'bool'
    inf_set_lowoff(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_macros_enabled in module ida_ida:

inf_set_macros_enabled(*args) -> 'bool'
    inf_set_macros_enabled(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_main in module ida_ida:

inf_set_main(*args) -> 'bool'
    inf_set_main(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_map_stkargs in module ida_ida:

inf_set_map_stkargs(*args) -> 'bool'
    inf_set_map_stkargs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_margin in module ida_ida:

inf_set_margin(*args) -> 'bool'
    inf_set_margin(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_mark_code in module ida_ida:

inf_set_mark_code(*args) -> 'bool'
    inf_set_mark_code(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_max_autoname_len in module ida_ida:

inf_set_max_autoname_len(*args) -> 'bool'
    inf_set_max_autoname_len(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_max_ea in module ida_ida:

inf_set_max_ea(*args) -> 'bool'
    inf_set_max_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_maxref in module ida_ida:

inf_set_maxref(*args) -> 'bool'
    inf_set_maxref(_v) -> bool
    
    @param _v: uval_t

Help on function inf_set_mem_aligned4 in module ida_ida:

inf_set_mem_aligned4(*args) -> 'bool'
    inf_set_mem_aligned4(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_min_ea in module ida_ida:

inf_set_min_ea(*args) -> 'bool'
    inf_set_min_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_nametype in module ida_ida:

inf_set_nametype(*args) -> 'bool'
    inf_set_nametype(_v) -> bool
    
    @param _v: char

Help on function inf_set_netdelta in module ida_ida:

inf_set_netdelta(*args) -> 'bool'
    inf_set_netdelta(_v) -> bool
    
    @param _v: sval_t

Help on function inf_set_no_store_user_info in module ida_ida:

inf_set_no_store_user_info(*args) -> 'bool'
    inf_set_no_store_user_info(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_noflow_to_data in module ida_ida:

inf_set_noflow_to_data(*args) -> 'bool'
    inf_set_noflow_to_data(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_noret_ana in module ida_ida:

inf_set_noret_ana(*args) -> 'bool'
    inf_set_noret_ana(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_omax_ea in module ida_ida:

inf_set_omax_ea(*args) -> 'bool'
    inf_set_omax_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_omin_ea in module ida_ida:

inf_set_omin_ea(*args) -> 'bool'
    inf_set_omin_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_op_offset in module ida_ida:

inf_set_op_offset(*args) -> 'bool'
    inf_set_op_offset(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_ostype in module ida_ida:

inf_set_ostype(*args) -> 'bool'
    inf_set_ostype(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_outflags in module ida_ida:

inf_set_outflags(*args) -> 'bool'
    inf_set_outflags(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_pack_idb in module ida_ida:

inf_set_pack_idb(*args) -> 'bool'
    inf_set_pack_idb(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_pack_stkargs in module ida_ida:

inf_set_pack_stkargs(*args) -> 'bool'
    inf_set_pack_stkargs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_prefflag in module ida_ida:

inf_set_prefflag(*args) -> 'bool'
    inf_set_prefflag(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_prefix_show_funcoff in module ida_ida:

inf_set_prefix_show_funcoff(*args) -> 'bool'
    inf_set_prefix_show_funcoff(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_prefix_show_segaddr in module ida_ida:

inf_set_prefix_show_segaddr(*args) -> 'bool'
    inf_set_prefix_show_segaddr(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_prefix_show_stack in module ida_ida:

inf_set_prefix_show_stack(*args) -> 'bool'
    inf_set_prefix_show_stack(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_prefix_truncate_opcode_bytes in module ida_ida:

inf_set_prefix_truncate_opcode_bytes(*args) -> 'bool'
    inf_set_prefix_truncate_opcode_bytes(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_privrange in module ida_ida:

inf_set_privrange(*args) -> 'bool'
    inf_set_privrange(_v) -> bool
    
    @param _v: range_t const &

Help on function inf_set_privrange_end_ea in module ida_ida:

inf_set_privrange_end_ea(*args) -> 'bool'
    inf_set_privrange_end_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_privrange_start_ea in module ida_ida:

inf_set_privrange_start_ea(*args) -> 'bool'
    inf_set_privrange_start_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_procname in module ida_ida:

inf_set_procname(*args) -> 'bool'
    inf_set_procname(_v, len=size_t(-1)) -> bool
    
    @param _v: char const *
    @param len: size_t

Help on function inf_set_propagate_regargs in module ida_ida:

inf_set_propagate_regargs(*args) -> 'bool'
    inf_set_propagate_regargs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_propagate_stkargs in module ida_ida:

inf_set_propagate_stkargs(*args) -> 'bool'
    inf_set_propagate_stkargs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_readonly_idb in module ida_ida:

inf_set_readonly_idb(*args) -> 'bool'
    inf_set_readonly_idb(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_refcmtnum in module ida_ida:

inf_set_refcmtnum(*args) -> 'bool'
    inf_set_refcmtnum(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_rename_jumpfunc in module ida_ida:

inf_set_rename_jumpfunc(*args) -> 'bool'
    inf_set_rename_jumpfunc(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_rename_nullsub in module ida_ida:

inf_set_rename_nullsub(*args) -> 'bool'
    inf_set_rename_nullsub(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_short_demnames in module ida_ida:

inf_set_short_demnames(*args) -> 'bool'
    inf_set_short_demnames(_v) -> bool
    
    @param _v: uint32

Help on function inf_set_should_create_stkvars in module ida_ida:

inf_set_should_create_stkvars(*args) -> 'bool'
    inf_set_should_create_stkvars(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_should_trace_sp in module ida_ida:

inf_set_should_trace_sp(*args) -> 'bool'
    inf_set_should_trace_sp(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_all_comments in module ida_ida:

inf_set_show_all_comments(*args) -> 'bool'
    inf_set_show_all_comments(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_hidden_funcs in module ida_ida:

inf_set_show_hidden_funcs(*args) -> 'bool'
    inf_set_show_hidden_funcs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_hidden_insns in module ida_ida:

inf_set_show_hidden_insns(*args) -> 'bool'
    inf_set_show_hidden_insns(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_hidden_segms in module ida_ida:

inf_set_show_hidden_segms(*args) -> 'bool'
    inf_set_show_hidden_segms(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_repeatables in module ida_ida:

inf_set_show_repeatables(*args) -> 'bool'
    inf_set_show_repeatables(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_src_linnum in module ida_ida:

inf_set_show_src_linnum(*args) -> 'bool'
    inf_set_show_src_linnum(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_xref_fncoff in module ida_ida:

inf_set_show_xref_fncoff(*args) -> 'bool'
    inf_set_show_xref_fncoff(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_xref_seg in module ida_ida:

inf_set_show_xref_seg(*args) -> 'bool'
    inf_set_show_xref_seg(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_xref_tmarks in module ida_ida:

inf_set_show_xref_tmarks(*args) -> 'bool'
    inf_set_show_xref_tmarks(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_show_xref_val in module ida_ida:

inf_set_show_xref_val(*args) -> 'bool'
    inf_set_show_xref_val(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_snapshot in module ida_ida:

inf_set_snapshot(*args) -> 'bool'
    inf_set_snapshot(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_specsegs in module ida_ida:

inf_set_specsegs(*args) -> 'bool'
    inf_set_specsegs(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_stack_ldbl in module ida_ida:

inf_set_stack_ldbl(*args) -> 'bool'
    inf_set_stack_ldbl(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_stack_varargs in module ida_ida:

inf_set_stack_varargs(*args) -> 'bool'
    inf_set_stack_varargs(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_start_cs in module ida_ida:

inf_set_start_cs(*args) -> 'bool'
    inf_set_start_cs(_v) -> bool
    
    @param _v: sel_t

Help on function inf_set_start_ea in module ida_ida:

inf_set_start_ea(*args) -> 'bool'
    inf_set_start_ea(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_start_ip in module ida_ida:

inf_set_start_ip(*args) -> 'bool'
    inf_set_start_ip(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_start_sp in module ida_ida:

inf_set_start_sp(*args) -> 'bool'
    inf_set_start_sp(_v) -> bool
    
    @param _v: ea_t

Help on function inf_set_start_ss in module ida_ida:

inf_set_start_ss(*args) -> 'bool'
    inf_set_start_ss(_v) -> bool
    
    @param _v: sel_t

Help on function inf_set_strlit_autocmt in module ida_ida:

inf_set_strlit_autocmt(*args) -> 'bool'
    inf_set_strlit_autocmt(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_strlit_break in module ida_ida:

inf_set_strlit_break(*args) -> 'bool'
    inf_set_strlit_break(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_strlit_flags in module ida_ida:

inf_set_strlit_flags(*args) -> 'bool'
    inf_set_strlit_flags(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_strlit_name_bit in module ida_ida:

inf_set_strlit_name_bit(*args) -> 'bool'
    inf_set_strlit_name_bit(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_strlit_names in module ida_ida:

inf_set_strlit_names(*args) -> 'bool'
    inf_set_strlit_names(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_strlit_pref in module ida_ida:

inf_set_strlit_pref(*args) -> 'bool'
    inf_set_strlit_pref(_v, len=size_t(-1)) -> bool
    
    @param _v: char const *
    @param len: size_t

Help on function inf_set_strlit_savecase in module ida_ida:

inf_set_strlit_savecase(*args) -> 'bool'
    inf_set_strlit_savecase(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_strlit_serial_names in module ida_ida:

inf_set_strlit_serial_names(*args) -> 'bool'
    inf_set_strlit_serial_names(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_strlit_sernum in module ida_ida:

inf_set_strlit_sernum(*args) -> 'bool'
    inf_set_strlit_sernum(_v) -> bool
    
    @param _v: uval_t

Help on function inf_set_strlit_zeroes in module ida_ida:

inf_set_strlit_zeroes(*args) -> 'bool'
    inf_set_strlit_zeroes(_v) -> bool
    
    @param _v: char

Help on function inf_set_strtype in module ida_ida:

inf_set_strtype(*args) -> 'bool'
    inf_set_strtype(_v) -> bool
    
    @param _v: int32

Help on function inf_set_trace_flow in module ida_ida:

inf_set_trace_flow(*args) -> 'bool'
    inf_set_trace_flow(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_truncate_on_del in module ida_ida:

inf_set_truncate_on_del(*args) -> 'bool'
    inf_set_truncate_on_del(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_type_xrefnum in module ida_ida:

inf_set_type_xrefnum(*args) -> 'bool'
    inf_set_type_xrefnum(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_unicode_strlits in module ida_ida:

inf_set_unicode_strlits(*args) -> 'bool'
    inf_set_unicode_strlits(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_use_allasm in module ida_ida:

inf_set_use_allasm(*args) -> 'bool'
    inf_set_use_allasm(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_use_flirt in module ida_ida:

inf_set_use_flirt(*args) -> 'bool'
    inf_set_use_flirt(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_use_gcc_layout in module ida_ida:

inf_set_use_gcc_layout(*args) -> 'bool'
    inf_set_use_gcc_layout(_v=True) -> bool
    
    @param _v: bool

Help on function inf_set_version in module ida_ida:

inf_set_version(*args) -> 'bool'
    inf_set_version(_v) -> bool
    
    @param _v: ushort

Help on function inf_set_xrefflag in module ida_ida:

inf_set_xrefflag(*args) -> 'bool'
    inf_set_xrefflag(_v) -> bool
    
    @param _v: uchar

Help on function inf_set_xrefnum in module ida_ida:

inf_set_xrefnum(*args) -> 'bool'
    inf_set_xrefnum(_v) -> bool
    
    @param _v: uchar

Help on function inf_should_create_stkvars in module ida_ida:

inf_should_create_stkvars(*args) -> 'bool'
    inf_should_create_stkvars() -> bool

Help on function inf_should_trace_sp in module ida_ida:

inf_should_trace_sp(*args) -> 'bool'
    inf_should_trace_sp() -> bool

Help on function inf_show_all_comments in module ida_ida:

inf_show_all_comments(*args) -> 'bool'
    inf_show_all_comments() -> bool

Help on function inf_show_hidden_funcs in module ida_ida:

inf_show_hidden_funcs(*args) -> 'bool'
    inf_show_hidden_funcs() -> bool

Help on function inf_show_hidden_insns in module ida_ida:

inf_show_hidden_insns(*args) -> 'bool'
    inf_show_hidden_insns() -> bool

Help on function inf_show_hidden_segms in module ida_ida:

inf_show_hidden_segms(*args) -> 'bool'
    inf_show_hidden_segms() -> bool

Help on function inf_show_repeatables in module ida_ida:

inf_show_repeatables(*args) -> 'bool'
    inf_show_repeatables() -> bool

Help on function inf_show_src_linnum in module ida_ida:

inf_show_src_linnum(*args) -> 'bool'
    inf_show_src_linnum() -> bool

Help on function inf_show_xref_fncoff in module ida_ida:

inf_show_xref_fncoff(*args) -> 'bool'
    inf_show_xref_fncoff() -> bool

Help on function inf_show_xref_seg in module ida_ida:

inf_show_xref_seg(*args) -> 'bool'
    inf_show_xref_seg() -> bool

Help on function inf_show_xref_tmarks in module ida_ida:

inf_show_xref_tmarks(*args) -> 'bool'
    inf_show_xref_tmarks() -> bool

Help on function inf_show_xref_val in module ida_ida:

inf_show_xref_val(*args) -> 'bool'
    inf_show_xref_val() -> bool

Help on function inf_strlit_autocmt in module ida_ida:

inf_strlit_autocmt(*args) -> 'bool'
    inf_strlit_autocmt() -> bool

Help on function inf_strlit_name_bit in module ida_ida:

inf_strlit_name_bit(*args) -> 'bool'
    inf_strlit_name_bit() -> bool

Help on function inf_strlit_names in module ida_ida:

inf_strlit_names(*args) -> 'bool'
    inf_strlit_names() -> bool

Help on function inf_strlit_savecase in module ida_ida:

inf_strlit_savecase(*args) -> 'bool'
    inf_strlit_savecase() -> bool

Help on function inf_strlit_serial_names in module ida_ida:

inf_strlit_serial_names(*args) -> 'bool'
    inf_strlit_serial_names() -> bool

Help on function inf_test_mode in module ida_ida:

inf_test_mode(*args) -> 'bool'
    inf_test_mode() -> bool

Help on function inf_trace_flow in module ida_ida:

inf_trace_flow(*args) -> 'bool'
    inf_trace_flow() -> bool

Help on function inf_truncate_on_del in module ida_ida:

inf_truncate_on_del(*args) -> 'bool'
    inf_truncate_on_del() -> bool

Help on function inf_unicode_strlits in module ida_ida:

inf_unicode_strlits(*args) -> 'bool'
    inf_unicode_strlits() -> bool

Help on function inf_use_flirt in module ida_ida:

inf_use_flirt(*args) -> 'bool'
    inf_use_flirt() -> bool

Help on function is_filetype_like_binary in module ida_ida:

is_filetype_like_binary(*args) -> 'bool'
    is_filetype_like_binary(ft) -> bool
    Is unstructured input file?
    
    @param ft: (C++: filetype_t) enum filetype_t

Help on function <lambda> in module ida_ida:

<lambda> lambda *args

Help on function switch_dbctx in module ida_ida:

switch_dbctx(*args) -> 'dbctx_t *'
    switch_dbctx(idx) -> dbctx_t *
    Switch to the database with the provided context ID
    
    @param idx: (C++: size_t) the index of the database to switch to
    @return: the current dbctx_t instance or nullptr

Help on function to_ea in module ida_ida:

to_ea(*args) -> 'ea_t'
    to_ea(reg_cs, reg_ip) -> ea_t
    Convert (sel,off) value to a linear address.
    
    @param reg_cs: (C++: sel_t)
    @param reg_ip: (C++: uval_t)

Module "ida_idaapi"s docstring:
"""None"""

Help on class CustomIDAMemo in module ida_kernwin:

class CustomIDAMemo(View_Hooks)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Method resolution order:
 |      CustomIDAMemo
 |      View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  __init__(self)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> View_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |      A view is activated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |      Click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |      View closed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |      Cursor position changed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |      Double click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |      A view is deactivated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |      Key down event
 |      
 |      @param view: (TWidget *)
 |      @param key: (int)
 |      @param state: (::view_event_state_t)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |      The location for the view has changed (can be either the place_t, the
 |      renderer_info_t, or both.)
 |      
 |      @param view: (TWidget *)
 |      @param now: (const lochist_entry_t *)
 |      @param was: (const lochist_entry_t *)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |      The mouse moved on the view
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |      The user moved the mouse over (or out of) a node or an edge. This is only
 |      relevant in a graph view.
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |      A view's renderer has changed.
 |      
 |      @param view: (TWidget *)
 |      @param rt: (tcc_renderer_type_t)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |      A view is being created.
 |      
 |      @param view: (TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on __IDAPython_Completion_Util in module ida_idaapi object:

class __IDAPython_Completion_Util(builtins.object)
 |  Internal utility class for auto-completion support
 |  
 |  Methods defined here:
 |  
 |  __call__(self, line, x)
 |      Call self as a function.
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  debug(self, *args)
 |  
 |  dir_namespace(self, m, prefix)
 |  
 |  get_candidates(self, qname, line, match_syntax_char)
 |  
 |  maybe_extend_syntactically(self, ns, name, line, syntax_char)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  QNAME_PAT = re.compile('([a-zA-Z_]([a-zA-Z0-9_\\.]*)?)')

Help on function IDAPython_ExecScript in module ida_idaapi:

IDAPython_ExecScript(path, g, print_error=True)
    Run the specified script.
    
    This function is used by the low-level plugin code.

Help on function IDAPython_ExecSystem in module ida_idaapi:

IDAPython_ExecSystem(cmd)
    Executes a command with popen().

Help on function IDAPython_FormatExc in module ida_idaapi:

IDAPython_FormatExc(etype, value=None, tb=None, limit=None)
    This function is used to format an exception given the
    values returned by a PyErr_Fetch()

Help on function IDAPython_LoadProcMod in module ida_idaapi:

IDAPython_LoadProcMod(path, g, print_error=True)
    Load processor module.

Help on function IDAPython_UnLoadProcMod in module ida_idaapi:

IDAPython_UnLoadProcMod(script, g, print_error=True)
    Unload processor module.

Help on class IDAPython_displayhook in module ida_idaapi:

class IDAPython_displayhook(builtins.object)
 |  # ------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _print_hex(self, x)
 |  
 |  displayhook(self, item)
 |  
 |  format_item(self, num_printer, storage, item)
 |  
 |  format_seq(self, num_printer, storage, item, opn, cls)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class PyIdc_cvt_int64__ in module ida_idaapi:

class PyIdc_cvt_int64__(pyidc_cvt_helper__)
 |  Helper class for explicitly representing VT_INT64 values
 |  
 |  Method resolution order:
 |      PyIdc_cvt_int64__
 |      pyidc_cvt_helper__
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  _PyIdc_cvt_int64____op = __op(self, op_n, other, rev=False)
 |  
 |  __add__(self, other)
 |  
 |  __div__(self, other)
 |  
 |  __init__(self, v)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __mul__(self, other)
 |  
 |  __radd__(self, other)
 |  
 |  __rdiv__(self, other)
 |  
 |  __rmul__(self, other)
 |  
 |  __rsub__(self, other)
 |  
 |  __sub__(self, other)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _PyIdc_cvt_int64____op_table = {0: <function PyIdc_cvt_int64__.<lambda...
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pyidc_cvt_helper__:
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_cvt_helper__:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on class PyIdc_cvt_refclass__ in module ida_idaapi:

class PyIdc_cvt_refclass__(pyidc_cvt_helper__)
 |  Helper class for representing references to immutable objects
 |  
 |  Method resolution order:
 |      PyIdc_cvt_refclass__
 |      pyidc_cvt_helper__
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, v)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  cstr(self)
 |      Returns the string as a C string (up to the zero termination)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from pyidc_cvt_helper__:
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_cvt_helper__:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on IDAPython_displayhook in module ida_idaapi object:

class IDAPython_displayhook(builtins.object)
 |  # ------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _print_hex(self, x)
 |  
 |  displayhook(self, item)
 |  
 |  format_item(self, num_printer, storage, item)
 |  
 |  format_seq(self, num_printer, storage, item, opn, cls)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class __IDAPython_Completion_Util in module ida_idaapi:

class __IDAPython_Completion_Util(builtins.object)
 |  Internal utility class for auto-completion support
 |  
 |  Methods defined here:
 |  
 |  __call__(self, line, x)
 |      Call self as a function.
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  debug(self, *args)
 |  
 |  dir_namespace(self, m, prefix)
 |  
 |  get_candidates(self, qname, line, match_syntax_char)
 |  
 |  maybe_extend_syntactically(self, ns, name, line, syntax_char)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  QNAME_PAT = re.compile('([a-zA-Z_]([a-zA-Z0-9_\\.]*)?)')

Help on function __install_excepthook in module ida_idaapi:

__install_excepthook()
    # Since version 5.5, PyQt5 doesn't simply print the PyQt exceptions by default
    # anymore: https://github.com/baoboa/pyqt5/commit/1e1d8a3ba677ef3e47b916b8a5b9c281d0f8e4b5#diff-848704a82f6a6e3a13112145ce32ac69L63
    # The default behavior now is that qFatal() is called, causing the application
    # to abort().
    # We do not want that to happen in IDA, and simply having a sys.excepthook
    # that is different from sys.__excepthook__ is enough for PyQt5 to return
    # to the previous behavior

Help on function _bounded_getitem_iterator in module ida_idaapi:

_bounded_getitem_iterator(self)
    Helper function, to be set as __iter__ method for qvector-, or array-based classes.

Help on function _listify_types in module ida_idaapi:

_listify_types(*classes)

Help on function _make_missed_695bwcompat_property in module ida_idaapi:

_make_missed_695bwcompat_property(bad_attr, new_attr, has_setter)

Help on function _make_one_time_warning_message in module ida_idaapi:

_make_one_time_warning_message(bad_attr, new_attr)

Help on function _qvector_back in module ida_idaapi:

_qvector_back(self)
    # -----------------------------------------------------------------------

Help on function _qvector_front in module ida_idaapi:

_qvector_front(self)
    # -----------------------------------------------------------------------

Help on function _replace_module_function in module ida_idaapi:

_replace_module_function(replacement)

Help on function _utf8_native in module ida_idaapi:

_utf8_native(utf8)

Help on function as_UTF16 in module ida_idaapi:

as_UTF16(s)
    Convenience function to convert a string into appropriate unicode format

Help on function as_cstr in module ida_idaapi:

as_cstr(val)
    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
    It scans for the first \x00 and returns the string value up to that point.

Help on function as_int32 in module ida_idaapi:

as_int32(v)
    Returns a number as a signed int32 number

Help on function as_signed in module ida_idaapi:

as_signed(v, nbits=32)
    Returns a number as signed. The number of bits are specified by the user.
    The MSB holds the sign.

Help on function as_uint32 in module ida_idaapi:

as_uint32(v)
    Returns a number as an unsigned int32 number

Help on function copy_bits in module ida_idaapi:

copy_bits(v, s, e=-1)
    Copy bits from a value
    @param v: the value
    @param s: starting bit (0-based)
    @param e: ending bit

Help on function disable_script_timeout in module ida_idaapi:

disable_script_timeout(*args) -> 'void'
    disable_script_timeout()
    Disables the script timeout and hides the script wait box.
    Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
    
    @return: None

Help on function enable_extlang_python in module ida_idaapi:

enable_extlang_python(*args) -> 'void'
    enable_extlang_python(enable)
    Enables or disables Python extlang.
    When enabled, all expressions will be evaluated by Python.
    
    @param enable: Set to True to enable, False otherwise

Help on function enable_python_cli in module ida_idaapi:

enable_python_cli(*args) -> 'void'
    enable_python_cli(enable)
    
    @param enable: bool

Help on function format_basestring in module ida_idaapi:

format_basestring(*args) -> 'PyObject *'
    format_basestring(_in) -> str
    
    @param _in: PyObject *

Help on function get_inf_structure in module ida_idaapi:

get_inf_structure(*args) -> 'idainfo *'
    get_inf_structure() -> idainfo
    Returns the global variable 'inf' (an instance of idainfo structure, see ida.hpp)

Help on class loader_input_t in module ida_idaapi:

class loader_input_t(builtins.object)
 |  A helper class to work with linput_t related functions.
 |  This class is also used by file loaders scripts.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, pycapsule=None) -> loader_input_t
 |      
 |      @param pycapsule: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_loader_input_t(...)
 |      delete_loader_input_t(self)
 |  
 |  close(self, *args) -> 'void'
 |      close(self)
 |      Closes the file
 |  
 |  file2base(self, *args) -> 'int'
 |      file2base(self, pos, ea1, ea2, patchable) -> int
 |      Load portion of file into the database
 |      This function will include (ea1..ea2) into the addressing space of the
 |      program (make it enabled)
 |      
 |      @param pos: position in the file
 |      @param ea1: ..ea2): range of destination linear addresses
 |      @param ea1: ..ea2): range of destination linear addresses
 |      @param patchable: should the kernel remember correspondance of
 |                        file offsets to linear addresses.
 |      @return: 1-ok,0-read error, a warning is displayed
 |  
 |  filename(self, *args) -> 'PyObject *'
 |      filename(self) -> PyObject *
 |  
 |  get_byte(self, *args) -> 'PyObject *'
 |      get_byte(self) -> PyObject *
 |      Reads a single byte from the file. Returns None if EOF or the read byte
 |  
 |  get_linput(self, *args) -> 'linput_t *'
 |      get_linput(self) -> linput_t *
 |  
 |  gets(self, *args) -> 'PyObject *'
 |      gets(self, len) -> str
 |      Reads a line from the input file. Returns the read line or None
 |      
 |      @param len: size_t
 |  
 |  getz(self, *args) -> 'PyObject *'
 |      getz(self, sz, fpos=-1) -> PyObject *
 |      Returns a zero terminated string at the given position
 |      
 |      @param sz: maximum size of the string
 |      @param fpos: if != -1 then seek will be performed before reading
 |      @return: The string or None on failure.
 |  
 |  open(self, *args) -> 'bool'
 |      open(self, filename, remote=False) -> bool
 |      Opens a file (or a remote file)
 |      
 |      @param filename: char const *
 |      @param remote: bool
 |      @return: Boolean
 |  
 |  open_memory(self, *args) -> 'bool'
 |      open_memory(self, start, size=0) -> bool
 |      Create a linput for process memory (By internally calling idaapi.create_memory_linput())
 |      This linput will use dbg->read_memory() to read data
 |      
 |      @param start: starting address of the input
 |      @param size: size of the memory range to represent as linput
 |                  if unknown, may be passed as 0
 |  
 |  opened(self, *args) -> 'bool'
 |      opened(self) -> bool
 |      Checks if the file is opened or not
 |  
 |  read(self, *args) -> 'PyObject *'
 |      read(self, size) -> bytes or None
 |      Reads from the file. Returns the buffer or None
 |      
 |      @param size: size_t
 |  
 |  readbytes(self, *args) -> 'PyObject *'
 |      readbytes(self, size, big_endian) -> PyObject *
 |      Similar to read() but it respect the endianness
 |      
 |      @param size: size_t
 |      @param big_endian: bool
 |  
 |  seek(self, *args) -> 'int64'
 |      seek(self, pos, whence=SEEK_SET) -> int64
 |      Set input source position
 |      
 |      @param pos: int64
 |      @param whence: int
 |      @return: the new position (not 0 as fseek!)
 |  
 |  set_linput(self, *args) -> 'void'
 |      set_linput(self, linput)
 |      Links the current loader_input_t instance to a linput_t instance
 |      
 |      @param linput: linput_t *
 |  
 |  size(self, *args) -> 'int64'
 |      size(self) -> int64
 |  
 |  tell(self, *args) -> 'int64'
 |      tell(self) -> int64
 |      Returns the current position
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  from_capsule(*args) -> 'loader_input_t *'
 |      from_capsule(pycapsule) -> loader_input_t
 |      
 |      @param pycapsule: PyObject *
 |  
 |  from_fp(*args) -> 'loader_input_t *'
 |      from_fp(fp) -> loader_input_t
 |      A static method to construct an instance from a FILE*
 |      
 |      @param fp: FILE *
 |  
 |  from_linput(*args) -> 'loader_input_t *'
 |      from_linput(linput) -> loader_input_t
 |      
 |      @param linput: linput_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __idc_cvt_id__
 |      __idc_cvt_id__
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function loader_input_t_from_capsule in module ida_idaapi:

loader_input_t_from_capsule(*args) -> 'loader_input_t *'
    loader_input_t_from_capsule(pycapsule) -> loader_input_t
    
    @param pycapsule: PyObject *

Help on function loader_input_t_from_fp in module ida_idaapi:

loader_input_t_from_fp(*args) -> 'loader_input_t *'
    loader_input_t_from_fp(fp) -> loader_input_t
    
    @param fp: FILE *

Help on function loader_input_t_from_linput in module ida_idaapi:

loader_input_t_from_linput(*args) -> 'loader_input_t *'
    loader_input_t_from_linput(linput) -> loader_input_t
    
    @param linput: linput_t *

Help on function notify_when in module ida_idaapi:

notify_when(when, callback)
    Register a callback that will be called when an event happens.
    @param when: one of NW_XXXX constants
    @param callback: This callback prototype varies depending on the 'when' parameter:
                     The general callback format:
                         def notify_when_callback(nw_code)
                     In the case of NW_OPENIDB:
                         def notify_when_callback(nw_code, is_old_database)
    @return: Boolean

Help on class object_t in module ida_idaapi:

class object_t(builtins.object)
 |  Helper class used to initialize empty objects
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, idx)
 |      Allow access to object attributes by index (like dictionaries)
 |  
 |  __init__(self, **kwds)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function parse_command_line3 in module ida_idaapi:

parse_command_line3(*args) -> 'PyObject *'
    parse_command_line3(cmdline) -> PyObject *
    
    @param cmdline: char const *

Help on class plugin_t in module ida_idaapi:

class plugin_t(pyidc_opaque_object_t)
 |  Base class for all scripted plugins.
 |  
 |  Method resolution order:
 |      plugin_t
 |      pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class plugmod_t in module ida_idaapi:

class plugmod_t(pyidc_opaque_object_t)
 |  Base class for all scripted multi-plugins.
 |  
 |  Method resolution order:
 |      plugmod_t
 |      pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class py_clinked_object_t in module ida_idaapi:

class py_clinked_object_t(pyidc_opaque_object_t)
 |  This is a utility and base class for C linked objects
 |  
 |  Method resolution order:
 |      py_clinked_object_t
 |      pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  __init__(self, lnk=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  assign(self, other)
 |      Overwrite me.
 |      This method allows you to assign an instance contents to anothers
 |      @return: Boolean
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function pycim_get_widget in module ida_idaapi:

pycim_get_widget(*args) -> 'TWidget *'
    pycim_get_widget(_self) -> TWidget *
    
    @param self: PyObject *

Help on function pycim_view_close in module ida_idaapi:

pycim_view_close(*args) -> 'void'
    pycim_view_close(_self)
    
    @param self: PyObject *

Help on function pygc_create_groups in module ida_idaapi:

pygc_create_groups(*args) -> 'PyObject *'
    pygc_create_groups(_self, groups_infos) -> [int, ...] or None
    
    @param self: PyObject *
    @param groups_infos: PyObject *

Help on function pygc_delete_groups in module ida_idaapi:

pygc_delete_groups(*args) -> 'PyObject *'
    pygc_delete_groups(_self, groups, new_current) -> bool
    
    @param self: PyObject *
    @param groups: PyObject *
    @param new_current: PyObject *

Help on function pygc_refresh in module ida_idaapi:

pygc_refresh(*args) -> 'void'
    pygc_refresh(_self)
    
    @param self: PyObject *

Help on function pygc_set_groups_visibility in module ida_idaapi:

pygc_set_groups_visibility(*args) -> 'PyObject *'
    pygc_set_groups_visibility(_self, groups, expand, new_current) -> bool
    
    @param self: PyObject *
    @param groups: PyObject *
    @param expand: PyObject *
    @param new_current: PyObject *

Help on class pyidc_cvt_helper__ in module ida_idaapi:

class pyidc_cvt_helper__(builtins.object)
 |  This is a special helper object that helps detect which kind
 |  of object is this python object wrapping and how to convert it
 |  back and from IDC.
 |  This object is characterized by its special attribute and its value
 |  
 |  Methods defined here:
 |  
 |  __init__(self, cvt_id, value)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _pyidc_cvt_helper____get_value = __get_value(self)
 |  
 |  _pyidc_cvt_helper____set_value = __set_value(self, v)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  value

Help on class pyidc_opaque_object_t in module ida_idaapi:

class pyidc_opaque_object_t(builtins.object)
 |  This is the base class for all Python<->IDC opaque objects
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __idc_cvt_id__ = 2

Help on function replfun in module ida_idaapi:

replfun(func)

Help on function require in module ida_idaapi:

require(modulename, package=None)
    Load, or reload a module.
    
    When under heavy development, a user's tool might consist of multiple
    modules. If those are imported using the standard 'import' mechanism,
    there is no guarantee that the Python implementation will re-read
    and re-evaluate the module's Python code. In fact, it usually doesn't.
    What should be done instead is 'reload()'-ing that module.
    
    This is a simple helper function that will do just that: In case the
    module doesn't exist, it 'import's it, and if it does exist,
    'reload()'s it.
    
    The importing module (i.e., the module calling require()) will have
    the loaded module bound to its globals(), under the name 'modulename'.
    (If require() is called from the command line, the importing module
    will be '__main__'.)
    
    For more information, see: <http://www.hexblog.com/?p=749>.

Help on function set_script_timeout in module ida_idaapi:

set_script_timeout(*args) -> 'int'
    set_script_timeout(timeout) -> int
    Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
    See also L{disable_script_timeout}.
    
    @param timeout: This value is in seconds.
                    If this value is set to zero then the script will never timeout.
    @return: Returns the old timeout value

Help on function struct_unpack in module ida_idaapi:

struct_unpack(buffer, signed=False, offs=0)
    Unpack a buffer given its length and offset using struct.unpack_from().
    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.

Module "ida_idc"s docstring:
"""None"""

Help on function get_mark_comment in module ida_idc:

get_mark_comment(*args) -> 'PyObject *'
    get_mark_comment(slot) -> PyObject *
    
    @param slot: int32

Help on function get_marked_pos in module ida_idc:

get_marked_pos(*args) -> 'ea_t'
    get_marked_pos(slot) -> ea_t
    
    @param slot: int32

Help on function mark_position in module ida_idc:

mark_position(*args) -> 'void'
    mark_position(ea, lnnum, x, y, slot, comment)
    
    @param ea: ea_t
    @param lnnum: int
    @param x: short
    @param y: short
    @param slot: int32
    @param comment: char const *

Module "ida_idd"s docstring:
"""
Contains definition of the interface to IDD modules.

The interface consists of structures describing the target debugged processor
and a debugging API."""

Help on Appcall__ in module ida_idd object:

class Appcall__(builtins.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  _Appcall____get_consts = __get_consts(self)
 |  
 |  __getattr__(self, name_or_ea)
 |      Allows you to call functions as if they were member functions (by returning a callable object)
 |  
 |  __getitem__(self, idx)
 |      Use self[func_name] syntax if the function name contains invalid characters for an attribute name
 |      See __getattr___
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  UTF16(s)
 |  
 |  _Appcall____name_or_ea = __name_or_ea(name_or_ea)
 |      Function that accepts a name or an ea and checks if the address is enabled.
 |      If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
 |      @return:     - Returns the resolved EA or
 |          - Raises an exception if the address is not enabled
 |  
 |  _Appcall____typedecl_or_tinfo = __typedecl_or_tinfo(typedecl_or_tinfo, flags=None)
 |      Function that accepts a tinfo_t object or type declaration as a string
 |      If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
 |      @return:     - Returns the tinfo_t object
 |          - Raises an exception if the declaration cannot be parsed
 |  
 |  array(type_name)
 |      Defines an array type. Later you need to pack() / unpack()
 |  
 |  buffer(str=None, size=0, fill='\x00')
 |      Creates a string buffer. The returned value (r) will be a byref object.
 |      Use r.value to get the contents and r.size to get the buffer's size
 |  
 |  byref(val)
 |      Method to create references to immutable objects
 |      Currently we support references to int/strings
 |      Objects need not be passed by reference (this will be done automatically)
 |  
 |  cleanup_appcall(tid=0)
 |      Equivalent to IDC's CleanupAppcall()
 |  
 |  cstr(val)
 |  
 |  get_appcall_options()
 |      Return the global Appcall options
 |  
 |  int64(v)
 |      Whenever a 64bit number is needed use this method to construct an object
 |  
 |  obj(**kwds)
 |      Returns an empty object or objects with attributes as passed via its keywords arguments
 |  
 |  proto(name_or_ea, proto_or_tinfo, flags=None)
 |      Allows you to instantiate an appcall (callable object) with the desired prototype
 |      @param name_or_ea: The name of the function (will be resolved with LocByName())
 |      @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
 |      @return:     - On failure it raises an exception if the prototype could not be parsed
 |            or the address is not resolvable
 |          - Returns a callbable Appcall instance with the given prototypes and flags
 |  
 |  set_appcall_options(opt)
 |      Method to change the Appcall options globally (not per Appcall)
 |  
 |  typedobj(typedecl_or_tinfo, ea=None)
 |      Returns an appcall object for a type (can be given as tinfo_t object or
 |      as a string declaration)
 |      One can then use retrieve() member method
 |      @param ea: Optional parameter that later can be used to retrieve the type
 |      @return: Appcall object or raises ValueError exception
 |  
 |  unicode = UTF16(s)
 |  
 |  valueof(name, default=0)
 |      Returns the numeric value of a given name string.
 |      If the name could not be resolved then the default value will be returned
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Consts
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  APPCALL_DEBEV = 2
 |  
 |  APPCALL_MANUAL = 1
 |  
 |  APPCALL_TIMEOUT = 4
 |  
 |  __name__ = 'Appcall__'

Help on class Appcall__ in module ida_idd:

class Appcall__(builtins.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  _Appcall____get_consts = __get_consts(self)
 |  
 |  __getattr__(self, name_or_ea)
 |      Allows you to call functions as if they were member functions (by returning a callable object)
 |  
 |  __getitem__(self, idx)
 |      Use self[func_name] syntax if the function name contains invalid characters for an attribute name
 |      See __getattr___
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  UTF16(s)
 |  
 |  _Appcall____name_or_ea = __name_or_ea(name_or_ea)
 |      Function that accepts a name or an ea and checks if the address is enabled.
 |      If a name is passed then idaapi.get_name_ea() is applied to retrieve the name
 |      @return:     - Returns the resolved EA or
 |          - Raises an exception if the address is not enabled
 |  
 |  _Appcall____typedecl_or_tinfo = __typedecl_or_tinfo(typedecl_or_tinfo, flags=None)
 |      Function that accepts a tinfo_t object or type declaration as a string
 |      If a type declaration is passed then ida_typeinf.parse_decl() is applied to prepare tinfo_t object
 |      @return:     - Returns the tinfo_t object
 |          - Raises an exception if the declaration cannot be parsed
 |  
 |  array(type_name)
 |      Defines an array type. Later you need to pack() / unpack()
 |  
 |  buffer(str=None, size=0, fill='\x00')
 |      Creates a string buffer. The returned value (r) will be a byref object.
 |      Use r.value to get the contents and r.size to get the buffer's size
 |  
 |  byref(val)
 |      Method to create references to immutable objects
 |      Currently we support references to int/strings
 |      Objects need not be passed by reference (this will be done automatically)
 |  
 |  cleanup_appcall(tid=0)
 |      Equivalent to IDC's CleanupAppcall()
 |  
 |  cstr(val)
 |  
 |  get_appcall_options()
 |      Return the global Appcall options
 |  
 |  int64(v)
 |      Whenever a 64bit number is needed use this method to construct an object
 |  
 |  obj(**kwds)
 |      Returns an empty object or objects with attributes as passed via its keywords arguments
 |  
 |  proto(name_or_ea, proto_or_tinfo, flags=None)
 |      Allows you to instantiate an appcall (callable object) with the desired prototype
 |      @param name_or_ea: The name of the function (will be resolved with LocByName())
 |      @param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
 |      @return:     - On failure it raises an exception if the prototype could not be parsed
 |            or the address is not resolvable
 |          - Returns a callbable Appcall instance with the given prototypes and flags
 |  
 |  set_appcall_options(opt)
 |      Method to change the Appcall options globally (not per Appcall)
 |  
 |  typedobj(typedecl_or_tinfo, ea=None)
 |      Returns an appcall object for a type (can be given as tinfo_t object or
 |      as a string declaration)
 |      One can then use retrieve() member method
 |      @param ea: Optional parameter that later can be used to retrieve the type
 |      @return: Appcall object or raises ValueError exception
 |  
 |  unicode = UTF16(s)
 |  
 |  valueof(name, default=0)
 |      Returns the numeric value of a given name string.
 |      If the name could not be resolved then the default value will be returned
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Consts
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  APPCALL_DEBEV = 2
 |  
 |  APPCALL_MANUAL = 1
 |  
 |  APPCALL_TIMEOUT = 4
 |  
 |  __name__ = 'Appcall__'

Help on class Appcall_array__ in module ida_idd:

class Appcall_array__(builtins.object)
 |  This class is used with Appcall.array() method
 |  
 |  Methods defined here:
 |  
 |  __init__(self, tp)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  pack(self, L)
 |      Packs a list or tuple into a byref buffer
 |  
 |  try_to_convert_to_list(self, obj)
 |      Is this object a list? We check for the existance of attribute zero and attribute self.size-1
 |  
 |  unpack(self, buf, as_list=True)
 |      Unpacks an array back into a list or an object
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class Appcall_callable__ in module ida_idd:

class Appcall_callable__(builtins.object)
 |  Helper class to issue appcalls using a natural syntax:
 |    appcall.FunctionNameInTheDatabase(arguments, ....)
 |  or
 |    appcall["Function@8"](arguments, ...)
 |  or
 |    f8 = appcall["Function@8"]
 |    f8(arg1, arg2, ...)
 |  or
 |    o = appcall.obj()
 |    i = byref(5)
 |    appcall.funcname(arg1, i, "hello", o)
 |  
 |  Methods defined here:
 |  
 |  _Appcall_callable____get_ea = __get_ea(self)
 |  
 |  _Appcall_callable____get_fields = __get_fields(self)
 |  
 |  _Appcall_callable____get_options = __get_options(self)
 |  
 |  _Appcall_callable____get_size = __get_size(self)
 |  
 |  _Appcall_callable____get_tif = __get_tif(self)
 |  
 |  _Appcall_callable____get_timeout = __get_timeout(self)
 |  
 |  _Appcall_callable____get_type = __get_type(self)
 |  
 |  _Appcall_callable____set_ea = __set_ea(self, val)
 |  
 |  _Appcall_callable____set_options = __set_options(self, v)
 |  
 |  _Appcall_callable____set_timeout = __set_timeout(self, v)
 |  
 |  __call__(self, *args)
 |      Make object callable. We redirect execution to idaapi.appcall()
 |  
 |  __init__(self, ea, tinfo_or_typestr=None, fields=None)
 |      Initializes an appcall with a given function ea
 |  
 |  retrieve(self, src=None, flags=0)
 |      Unpacks a typed object from the database if an ea is given or from a string if a string was passed
 |      @param src: the address of the object or a string
 |      @return: Returns a tuple of boolean and object or error number (Bool, Error | Object).
 |  
 |  store(self, obj, dest_ea=None, base_ea=0, flags=0)
 |      Packs an object into a given ea if provided or into a string if no address was passed.
 |      @param obj: The object to pack
 |      @param dest_ea: If packing to idb this will be the store location
 |      @param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
 |      
 |      @return:     - If packing to a string then a Tuple(Boolean, packed_string or error code)
 |          - If packing to the database then a return code is returned (0 is success)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |  
 |  fields
 |  
 |  options
 |  
 |  size
 |  
 |  tif
 |  
 |  timeout
 |  
 |  type

Help on class Appcall_consts__ in module ida_idd:

class Appcall_consts__(builtins.object)
 |  Helper class used by Appcall.Consts attribute
 |  It is used to retrieve constants via attribute access
 |  
 |  Methods defined here:
 |  
 |  __getattr__(self, attr)
 |  
 |  __init__(self, default=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function appcall in module ida_idd:

appcall(*args) -> 'PyObject *'
    appcall(func_ea, tid, _type_or_none, _fields, arg_list) -> PyObject *
    
    @param func_ea: ea_t
    @param tid: thid_t
    @param _type_or_none: bytevec_t const &
    @param _fields: bytevec_t const &
    @param arg_list: PyObject *

Help on class bptaddr_t in module ida_idd:

class bptaddr_t(builtins.object)
 |  Proxy of C++ bptaddr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> bptaddr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bptaddr_t(...)
 |      delete_bptaddr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hea
 |      hea
 |  
 |  kea
 |      kea
 |  
 |  thisown
 |      The membership flag

Help on class call_stack_info_t in module ida_idd:

class call_stack_info_t(builtins.object)
 |  Proxy of C++ call_stack_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: call_stack_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: call_stack_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_call_stack_info_t(...)
 |      delete_call_stack_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  callea
 |      callea
 |  
 |  fp
 |      fp
 |  
 |  funcea
 |      funcea
 |  
 |  funcok
 |      funcok
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class call_stack_info_vec_t in module ida_idd:

class call_stack_info_vec_t(builtins.object)
 |  Proxy of C++ qvector< call_stack_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< call_stack_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'call_stack_info_t const &'
 |      __getitem__(self, i) -> call_stack_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_info_vec_t
 |      __init__(self, x) -> call_stack_info_vec_t
 |      
 |      @param x: qvector< call_stack_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< call_stack_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: call_stack_info_t const &
 |  
 |  __swig_destroy__ = delete_call_stack_info_vec_t(...)
 |      delete_call_stack_info_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: call_stack_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  at(self, *args) -> 'call_stack_info_t const &'
 |      at(self, _idx) -> call_stack_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      begin(self) -> call_stack_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      end(self) -> call_stack_info_t
 |  
 |  erase(self, *args) -> 'qvector< call_stack_info_t >::iterator'
 |      erase(self, it) -> call_stack_info_t
 |      
 |      @param it: qvector< call_stack_info_t >::iterator
 |      
 |      erase(self, first, last) -> call_stack_info_t
 |      
 |      @param first: qvector< call_stack_info_t >::iterator
 |      @param last: qvector< call_stack_info_t >::iterator
 |  
 |  extract(self, *args) -> 'call_stack_info_t *'
 |      extract(self) -> call_stack_info_t
 |  
 |  find(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      find(self, x) -> call_stack_info_t
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=call_stack_info_t())
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: call_stack_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< call_stack_info_t >::iterator'
 |      insert(self, it, x) -> call_stack_info_t
 |      
 |      @param it: qvector< call_stack_info_t >::iterator
 |      @param x: call_stack_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'call_stack_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: call_stack_info_t const &
 |      
 |      push_back(self) -> call_stack_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: call_stack_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< call_stack_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class call_stack_t in module ida_idd:

class call_stack_t(call_stack_info_vec_t)
 |  Proxy of C++ call_stack_t class.
 |  
 |  Method resolution order:
 |      call_stack_t
 |      call_stack_info_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> call_stack_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_call_stack_t(...)
 |      delete_call_stack_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from call_stack_info_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< call_stack_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'call_stack_info_t const &'
 |      __getitem__(self, i) -> call_stack_info_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< call_stack_info_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: call_stack_info_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: call_stack_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  at(self, *args) -> 'call_stack_info_t const &'
 |      at(self, _idx) -> call_stack_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      begin(self) -> call_stack_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      end(self) -> call_stack_info_t
 |  
 |  erase(self, *args) -> 'qvector< call_stack_info_t >::iterator'
 |      erase(self, it) -> call_stack_info_t
 |      
 |      @param it: qvector< call_stack_info_t >::iterator
 |      
 |      erase(self, first, last) -> call_stack_info_t
 |      
 |      @param first: qvector< call_stack_info_t >::iterator
 |      @param last: qvector< call_stack_info_t >::iterator
 |  
 |  extract(self, *args) -> 'call_stack_info_t *'
 |      extract(self) -> call_stack_info_t
 |  
 |  find(self, *args) -> 'qvector< call_stack_info_t >::const_iterator'
 |      find(self, x) -> call_stack_info_t
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=call_stack_info_t())
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: call_stack_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: call_stack_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< call_stack_info_t >::iterator'
 |      insert(self, it, x) -> call_stack_info_t
 |      
 |      @param it: qvector< call_stack_info_t >::iterator
 |      @param x: call_stack_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'call_stack_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: call_stack_info_t const &
 |      
 |      push_back(self) -> call_stack_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: call_stack_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< call_stack_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from call_stack_info_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from call_stack_info_vec_t:
 |  
 |  __hash__ = None

Help on function can_exc_continue in module ida_idd:

can_exc_continue(*args) -> 'bool'
    can_exc_continue(ev) -> bool
    
    @param ev: debug_event_t const *

Help on function cleanup_appcall in module ida_idd:

cleanup_appcall(*args) -> 'error_t'
    cleanup_appcall(tid) -> error_t
    Cleanup after manual appcall.
    
    @param tid: (C++: thid_t) thread to use. NO_THREAD means to use the current thread The
                application state is restored as it was before calling the last
                appcall(). Nested appcalls are supported.
    @return: eOk if successful, otherwise an error code

Help on function dbg_appcall in module ida_idd:

dbg_appcall(*args) -> 'error_t'
    dbg_appcall(retval, func_ea, tid, ptif, argv, argnum) -> error_t
    Call a function from the debugged application.
    
    @param retval: (C++: idc_value_t *) function return value
    * for APPCALL_MANUAL, r will hold the new stack point value
    * for APPCALL_DEBEV, r will hold the exception information upon failure and the
    return code will be eExecThrow
    @param func_ea: (C++: ea_t) address to call
    @param tid: (C++: thid_t) thread to use. NO_THREAD means to use the current thread
    @param ptif: (C++: const tinfo_t *) pointer to type of the function to call
    @param argv: (C++: idc_value_t *) array of arguments
    @param argnum: (C++: size_t) number of actual arguments
    @return: eOk if successful, otherwise an error code

Help on built-in function dbg_can_query in module _ida_dbg:

dbg_can_query(...)
    dbg_can_query() -> bool

Help on function dbg_get_memory_info in module ida_idd:

dbg_get_memory_info(*args) -> 'PyObject *'
    dbg_get_memory_info() -> PyObject *
    This function returns the memory configuration of a debugged process.
    
    @return:     None if no debugger is active
        tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm)

Help on function dbg_get_name in module ida_idd:

dbg_get_name(*args) -> 'PyObject *'
    dbg_get_name() -> PyObject *
    This function returns the current debugger's name.
    
    @return: Debugger name or None if no debugger is active

Help on function dbg_get_registers in module ida_idd:

dbg_get_registers(*args) -> 'PyObject *'
    dbg_get_registers() -> PyObject *
    This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    
    @return:     None if no debugger is loaded
        tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
        The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)

Help on function dbg_get_thread_sreg_base in module ida_idd:

dbg_get_thread_sreg_base(*args) -> 'PyObject *'
    dbg_get_thread_sreg_base(tid, sreg_value) -> PyObject *
    Returns the segment register base value
    
    @param tid: thread id
    @param sreg_value: segment register (selector) value
    @return:     - The base as an 'ea'
        - Or None on failure

Help on function dbg_read_memory in module ida_idd:

dbg_read_memory(*args) -> 'PyObject *'
    dbg_read_memory(ea, sz) -> PyObject *
    Reads from the debugee's memory at the specified ea
    
    @param ea: ea_t
    @param sz: size_t
    @return:     - The read buffer (as a string)
        - Or None on failure

Help on function dbg_write_memory in module ida_idd:

dbg_write_memory(*args) -> 'PyObject *'
    dbg_write_memory(ea, buf) -> bool
    Writes a buffer to the debugee's memory
    
    @param ea: ea_t
    @param buf: bytevec_t const &
    @return: Boolean

Help on class debapp_attrs_t in module ida_idd:

class debapp_attrs_t(builtins.object)
 |  Proxy of C++ debapp_attrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> debapp_attrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_debapp_attrs_t(...)
 |      delete_debapp_attrs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  addrsize
 |      addrsize
 |  
 |  cbsize
 |      cbsize
 |  
 |  is_be
 |      is_be
 |  
 |  platform
 |      platform
 |  
 |  thisown
 |      The membership flag

Help on class debug_event_t in module ida_idd:

class debug_event_t(builtins.object)
 |  Proxy of C++ debug_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> debug_event_t
 |      __init__(self, r) -> debug_event_t
 |      
 |      @param r: debug_event_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_debug_event_t(...)
 |      delete_debug_event_t(self)
 |  
 |  bpt(self, *args) -> 'bptaddr_t const &'
 |      bpt(self) -> bptaddr_t
 |  
 |  bpt_ea(self, *args) -> 'ea_t'
 |      bpt_ea(self) -> ea_t
 |      On some systems with special memory mappings the triggered ea might be different
 |      from the actual ea. Calculate the address to use.
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      clear the dependent information (see below), set event code to NO_EVENT
 |  
 |  clear_all(self, *args) -> 'void'
 |      clear_all(self)
 |  
 |  copy(self, *args) -> 'debug_event_t &'
 |      copy(self, r) -> debug_event_t
 |      
 |      @param r: debug_event_t const &
 |  
 |  eid(self, *args) -> 'event_id_t'
 |      eid(self) -> event_id_t
 |      Event code.
 |  
 |  exc(self, *args) -> 'excinfo_t const &'
 |      exc(self) -> excinfo_t
 |  
 |  exit_code(self, *args) -> 'int const &'
 |      exit_code(self) -> int const &
 |  
 |  info(self, *args) -> 'qstring const &'
 |      info(self) -> qstring
 |      info(self) -> qstring const &
 |  
 |  modinfo(self, *args) -> 'modinfo_t const &'
 |      modinfo(self) -> modinfo_t
 |  
 |  set_bpt(self, *args) -> 'bptaddr_t &'
 |      set_bpt(self) -> bptaddr_t
 |  
 |  set_eid(self, *args) -> 'void'
 |      set_eid(self, id)
 |      Set event code. If the new event code is compatible with the old one then the
 |      dependent information (see below) will be preserved. Otherwise the event will be
 |      cleared and the new event code will be set.
 |      
 |      @param id: (C++: event_id_t) enum event_id_t
 |  
 |  set_exception(self, *args) -> 'excinfo_t &'
 |      set_exception(self) -> excinfo_t
 |  
 |  set_exit_code(self, *args) -> 'void'
 |      set_exit_code(self, id, code)
 |      
 |      @param id: enum event_id_t
 |      @param code: int
 |  
 |  set_info(self, *args) -> 'qstring &'
 |      set_info(self, id) -> qstring &
 |      
 |      @param id: enum event_id_t
 |  
 |  set_modinfo(self, *args) -> 'modinfo_t &'
 |      set_modinfo(self, id) -> modinfo_t
 |      
 |      @param id: enum event_id_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  handled
 |      handled
 |  
 |  pid
 |      pid
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tid

Help on class exception_info_t in module ida_idd:

class exception_info_t(builtins.object)
 |  Proxy of C++ exception_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> exception_info_t
 |      __init__(self, _code, _flags, _name, _desc) -> exception_info_t
 |      
 |      @param _code: uint
 |      @param _flags: uint32
 |      @param _name: char const *
 |      @param _desc: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_exception_info_t(...)
 |      delete_exception_info_t(self)
 |  
 |  break_on(self, *args) -> 'bool'
 |      break_on(self) -> bool
 |      Should we break on the exception?
 |  
 |  handle(self, *args) -> 'bool'
 |      handle(self) -> bool
 |      Should we handle the exception?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      code
 |  
 |  desc
 |      desc
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag

Help on class excinfo_t in module ida_idd:

class excinfo_t(builtins.object)
 |  Proxy of C++ excinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> excinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_excinfo_t(...)
 |      delete_excinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  can_cont
 |      can_cont
 |  
 |  code
 |      code
 |  
 |  ea
 |      ea
 |  
 |  info
 |      info
 |  
 |  thisown
 |      The membership flag

Help on class excvec_t in module ida_idd:

class excvec_t(builtins.object)
 |  Proxy of C++ qvector< exception_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'exception_info_t const &'
 |      __getitem__(self, i) -> exception_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> excvec_t
 |      __init__(self, x) -> excvec_t
 |      
 |      @param x: qvector< exception_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: exception_info_t const &
 |  
 |  __swig_destroy__ = delete_excvec_t(...)
 |      delete_excvec_t(self)
 |  
 |  at(self, *args) -> 'exception_info_t const &'
 |      at(self, _idx) -> exception_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< exception_info_t >::const_iterator'
 |      begin(self) -> exception_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< exception_info_t >::const_iterator'
 |      end(self) -> exception_info_t
 |  
 |  erase(self, *args) -> 'qvector< exception_info_t >::iterator'
 |      erase(self, it) -> exception_info_t
 |      
 |      @param it: qvector< exception_info_t >::iterator
 |      
 |      erase(self, first, last) -> exception_info_t
 |      
 |      @param first: qvector< exception_info_t >::iterator
 |      @param last: qvector< exception_info_t >::iterator
 |  
 |  extract(self, *args) -> 'exception_info_t *'
 |      extract(self) -> exception_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=exception_info_t())
 |      
 |      @param x: exception_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: exception_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< exception_info_t >::iterator'
 |      insert(self, it, x) -> exception_info_t
 |      
 |      @param it: qvector< exception_info_t >::iterator
 |      @param x: exception_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'exception_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: exception_info_t const &
 |      
 |      push_back(self) -> exception_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: exception_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< exception_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function get_event_bpt_hea in module ida_idd:

get_event_bpt_hea(*args) -> 'ea_t'
    get_event_bpt_hea(ev) -> ea_t
    
    @param ev: debug_event_t const *

Help on function get_event_exc_code in module ida_idd:

get_event_exc_code(*args) -> 'uint'
    get_event_exc_code(ev) -> uint
    
    @param ev: debug_event_t const *

Help on function get_event_exc_ea in module ida_idd:

get_event_exc_ea(*args) -> 'ea_t'
    get_event_exc_ea(ev) -> ea_t
    
    @param ev: debug_event_t const *

Help on function get_event_exc_info in module ida_idd:

get_event_exc_info(*args) -> 'size_t'
    get_event_exc_info(ev) -> str
    
    @param ev: debug_event_t const *

Help on function get_event_info in module ida_idd:

get_event_info(*args) -> 'size_t'
    get_event_info(ev) -> str
    
    @param ev: debug_event_t const *

Help on function get_event_module_base in module ida_idd:

get_event_module_base(*args) -> 'ea_t'
    get_event_module_base(ev) -> ea_t
    
    @param ev: debug_event_t const *

Help on function get_event_module_name in module ida_idd:

get_event_module_name(*args) -> 'size_t'
    get_event_module_name(ev) -> str
    
    @param ev: debug_event_t const *

Help on function get_event_module_size in module ida_idd:

get_event_module_size(*args) -> 'asize_t'
    get_event_module_size(ev) -> asize_t
    
    @param ev: debug_event_t const *

Help on class meminfo_vec_t in module ida_idd:

class meminfo_vec_t(meminfo_vec_template_t)
 |  Proxy of C++ meminfo_vec_t class.
 |  
 |  Method resolution order:
 |      meminfo_vec_t
 |      meminfo_vec_template_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> meminfo_vec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_meminfo_vec_t(...)
 |      delete_meminfo_vec_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from meminfo_vec_template_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< memory_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'memory_info_t const &'
 |      __getitem__(self, i) -> memory_info_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< memory_info_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: memory_info_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: memory_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: memory_info_t const &
 |  
 |  at(self, *args) -> 'memory_info_t const &'
 |      at(self, _idx) -> memory_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      begin(self) -> memory_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      end(self) -> memory_info_t
 |  
 |  erase(self, *args) -> 'qvector< memory_info_t >::iterator'
 |      erase(self, it) -> memory_info_t
 |      
 |      @param it: qvector< memory_info_t >::iterator
 |      
 |      erase(self, first, last) -> memory_info_t
 |      
 |      @param first: qvector< memory_info_t >::iterator
 |      @param last: qvector< memory_info_t >::iterator
 |  
 |  extract(self, *args) -> 'memory_info_t *'
 |      extract(self) -> memory_info_t
 |  
 |  find(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      find(self, x) -> memory_info_t
 |      
 |      @param x: memory_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=memory_info_t())
 |      
 |      @param x: memory_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: memory_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: memory_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< memory_info_t >::iterator'
 |      insert(self, it, x) -> memory_info_t
 |      
 |      @param it: qvector< memory_info_t >::iterator
 |      @param x: memory_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'memory_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: memory_info_t const &
 |      
 |      push_back(self) -> memory_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: memory_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< memory_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from meminfo_vec_template_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from meminfo_vec_template_t:
 |  
 |  __hash__ = None

Help on class meminfo_vec_template_t in module ida_idd:

class meminfo_vec_template_t(builtins.object)
 |  Proxy of C++ qvector< memory_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< memory_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'memory_info_t const &'
 |      __getitem__(self, i) -> memory_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> meminfo_vec_template_t
 |      __init__(self, x) -> meminfo_vec_template_t
 |      
 |      @param x: qvector< memory_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< memory_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: memory_info_t const &
 |  
 |  __swig_destroy__ = delete_meminfo_vec_template_t(...)
 |      delete_meminfo_vec_template_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: memory_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: memory_info_t const &
 |  
 |  at(self, *args) -> 'memory_info_t const &'
 |      at(self, _idx) -> memory_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      begin(self) -> memory_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      end(self) -> memory_info_t
 |  
 |  erase(self, *args) -> 'qvector< memory_info_t >::iterator'
 |      erase(self, it) -> memory_info_t
 |      
 |      @param it: qvector< memory_info_t >::iterator
 |      
 |      erase(self, first, last) -> memory_info_t
 |      
 |      @param first: qvector< memory_info_t >::iterator
 |      @param last: qvector< memory_info_t >::iterator
 |  
 |  extract(self, *args) -> 'memory_info_t *'
 |      extract(self) -> memory_info_t
 |  
 |  find(self, *args) -> 'qvector< memory_info_t >::const_iterator'
 |      find(self, x) -> memory_info_t
 |      
 |      @param x: memory_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=memory_info_t())
 |      
 |      @param x: memory_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: memory_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: memory_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< memory_info_t >::iterator'
 |      insert(self, it, x) -> memory_info_t
 |      
 |      @param it: qvector< memory_info_t >::iterator
 |      @param x: memory_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'memory_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: memory_info_t const &
 |      
 |      push_back(self) -> memory_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: memory_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< memory_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class memory_info_t in module ida_idd:

class memory_info_t(ida_range.range_t)
 |  Proxy of C++ memory_info_t class.
 |  
 |  Method resolution order:
 |      memory_info_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: memory_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> memory_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: memory_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_memory_info_t(...)
 |      delete_memory_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bitness
 |      bitness
 |  
 |  name
 |      name
 |  
 |  perm
 |      perm
 |  
 |  sbase
 |      sbase
 |  
 |  sclass
 |      sclass
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea

Help on class modinfo_t in module ida_idd:

class modinfo_t(builtins.object)
 |  Proxy of C++ modinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> modinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_modinfo_t(...)
 |      delete_modinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      base
 |  
 |  name
 |      name
 |  
 |  rebase_to
 |      rebase_to
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag

Help on class process_info_t in module ida_idd:

class process_info_t(builtins.object)
 |  Proxy of C++ process_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> process_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_process_info_t(...)
 |      delete_process_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  pid
 |      pid
 |  
 |  thisown
 |      The membership flag

Help on class procinfo_vec_t in module ida_idd:

class procinfo_vec_t(builtins.object)
 |  Proxy of C++ qvector< process_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'process_info_t const &'
 |      __getitem__(self, i) -> process_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> procinfo_vec_t
 |      __init__(self, x) -> procinfo_vec_t
 |      
 |      @param x: qvector< process_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: process_info_t const &
 |  
 |  __swig_destroy__ = delete_procinfo_vec_t(...)
 |      delete_procinfo_vec_t(self)
 |  
 |  at(self, *args) -> 'process_info_t const &'
 |      at(self, _idx) -> process_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< process_info_t >::const_iterator'
 |      begin(self) -> process_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< process_info_t >::const_iterator'
 |      end(self) -> process_info_t
 |  
 |  erase(self, *args) -> 'qvector< process_info_t >::iterator'
 |      erase(self, it) -> process_info_t
 |      
 |      @param it: qvector< process_info_t >::iterator
 |      
 |      erase(self, first, last) -> process_info_t
 |      
 |      @param first: qvector< process_info_t >::iterator
 |      @param last: qvector< process_info_t >::iterator
 |  
 |  extract(self, *args) -> 'process_info_t *'
 |      extract(self) -> process_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=process_info_t())
 |      
 |      @param x: process_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: process_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< process_info_t >::iterator'
 |      insert(self, it, x) -> process_info_t
 |      
 |      @param it: qvector< process_info_t >::iterator
 |      @param x: process_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'process_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: process_info_t const &
 |      
 |      push_back(self) -> process_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: process_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< process_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class register_info_t in module ida_idd:

class register_info_t(builtins.object)
 |  Proxy of C++ register_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> register_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_register_info_t(...)
 |      delete_register_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bit_strings
 |      bit_strings
 |  
 |  default_bit_strings_mask
 |      default_bit_strings_mask
 |  
 |  dtype
 |      dtype
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  register_class
 |      register_class
 |  
 |  thisown
 |      The membership flag

Help on class regval_t in module ida_idd:

class regval_t(builtins.object)
 |  Proxy of C++ regval_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: regval_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regval_t
 |      __init__(self, r) -> regval_t
 |      
 |      @param r: regval_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: regval_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regval_t(...)
 |      delete_regval_t(self)
 |  
 |  bytes(self, *args) -> 'bytevec_t const &'
 |      bytes(self) -> bytevec_t
 |      Get const custom value.
 |      bytes(self) -> bytevec_t const &
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Clear register value.
 |  
 |  get_data(self, *args) -> 'void const *'
 |      get_data(self)
 |      Get const pointer to value.
 |      get_data(self) -> void const *
 |  
 |  get_data_size(self, *args) -> 'size_t'
 |      get_data_size(self) -> size_t
 |      Get size of value.
 |  
 |  set_bytes(self, *args) -> 'bytevec_t &'
 |      set_bytes(self, data, size)
 |      Initialize this regval to an empty custom value.
 |      
 |      @param data: uchar const *
 |      @param size: size_t
 |      
 |      set_bytes(self, v)
 |      
 |      @param v: bytevec_t const &
 |      
 |      set_bytes(self) -> bytevec_t &
 |  
 |  set_float(self, *args) -> 'void'
 |      set_float(self, x)
 |      Set float value (fval)
 |      
 |      @param x: (C++: const fpvalue_t &) fpvalue_t const &
 |  
 |  set_int(self, *args) -> 'void'
 |      set_int(self, x)
 |      Set int value (ival)
 |      
 |      @param x: (C++: uint64)
 |  
 |  set_unavailable(self, *args) -> 'void'
 |      set_unavailable(self)
 |      Mark as unavailable.
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Set this = r and r = this.
 |      
 |      @param r: (C++: regval_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fval
 |      fval
 |  
 |  ival
 |      ival
 |  
 |  rvtype
 |      rvtype
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class scattered_segm_t in module ida_idd:

class scattered_segm_t(ida_range.range_t)
 |  Proxy of C++ scattered_segm_t class.
 |  
 |  Method resolution order:
 |      scattered_segm_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scattered_segm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scattered_segm_t(...)
 |      delete_scattered_segm_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function set_debug_event_code in module ida_idd:

set_debug_event_code(*args) -> 'void'
    set_debug_event_code(ev, id)
    
    @param ev: debug_event_t *
    @param id: enum event_id_t

Help on class thread_name_t in module ida_idd:

class thread_name_t(builtins.object)
 |  Proxy of C++ thread_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> thread_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_thread_name_t(...)
 |      delete_thread_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tid

Module "ida_idp"s docstring:
"""
Contains definition of the interface to IDP modules.

The interface consists of two structures:
* definition of target assembler: ::ash
* definition of current processor: ::ph

These structures contain information about target processor and assembler
features.

It also defines two groups of kernel events:
* processor_t::event_t processor related events
* idb_event:event_code_t database related events

The processor related events are used to communicate with the processor module.
The database related events are used to inform any interested parties, like
plugins or processor modules, about the changes in the database."""

Help on function AssembleLine in module ida_idp:

AssembleLine(*args) -> 'PyObject *'
    AssembleLine(ea, cs, ip, use32, nonnul_line) -> bytes
    Assemble an instruction to a string (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment
    @param nonnul_line: char const *
    @return:     - None on failure
        - or a string containing the assembled instruction

Help on class IDB_Hooks in module ida_idp:

class IDB_Hooks(builtins.object)
 |  Proxy of C++ IDB_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> IDB_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDB_Hooks(...)
 |      delete_IDB_Hooks(self)
 |  
 |  adding_segm(self, *args) -> 'void'
 |      adding_segm(self, s)
 |      A segment is being created.
 |      
 |      @param s: (segment_t *)
 |  
 |  allsegs_moved(self, *args) -> 'void'
 |      allsegs_moved(self, info)
 |      Program rebasing is complete. This event is generated after series of segm_moved
 |      events
 |      
 |      @param info: (segm_move_infos_t *)
 |  
 |  auto_empty(self, *args) -> 'void'
 |      auto_empty(self)
 |  
 |  auto_empty_finally(self, *args) -> 'void'
 |      auto_empty_finally(self)
 |  
 |  bookmark_changed(self, *args) -> 'void'
 |      bookmark_changed(self, index, pos, desc, operation)
 |      Boomarked position changed.
 |      
 |      @param index: (uint32)
 |      @param pos: (::const lochist_entry_t *)
 |      @param desc: (::const char *)
 |      @param operation: (int) 0-added, 1-updated, 2-deleted if desc==nullptr, then the
 |                        bookmark was deleted.
 |  
 |  byte_patched(self, *args) -> 'void'
 |      byte_patched(self, ea, old_value)
 |      A byte has been patched.
 |      
 |      @param ea: (::ea_t)
 |      @param old_value: (uint32)
 |  
 |  callee_addr_changed(self, *args) -> 'void'
 |      callee_addr_changed(self, ea, callee)
 |      Callee address has been updated by the user.
 |      
 |      @param ea: (::ea_t)
 |      @param callee: (::ea_t)
 |  
 |  changing_cmt(self, *args) -> 'void'
 |      changing_cmt(self, ea, repeatable_cmt, newcmt)
 |      An item comment is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param repeatable_cmt: (bool)
 |      @param newcmt: (const char *)
 |  
 |  changing_enum_bf(self, *args) -> 'void'
 |      changing_enum_bf(self, id, new_bf)
 |      An enum type 'bitfield' attribute is to be changed.
 |      
 |      @param id: (enum_t)
 |      @param new_bf: (bool)
 |  
 |  changing_enum_cmt(self, *args) -> 'void'
 |      changing_enum_cmt(self, id, repeatable, newcmt)
 |      An enum or member type comment is to be changed.
 |      
 |      @param id: (tid_t)
 |      @param repeatable: (bool)
 |      @param newcmt: (const char *)
 |  
 |  changing_op_ti(self, *args) -> 'void'
 |      changing_op_ti(self, ea, n, new_type, new_fnames)
 |      An operand typestring (c/c++ prototype) is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int)
 |      @param new_type: (const type_t *)
 |      @param new_fnames: (const p_list *)
 |  
 |  changing_op_type(self, *args) -> 'void'
 |      changing_op_type(self, ea, n, opinfo)
 |      An operand type (offset, hex, etc...) is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
 |      @param opinfo: (const opinfo_t *) additional operand info
 |  
 |  changing_range_cmt(self, *args) -> 'void'
 |      changing_range_cmt(self, kind, a, cmt, repeatable)
 |      Range comment is to be changed.
 |      
 |      @param kind: (range_kind_t)
 |      @param a: (const range_t *)
 |      @param cmt: (const char *)
 |      @param repeatable: (bool)
 |  
 |  changing_segm_class(self, *args) -> 'void'
 |      changing_segm_class(self, s)
 |      Segment class is being changed.
 |      
 |      @param s: (segment_t *)
 |  
 |  changing_segm_end(self, *args) -> 'void'
 |      changing_segm_end(self, s, new_end, segmod_flags)
 |      Segment end address is to be changed.
 |      
 |      @param s: (segment_t *)
 |      @param new_end: (::ea_t)
 |      @param segmod_flags: (int)
 |  
 |  changing_segm_name(self, *args) -> 'void'
 |      changing_segm_name(self, s, oldname)
 |      Segment name is being changed.
 |      
 |      @param s: (segment_t *)
 |      @param oldname: (const char *)
 |  
 |  changing_segm_start(self, *args) -> 'void'
 |      changing_segm_start(self, s, new_start, segmod_flags)
 |      Segment start address is to be changed.
 |      
 |      @param s: (segment_t *)
 |      @param new_start: (::ea_t)
 |      @param segmod_flags: (int)
 |  
 |  changing_struc_align(self, *args) -> 'void'
 |      changing_struc_align(self, sptr)
 |      A structure type is being changed (the struct alignment).
 |      
 |      @param sptr: (struc_t *)
 |  
 |  changing_struc_cmt(self, *args) -> 'void'
 |      changing_struc_cmt(self, struc_id, repeatable, newcmt)
 |      A structure type comment is to be changed.
 |      
 |      @param struc_id: (tid_t)
 |      @param repeatable: (bool)
 |      @param newcmt: (const char *)
 |  
 |  changing_struc_member(self, *args) -> 'void'
 |      changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
 |      A structure member is to be changed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |      @param flag: (flags_t)
 |      @param ti: (const opinfo_t *)
 |      @param nbytes: (::asize_t)
 |  
 |  changing_ti(self, *args) -> 'void'
 |      changing_ti(self, ea, new_type, new_fnames)
 |      An item typestring (c/c++ prototype) is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param new_type: (const type_t *)
 |      @param new_fnames: (const p_list *)
 |  
 |  closebase(self, *args) -> 'void'
 |      closebase(self)
 |      The database will be closed now.
 |  
 |  cmt_changed(self, *args) -> 'void'
 |      cmt_changed(self, ea, repeatable_cmt)
 |      An item comment has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param repeatable_cmt: (bool)
 |  
 |  compiler_changed(self, *args) -> 'void'
 |      compiler_changed(self, adjust_inf_fields)
 |      The kernel has changed the compiler information. ( idainfo::cc structure;
 |      get_abi_name)
 |      
 |      @param adjust_inf_fields: (::bool) may change inf fields?
 |  
 |  deleting_enum(self, *args) -> 'void'
 |      deleting_enum(self, id)
 |      An enum type is to be deleted.
 |      
 |      @param id: (enum_t)
 |  
 |  deleting_enum_member(self, *args) -> 'void'
 |      deleting_enum_member(self, id, cid)
 |      An enum member is to be deleted.
 |      
 |      @param id: (enum_t)
 |      @param cid: (const_t)
 |  
 |  deleting_func(self, *args) -> 'void'
 |      deleting_func(self, pfn)
 |      The kernel is about to delete a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  deleting_func_tail(self, *args) -> 'void'
 |      deleting_func_tail(self, pfn, tail)
 |      A function tail chunk is to be removed.
 |      
 |      @param pfn: (func_t *)
 |      @param tail: (const range_t *)
 |  
 |  deleting_segm(self, *args) -> 'void'
 |      deleting_segm(self, start_ea)
 |      A segment is to be deleted.
 |      
 |      @param start_ea: (::ea_t)
 |  
 |  deleting_struc(self, *args) -> 'void'
 |      deleting_struc(self, sptr)
 |      A structure type is to be deleted.
 |      
 |      @param sptr: (struc_t *)
 |  
 |  deleting_struc_member(self, *args) -> 'void'
 |      deleting_struc_member(self, sptr, mptr)
 |      A structure member is to be deleted.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  deleting_tryblks(self, *args) -> 'void'
 |      deleting_tryblks(self, range)
 |      About to delete tryblk information in given range
 |      
 |      @param range: (const range_t *)
 |  
 |  destroyed_items(self, *args) -> 'void'
 |      destroyed_items(self, ea1, ea2, will_disable_range)
 |      Instructions/data have been destroyed in [ea1,ea2).
 |      
 |      @param ea1: (::ea_t)
 |      @param ea2: (::ea_t)
 |      @param will_disable_range: (bool)
 |  
 |  determined_main(self, *args) -> 'void'
 |      determined_main(self, main)
 |      The main() function has been determined.
 |      
 |      @param main: (::ea_t) address of the main() function
 |  
 |  dirtree_link(self, *args) -> 'void'
 |      dirtree_link(self, dt, path, link)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |      @param link: (::bool)
 |  
 |  dirtree_mkdir(self, *args) -> 'void'
 |      dirtree_mkdir(self, dt, path)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |  
 |  dirtree_move(self, *args) -> 'void'
 |      dirtree_move(self, dt, _from, to)
 |      
 |      @param dt: (dirtree_t *)
 |      @param from: (::const char *)
 |      @param to: (::const char *)
 |  
 |  dirtree_rank(self, *args) -> 'void'
 |      dirtree_rank(self, dt, path, rank)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |      @param rank: (::size_t)
 |  
 |  dirtree_rmdir(self, *args) -> 'void'
 |      dirtree_rmdir(self, dt, path)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |  
 |  dirtree_rminode(self, *args) -> 'void'
 |      dirtree_rminode(self, dt, inode)
 |      
 |      @param dt: (dirtree_t *)
 |      @param inode: (inode_t)
 |  
 |  dirtree_segm_moved(self, *args) -> 'void'
 |      dirtree_segm_moved(self, dt)
 |      
 |      @param dt: (dirtree_t *)
 |  
 |  enum_bf_changed(self, *args) -> 'void'
 |      enum_bf_changed(self, id)
 |      An enum type 'bitfield' attribute has been changed.
 |      
 |      @param id: (enum_t)
 |  
 |  enum_cmt_changed(self, *args) -> 'void'
 |      enum_cmt_changed(self, id, repeatable)
 |      An enum or member type comment has been changed.
 |      
 |      @param id: (tid_t)
 |      @param repeatable: (bool)
 |  
 |  enum_created(self, *args) -> 'void'
 |      enum_created(self, id)
 |      An enum type has been created.
 |      
 |      @param id: (enum_t)
 |  
 |  enum_deleted(self, *args) -> 'void'
 |      enum_deleted(self, id)
 |      An enum type has been deleted.
 |      
 |      @param id: (enum_t)
 |  
 |  enum_flag_changed(self, *args) -> 'void'
 |      enum_flag_changed(self, id, F)
 |      Enum flags have been changed.
 |      
 |      @param id: (enum_t)
 |      @param F: (flags_t)
 |  
 |  enum_member_created(self, *args) -> 'void'
 |      enum_member_created(self, id, cid)
 |      An enum member has been created.
 |      
 |      @param id: (enum_t)
 |      @param cid: (const_t)
 |  
 |  enum_member_deleted(self, *args) -> 'void'
 |      enum_member_deleted(self, id, cid)
 |      An enum member has been deleted.
 |      
 |      @param id: (enum_t)
 |      @param cid: (const_t)
 |  
 |  enum_ordinal_changed(self, *args) -> 'void'
 |      enum_ordinal_changed(self, id, ord)
 |      Enum mapping to a local type has been changed.
 |      
 |      @param id: (enum_t)
 |      @param ord: (int)
 |  
 |  enum_renamed(self, *args) -> 'void'
 |      enum_renamed(self, id)
 |      An enum or member has been renamed.
 |      
 |      @param id: (tid_t)
 |  
 |  enum_width_changed(self, *args) -> 'void'
 |      enum_width_changed(self, id, width)
 |      Enum width has been changed.
 |      
 |      @param id: (enum_t)
 |      @param width: (int)
 |  
 |  expanding_struc(self, *args) -> 'void'
 |      expanding_struc(self, sptr, offset, delta)
 |      A structure type is to be expanded/shrunk.
 |      
 |      @param sptr: (struc_t *)
 |      @param offset: (::ea_t)
 |      @param delta: (::adiff_t)
 |  
 |  extlang_changed(self, *args) -> 'void'
 |      extlang_changed(self, kind, el, idx)
 |      The list of extlangs or the default extlang was changed.
 |      
 |      @param kind: (int) 0: extlang installed 1: extlang removed 2: default extlang
 |                   changed
 |      @param el: (extlang_t *) pointer to the extlang affected
 |      @param idx: (int) extlang index
 |  
 |  extra_cmt_changed(self, *args) -> 'void'
 |      extra_cmt_changed(self, ea, line_idx, cmt)
 |      An extra comment has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param line_idx: (int)
 |      @param cmt: (const char *)
 |  
 |  flow_chart_created(self, *args) -> 'void'
 |      flow_chart_created(self, fc)
 |      Gui has retrieved a function flow chart. Plugins may modify the flow chart in
 |      this callback.
 |      
 |      @param fc: (qflow_chart_t *)
 |  
 |  frame_deleted(self, *args) -> 'void'
 |      frame_deleted(self, pfn)
 |      The kernel has deleted a function frame.
 |      
 |      @param pfn: (func_t *)
 |  
 |  func_added(self, *args) -> 'void'
 |      func_added(self, pfn)
 |      The kernel has added a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  func_deleted(self, *args) -> 'void'
 |      func_deleted(self, func_ea)
 |      A function has been deleted.
 |      
 |      @param func_ea: (::ea_t)
 |  
 |  func_noret_changed(self, *args) -> 'void'
 |      func_noret_changed(self, pfn)
 |      FUNC_NORET bit has been changed.
 |      
 |      @param pfn: (func_t *)
 |  
 |  func_tail_appended(self, *args) -> 'void'
 |      func_tail_appended(self, pfn, tail)
 |      A function tail chunk has been appended.
 |      
 |      @param pfn: (func_t *)
 |      @param tail: (func_t *)
 |  
 |  func_tail_deleted(self, *args) -> 'void'
 |      func_tail_deleted(self, pfn, tail_ea)
 |      A function tail chunk has been removed.
 |      
 |      @param pfn: (func_t *)
 |      @param tail_ea: (::ea_t)
 |  
 |  func_updated(self, *args) -> 'void'
 |      func_updated(self, pfn)
 |      The kernel has updated a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  idasgn_loaded(self, *args) -> 'void'
 |      idasgn_loaded(self, short_sig_name)
 |      FLIRT signature has been loaded for normal processing (not for recognition of
 |      startup sequences).
 |      
 |      @param short_sig_name: (const char *)
 |  
 |  item_color_changed(self, *args) -> 'void'
 |      item_color_changed(self, ea, color)
 |      An item color has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param color: (bgcolor_t) if color==DEFCOLOR, the the color is deleted.
 |  
 |  kernel_config_loaded(self, *args) -> 'void'
 |      kernel_config_loaded(self, pass_number)
 |      This event is issued when ida.cfg is parsed.
 |      
 |      @param pass_number: (int)
 |  
 |  loader_finished(self, *args) -> 'void'
 |      loader_finished(self, li, neflags, filetypename)
 |      External file loader finished its work. Use this event to augment the existing
 |      loader functionality.
 |      
 |      @param li: (linput_t *)
 |      @param neflags: (uint16) Load file flags
 |      @param filetypename: (const char *)
 |  
 |  local_types_changed(self, *args) -> 'void'
 |      local_types_changed(self)
 |      Local types have been changed.
 |  
 |  make_code(self, *args) -> 'void'
 |      make_code(self, insn)
 |      An instruction is being created.
 |      
 |      @param insn: (const insn_t*)
 |  
 |  make_data(self, *args) -> 'void'
 |      make_data(self, ea, flags, tid, len)
 |      A data item is being created.
 |      
 |      @param ea: (::ea_t)
 |      @param flags: (flags_t)
 |      @param tid: (tid_t)
 |      @param len: (::asize_t)
 |  
 |  op_ti_changed(self, *args) -> 'void'
 |      op_ti_changed(self, ea, n, type, fnames)
 |      An operand typestring (c/c++ prototype) has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int)
 |      @param type: (const type_t *)
 |      @param fnames: (const p_list *)
 |  
 |  op_type_changed(self, *args) -> 'void'
 |      op_type_changed(self, ea, n)
 |      An operand type (offset, hex, etc...) has been set or deleted.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
 |  
 |  range_cmt_changed(self, *args) -> 'void'
 |      range_cmt_changed(self, kind, a, cmt, repeatable)
 |      Range comment has been changed.
 |      
 |      @param kind: (range_kind_t)
 |      @param a: (const range_t *)
 |      @param cmt: (const char *)
 |      @param repeatable: (bool)
 |  
 |  renamed(self, *args) -> 'void'
 |      renamed(self, ea, new_name, local_name, old_name)
 |      The kernel has renamed a byte. See also the rename event
 |      
 |      @param ea: (::ea_t)
 |      @param new_name: (const char *) can be nullptr
 |      @param local_name: (bool)
 |      @param old_name: (const char *) can be nullptr
 |  
 |  renaming_enum(self, *args) -> 'void'
 |      renaming_enum(self, id, is_enum, newname)
 |      An enum or enum member is to be renamed.
 |      
 |      @param id: (tid_t)
 |      @param is_enum: (bool)
 |      @param newname: (const char *)
 |  
 |  renaming_struc(self, *args) -> 'void'
 |      renaming_struc(self, id, oldname, newname)
 |      A structure type is to be renamed.
 |      
 |      @param id: (tid_t)
 |      @param oldname: (const char *)
 |      @param newname: (const char *)
 |  
 |  renaming_struc_member(self, *args) -> 'void'
 |      renaming_struc_member(self, sptr, mptr, newname)
 |      A structure member is to be renamed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |      @param newname: (const char *)
 |  
 |  savebase(self, *args) -> 'void'
 |      savebase(self)
 |      The database is being saved.
 |  
 |  segm_added(self, *args) -> 'void'
 |      segm_added(self, s)
 |      A new segment has been created.
 |      
 |      @param s: (segment_t *) See also adding_segm
 |  
 |  segm_attrs_updated(self, *args) -> 'void'
 |      segm_attrs_updated(self, s)
 |      Segment attributes has been changed.
 |      
 |      @param s: (segment_t *) This event is generated for secondary segment attributes
 |                (examples: color, permissions, etc)
 |  
 |  segm_class_changed(self, *args) -> 'void'
 |      segm_class_changed(self, s, sclass)
 |      Segment class has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param sclass: (const char *)
 |  
 |  segm_deleted(self, *args) -> 'void'
 |      segm_deleted(self, start_ea, end_ea, flags)
 |      A segment has been deleted.
 |      
 |      @param start_ea: (::ea_t)
 |      @param end_ea: (::ea_t)
 |      @param flags: (int)
 |  
 |  segm_end_changed(self, *args) -> 'void'
 |      segm_end_changed(self, s, oldend)
 |      Segment end address has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param oldend: (::ea_t)
 |  
 |  segm_moved(self, *args) -> 'void'
 |      segm_moved(self, _from, to, size, changed_netmap)
 |      Segment has been moved.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param size: (::asize_t)
 |      @param changed_netmap: (bool) See also idb_event::allsegs_moved
 |  
 |  segm_name_changed(self, *args) -> 'void'
 |      segm_name_changed(self, s, name)
 |      Segment name has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param name: (const char *)
 |  
 |  segm_start_changed(self, *args) -> 'void'
 |      segm_start_changed(self, s, oldstart)
 |      Segment start address has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param oldstart: (::ea_t)
 |  
 |  set_func_end(self, *args) -> 'void'
 |      set_func_end(self, pfn, new_end)
 |      Function chunk end address will be changed.
 |      
 |      @param pfn: (func_t *)
 |      @param new_end: (::ea_t)
 |  
 |  set_func_start(self, *args) -> 'void'
 |      set_func_start(self, pfn, new_start)
 |      Function chunk start address will be changed.
 |      
 |      @param pfn: (func_t *)
 |      @param new_start: (::ea_t)
 |  
 |  sgr_changed(self, *args) -> 'void'
 |      sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
 |      The kernel has changed a segment register value.
 |      
 |      @param start_ea: (::ea_t)
 |      @param end_ea: (::ea_t)
 |      @param regnum: (int)
 |      @param value: (::sel_t)
 |      @param old_value: (::sel_t)
 |      @param tag: (uchar) Segment register range tags
 |  
 |  sgr_deleted(self, *args) -> 'void'
 |      sgr_deleted(self, start_ea, end_ea, regnum)
 |      The kernel has deleted a segment register value.
 |      
 |      @param start_ea: (::ea_t)
 |      @param end_ea: (::ea_t)
 |      @param regnum: (int)
 |  
 |  stkpnts_changed(self, *args) -> 'void'
 |      stkpnts_changed(self, pfn)
 |      Stack change points have been modified.
 |      
 |      @param pfn: (func_t *)
 |  
 |  struc_align_changed(self, *args) -> 'void'
 |      struc_align_changed(self, sptr)
 |      A structure type has been changed (the struct alignment).
 |      
 |      @param sptr: (struc_t *)
 |  
 |  struc_cmt_changed(self, *args) -> 'void'
 |      struc_cmt_changed(self, struc_id, repeatable_cmt)
 |      A structure type comment has been changed.
 |      
 |      @param struc_id: (tid_t)
 |      @param repeatable_cmt: (bool)
 |  
 |  struc_created(self, *args) -> 'void'
 |      struc_created(self, struc_id)
 |      A new structure type has been created.
 |      
 |      @param struc_id: (tid_t)
 |  
 |  struc_deleted(self, *args) -> 'void'
 |      struc_deleted(self, struc_id)
 |      A structure type has been deleted.
 |      
 |      @param struc_id: (tid_t)
 |  
 |  struc_expanded(self, *args) -> 'void'
 |      struc_expanded(self, sptr)
 |      A structure type has been expanded/shrank.
 |      
 |      @param sptr: (struc_t *)
 |  
 |  struc_member_changed(self, *args) -> 'void'
 |      struc_member_changed(self, sptr, mptr)
 |      A structure member has been changed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  struc_member_created(self, *args) -> 'void'
 |      struc_member_created(self, sptr, mptr)
 |      A structure member has been created.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  struc_member_deleted(self, *args) -> 'void'
 |      struc_member_deleted(self, sptr, member_id, offset)
 |      A structure member has been deleted.
 |      
 |      @param sptr: (struc_t *)
 |      @param member_id: (tid_t)
 |      @param offset: (::ea_t)
 |  
 |  struc_member_renamed(self, *args) -> 'void'
 |      struc_member_renamed(self, sptr, mptr)
 |      A structure member has been renamed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  struc_renamed(self, *args) -> 'void'
 |      struc_renamed(self, sptr, success)
 |      A structure type has been renamed.
 |      
 |      @param sptr: (struc_t *)
 |      @param success: (::bool) the structure was successfully renamed
 |  
 |  tail_owner_changed(self, *args) -> 'void'
 |      tail_owner_changed(self, tail, owner_func, old_owner)
 |      A tail chunk owner has been changed.
 |      
 |      @param tail: (func_t *)
 |      @param owner_func: (::ea_t)
 |      @param old_owner: (::ea_t)
 |  
 |  thunk_func_created(self, *args) -> 'void'
 |      thunk_func_created(self, pfn)
 |      A thunk bit has been set for a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  ti_changed(self, *args) -> 'void'
 |      ti_changed(self, ea, type, fnames)
 |      An item typestring (c/c++ prototype) has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param type: (const type_t *)
 |      @param fnames: (const p_list *)
 |  
 |  tryblks_updated(self, *args) -> 'void'
 |      tryblks_updated(self, tbv)
 |      Updated tryblk information
 |      
 |      @param tbv: (const ::tryblks_t *)
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  updating_tryblks(self, *args) -> 'void'
 |      updating_tryblks(self, tbv)
 |      About to update tryblk information
 |      
 |      @param tbv: (const ::tryblks_t *)
 |  
 |  upgraded(self, *args) -> 'void'
 |      upgraded(self, _from)
 |      The database has been upgraded and the receiver can upgrade its info as well
 |      
 |      @param from: (int) - old IDB version
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class IDP_Hooks in module ida_idp:

class IDP_Hooks(builtins.object)
 |  Proxy of C++ IDP_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> IDP_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDP_Hooks(...)
 |      delete_IDP_Hooks(self)
 |  
 |  ev_add_cref(self, *args) -> 'int'
 |      ev_add_cref(self, _from, to, type) -> int
 |      A code reference is being created.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param type: (cref_t)
 |      @retval <0: cancel cref creation
 |      @retval 0: not implemented or continue
 |  
 |  ev_add_dref(self, *args) -> 'int'
 |      ev_add_dref(self, _from, to, type) -> int
 |      A data reference is being created.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param type: (dref_t)
 |      @retval <0: cancel dref creation
 |      @retval 0: not implemented or continue
 |  
 |  ev_adjust_argloc(self, *args) -> 'int'
 |      ev_adjust_argloc(self, argloc, optional_type, size) -> int
 |      Adjust argloc according to its type/size and platform endianess
 |      
 |      @param argloc: (argloc_t *), inout
 |      @param type: (const tinfo_t *), may be nullptr nullptr means primitive type of
 |                   given size
 |      @param size: (int) 'size' makes no sense if type != nullptr (type->get_size()
 |                   should be used instead)
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: error
 |  
 |  ev_adjust_libfunc_ea(self, *args) -> 'int'
 |      ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
 |      Called when a signature module has been matched against bytes in the database.
 |      This is used to compute the offset at which a particular module's libfunc should
 |      be applied.
 |      
 |      @param sig: (const idasgn_t *)
 |      @param libfun: (const libfunc_t *)
 |      @param ea: (::ea_t *)
 |      @note: 'ea' initially contains the ea_t of the start of the pattern match
 |      @retval 1: the ea_t pointed to by the third argument was modified.
 |      @retval <=0: not modified. use default algorithm.
 |  
 |  ev_adjust_refinfo(self, *args) -> 'int'
 |      ev_adjust_refinfo(self, ri, ea, n, fd) -> int
 |      Called from apply_fixup before converting operand to reference. Can be used for
 |      changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some
 |      references)
 |      
 |      @param ri: (refinfo_t *)
 |      @param ea: (::ea_t) instruction address
 |      @param n: (int) operand number
 |      @param fd: (const fixup_data_t *)
 |      @retval <0: do not create an offset
 |      @retval 0: not implemented or refinfo adjusted
 |  
 |  ev_ana_insn(self, *args) -> 'bool'
 |      ev_ana_insn(self, out) -> bool
 |      Analyze one instruction and fill 'out' structure. This function shouldn't change
 |      the database, flags or anything else. All these actions should be performed only
 |      by emu_insn() function. insn_t::ea contains address of instruction to analyze.
 |      
 |      @param out: (insn_t *)
 |      @return: length of the instruction in bytes, 0 if instruction can't be decoded.
 |      @retval 0: if instruction can't be decoded.
 |  
 |  ev_analyze_prolog(self, *args) -> 'int'
 |      ev_analyze_prolog(self, ea) -> int
 |      Analyzes function prolog, epilog, and updates purge, and function attributes
 |      
 |      @param ea: (::ea_t) start of function
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_arch_changed(self, *args) -> 'int'
 |      ev_arch_changed(self) -> int
 |      The loader is done parsing arch-related information, which the processor module
 |      might want to use to finish its initialization.
 |      @retval 1: if success
 |      @retval 0: not implemented or failed
 |  
 |  ev_arg_addrs_ready(self, *args) -> 'int'
 |      ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
 |      Argument address info is ready.
 |      
 |      @param caller: (::ea_t)
 |      @param n: (int) number of formal arguments
 |      @param tif: (tinfo_t *) call prototype
 |      @param addrs: (::ea_t *) argument intilization addresses
 |      @retval <0: do not save into idb; other values mean "ok to save"
 |  
 |  ev_asm_installed(self, *args) -> 'int'
 |      ev_asm_installed(self, asmnum) -> int
 |      After setting a new assembler
 |      
 |      @param asmnum: (int) See also ev_newasm
 |  
 |  ev_assemble(self, *args) -> 'PyObject *'
 |      ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
 |      Assemble an instruction. (display a warning if an error is found).
 |      
 |      @param ea: (::ea_t) linear address of instruction
 |      @param cs: (::ea_t) cs of instruction
 |      @param ip: (::ea_t) ip of instruction
 |      @param use32: (bool) is 32bit segment?
 |      @param line: (const char *) line to assemble
 |      @return: size of the instruction in bytes
 |  
 |  ev_auto_queue_empty(self, *args) -> 'int'
 |      ev_auto_queue_empty(self, type) -> int
 |      One analysis queue is empty.
 |      
 |      @param type: (atype_t)
 |      @retval void: see also idb_event::auto_empty_finally
 |  
 |  ev_calc_arglocs(self, *args) -> 'int'
 |      ev_calc_arglocs(self, fti) -> int
 |      Calculate function argument locations. This callback should fill retloc, all
 |      arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions.
 |      
 |      @param fti: (func_type_data_t *) points to the func type info
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: error
 |  
 |  ev_calc_cdecl_purged_bytes(self, *args) -> 'int'
 |      ev_calc_cdecl_purged_bytes(self, ea) -> int
 |      Calculate number of purged bytes after call.
 |      
 |      @param ea: (::ea_t) address of the call instruction
 |      @return: number of purged bytes (usually add sp, N)
 |  
 |  ev_calc_next_eas(self, *args) -> 'int'
 |      ev_calc_next_eas(self, res, insn, over) -> int
 |      Calculate list of addresses the instruction in 'insn' may pass control to. This
 |      callback is required for source level debugging.
 |      
 |      @param res: (eavec_t *), out: array for the results.
 |      @param insn: (const insn_t*) the instruction
 |      @param over: (bool) calculate for step over (ignore call targets)
 |      @retval <0: incalculable (indirect jumps, for example)
 |      @retval >=0: number of addresses of called functions in the array. They must be
 |                   put at the beginning of the array (0 if over=true)
 |  
 |  ev_calc_purged_bytes(self, *args) -> 'int'
 |      ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
 |      Calculate number of purged bytes by the given function type.
 |      
 |      @param p_purged_bytes: (int *) ptr to output
 |      @param fti: (const func_type_data_t *) func type details
 |      @retval 1
 |      @retval 0: not implemented
 |  
 |  ev_calc_retloc(self, *args) -> 'int'
 |      ev_calc_retloc(self, retloc, rettype, cc) -> int
 |      Calculate return value location.
 |      
 |      @param retloc: (argloc_t *)
 |      @param rettype: (const tinfo_t *)
 |      @param cc: (cm_t)
 |      @retval 0: not implemented
 |      @retval 1: ok,
 |      @retval -1: error
 |  
 |  ev_calc_spdelta(self, *args) -> 'int'
 |      ev_calc_spdelta(self, spdelta, insn) -> int
 |      Calculate amount of change to sp for the given insn. This event is required to
 |      decompile code snippets.
 |      
 |      @param spdelta: (sval_t *)
 |      @param insn: (const insn_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_calc_step_over(self, *args) -> 'int'
 |      ev_calc_step_over(self, target, ip) -> int
 |      Calculate the address of the instruction which will be executed after "step
 |      over". The kernel will put a breakpoint there. If the step over is equal to step
 |      into or we cannot calculate the address, return BADADDR.
 |      
 |      @param target: (::ea_t *) pointer to the answer
 |      @param ip: (::ea_t) instruction address
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_calc_switch_cases(self, *args) -> 'int'
 |      ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
 |      Calculate case values and targets for a custom jump table.
 |      
 |      @param casevec: (::casevec_t *) vector of case values (may be nullptr)
 |      @param targets: (eavec_t *) corresponding target addresses (my be nullptr)
 |      @param insn_ea: (::ea_t) address of the 'indirect jump' instruction
 |      @param si: (switch_info_t *) switch information
 |      @retval 1: ok
 |      @retval <=0: failed
 |  
 |  ev_calc_varglocs(self, *args) -> 'int'
 |      ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
 |      Calculate locations of the arguments that correspond to '...'.
 |      
 |      @param ftd: (func_type_data_t *), inout: info about all arguments (including
 |                  varargs)
 |      @param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be
 |                       nullptr
 |      @param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be
 |                          nullptr
 |      @param nfixed: (int) number of fixed arguments
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: error On some platforms variadic calls require passing additional
 |                  information: for example, number of floating variadic arguments must
 |                  be passed in rax on gcc-x64. The locations and values that
 |                  constitute this additional information are returned in the buffers
 |                  pointed by aux_regs and aux_stkargs
 |  
 |  ev_calcrel(self, *args) -> 'int'
 |      ev_calcrel(self) -> int
 |      Reserved.
 |  
 |  ev_can_have_type(self, *args) -> 'int'
 |      ev_can_have_type(self, op) -> int
 |      Can the operand have a type as offset, segment, decimal, etc? (for example, a
 |      register AX can't have a type, meaning that the user can't change its
 |      representation. see bytes.hpp for information about types and flags)
 |      
 |      @param op: (const op_t *)
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_clean_tbit(self, *args) -> 'int'
 |      ev_clean_tbit(self, ea, getreg, regvalues) -> int
 |      Clear the TF bit after an insn like pushf stored it in memory.
 |      
 |      @param ea: (::ea_t) instruction address
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 1: ok
 |      @retval 0: failed
 |  
 |  ev_cmp_operands(self, *args) -> 'int'
 |      ev_cmp_operands(self, op1, op2) -> int
 |      Compare instruction operands
 |      
 |      @param op1: (const op_t*)
 |      @param op2: (const op_t*)
 |      @retval 1: equal
 |      @retval -1: not equal
 |      @retval 0: not implemented
 |  
 |  ev_coagulate(self, *args) -> 'int'
 |      ev_coagulate(self, start_ea) -> int
 |      Try to define some unexplored bytes. This notification will be called if the
 |      kernel tried all possibilities and could not find anything more useful than to
 |      convert to array of bytes. The module can help the kernel and convert the bytes
 |      into something more useful.
 |      
 |      @param start_ea: (::ea_t)
 |      @return: number of converted bytes
 |  
 |  ev_coagulate_dref(self, *args) -> 'int'
 |      ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
 |      Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb
 |      mode refs, we clear the last bit)
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param may_define: (bool)
 |      @param code_ea: (::ea_t *)
 |      @retval <0: failed dref analysis, >0 done dref analysis
 |      @retval 0: not implemented or continue
 |  
 |  ev_create_flat_group(self, *args) -> 'int'
 |      ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
 |      Create special segment representing the flat group.
 |      
 |      @param image_base: (::ea_t)
 |      @param bitness: (int)
 |      @param dataseg_sel: (::sel_t) return value is ignored
 |  
 |  ev_create_func_frame(self, *args) -> 'int'
 |      ev_create_func_frame(self, pfn) -> int
 |      Create a function frame for a newly created function Set up frame size, its
 |      attributes etc
 |      
 |      @param pfn: (func_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_create_merge_handlers(self, *args) -> 'int'
 |      ev_create_merge_handlers(self, md) -> int
 |      Create merge handlers, if needed
 |      
 |      @param md: (merge_data_t *) This event is generated immediately after opening
 |                 idbs.
 |      @return: must be 0
 |  
 |  ev_create_switch_xrefs(self, *args) -> 'int'
 |      ev_create_switch_xrefs(self, jumpea, si) -> int
 |      Create xrefs for a custom jump table.
 |      
 |      @param jumpea: (::ea_t) address of the jump insn
 |      @param si: (const switch_info_t *) switch information
 |      @return: must return 1 Must be implemented if module uses custom jump tables,
 |               SWI_CUSTOM
 |  
 |  ev_creating_segm(self, *args) -> 'int'
 |      ev_creating_segm(self, seg) -> int
 |      A new segment is about to be created.
 |      
 |      @param seg: (segment_t *)
 |      @retval 1: ok
 |      @retval <0: segment should not be created
 |  
 |  ev_decorate_name(self, *args) -> 'PyObject *'
 |      ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
 |      Decorate/undecorate a C symbol name.
 |      
 |      @param name: (const char *) name of symbol
 |      @param mangle: (bool) true-mangle, false-unmangle
 |      @param cc: (cm_t) calling convention
 |      @param optional_type: tinfo_t const *
 |      @retval 1: if success
 |      @retval 0: not implemented or failed
 |  
 |  ev_del_cref(self, *args) -> 'int'
 |      ev_del_cref(self, _from, to, expand) -> int
 |      A code reference is being deleted.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param expand: (bool)
 |      @retval <0: cancel cref deletion
 |      @retval 0: not implemented or continue
 |  
 |  ev_del_dref(self, *args) -> 'int'
 |      ev_del_dref(self, _from, to) -> int
 |      A data reference is being deleted.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @retval <0: cancel dref deletion
 |      @retval 0: not implemented or continue
 |  
 |  ev_delay_slot_insn(self, *args) -> 'PyObject *'
 |      ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
 |      Get delay slot instruction
 |      
 |      @param ea: (::ea_t *) in: instruction address in question, out: (if the answer
 |                 is positive) if the delay slot contains valid insn: the address of
 |                 the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
 |      @param bexec: (bool *) execute slot if jumping, initially set to 'true'
 |      @param fexec: (bool *) execute slot if not jumping, initally set to 'true'
 |      @retval 1: positive answer
 |      @retval <=0: ordinary insn
 |      @note: Input EA may point to the instruction with a delay slot or to the delay
 |             slot instruction itself.
 |  
 |  ev_demangle_name(self, *args) -> 'PyObject *'
 |      ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
 |      Demangle a C++ (or another language) name into a user-readable string. This
 |      event is called by demangle_name()
 |      
 |      @param name: (const char *) mangled name
 |      @param disable_mask: (uint32) flags to inhibit parts of output or compiler
 |                           info/other (see MNG_)
 |      @param demreq: (demreq_type_t) operation to perform
 |      @retval 1: if success
 |      @retval 0: not implemented
 |      @note: if you call demangle_name() from the handler, protect against recursion!
 |  
 |  ev_emu_insn(self, *args) -> 'bool'
 |      ev_emu_insn(self, insn) -> bool
 |      Emulate instruction, create cross-references, plan to analyze subsequent
 |      instructions, modify flags etc. Upon entrance to this function, all information
 |      about the instruction is in 'insn' structure.
 |      
 |      @param insn: (const insn_t *)
 |      @retval 1: ok
 |      @retval -1: the kernel will delete the instruction
 |  
 |  ev_endbinary(self, *args) -> 'int'
 |      ev_endbinary(self, ok) -> int
 |      IDA has loaded a binary file.
 |      
 |      @param ok: (bool) file loaded successfully?
 |  
 |  ev_ending_undo(self, *args) -> 'int'
 |      ev_ending_undo(self, action_name, is_undo) -> int
 |      Ended undoing/redoing an action
 |      
 |      @param action_name: (const char *) action that we finished undoing/redoing. is
 |                          not nullptr.
 |      @param is_undo: (bool) true if performing undo, false if performing redo
 |  
 |  ev_equal_reglocs(self, *args) -> 'int'
 |      ev_equal_reglocs(self, a1, a2) -> int
 |      Are 2 register arglocs the same?. We need this callback for the pc module.
 |      
 |      @param a1: (argloc_t *)
 |      @param a2: (argloc_t *)
 |      @retval 1: yes
 |      @retval -1: no
 |      @retval 0: not implemented
 |  
 |  ev_extract_address(self, *args) -> 'int'
 |      ev_extract_address(self, out_ea, screen_ea, string, position) -> int
 |      Extract address from a string.
 |      
 |      @param out_ea: (ea_t *), out
 |      @param screen_ea: (ea_t)
 |      @param string: (const char *)
 |      @param position: (size_t)
 |      @retval 1: ok
 |      @retval 0: kernel should use the standard algorithm
 |      @retval -1: error
 |  
 |  ev_find_op_value(self, *args) -> 'PyObject *'
 |      ev_find_op_value(self, pinsn, opn) -> PyObject *
 |      Find operand value via a register tracker. The returned value in 'out' is valid
 |      before executing the instruction.
 |      
 |      @param pinsn: (const insn_t *) instruction
 |      @param opn: (int) operand index
 |      @retval 1: if implemented, and value was found
 |      @retval 0: not implemented, -1 decoding failed, or no value found
 |  
 |  ev_find_reg_value(self, *args) -> 'PyObject *'
 |      ev_find_reg_value(self, pinsn, reg) -> PyObject *
 |      Find register value via a register tracker. The returned value in 'out' is valid
 |      before executing the instruction.
 |      
 |      @param pinsn: (const insn_t *) instruction
 |      @param reg: (int) register index
 |      @retval 1: if implemented, and value was found
 |      @retval 0: not implemented, -1 decoding failed, or no value found
 |  
 |  ev_func_bounds(self, *args) -> 'int'
 |      ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea) -> int
 |      find_func_bounds() finished its work. The module may fine tune the function
 |      bounds
 |      
 |      @param possible_return_code: (int *), in/out
 |      @param pfn: (func_t *)
 |      @param max_func_end_ea: (::ea_t) (from the kernel's point of view)
 |      @retval void
 |  
 |  ev_gen_asm_or_lst(self, *args) -> 'int'
 |      ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -> int
 |      
 |      @param starting: (bool) beginning listing generation
 |      @param fp: (FILE *) output file
 |      @param is_asm: (bool) true:assembler, false:listing
 |      @param flags: (int) flags passed to gen_file()
 |      @param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this
 |                      callback is defined for this code, it will be used by the kernel
 |                      to output the generated lines
 |      @retval void
 |  
 |  ev_gen_map_file(self, *args) -> 'int'
 |      ev_gen_map_file(self, nlines, fp) -> int
 |      Generate map file. If not implemented the kernel itself will create the map
 |      file.
 |      
 |      @param nlines: (int *) number of lines in map file (-1 means write error)
 |      @param fp: (FILE *) output file
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: write error
 |  
 |  ev_gen_regvar_def(self, *args) -> 'int'
 |      ev_gen_regvar_def(self, outctx, v) -> int
 |      Generate register variable definition line.
 |      
 |      @param outctx: (outctx_t *)
 |      @param v: (regvar_t *)
 |      @retval >0: ok, generated the definition text
 |      @retval 0: not implemented
 |  
 |  ev_gen_src_file_lnnum(self, *args) -> 'int'
 |      ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
 |      
 |      @param outctx: (outctx_t *) output context
 |      @param file: (const char *) source file (may be nullptr)
 |      @param lnnum: (size_t) line number
 |      @retval 1: directive has been generated
 |      @retval 0: not implemented
 |  
 |  ev_gen_stkvar_def(self, *args) -> 'int'
 |      ev_gen_stkvar_def(self, outctx, mptr, v) -> int
 |      Generate stack variable definition line Default line is varname = type ptr
 |      value, where 'type' is one of byte,word,dword,qword,tbyte
 |      
 |      @param outctx: (outctx_t *)
 |      @param mptr: (const member_t *)
 |      @param v: (sval_t)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_get_abi_info(self, *args) -> 'int'
 |      ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
 |      Get all possible ABI names and optional extensions for given compiler
 |      abiname/option is a string entirely consisting of letters, digits and underscore
 |      
 |      @param abi_names: (qstrvec_t *) - all possible ABis each in form abiname-
 |                        opt1-opt2-...
 |      @param abi_opts: (qstrvec_t *) - array of all possible options in form
 |                       "opt:description" or opt:hint-line#description
 |      @param comp: (comp_t) - compiler ID
 |      @retval 0: not implemented
 |      @retval 1: ok
 |  
 |  ev_get_autocmt(self, *args) -> 'PyObject *'
 |      ev_get_autocmt(self, insn) -> PyObject *
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @retval 1: new comment has been generated
 |      @retval 0: callback has not been handled. the buffer must not be changed in this
 |                 case
 |  
 |  ev_get_bg_color(self, *args) -> 'int'
 |      ev_get_bg_color(self, color, ea) -> int
 |      Get item background color. Plugins can hook this callback to color disassembly
 |      lines dynamically
 |      
 |      @param color: (bgcolor_t *), out
 |      @param ea: (::ea_t)
 |      @retval 0: not implemented
 |      @retval 1: color set
 |  
 |  ev_get_cc_regs(self, *args) -> 'int'
 |      ev_get_cc_regs(self, regs, cc) -> int
 |      Get register allocation convention for given calling convention
 |      
 |      @param regs: (callregs_t *), out
 |      @param cc: (cm_t)
 |      @retval 1
 |      @retval 0: not implemented
 |  
 |  ev_get_code16_mode(self, *args) -> 'int'
 |      ev_get_code16_mode(self, ea) -> int
 |      Get ISA 16-bit mode
 |      
 |      @param ea: (ea_t) address to get the ISA mode
 |      @retval 1: 16-bit mode
 |      @retval 0: not implemented or 32-bit mode
 |  
 |  ev_get_dbr_opnum(self, *args) -> 'int'
 |      ev_get_dbr_opnum(self, opnum, insn) -> int
 |      Get the number of the operand to be displayed in the debugger reference view
 |      (text mode).
 |      
 |      @param opnum: (int *) operand number (out, -1 means no such operand)
 |      @param insn: (const insn_t*) the instruction
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_get_default_enum_size(self, *args) -> 'int'
 |      ev_get_default_enum_size(self) -> int
 |      Get default enum size. Not generated anymore. inf_get_cc_size_e() is used
 |      instead
 |  
 |  ev_get_frame_retsize(self, *args) -> 'int'
 |      ev_get_frame_retsize(self, frsize, pfn) -> int
 |      Get size of function return address in bytes If this event is not implemented,
 |      the kernel will assume
 |      * 8 bytes for 64-bit function
 |      * 4 bytes for 32-bit function
 |      * 2 bytes otherwise
 |      
 |      @param frsize: (int *) frame size (out)
 |      @param pfn: (const func_t *), can't be nullptr
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_get_macro_insn_head(self, *args) -> 'int'
 |      ev_get_macro_insn_head(self, head, ip) -> int
 |      Calculate the start of a macro instruction. This notification is called if IP
 |      points to the middle of an instruction
 |      
 |      @param head: (::ea_t *), out: answer, BADADDR means normal instruction
 |      @param ip: (::ea_t) instruction address
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_get_operand_string(self, *args) -> 'PyObject *'
 |      ev_get_operand_string(self, insn, opnum) -> PyObject *
 |      Request text string for operand (cli, java, ...).
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param opnum: (int) operand number, -1 means any string operand
 |      @retval 0: no string (or empty string)
 |      @retval >0: original string length without terminating zero
 |  
 |  ev_get_procmod(self, *args) -> 'int'
 |      ev_get_procmod(self) -> int
 |      Get pointer to the processor module object. All processor modules must implement
 |      this. The pointer is returned as size_t.
 |  
 |  ev_get_reg_accesses(self, *args) -> 'int'
 |      ev_get_reg_accesses(self, accvec, insn, flags) -> int
 |      Get info about the registers that are used/changed by an instruction.
 |      
 |      @param accvec: (reg_accesses_t*) out: info about accessed registers
 |      @param insn: (const insn_t *) instruction in question
 |      @param flags: (int) reserved, must be 0
 |      @retval -1: if accvec is nullptr
 |      @retval 1: found the requested access (and filled accvec)
 |      @retval 0: not implemented
 |  
 |  ev_get_reg_info(self, *args) -> 'int'
 |      ev_get_reg_info(self, main_regname, bitrange, regname) -> int
 |      Get register information by its name. example: "ah" returns:
 |      * main_regname="eax"
 |      * bitrange_t = { offset==8, nbits==8 }
 |      
 |      This callback may be unimplemented if the register names are all present in
 |      processor_t::reg_names and they all have the same size
 |      
 |      @param main_regname: (const char **), out
 |      @param bitrange: (bitrange_t *), out: position and size of the value within
 |                       'main_regname' (empty bitrange == whole register)
 |      @param regname: (const char *)
 |      @retval 1: ok
 |      @retval -1: failed (not found)
 |      @retval 0: unimplemented
 |  
 |  ev_get_reg_name(self, *args) -> 'PyObject *'
 |      ev_get_reg_name(self, reg, width, reghi) -> PyObject *
 |      Generate text representation of a register. Most processor modules do not need
 |      to implement this callback. It is useful only if processor_t::reg_names[reg]
 |      does not provide the correct register name.
 |      
 |      @param reg: (int) internal register number as defined in the processor module
 |      @param width: (size_t) register width in bytes
 |      @param reghi: (int) if not -1 then this function will return the register pair
 |      @retval -1: if error
 |      @retval strlen(buf): if success
 |  
 |  ev_get_simd_types(self, *args) -> 'int'
 |      ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
 |      Get SIMD-related types according to given attributes ant/or argument location
 |      
 |      @param out: (::simd_info_vec_t *)
 |      @param simd_attrs: (const simd_info_t *), may be nullptr
 |      @param argloc: (const argloc_t *), may be nullptr
 |      @param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
 |      @retval number: of found types
 |      @retval -1: error If name==nullptr, initialize all SIMD types
 |  
 |  ev_get_stkarg_area_info(self, *args) -> 'int'
 |      ev_get_stkarg_area_info(self, out, cc) -> int
 |      Get some metrics of the stack argument area.
 |      
 |      @param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
 |      @param cc: (cm_t) calling convention
 |      @retval 1: if success
 |      @retval 0: not implemented
 |  
 |  ev_get_stkvar_scale_factor(self, *args) -> 'int'
 |      ev_get_stkvar_scale_factor(self) -> int
 |      Should stack variable references be multiplied by a coefficient before being
 |      used in the stack frame?. Currently used by TMS320C55 because the references
 |      into the stack should be multiplied by 2
 |      
 |      @return: scaling factor
 |      @retval 0: not implemented
 |      @note: PR_SCALE_STKVARS should be set to use this callback
 |  
 |  ev_getreg(self, *args) -> 'int'
 |      ev_getreg(self, regval, regnum) -> int
 |      IBM PC only internal request, should never be used for other purpose Get
 |      register value by internal index
 |      
 |      @param regval: (uval_t *), out
 |      @param regnum: (int)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |      @retval -1: failed (undefined value or bad regnum)
 |  
 |  ev_init(self, *args) -> 'int'
 |      ev_init(self, idp_modname) -> int
 |      The IDP module is just loaded.
 |      
 |      @param idp_modname: (const char *) processor module name
 |      @retval <0: on failure
 |  
 |  ev_insn_reads_tbit(self, *args) -> 'int'
 |      ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
 |      Check if insn will read the TF bit.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 2: yes, will generate 'step' exception
 |      @retval 1: yes, will store the TF bit in memory
 |      @retval 0: no
 |  
 |  ev_is_align_insn(self, *args) -> 'int'
 |      ev_is_align_insn(self, ea) -> int
 |      Is the instruction created only for alignment purposes?. Do not directly call
 |      this function, use is_align_insn()
 |      
 |      @param ea: (ea_t) - instruction address
 |      @retval number: of bytes in the instruction
 |  
 |  ev_is_alloca_probe(self, *args) -> 'int'
 |      ev_is_alloca_probe(self, ea) -> int
 |      Does the function at 'ea' behave as __alloca_probe?
 |      
 |      @param ea: (::ea_t)
 |      @retval 1: yes
 |      @retval 0: no
 |  
 |  ev_is_basic_block_end(self, *args) -> 'int'
 |      ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
 |      Is the current instruction end of a basic block?. This function should be
 |      defined for processors with delayed jump slots.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param call_insn_stops_block: (bool)
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_is_call_insn(self, *args) -> 'int'
 |      ev_is_call_insn(self, insn) -> int
 |      Is the instruction a "call"?
 |      
 |      @param insn: (const insn_t *) instruction
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_is_cond_insn(self, *args) -> 'int'
 |      ev_is_cond_insn(self, insn) -> int
 |      Is conditional instruction?
 |      
 |      @param insn: (const insn_t *) instruction address
 |      @retval 1: yes
 |      @retval -1: no
 |      @retval 0: not implemented or not instruction
 |  
 |  ev_is_control_flow_guard(self, *args) -> 'int'
 |      ev_is_control_flow_guard(self, p_reg, insn) -> int
 |      Detect if an instruction is a "thunk call" to a flow guard function (equivalent
 |      to call reg/return/nop)
 |      
 |      @param p_reg: (int *) indirect register number, may be -1
 |      @param insn: (const insn_t *) call/jump instruction
 |      @retval -1: no thunk detected
 |      @retval 1: indirect call
 |      @retval 2: security check routine call (NOP)
 |      @retval 3: return thunk
 |      @retval 0: not implemented
 |  
 |  ev_is_far_jump(self, *args) -> 'int'
 |      ev_is_far_jump(self, icode) -> int
 |      is indirect far jump or call instruction? meaningful only if the processor has
 |      'near' and 'far' reference types
 |      
 |      @param icode: (int)
 |      @retval 0: not implemented
 |      @retval 1: yes
 |      @retval -1: no
 |  
 |  ev_is_indirect_jump(self, *args) -> 'int'
 |      ev_is_indirect_jump(self, insn) -> int
 |      Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all
 |      jump types jumps, please define this callback.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @retval 0: use CF_JUMP
 |      @retval 1: no
 |      @retval 2: yes
 |  
 |  ev_is_insn_table_jump(self, *args) -> 'int'
 |      ev_is_insn_table_jump(self) -> int
 |      Reserved.
 |  
 |  ev_is_jump_func(self, *args) -> 'int'
 |      ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
 |      Is the function a trivial "jump" function?.
 |      
 |      @param pfn: (func_t *)
 |      @param jump_target: (::ea_t *)
 |      @param func_pointer: (::ea_t *)
 |      @retval <0: no
 |      @retval 0: don't know
 |      @retval 1: yes, see 'jump_target' and 'func_pointer'
 |  
 |  ev_is_ret_insn(self, *args) -> 'int'
 |      ev_is_ret_insn(self, insn, strict) -> int
 |      Is the instruction a "return"?
 |      
 |      @param insn: (const insn_t *) instruction
 |      @param strict: (bool) 1: report only ret instructions 0: include instructions
 |                     like "leave" which begins the function epilog
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_is_sane_insn(self, *args) -> 'int'
 |      ev_is_sane_insn(self, insn, no_crefs) -> int
 |      Is the instruction sane for the current file type?.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries
 |                       to convert unexplored bytes to an instruction (but there is no
 |                       other reason to convert them into an instruction) 0: the
 |                       instruction is created because of some coderef, user request or
 |                       another weighty reason.
 |      @retval >=0: ok
 |      @retval <0: no, the instruction isn't likely to appear in the program
 |  
 |  ev_is_sp_based(self, *args) -> 'int'
 |      ev_is_sp_based(self, mode, insn, op) -> int
 |      Check whether the operand is relative to stack pointer or frame pointer This
 |      event is used to determine how to output a stack variable If not implemented,
 |      then all operands are sp based by default. Implement this event only if some
 |      stack references use frame pointer instead of stack pointer.
 |      
 |      @param mode: (int *) out, combination of SP/FP operand flags
 |      @param insn: (const insn_t *)
 |      @param op: (const op_t *)
 |      @retval 0: not implemented
 |      @retval 1: ok
 |  
 |  ev_is_switch(self, *args) -> 'int'
 |      ev_is_switch(self, si, insn) -> int
 |      Find 'switch' idiom or override processor module's decision. It will be called
 |      for instructions marked with CF_JUMP.
 |      
 |      @param si: (switch_info_t *), out
 |      @param insn: (const insn_t *) instruction possibly belonging to a switch
 |      @retval 1: switch is found, 'si' is filled. IDA will create the switch using the
 |                 filled 'si'
 |      @retval -1: no switch found. This value forbids switch creation by the processor
 |                  module
 |      @retval 0: not implemented
 |  
 |  ev_last_cb_before_loader(self, *args) -> 'int'
 |      ev_last_cb_before_loader(self) -> int
 |  
 |  ev_loader(self, *args) -> 'int'
 |      ev_loader(self) -> int
 |      This code and higher ones are reserved for the loaders. The arguments and the
 |      return values are defined by the loaders
 |  
 |  ev_lower_func_type(self, *args) -> 'int'
 |      ev_lower_func_type(self, argnums, fti) -> int
 |      Get function arguments which should be converted to pointers when lowering
 |      function prototype. The processor module can also modify 'fti' in order to make
 |      non-standard conversion of some arguments.
 |      
 |      @param argnums: (intvec_t *), out - numbers of arguments to be converted to
 |                      pointers in acsending order
 |      @param fti: (func_type_data_t *), inout func type details (special values -1/-2
 |                  for return value - position of hidden 'retstr' argument: -1 - at the
 |                  beginning, -2 - at the end)
 |      @retval 0: not implemented
 |      @retval 1: argnums was filled
 |      @retval 2: argnums was filled and made substantial changes to fti
 |  
 |  ev_max_ptr_size(self, *args) -> 'int'
 |      ev_max_ptr_size(self) -> int
 |      Get maximal size of a pointer in bytes.
 |      
 |      @return: max possible size of a pointer
 |  
 |  ev_may_be_func(self, *args) -> 'int'
 |      ev_may_be_func(self, insn, state) -> int
 |      Can a function start here?
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
 |      @return: probability 1..100
 |      @note: Actually IDA uses 3 intervals of a probability: 0..50 not a function,
 |             51..99 a function (IDA needs another proof), 100 a function (no other
 |             proofs needed)
 |  
 |  ev_may_show_sreg(self, *args) -> 'int'
 |      ev_may_show_sreg(self, current_ea) -> int
 |      The kernel wants to display the segment registers in the messages window.
 |      
 |      @param current_ea: (::ea_t)
 |      @retval <0: if the kernel should not show the segment registers. (assuming that
 |                  the module has done it)
 |      @retval 0: not implemented
 |  
 |  ev_moving_segm(self, *args) -> 'int'
 |      ev_moving_segm(self, seg, to, flags) -> int
 |      May the kernel move the segment?
 |      
 |      @param seg: (segment_t *) segment to move
 |      @param to: (::ea_t) new segment start address
 |      @param flags: (int) combination of Move segment flags
 |      @retval 0: yes
 |      @retval <0: the kernel should stop
 |  
 |  ev_newasm(self, *args) -> 'int'
 |      ev_newasm(self, asmnum) -> int
 |      Before setting a new assembler.
 |      
 |      @param asmnum: (int) See also ev_asm_installed
 |  
 |  ev_newbinary(self, *args) -> 'int'
 |      ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
 |      IDA is about to load a binary file.
 |      
 |      @param filename: (char *) binary file name
 |      @param fileoff: (qoff64_t) offset in the file
 |      @param basepara: (::ea_t) base loading paragraph
 |      @param binoff: (::ea_t) loader offset
 |      @param nbytes: (::uint64) number of bytes to load
 |  
 |  ev_newfile(self, *args) -> 'int'
 |      ev_newfile(self, fname) -> int
 |      A new file has been loaded.
 |      
 |      @param fname: (char *) input file name
 |  
 |  ev_newprc(self, *args) -> 'int'
 |      ev_newprc(self, pnum, keep_cfg) -> int
 |      Before changing processor type.
 |      
 |      @param pnum: (int) processor number in the array of processor names
 |      @param keep_cfg: (bool) true: do not modify kernel configuration
 |      @retval 1: ok
 |      @retval <0: prohibit
 |  
 |  ev_next_exec_insn(self, *args) -> 'int'
 |      ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
 |      Get next address to be executed This function must return the next address to be
 |      executed. If the instruction following the current one is executed, then it must
 |      return BADADDR Usually the instructions to consider are: jumps, branches, calls,
 |      returns. This function is essential if the 'single step' is not supported in
 |      hardware.
 |      
 |      @param target: (::ea_t *), out: pointer to the answer
 |      @param ea: (::ea_t) instruction address
 |      @param tid: (int) current therad id
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_oldfile(self, *args) -> 'int'
 |      ev_oldfile(self, fname) -> int
 |      An old file has been loaded.
 |      
 |      @param fname: (char *) input file name
 |  
 |  ev_out_assumes(self, *args) -> 'int'
 |      ev_out_assumes(self, outctx) -> int
 |      Function to produce assume directives when segment register value changes.
 |      
 |      @param outctx: (outctx_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_data(self, *args) -> 'int'
 |      ev_out_data(self, outctx, analyze_only) -> int
 |      Generate text representation of data items This function may change the database
 |      and create cross-references if analyze_only is set
 |      
 |      @param outctx: (outctx_t *)
 |      @param analyze_only: (bool)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_footer(self, *args) -> 'int'
 |      ev_out_footer(self, outctx) -> int
 |      Function to produce end of disassembled text
 |      
 |      @param outctx: (outctx_t *)
 |      @retval void
 |  
 |  ev_out_header(self, *args) -> 'int'
 |      ev_out_header(self, outctx) -> int
 |      Function to produce start of disassembled text
 |      
 |      @param outctx: (outctx_t *)
 |      @retval void
 |  
 |  ev_out_insn(self, *args) -> 'bool'
 |      ev_out_insn(self, outctx) -> bool
 |      Generate text representation of an instruction in 'ctx.insn' outctx_t provides
 |      functions to output the generated text. This function shouldn't change the
 |      database, flags or anything else. All these actions should be performed only by
 |      emu_insn() function.
 |      
 |      @param outctx: (outctx_t *)
 |      @retval void
 |  
 |  ev_out_label(self, *args) -> 'int'
 |      ev_out_label(self, outctx, colored_name) -> int
 |      The kernel is going to generate an instruction label line or a function header.
 |      
 |      @param outctx: (outctx_t *)
 |      @param colored_name: (const char *)
 |      @retval <0: if the kernel should not generate the label
 |      @retval 0: not implemented or continue
 |  
 |  ev_out_mnem(self, *args) -> 'int'
 |      ev_out_mnem(self, outctx) -> int
 |      Generate instruction mnemonics. This callback should append the colored
 |      mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be
 |      called.
 |      
 |      @param outctx: (outctx_t *)
 |      @retval 1: if appended the mnemonics
 |      @retval 0: not implemented
 |  
 |  ev_out_operand(self, *args) -> 'bool'
 |      ev_out_operand(self, outctx, op) -> bool
 |      Generate text representation of an instruction operand outctx_t provides
 |      functions to output the generated text. All these actions should be performed
 |      only by emu_insn() function.
 |      
 |      @param outctx: (outctx_t *)
 |      @param op: (const op_t *)
 |      @retval 1: ok
 |      @retval -1: operand is hidden
 |  
 |  ev_out_segend(self, *args) -> 'int'
 |      ev_out_segend(self, outctx, seg) -> int
 |      Function to produce end of segment
 |      
 |      @param outctx: (outctx_t *)
 |      @param seg: (segment_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_segstart(self, *args) -> 'int'
 |      ev_out_segstart(self, outctx, seg) -> int
 |      Function to produce start of segment
 |      
 |      @param outctx: (outctx_t *)
 |      @param seg: (segment_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_special_item(self, *args) -> 'int'
 |      ev_out_special_item(self, outctx, segtype) -> int
 |      Generate text representation of an item in a special segment i.e. absolute
 |      symbols, externs, communal definitions etc
 |      
 |      @param outctx: (outctx_t *)
 |      @param segtype: (uchar)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |      @retval -1: overflow
 |  
 |  ev_privrange_changed(self, *args) -> 'int'
 |      ev_privrange_changed(self, old_privrange, delta) -> int
 |      Privrange interval has been moved to a new location. Most common actions to be
 |      done by module in this case: fix indices of netnodes used by module
 |      
 |      @param old_privrange: (const range_t *) - old privrange interval
 |      @param delta: (::adiff_t)
 |      @return: 0 Ok
 |      -1 error (and message in errbuf)
 |  
 |  ev_realcvt(self, *args) -> 'int'
 |      ev_realcvt(self, m, e, swt) -> int
 |      Floating point -> IEEE conversion
 |      
 |      @param m: (void *) ptr to processor-specific floating point value
 |      @param e: (fpvalue_t *) IDA representation of a floating point value
 |      @param swt: (uint16) operation (see realcvt() in ieee.h)
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval unknown
 |  
 |  ev_rename(self, *args) -> 'int'
 |      ev_rename(self, ea, new_name) -> int
 |      The kernel is going to rename a byte.
 |      
 |      @param ea: (::ea_t)
 |      @param new_name: (const char *)
 |      @retval <0: if the kernel should not rename it.
 |      @retval 2: to inhibit the notification. I.e., the kernel should not rename, but
 |                 'set_name()' should return 'true'. also see renamed the return value
 |                 is ignored when kernel is going to delete name
 |  
 |  ev_replaying_undo(self, *args) -> 'int'
 |      ev_replaying_undo(self, action_name, vec, is_undo) -> int
 |      Replaying an undo/redo buffer
 |      
 |      @param action_name: (const char *) action that we perform undo/redo for. may be
 |                          nullptr for intermediary buffers.
 |      @param vec: (const undo_records_t *)
 |      @param is_undo: (bool) true if performing undo, false if performing redo This
 |                      event may be generated multiple times per undo/redo
 |  
 |  ev_set_code16_mode(self, *args) -> 'int'
 |      ev_set_code16_mode(self, ea, code16) -> int
 |      Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set
 |      ISA 16-bit mode
 |      
 |      @param ea: (ea_t) address to set new ISA mode
 |      @param code16: (bool) true for 16-bit mode, false for 32-bit mode
 |  
 |  ev_set_idp_options(self, *args) -> 'int'
 |      ev_set_idp_options(self, keyword, value_type, value, idb_loaded) -> int
 |      Set IDP-specific configuration option Also see set_options_t in config.hpp
 |      
 |      @param keyword: (const char *)
 |      @param value_type: (int)
 |      @param value: (const void *)
 |      @param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been
 |                         generated
 |      @retval 1: ok
 |      @retval 0: not implemented
 |      @retval -1: error (and message in errbuf)
 |  
 |  ev_set_proc_options(self, *args) -> 'int'
 |      ev_set_proc_options(self, options, confidence) -> int
 |      Called if the user specified an option string in the command line: -p<processor
 |      name>:<options>. Can be used for setting a processor subtype. Also called if
 |      option string is passed to set_processor_type() and IDC's SetProcessorType().
 |      
 |      @param options: (const char *)
 |      @param confidence: (int) 0: loader's suggestion 1: user's decision
 |      @retval <0: if bad option string
 |  
 |  ev_setup_til(self, *args) -> 'int'
 |      ev_setup_til(self) -> int
 |      Setup default type libraries. (called after loading a new file into the
 |      database). The processor module may load tils, setup memory model and perform
 |      other actions required to set up the type system. This is an optional callback.
 |      @retval void
 |  
 |  ev_str2reg(self, *args) -> 'int'
 |      ev_str2reg(self, regname) -> int
 |      Convert a register name to a register number. The register number is the
 |      register index in the processor_t::reg_names array Most processor modules do not
 |      need to implement this callback It is useful only if processor_t::reg_names[reg]
 |      does not provide the correct register names
 |      
 |      @param regname: (const char *)
 |      @retval register: number + 1
 |      @retval 0: not implemented or could not be decoded
 |  
 |  ev_term(self, *args) -> 'int'
 |      ev_term(self) -> int
 |      The IDP module is being unloaded.
 |  
 |  ev_treat_hindering_item(self, *args) -> 'int'
 |      ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
 |      An item hinders creation of another item.
 |      
 |      @param hindering_item_ea: (::ea_t)
 |      @param new_item_flags: (flags_t) (0 for code)
 |      @param new_item_ea: (::ea_t)
 |      @param new_item_length: (::asize_t)
 |      @retval 0: no reaction
 |      @retval !=0: the kernel may delete the hindering item
 |  
 |  ev_undefine(self, *args) -> 'int'
 |      ev_undefine(self, ea) -> int
 |      An item in the database (insn or data) is being deleted.
 |      
 |      @param ea: (ea_t)
 |      @retval 1: do not delete srranges at the item end
 |      @retval 0: srranges can be deleted
 |  
 |  ev_update_call_stack(self, *args) -> 'int'
 |      ev_update_call_stack(self, stack, tid, getreg, regvalues) -> int
 |      Calculate the call stack trace for the given thread. This callback is invoked
 |      when the process is suspended and should fill the 'trace' object with the
 |      information about the current call stack. Note that this callback is NOT invoked
 |      if the current debugger backend implements stack tracing via
 |      debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes
 |      priority. Implementing this callback in the processor module is useful when
 |      multiple debugging platforms follow similar patterns, and thus the same
 |      processor-specific algorithm can be used for different platforms.
 |      
 |      @param stack: (call_stack_t *) result
 |      @param tid: (int) thread id
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 1: ok
 |      @retval -1: failed
 |      @retval 0: unimplemented
 |  
 |  ev_use_arg_types(self, *args) -> 'int'
 |      ev_use_arg_types(self, ea, fti, rargs) -> int
 |      Use information about callee arguments.
 |      
 |      @param ea: (::ea_t) address of the call instruction
 |      @param fti: (func_type_data_t *) info about function type
 |      @param rargs: (funcargvec_t *) array of register arguments
 |      @retval 1: (and removes handled arguments from fti and rargs)
 |      @retval 0: not implemented
 |  
 |  ev_use_regarg_type(self, *args) -> 'PyObject *'
 |      ev_use_regarg_type(self, ea, rargs) -> PyObject *
 |      Use information about register argument.
 |      
 |      @param ea: (::ea_t) address of the instruction
 |      @param rargs: (const funcargvec_t *) vector of register arguments (including
 |                    regs extracted from scattered arguments)
 |      @retval 1
 |      @retval 0: not implemented
 |  
 |  ev_use_stkarg_type(self, *args) -> 'int'
 |      ev_use_stkarg_type(self, ea, arg) -> int
 |      Use information about a stack argument.
 |      
 |      @param ea: (::ea_t) address of the push instruction which pushes the function
 |                 argument into the stack
 |      @param arg: (const funcarg_t *) argument info
 |      @retval 1: ok
 |      @retval <=0: failed, the kernel will create a comment with the argument name or
 |                   type for the instruction
 |  
 |  ev_validate_flirt_func(self, *args) -> 'int'
 |      ev_validate_flirt_func(self, start_ea, funcname) -> int
 |      Flirt has recognized a library function. This callback can be used by a plugin
 |      or proc module to intercept it and validate such a function.
 |      
 |      @param start_ea: (::ea_t)
 |      @param funcname: (const char *)
 |      @retval -1: do not create a function,
 |      @retval 0: function is validated
 |  
 |  ev_verify_noreturn(self, *args) -> 'int'
 |      ev_verify_noreturn(self, pfn) -> int
 |      The kernel wants to set 'noreturn' flags for a function.
 |      
 |      @param pfn: (func_t *)
 |      @retval 0: ok. any other value: do not set 'noreturn' flag
 |  
 |  ev_verify_sp(self, *args) -> 'int'
 |      ev_verify_sp(self, pfn) -> int
 |      All function instructions have been analyzed. Now the processor module can
 |      analyze the stack pointer for the whole function
 |      
 |      @param pfn: (func_t *)
 |      @retval 0: ok
 |      @retval <0: bad stack pointer
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __ph in module ida_idp:

class __ph(builtins.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cnbits
 |  
 |  dnbits
 |  
 |  flag
 |  
 |  icode_return
 |  
 |  id
 |  
 |  instruc
 |  
 |  instruc_end
 |  
 |  instruc_start
 |  
 |  reg_code_sreg
 |  
 |  reg_data_sreg
 |  
 |  reg_first_sreg
 |  
 |  reg_last_sreg
 |  
 |  regnames
 |  
 |  segreg_size
 |  
 |  tbyte_size
 |  
 |  version

Help on class _idp_cvar_t in module ida_idp:

class _idp_cvar_t(builtins.object)
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ash

Help on class _notify_when_dispatcher_t in module ida_idp:

class _notify_when_dispatcher_t(builtins.object)
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  _find(self, fun)
 |  
 |  dispatch(self, slot, *args)
 |  
 |  notify_when(self, when, fun)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _IDB_Hooks = <class 'ida_idp._notify_when_dispatcher_t._IDB_Hooks'>
 |      Proxy of C++ IDB_Hooks class.
 |  
 |  _IDP_Hooks = <class 'ida_idp._notify_when_dispatcher_t._IDP_Hooks'>
 |      Proxy of C++ IDP_Hooks class.
 |  
 |  _callback_t = <class 'ida_idp._notify_when_dispatcher_t._callback_t'>

Help on class _processor_t_Trampoline_IDB_Hooks in module ida_idp:

class _processor_t_Trampoline_IDB_Hooks(IDB_Hooks)
 |  Proxy of C++ IDB_Hooks class.
 |  
 |  Method resolution order:
 |      _processor_t_Trampoline_IDB_Hooks
 |      IDB_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, proc)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> IDB_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  _processor_t_Trampoline_IDB_Hooks__dummy = __dummy(self, *args)
 |  
 |  _processor_t_Trampoline_IDB_Hooks__make_parent_caller = __make_parent_caller(self, key)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from IDB_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDB_Hooks(...)
 |      delete_IDB_Hooks(self)
 |  
 |  adding_segm(self, *args) -> 'void'
 |      adding_segm(self, s)
 |      A segment is being created.
 |      
 |      @param s: (segment_t *)
 |  
 |  allsegs_moved(self, *args) -> 'void'
 |      allsegs_moved(self, info)
 |      Program rebasing is complete. This event is generated after series of segm_moved
 |      events
 |      
 |      @param info: (segm_move_infos_t *)
 |  
 |  auto_empty(self, *args) -> 'void'
 |      auto_empty(self)
 |  
 |  auto_empty_finally(self, *args) -> 'void'
 |      auto_empty_finally(self)
 |  
 |  bookmark_changed(self, *args) -> 'void'
 |      bookmark_changed(self, index, pos, desc, operation)
 |      Boomarked position changed.
 |      
 |      @param index: (uint32)
 |      @param pos: (::const lochist_entry_t *)
 |      @param desc: (::const char *)
 |      @param operation: (int) 0-added, 1-updated, 2-deleted if desc==nullptr, then the
 |                        bookmark was deleted.
 |  
 |  byte_patched(self, *args) -> 'void'
 |      byte_patched(self, ea, old_value)
 |      A byte has been patched.
 |      
 |      @param ea: (::ea_t)
 |      @param old_value: (uint32)
 |  
 |  callee_addr_changed(self, *args) -> 'void'
 |      callee_addr_changed(self, ea, callee)
 |      Callee address has been updated by the user.
 |      
 |      @param ea: (::ea_t)
 |      @param callee: (::ea_t)
 |  
 |  changing_cmt(self, *args) -> 'void'
 |      changing_cmt(self, ea, repeatable_cmt, newcmt)
 |      An item comment is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param repeatable_cmt: (bool)
 |      @param newcmt: (const char *)
 |  
 |  changing_enum_bf(self, *args) -> 'void'
 |      changing_enum_bf(self, id, new_bf)
 |      An enum type 'bitfield' attribute is to be changed.
 |      
 |      @param id: (enum_t)
 |      @param new_bf: (bool)
 |  
 |  changing_enum_cmt(self, *args) -> 'void'
 |      changing_enum_cmt(self, id, repeatable, newcmt)
 |      An enum or member type comment is to be changed.
 |      
 |      @param id: (tid_t)
 |      @param repeatable: (bool)
 |      @param newcmt: (const char *)
 |  
 |  changing_op_ti(self, *args) -> 'void'
 |      changing_op_ti(self, ea, n, new_type, new_fnames)
 |      An operand typestring (c/c++ prototype) is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int)
 |      @param new_type: (const type_t *)
 |      @param new_fnames: (const p_list *)
 |  
 |  changing_op_type(self, *args) -> 'void'
 |      changing_op_type(self, ea, n, opinfo)
 |      An operand type (offset, hex, etc...) is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
 |      @param opinfo: (const opinfo_t *) additional operand info
 |  
 |  changing_range_cmt(self, *args) -> 'void'
 |      changing_range_cmt(self, kind, a, cmt, repeatable)
 |      Range comment is to be changed.
 |      
 |      @param kind: (range_kind_t)
 |      @param a: (const range_t *)
 |      @param cmt: (const char *)
 |      @param repeatable: (bool)
 |  
 |  changing_segm_class(self, *args) -> 'void'
 |      changing_segm_class(self, s)
 |      Segment class is being changed.
 |      
 |      @param s: (segment_t *)
 |  
 |  changing_segm_end(self, *args) -> 'void'
 |      changing_segm_end(self, s, new_end, segmod_flags)
 |      Segment end address is to be changed.
 |      
 |      @param s: (segment_t *)
 |      @param new_end: (::ea_t)
 |      @param segmod_flags: (int)
 |  
 |  changing_segm_name(self, *args) -> 'void'
 |      changing_segm_name(self, s, oldname)
 |      Segment name is being changed.
 |      
 |      @param s: (segment_t *)
 |      @param oldname: (const char *)
 |  
 |  changing_segm_start(self, *args) -> 'void'
 |      changing_segm_start(self, s, new_start, segmod_flags)
 |      Segment start address is to be changed.
 |      
 |      @param s: (segment_t *)
 |      @param new_start: (::ea_t)
 |      @param segmod_flags: (int)
 |  
 |  changing_struc_align(self, *args) -> 'void'
 |      changing_struc_align(self, sptr)
 |      A structure type is being changed (the struct alignment).
 |      
 |      @param sptr: (struc_t *)
 |  
 |  changing_struc_cmt(self, *args) -> 'void'
 |      changing_struc_cmt(self, struc_id, repeatable, newcmt)
 |      A structure type comment is to be changed.
 |      
 |      @param struc_id: (tid_t)
 |      @param repeatable: (bool)
 |      @param newcmt: (const char *)
 |  
 |  changing_struc_member(self, *args) -> 'void'
 |      changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
 |      A structure member is to be changed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |      @param flag: (flags_t)
 |      @param ti: (const opinfo_t *)
 |      @param nbytes: (::asize_t)
 |  
 |  changing_ti(self, *args) -> 'void'
 |      changing_ti(self, ea, new_type, new_fnames)
 |      An item typestring (c/c++ prototype) is to be changed.
 |      
 |      @param ea: (::ea_t)
 |      @param new_type: (const type_t *)
 |      @param new_fnames: (const p_list *)
 |  
 |  closebase(self, *args) -> 'void'
 |      closebase(self)
 |      The database will be closed now.
 |  
 |  cmt_changed(self, *args) -> 'void'
 |      cmt_changed(self, ea, repeatable_cmt)
 |      An item comment has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param repeatable_cmt: (bool)
 |  
 |  compiler_changed(self, *args) -> 'void'
 |      compiler_changed(self, adjust_inf_fields)
 |      The kernel has changed the compiler information. ( idainfo::cc structure;
 |      get_abi_name)
 |      
 |      @param adjust_inf_fields: (::bool) may change inf fields?
 |  
 |  deleting_enum(self, *args) -> 'void'
 |      deleting_enum(self, id)
 |      An enum type is to be deleted.
 |      
 |      @param id: (enum_t)
 |  
 |  deleting_enum_member(self, *args) -> 'void'
 |      deleting_enum_member(self, id, cid)
 |      An enum member is to be deleted.
 |      
 |      @param id: (enum_t)
 |      @param cid: (const_t)
 |  
 |  deleting_func(self, *args) -> 'void'
 |      deleting_func(self, pfn)
 |      The kernel is about to delete a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  deleting_func_tail(self, *args) -> 'void'
 |      deleting_func_tail(self, pfn, tail)
 |      A function tail chunk is to be removed.
 |      
 |      @param pfn: (func_t *)
 |      @param tail: (const range_t *)
 |  
 |  deleting_segm(self, *args) -> 'void'
 |      deleting_segm(self, start_ea)
 |      A segment is to be deleted.
 |      
 |      @param start_ea: (::ea_t)
 |  
 |  deleting_struc(self, *args) -> 'void'
 |      deleting_struc(self, sptr)
 |      A structure type is to be deleted.
 |      
 |      @param sptr: (struc_t *)
 |  
 |  deleting_struc_member(self, *args) -> 'void'
 |      deleting_struc_member(self, sptr, mptr)
 |      A structure member is to be deleted.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  deleting_tryblks(self, *args) -> 'void'
 |      deleting_tryblks(self, range)
 |      About to delete tryblk information in given range
 |      
 |      @param range: (const range_t *)
 |  
 |  destroyed_items(self, *args) -> 'void'
 |      destroyed_items(self, ea1, ea2, will_disable_range)
 |      Instructions/data have been destroyed in [ea1,ea2).
 |      
 |      @param ea1: (::ea_t)
 |      @param ea2: (::ea_t)
 |      @param will_disable_range: (bool)
 |  
 |  determined_main(self, *args) -> 'void'
 |      determined_main(self, main)
 |      The main() function has been determined.
 |      
 |      @param main: (::ea_t) address of the main() function
 |  
 |  dirtree_link(self, *args) -> 'void'
 |      dirtree_link(self, dt, path, link)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |      @param link: (::bool)
 |  
 |  dirtree_mkdir(self, *args) -> 'void'
 |      dirtree_mkdir(self, dt, path)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |  
 |  dirtree_move(self, *args) -> 'void'
 |      dirtree_move(self, dt, _from, to)
 |      
 |      @param dt: (dirtree_t *)
 |      @param from: (::const char *)
 |      @param to: (::const char *)
 |  
 |  dirtree_rank(self, *args) -> 'void'
 |      dirtree_rank(self, dt, path, rank)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |      @param rank: (::size_t)
 |  
 |  dirtree_rmdir(self, *args) -> 'void'
 |      dirtree_rmdir(self, dt, path)
 |      
 |      @param dt: (dirtree_t *)
 |      @param path: (::const char *)
 |  
 |  dirtree_rminode(self, *args) -> 'void'
 |      dirtree_rminode(self, dt, inode)
 |      
 |      @param dt: (dirtree_t *)
 |      @param inode: (inode_t)
 |  
 |  dirtree_segm_moved(self, *args) -> 'void'
 |      dirtree_segm_moved(self, dt)
 |      
 |      @param dt: (dirtree_t *)
 |  
 |  enum_bf_changed(self, *args) -> 'void'
 |      enum_bf_changed(self, id)
 |      An enum type 'bitfield' attribute has been changed.
 |      
 |      @param id: (enum_t)
 |  
 |  enum_cmt_changed(self, *args) -> 'void'
 |      enum_cmt_changed(self, id, repeatable)
 |      An enum or member type comment has been changed.
 |      
 |      @param id: (tid_t)
 |      @param repeatable: (bool)
 |  
 |  enum_created(self, *args) -> 'void'
 |      enum_created(self, id)
 |      An enum type has been created.
 |      
 |      @param id: (enum_t)
 |  
 |  enum_deleted(self, *args) -> 'void'
 |      enum_deleted(self, id)
 |      An enum type has been deleted.
 |      
 |      @param id: (enum_t)
 |  
 |  enum_flag_changed(self, *args) -> 'void'
 |      enum_flag_changed(self, id, F)
 |      Enum flags have been changed.
 |      
 |      @param id: (enum_t)
 |      @param F: (flags_t)
 |  
 |  enum_member_created(self, *args) -> 'void'
 |      enum_member_created(self, id, cid)
 |      An enum member has been created.
 |      
 |      @param id: (enum_t)
 |      @param cid: (const_t)
 |  
 |  enum_member_deleted(self, *args) -> 'void'
 |      enum_member_deleted(self, id, cid)
 |      An enum member has been deleted.
 |      
 |      @param id: (enum_t)
 |      @param cid: (const_t)
 |  
 |  enum_ordinal_changed(self, *args) -> 'void'
 |      enum_ordinal_changed(self, id, ord)
 |      Enum mapping to a local type has been changed.
 |      
 |      @param id: (enum_t)
 |      @param ord: (int)
 |  
 |  enum_renamed(self, *args) -> 'void'
 |      enum_renamed(self, id)
 |      An enum or member has been renamed.
 |      
 |      @param id: (tid_t)
 |  
 |  enum_width_changed(self, *args) -> 'void'
 |      enum_width_changed(self, id, width)
 |      Enum width has been changed.
 |      
 |      @param id: (enum_t)
 |      @param width: (int)
 |  
 |  expanding_struc(self, *args) -> 'void'
 |      expanding_struc(self, sptr, offset, delta)
 |      A structure type is to be expanded/shrunk.
 |      
 |      @param sptr: (struc_t *)
 |      @param offset: (::ea_t)
 |      @param delta: (::adiff_t)
 |  
 |  extlang_changed(self, *args) -> 'void'
 |      extlang_changed(self, kind, el, idx)
 |      The list of extlangs or the default extlang was changed.
 |      
 |      @param kind: (int) 0: extlang installed 1: extlang removed 2: default extlang
 |                   changed
 |      @param el: (extlang_t *) pointer to the extlang affected
 |      @param idx: (int) extlang index
 |  
 |  extra_cmt_changed(self, *args) -> 'void'
 |      extra_cmt_changed(self, ea, line_idx, cmt)
 |      An extra comment has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param line_idx: (int)
 |      @param cmt: (const char *)
 |  
 |  flow_chart_created(self, *args) -> 'void'
 |      flow_chart_created(self, fc)
 |      Gui has retrieved a function flow chart. Plugins may modify the flow chart in
 |      this callback.
 |      
 |      @param fc: (qflow_chart_t *)
 |  
 |  frame_deleted(self, *args) -> 'void'
 |      frame_deleted(self, pfn)
 |      The kernel has deleted a function frame.
 |      
 |      @param pfn: (func_t *)
 |  
 |  func_added(self, *args) -> 'void'
 |      func_added(self, pfn)
 |      The kernel has added a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  func_deleted(self, *args) -> 'void'
 |      func_deleted(self, func_ea)
 |      A function has been deleted.
 |      
 |      @param func_ea: (::ea_t)
 |  
 |  func_noret_changed(self, *args) -> 'void'
 |      func_noret_changed(self, pfn)
 |      FUNC_NORET bit has been changed.
 |      
 |      @param pfn: (func_t *)
 |  
 |  func_tail_appended(self, *args) -> 'void'
 |      func_tail_appended(self, pfn, tail)
 |      A function tail chunk has been appended.
 |      
 |      @param pfn: (func_t *)
 |      @param tail: (func_t *)
 |  
 |  func_tail_deleted(self, *args) -> 'void'
 |      func_tail_deleted(self, pfn, tail_ea)
 |      A function tail chunk has been removed.
 |      
 |      @param pfn: (func_t *)
 |      @param tail_ea: (::ea_t)
 |  
 |  func_updated(self, *args) -> 'void'
 |      func_updated(self, pfn)
 |      The kernel has updated a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  idasgn_loaded(self, *args) -> 'void'
 |      idasgn_loaded(self, short_sig_name)
 |      FLIRT signature has been loaded for normal processing (not for recognition of
 |      startup sequences).
 |      
 |      @param short_sig_name: (const char *)
 |  
 |  item_color_changed(self, *args) -> 'void'
 |      item_color_changed(self, ea, color)
 |      An item color has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param color: (bgcolor_t) if color==DEFCOLOR, the the color is deleted.
 |  
 |  kernel_config_loaded(self, *args) -> 'void'
 |      kernel_config_loaded(self, pass_number)
 |      This event is issued when ida.cfg is parsed.
 |      
 |      @param pass_number: (int)
 |  
 |  loader_finished(self, *args) -> 'void'
 |      loader_finished(self, li, neflags, filetypename)
 |      External file loader finished its work. Use this event to augment the existing
 |      loader functionality.
 |      
 |      @param li: (linput_t *)
 |      @param neflags: (uint16) Load file flags
 |      @param filetypename: (const char *)
 |  
 |  local_types_changed(self, *args) -> 'void'
 |      local_types_changed(self)
 |      Local types have been changed.
 |  
 |  make_code(self, *args) -> 'void'
 |      make_code(self, insn)
 |      An instruction is being created.
 |      
 |      @param insn: (const insn_t*)
 |  
 |  make_data(self, *args) -> 'void'
 |      make_data(self, ea, flags, tid, len)
 |      A data item is being created.
 |      
 |      @param ea: (::ea_t)
 |      @param flags: (flags_t)
 |      @param tid: (tid_t)
 |      @param len: (::asize_t)
 |  
 |  op_ti_changed(self, *args) -> 'void'
 |      op_ti_changed(self, ea, n, type, fnames)
 |      An operand typestring (c/c++ prototype) has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int)
 |      @param type: (const type_t *)
 |      @param fnames: (const p_list *)
 |  
 |  op_type_changed(self, *args) -> 'void'
 |      op_type_changed(self, ea, n)
 |      An operand type (offset, hex, etc...) has been set or deleted.
 |      
 |      @param ea: (::ea_t)
 |      @param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
 |  
 |  range_cmt_changed(self, *args) -> 'void'
 |      range_cmt_changed(self, kind, a, cmt, repeatable)
 |      Range comment has been changed.
 |      
 |      @param kind: (range_kind_t)
 |      @param a: (const range_t *)
 |      @param cmt: (const char *)
 |      @param repeatable: (bool)
 |  
 |  renamed(self, *args) -> 'void'
 |      renamed(self, ea, new_name, local_name, old_name)
 |      The kernel has renamed a byte. See also the rename event
 |      
 |      @param ea: (::ea_t)
 |      @param new_name: (const char *) can be nullptr
 |      @param local_name: (bool)
 |      @param old_name: (const char *) can be nullptr
 |  
 |  renaming_enum(self, *args) -> 'void'
 |      renaming_enum(self, id, is_enum, newname)
 |      An enum or enum member is to be renamed.
 |      
 |      @param id: (tid_t)
 |      @param is_enum: (bool)
 |      @param newname: (const char *)
 |  
 |  renaming_struc(self, *args) -> 'void'
 |      renaming_struc(self, id, oldname, newname)
 |      A structure type is to be renamed.
 |      
 |      @param id: (tid_t)
 |      @param oldname: (const char *)
 |      @param newname: (const char *)
 |  
 |  renaming_struc_member(self, *args) -> 'void'
 |      renaming_struc_member(self, sptr, mptr, newname)
 |      A structure member is to be renamed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |      @param newname: (const char *)
 |  
 |  savebase(self, *args) -> 'void'
 |      savebase(self)
 |      The database is being saved.
 |  
 |  segm_added(self, *args) -> 'void'
 |      segm_added(self, s)
 |      A new segment has been created.
 |      
 |      @param s: (segment_t *) See also adding_segm
 |  
 |  segm_attrs_updated(self, *args) -> 'void'
 |      segm_attrs_updated(self, s)
 |      Segment attributes has been changed.
 |      
 |      @param s: (segment_t *) This event is generated for secondary segment attributes
 |                (examples: color, permissions, etc)
 |  
 |  segm_class_changed(self, *args) -> 'void'
 |      segm_class_changed(self, s, sclass)
 |      Segment class has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param sclass: (const char *)
 |  
 |  segm_deleted(self, *args) -> 'void'
 |      segm_deleted(self, start_ea, end_ea, flags)
 |      A segment has been deleted.
 |      
 |      @param start_ea: (::ea_t)
 |      @param end_ea: (::ea_t)
 |      @param flags: (int)
 |  
 |  segm_end_changed(self, *args) -> 'void'
 |      segm_end_changed(self, s, oldend)
 |      Segment end address has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param oldend: (::ea_t)
 |  
 |  segm_moved(self, *args) -> 'void'
 |      segm_moved(self, _from, to, size, changed_netmap)
 |      Segment has been moved.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param size: (::asize_t)
 |      @param changed_netmap: (bool) See also idb_event::allsegs_moved
 |  
 |  segm_name_changed(self, *args) -> 'void'
 |      segm_name_changed(self, s, name)
 |      Segment name has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param name: (const char *)
 |  
 |  segm_start_changed(self, *args) -> 'void'
 |      segm_start_changed(self, s, oldstart)
 |      Segment start address has been changed.
 |      
 |      @param s: (segment_t *)
 |      @param oldstart: (::ea_t)
 |  
 |  set_func_end(self, *args) -> 'void'
 |      set_func_end(self, pfn, new_end)
 |      Function chunk end address will be changed.
 |      
 |      @param pfn: (func_t *)
 |      @param new_end: (::ea_t)
 |  
 |  set_func_start(self, *args) -> 'void'
 |      set_func_start(self, pfn, new_start)
 |      Function chunk start address will be changed.
 |      
 |      @param pfn: (func_t *)
 |      @param new_start: (::ea_t)
 |  
 |  sgr_changed(self, *args) -> 'void'
 |      sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
 |      The kernel has changed a segment register value.
 |      
 |      @param start_ea: (::ea_t)
 |      @param end_ea: (::ea_t)
 |      @param regnum: (int)
 |      @param value: (::sel_t)
 |      @param old_value: (::sel_t)
 |      @param tag: (uchar) Segment register range tags
 |  
 |  sgr_deleted(self, *args) -> 'void'
 |      sgr_deleted(self, start_ea, end_ea, regnum)
 |      The kernel has deleted a segment register value.
 |      
 |      @param start_ea: (::ea_t)
 |      @param end_ea: (::ea_t)
 |      @param regnum: (int)
 |  
 |  stkpnts_changed(self, *args) -> 'void'
 |      stkpnts_changed(self, pfn)
 |      Stack change points have been modified.
 |      
 |      @param pfn: (func_t *)
 |  
 |  struc_align_changed(self, *args) -> 'void'
 |      struc_align_changed(self, sptr)
 |      A structure type has been changed (the struct alignment).
 |      
 |      @param sptr: (struc_t *)
 |  
 |  struc_cmt_changed(self, *args) -> 'void'
 |      struc_cmt_changed(self, struc_id, repeatable_cmt)
 |      A structure type comment has been changed.
 |      
 |      @param struc_id: (tid_t)
 |      @param repeatable_cmt: (bool)
 |  
 |  struc_created(self, *args) -> 'void'
 |      struc_created(self, struc_id)
 |      A new structure type has been created.
 |      
 |      @param struc_id: (tid_t)
 |  
 |  struc_deleted(self, *args) -> 'void'
 |      struc_deleted(self, struc_id)
 |      A structure type has been deleted.
 |      
 |      @param struc_id: (tid_t)
 |  
 |  struc_expanded(self, *args) -> 'void'
 |      struc_expanded(self, sptr)
 |      A structure type has been expanded/shrank.
 |      
 |      @param sptr: (struc_t *)
 |  
 |  struc_member_changed(self, *args) -> 'void'
 |      struc_member_changed(self, sptr, mptr)
 |      A structure member has been changed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  struc_member_created(self, *args) -> 'void'
 |      struc_member_created(self, sptr, mptr)
 |      A structure member has been created.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  struc_member_deleted(self, *args) -> 'void'
 |      struc_member_deleted(self, sptr, member_id, offset)
 |      A structure member has been deleted.
 |      
 |      @param sptr: (struc_t *)
 |      @param member_id: (tid_t)
 |      @param offset: (::ea_t)
 |  
 |  struc_member_renamed(self, *args) -> 'void'
 |      struc_member_renamed(self, sptr, mptr)
 |      A structure member has been renamed.
 |      
 |      @param sptr: (struc_t *)
 |      @param mptr: (member_t *)
 |  
 |  struc_renamed(self, *args) -> 'void'
 |      struc_renamed(self, sptr, success)
 |      A structure type has been renamed.
 |      
 |      @param sptr: (struc_t *)
 |      @param success: (::bool) the structure was successfully renamed
 |  
 |  tail_owner_changed(self, *args) -> 'void'
 |      tail_owner_changed(self, tail, owner_func, old_owner)
 |      A tail chunk owner has been changed.
 |      
 |      @param tail: (func_t *)
 |      @param owner_func: (::ea_t)
 |      @param old_owner: (::ea_t)
 |  
 |  thunk_func_created(self, *args) -> 'void'
 |      thunk_func_created(self, pfn)
 |      A thunk bit has been set for a function.
 |      
 |      @param pfn: (func_t *)
 |  
 |  ti_changed(self, *args) -> 'void'
 |      ti_changed(self, ea, type, fnames)
 |      An item typestring (c/c++ prototype) has been changed.
 |      
 |      @param ea: (::ea_t)
 |      @param type: (const type_t *)
 |      @param fnames: (const p_list *)
 |  
 |  tryblks_updated(self, *args) -> 'void'
 |      tryblks_updated(self, tbv)
 |      Updated tryblk information
 |      
 |      @param tbv: (const ::tryblks_t *)
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  updating_tryblks(self, *args) -> 'void'
 |      updating_tryblks(self, tbv)
 |      About to update tryblk information
 |      
 |      @param tbv: (const ::tryblks_t *)
 |  
 |  upgraded(self, *args) -> 'void'
 |      upgraded(self, _from)
 |      The database has been upgraded and the receiver can upgrade its info as well
 |      
 |      @param from: (int) - old IDB version
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from IDB_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class asm_t in module ida_idp:

class asm_t(builtins.object)
 |  Proxy of C++ asm_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> asm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_asm_t(...)
 |      delete_asm_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  a_align
 |      a_align
 |  
 |  a_ascii
 |      a_ascii
 |  
 |  a_band
 |      a_band
 |  
 |  a_bnot
 |      a_bnot
 |  
 |  a_bor
 |      a_bor
 |  
 |  a_bss
 |      a_bss
 |  
 |  a_byte
 |      a_byte
 |  
 |  a_comdef
 |      a_comdef
 |  
 |  a_curip
 |      a_curip
 |  
 |  a_double
 |      a_double
 |  
 |  a_dups
 |      a_dups
 |  
 |  a_dword
 |      a_dword
 |  
 |  a_equ
 |      a_equ
 |  
 |  a_extrn
 |      a_extrn
 |  
 |  a_float
 |      a_float
 |  
 |  a_include_fmt
 |      a_include_fmt
 |  
 |  a_mod
 |      a_mod
 |  
 |  a_oword
 |      a_oword
 |  
 |  a_packreal
 |      a_packreal
 |  
 |  a_public
 |      a_public
 |  
 |  a_qword
 |      a_qword
 |  
 |  a_rva
 |      a_rva
 |  
 |  a_seg
 |      a_seg
 |  
 |  a_shl
 |      a_shl
 |  
 |  a_shr
 |      a_shr
 |  
 |  a_sizeof_fmt
 |      a_sizeof_fmt
 |  
 |  a_tbyte
 |      a_tbyte
 |  
 |  a_vstruc_fmt
 |      a_vstruc_fmt
 |  
 |  a_weak
 |      a_weak
 |  
 |  a_word
 |      a_word
 |  
 |  a_xor
 |      a_xor
 |  
 |  a_yword
 |      a_yword
 |  
 |  a_zword
 |      a_zword
 |  
 |  accsep
 |      accsep
 |  
 |  ascsep
 |      ascsep
 |  
 |  cmnt
 |      cmnt
 |  
 |  cmnt2
 |      cmnt2
 |  
 |  end
 |      end
 |  
 |  esccodes
 |      esccodes
 |  
 |  flag
 |      flag
 |  
 |  flag2
 |      flag2
 |  
 |  header
 |      header
 |  
 |  help
 |      help
 |  
 |  high16
 |      high16
 |  
 |  high8
 |      high8
 |  
 |  lbrace
 |      lbrace
 |  
 |  low16
 |      low16
 |  
 |  low8
 |      low8
 |  
 |  name
 |      name
 |  
 |  origin
 |      origin
 |  
 |  rbrace
 |      rbrace
 |  
 |  thisown
 |      The membership flag
 |  
 |  uflag
 |      uflag

Help on function assemble in module ida_idp:

assemble(*args) -> 'bool'
    assemble(ea, cs, ip, use32, line) -> bool
    Assemble an instruction into the database (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment?
    @param line: line to assemble
    
    @return: Boolean. True on success.

Help on function cfg_get_cc_header_path in module ida_idp:

cfg_get_cc_header_path(*args) -> 'char const *'
    cfg_get_cc_header_path(compid) -> char const *
    
    @param compid: comp_t

Help on function cfg_get_cc_parm in module ida_idp:

cfg_get_cc_parm(*args) -> 'char const *'
    cfg_get_cc_parm(compid, name) -> char const *
    
    @param compid: comp_t
    @param name: char const *

Help on function cfg_get_cc_predefined_macros in module ida_idp:

cfg_get_cc_predefined_macros(*args) -> 'char const *'
    cfg_get_cc_predefined_macros(compid) -> char const *
    
    @param compid: comp_t

Help on function delay_slot_insn in module ida_idp:

delay_slot_insn(*args) -> 'bool'
    delay_slot_insn(ea, bexec, fexec) -> bool
    
    @param ea: ea_t *
    @param bexec: bool *
    @param fexec: bool *

Help on function gen_idb_event in module ida_idp:

gen_idb_event(*args) -> 'void'
    gen_idb_event(code)
    the kernel will use this function to generate idb_events
    
    @param code: (C++: idb_event::event_code_t) enum idb_event::event_code_t

Help on function get_ash in module ida_idp:

get_ash(*args) -> 'asm_t *'
    get_ash() -> asm_t

Help on function get_idb_notifier_addr in module ida_idp:

get_idb_notifier_addr(*args) -> 'PyObject *'
    get_idb_notifier_addr(arg1) -> PyObject *
    
    @param arg1: PyObject *

Help on function get_idb_notifier_ud_addr in module ida_idp:

get_idb_notifier_ud_addr(*args) -> 'PyObject *'
    get_idb_notifier_ud_addr(hooks) -> PyObject *
    
    @param hooks: IDB_Hooks *

Help on function get_idp_name in module ida_idp:

get_idp_name(*args) -> 'size_t'
    get_idp_name() -> str
    Get name of the current processor module. The name is derived from the file
    name. For example, for IBM PC the module is named "pc.w32" (windows version),
    then the module name is "PC" (uppercase). If no processor module is loaded, this
    function will return nullptr

Help on function get_idp_notifier_addr in module ida_idp:

get_idp_notifier_addr(*args) -> 'PyObject *'
    get_idp_notifier_addr(arg1) -> PyObject *
    
    @param arg1: PyObject *

Help on function get_idp_notifier_ud_addr in module ida_idp:

get_idp_notifier_ud_addr(*args) -> 'PyObject *'
    get_idp_notifier_ud_addr(hooks) -> PyObject *
    
    @param hooks: IDP_Hooks *

Help on function get_ph in module ida_idp:

get_ph(*args) -> 'processor_t *'
    get_ph() -> processor_t *

Help on function get_reg_info in module ida_idp:

get_reg_info(*args) -> 'char const *'
    get_reg_info(regname, bitrange) -> char const *
    
    @param regname: char const *
    @param bitrange: bitrange_t *

Help on function get_reg_name in module ida_idp:

get_reg_name(*args) -> 'qstring *'
    get_reg_name(reg, width, reghi=-1) -> str
    Get text representation of a register. For most processors this function will
    just return processor_t::reg_names[reg]. If the processor module has implemented
    processor_t::get_reg_name, it will be used instead
    
    @param reg: (C++: int) internal register number as defined in the processor module
    @param width: (C++: size_t) register width in bytes
    @param reghi: (C++: int) if specified, then this function will return the register pair
    @return: length of register name in bytes or -1 if failure

Help on function has_cf_chg in module ida_idp:

has_cf_chg(*args) -> 'bool'
    has_cf_chg(feature, opnum) -> bool
    Does an instruction with the specified feature modify the i-th operand?
    
    @param feature: (C++: uint32)
    @param opnum: (C++: uint)

Help on function has_cf_use in module ida_idp:

has_cf_use(*args) -> 'bool'
    has_cf_use(feature, opnum) -> bool
    Does an instruction with the specified feature use a value of the i-th operand?
    
    @param feature: (C++: uint32)
    @param opnum: (C++: uint)

Help on function has_insn_feature in module ida_idp:

has_insn_feature(*args) -> 'bool'
    has_insn_feature(icode, bit) -> bool
    Does the specified instruction have the specified feature?
    
    @param icode: (C++: uint16)
    @param bit: (C++: uint32)

Help on function is_align_insn in module ida_idp:

is_align_insn(*args) -> 'int'
    is_align_insn(ea) -> int
    If the instruction at 'ea' looks like an alignment instruction, return its
    length in bytes. Otherwise return 0.
    
    @param ea: (C++: ea_t)

Help on function is_basic_block_end in module ida_idp:

is_basic_block_end(*args) -> 'bool'
    is_basic_block_end(insn, call_insn_stops_block) -> bool
    Is the instruction the end of a basic block?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param call_insn_stops_block: (C++: bool)

Help on function is_call_insn in module ida_idp:

is_call_insn(*args) -> 'bool'
    is_call_insn(insn) -> bool
    Is the instruction a "call"?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

Help on function is_indirect_jump_insn in module ida_idp:

is_indirect_jump_insn(*args) -> 'bool'
    is_indirect_jump_insn(insn) -> bool
    Is the instruction an indirect jump?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)

Help on function is_ret_insn in module ida_idp:

is_ret_insn(*args) -> 'bool'
    is_ret_insn(insn, strict=True) -> bool
    Is the instruction a "return"?
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param strict: (C++: bool)

Help on class num_range_t in module ida_idp:

class num_range_t(builtins.object)
 |  Proxy of C++ cfgopt_t::num_range_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _min, _max) -> num_range_t
 |      
 |      @param _min: int64
 |      @param _max: int64
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_num_range_t(...)
 |      delete_num_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  maxval
 |      maxval
 |  
 |  minval
 |      minval
 |  
 |  thisown
 |      The membership flag

Help on class params_t in module ida_idp:

class params_t(builtins.object)
 |  Proxy of C++ cfgopt_t::params_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _p1, _p2) -> params_t
 |      
 |      @param _p1: int64
 |      @param _p2: int64
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_params_t(...)
 |      delete_params_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  p1
 |      p1
 |  
 |  p2
 |      p2
 |  
 |  thisown
 |      The membership flag

Help on function parse_reg_name in module ida_idp:

parse_reg_name(*args) -> 'bool'
    parse_reg_name(ri, regname) -> bool
    Get register info by name.
    
    @param ri: (C++: reg_info_t *) result
    @param regname: (C++: const char *) name of register
    @return: success

Help on __ph in module ida_idp object:

class __ph(builtins.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cnbits
 |  
 |  dnbits
 |  
 |  flag
 |  
 |  icode_return
 |  
 |  id
 |  
 |  instruc
 |  
 |  instruc_end
 |  
 |  instruc_start
 |  
 |  reg_code_sreg
 |  
 |  reg_data_sreg
 |  
 |  reg_first_sreg
 |  
 |  reg_last_sreg
 |  
 |  regnames
 |  
 |  segreg_size
 |  
 |  tbyte_size
 |  
 |  version

Help on function ph_calcrel in module ida_idp:

ph_calcrel(*args) -> 'bytevec_t *, size_t *'
    ph_calcrel(ea)
    
    @param ea: ea_t

Help on function ph_find_op_value in module ida_idp:

ph_find_op_value(*args) -> 'unsigned-ea-like-numeric-type *'
    ph_find_op_value(insn, op) -> ssize_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: int

Help on function ph_find_reg_value in module ida_idp:

ph_find_reg_value(*args) -> 'unsigned-ea-like-numeric-type *'
    ph_find_reg_value(insn, reg) -> ssize_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param reg: int

Help on function ph_get_cnbits in module ida_idp:

ph_get_cnbits(*args) -> 'size_t'
    ph_get_cnbits() -> size_t
    Returns the 'ph.cnbits'

Help on function ph_get_dnbits in module ida_idp:

ph_get_dnbits(*args) -> 'size_t'
    ph_get_dnbits() -> size_t
    Returns the 'ph.dnbits'

Help on function ph_get_flag in module ida_idp:

ph_get_flag(*args) -> 'size_t'
    ph_get_flag() -> size_t
    Returns the 'ph.flag'

Help on function ph_get_icode_return in module ida_idp:

ph_get_icode_return(*args) -> 'size_t'
    ph_get_icode_return() -> size_t
    Returns the 'ph.icode_return'

Help on function ph_get_id in module ida_idp:

ph_get_id(*args) -> 'size_t'
    ph_get_id() -> size_t
    Returns the 'ph.id' field

Help on function ph_get_instruc in module ida_idp:

ph_get_instruc(*args) -> 'PyObject *'
    ph_get_instruc() -> [(str, int), ...]
    Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module

Help on function ph_get_instruc_end in module ida_idp:

ph_get_instruc_end(*args) -> 'size_t'
    ph_get_instruc_end() -> size_t
    Returns the 'ph.instruc_end'

Help on function ph_get_instruc_start in module ida_idp:

ph_get_instruc_start(*args) -> 'size_t'
    ph_get_instruc_start() -> size_t
    Returns the 'ph.instruc_start'

Help on function ph_get_operand_info in module ida_idp:

ph_get_operand_info(*args) -> 'PyObject *'
    ph_get_operand_info(ea, n) -> (int, int, int, int, int) or None
    Returns the operand information given an ea and operand number.
    
    @param ea: address
    @param n: operand number
    
    @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.

Help on function ph_get_reg_accesses in module ida_idp:

ph_get_reg_accesses(*args) -> 'ssize_t'
    ph_get_reg_accesses(accvec, insn, flags) -> ssize_t
    
    @param accvec: reg_accesses_t *
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param flags: int

Help on function ph_get_reg_code_sreg in module ida_idp:

ph_get_reg_code_sreg(*args) -> 'size_t'
    ph_get_reg_code_sreg() -> size_t
    Returns the 'ph.reg_code_sreg'

Help on function ph_get_reg_data_sreg in module ida_idp:

ph_get_reg_data_sreg(*args) -> 'size_t'
    ph_get_reg_data_sreg() -> size_t
    Returns the 'ph.reg_data_sreg'

Help on function ph_get_reg_first_sreg in module ida_idp:

ph_get_reg_first_sreg(*args) -> 'size_t'
    ph_get_reg_first_sreg() -> size_t
    Returns the 'ph.reg_first_sreg'

Help on function ph_get_reg_last_sreg in module ida_idp:

ph_get_reg_last_sreg(*args) -> 'size_t'
    ph_get_reg_last_sreg() -> size_t
    Returns the 'ph.reg_last_sreg'

Help on function ph_get_regnames in module ida_idp:

ph_get_regnames(*args) -> 'PyObject *'
    ph_get_regnames() -> [str, ...]
    Returns the list of register names as defined in the processor module

Help on function ph_get_segreg_size in module ida_idp:

ph_get_segreg_size(*args) -> 'size_t'
    ph_get_segreg_size() -> size_t
    Returns the 'ph.segreg_size'

Help on function ph_get_tbyte_size in module ida_idp:

ph_get_tbyte_size(*args) -> 'size_t'
    ph_get_tbyte_size() -> size_t
    Returns the 'ph.tbyte_size' field as defined in he processor module

Help on function ph_get_version in module ida_idp:

ph_get_version(*args) -> 'size_t'
    ph_get_version() -> size_t
    Returns the 'ph.version'

Help on function process_config_directive in module ida_idp:

process_config_directive(*args) -> 'void'
    process_config_directive(directive, priority=2)
    
    @param directive: char const *
    @param priority: int

Help on class processor_t in module ida_idp:

class processor_t(IDP_Hooks)
 |  Proxy of C++ IDP_Hooks class.
 |  
 |  Method resolution order:
 |      processor_t
 |      IDP_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> IDP_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  _get_idb_notifier_addr(self)
 |  
 |  _get_idb_notifier_ud_addr(self)
 |  
 |  _get_idp_notifier_addr(self)
 |  
 |  _get_idp_notifier_ud_addr(self)
 |  
 |  _get_notify(self, what, unimp_val=0, imp_forced_val=None, add_prefix=True, mandatory_impl=None)
 |      This helper is used to implement backward-compatibility
 |      of pre IDA 7.3 processor_t interfaces.
 |  
 |  _make_forced_value_wrapper(self, val, meth=None)
 |  
 |  _make_int_returning_wrapper(self, meth, intval=0)
 |  
 |  auto_empty(self, *args)
 |  
 |  auto_empty_finally(self, *args)
 |  
 |  closebase(self, *args)
 |  
 |  compiler_changed(self, *args)
 |  
 |  deleting_func(self, pfn)
 |  
 |  determined_main(self, *args)
 |  
 |  ev_ana_insn(self, *args)
 |      ev_ana_insn(self, out) -> bool
 |      Analyze one instruction and fill 'out' structure. This function shouldn't change
 |      the database, flags or anything else. All these actions should be performed only
 |      by emu_insn() function. insn_t::ea contains address of instruction to analyze.
 |      
 |      @param out: (insn_t *)
 |      @return: length of the instruction in bytes, 0 if instruction can't be decoded.
 |      @retval 0: if instruction can't be decoded.
 |  
 |  ev_assemble(self, *args)
 |      ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
 |      Assemble an instruction. (display a warning if an error is found).
 |      
 |      @param ea: (::ea_t) linear address of instruction
 |      @param cs: (::ea_t) cs of instruction
 |      @param ip: (::ea_t) ip of instruction
 |      @param use32: (bool) is 32bit segment?
 |      @param line: (const char *) line to assemble
 |      @return: size of the instruction in bytes
 |  
 |  ev_auto_queue_empty(self, *args)
 |      ev_auto_queue_empty(self, type) -> int
 |      One analysis queue is empty.
 |      
 |      @param type: (atype_t)
 |      @retval void: see also idb_event::auto_empty_finally
 |  
 |  ev_calc_step_over(self, target, ip)
 |      ev_calc_step_over(self, target, ip) -> int
 |      Calculate the address of the instruction which will be executed after "step
 |      over". The kernel will put a breakpoint there. If the step over is equal to step
 |      into or we cannot calculate the address, return BADADDR.
 |      
 |      @param target: (::ea_t *) pointer to the answer
 |      @param ip: (::ea_t) instruction address
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_can_have_type(self, *args)
 |      ev_can_have_type(self, op) -> int
 |      Can the operand have a type as offset, segment, decimal, etc? (for example, a
 |      register AX can't have a type, meaning that the user can't change its
 |      representation. see bytes.hpp for information about types and flags)
 |      
 |      @param op: (const op_t *)
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_cmp_operands(self, *args)
 |      ev_cmp_operands(self, op1, op2) -> int
 |      Compare instruction operands
 |      
 |      @param op1: (const op_t*)
 |      @param op2: (const op_t*)
 |      @retval 1: equal
 |      @retval -1: not equal
 |      @retval 0: not implemented
 |  
 |  ev_coagulate(self, *args)
 |      ev_coagulate(self, start_ea) -> int
 |      Try to define some unexplored bytes. This notification will be called if the
 |      kernel tried all possibilities and could not find anything more useful than to
 |      convert to array of bytes. The module can help the kernel and convert the bytes
 |      into something more useful.
 |      
 |      @param start_ea: (::ea_t)
 |      @return: number of converted bytes
 |  
 |  ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea)
 |      ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
 |      Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb
 |      mode refs, we clear the last bit)
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param may_define: (bool)
 |      @param code_ea: (::ea_t *)
 |      @retval <0: failed dref analysis, >0 done dref analysis
 |      @retval 0: not implemented or continue
 |  
 |  ev_create_func_frame(self, pfn)
 |      ev_create_func_frame(self, pfn) -> int
 |      Create a function frame for a newly created function Set up frame size, its
 |      attributes etc
 |      
 |      @param pfn: (func_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_create_switch_xrefs(self, *args)
 |      ev_create_switch_xrefs(self, jumpea, si) -> int
 |      Create xrefs for a custom jump table.
 |      
 |      @param jumpea: (::ea_t) address of the jump insn
 |      @param si: (const switch_info_t *) switch information
 |      @return: must return 1 Must be implemented if module uses custom jump tables,
 |               SWI_CUSTOM
 |  
 |  ev_creating_segm(self, s)
 |      ev_creating_segm(self, seg) -> int
 |      A new segment is about to be created.
 |      
 |      @param seg: (segment_t *)
 |      @retval 1: ok
 |      @retval <0: segment should not be created
 |  
 |  ev_emu_insn(self, *args)
 |      ev_emu_insn(self, insn) -> bool
 |      Emulate instruction, create cross-references, plan to analyze subsequent
 |      instructions, modify flags etc. Upon entrance to this function, all information
 |      about the instruction is in 'insn' structure.
 |      
 |      @param insn: (const insn_t *)
 |      @retval 1: ok
 |      @retval -1: the kernel will delete the instruction
 |  
 |  ev_endbinary(self, *args)
 |      ev_endbinary(self, ok) -> int
 |      IDA has loaded a binary file.
 |      
 |      @param ok: (bool) file loaded successfully?
 |  
 |  ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea)
 |      ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea) -> int
 |      find_func_bounds() finished its work. The module may fine tune the function
 |      bounds
 |      
 |      @param possible_return_code: (int *), in/out
 |      @param pfn: (func_t *)
 |      @param max_func_end_ea: (::ea_t) (from the kernel's point of view)
 |      @retval void
 |  
 |  ev_gen_map_file(self, nlines, fp)
 |      ev_gen_map_file(self, nlines, fp) -> int
 |      Generate map file. If not implemented the kernel itself will create the map
 |      file.
 |      
 |      @param nlines: (int *) number of lines in map file (-1 means write error)
 |      @param fp: (FILE *) output file
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: write error
 |  
 |  ev_gen_regvar_def(self, ctx, v)
 |      ev_gen_regvar_def(self, outctx, v) -> int
 |      Generate register variable definition line.
 |      
 |      @param outctx: (outctx_t *)
 |      @param v: (regvar_t *)
 |      @retval >0: ok, generated the definition text
 |      @retval 0: not implemented
 |  
 |  ev_gen_src_file_lnnum(self, *args)
 |      ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
 |      
 |      @param outctx: (outctx_t *) output context
 |      @param file: (const char *) source file (may be nullptr)
 |      @param lnnum: (size_t) line number
 |      @retval 1: directive has been generated
 |      @retval 0: not implemented
 |  
 |  ev_get_autocmt(self, *args)
 |      ev_get_autocmt(self, insn) -> PyObject *
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @retval 1: new comment has been generated
 |      @retval 0: callback has not been handled. the buffer must not be changed in this
 |                 case
 |  
 |  ev_get_frame_retsize(self, frsize, pfn)
 |      ev_get_frame_retsize(self, frsize, pfn) -> int
 |      Get size of function return address in bytes If this event is not implemented,
 |      the kernel will assume
 |      * 8 bytes for 64-bit function
 |      * 4 bytes for 32-bit function
 |      * 2 bytes otherwise
 |      
 |      @param frsize: (int *) frame size (out)
 |      @param pfn: (const func_t *), can't be nullptr
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_get_operand_string(self, buf, insn, opnum)
 |      ev_get_operand_string(self, insn, opnum) -> PyObject *
 |      Request text string for operand (cli, java, ...).
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param opnum: (int) operand number, -1 means any string operand
 |      @retval 0: no string (or empty string)
 |      @retval >0: original string length without terminating zero
 |  
 |  ev_is_align_insn(self, *args)
 |      ev_is_align_insn(self, ea) -> int
 |      Is the instruction created only for alignment purposes?. Do not directly call
 |      this function, use is_align_insn()
 |      
 |      @param ea: (ea_t) - instruction address
 |      @retval number: of bytes in the instruction
 |  
 |  ev_is_alloca_probe(self, *args)
 |      ev_is_alloca_probe(self, ea) -> int
 |      Does the function at 'ea' behave as __alloca_probe?
 |      
 |      @param ea: (::ea_t)
 |      @retval 1: yes
 |      @retval 0: no
 |  
 |  ev_is_basic_block_end(self, *args)
 |      ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
 |      Is the current instruction end of a basic block?. This function should be
 |      defined for processors with delayed jump slots.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param call_insn_stops_block: (bool)
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_is_call_insn(self, *args)
 |      ev_is_call_insn(self, insn) -> int
 |      Is the instruction a "call"?
 |      
 |      @param insn: (const insn_t *) instruction
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_is_far_jump(self, *args)
 |      ev_is_far_jump(self, icode) -> int
 |      is indirect far jump or call instruction? meaningful only if the processor has
 |      'near' and 'far' reference types
 |      
 |      @param icode: (int)
 |      @retval 0: not implemented
 |      @retval 1: yes
 |      @retval -1: no
 |  
 |  ev_is_indirect_jump(self, *args)
 |      ev_is_indirect_jump(self, insn) -> int
 |      Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all
 |      jump types jumps, please define this callback.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @retval 0: use CF_JUMP
 |      @retval 1: no
 |      @retval 2: yes
 |  
 |  ev_is_insn_table_jump(self, *args)
 |      ev_is_insn_table_jump(self) -> int
 |      Reserved.
 |  
 |  ev_is_ret_insn(self, *args)
 |      ev_is_ret_insn(self, insn, strict) -> int
 |      Is the instruction a "return"?
 |      
 |      @param insn: (const insn_t *) instruction
 |      @param strict: (bool) 1: report only ret instructions 0: include instructions
 |                     like "leave" which begins the function epilog
 |      @retval 0: unknown
 |      @retval <0: no
 |      @retval 1: yes
 |  
 |  ev_is_sane_insn(self, *args)
 |      ev_is_sane_insn(self, insn, no_crefs) -> int
 |      Is the instruction sane for the current file type?.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries
 |                       to convert unexplored bytes to an instruction (but there is no
 |                       other reason to convert them into an instruction) 0: the
 |                       instruction is created because of some coderef, user request or
 |                       another weighty reason.
 |      @retval >=0: ok
 |      @retval <0: no, the instruction isn't likely to appear in the program
 |  
 |  ev_is_sp_based(self, mode, insn, op)
 |      ev_is_sp_based(self, mode, insn, op) -> int
 |      Check whether the operand is relative to stack pointer or frame pointer This
 |      event is used to determine how to output a stack variable If not implemented,
 |      then all operands are sp based by default. Implement this event only if some
 |      stack references use frame pointer instead of stack pointer.
 |      
 |      @param mode: (int *) out, combination of SP/FP operand flags
 |      @param insn: (const insn_t *)
 |      @param op: (const op_t *)
 |      @retval 0: not implemented
 |      @retval 1: ok
 |  
 |  ev_is_switch(self, *args)
 |      ev_is_switch(self, si, insn) -> int
 |      Find 'switch' idiom or override processor module's decision. It will be called
 |      for instructions marked with CF_JUMP.
 |      
 |      @param si: (switch_info_t *), out
 |      @param insn: (const insn_t *) instruction possibly belonging to a switch
 |      @retval 1: switch is found, 'si' is filled. IDA will create the switch using the
 |                 filled 'si'
 |      @retval -1: no switch found. This value forbids switch creation by the processor
 |                  module
 |      @retval 0: not implemented
 |  
 |  ev_may_be_func(self, *args)
 |      ev_may_be_func(self, insn, state) -> int
 |      Can a function start here?
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
 |      @return: probability 1..100
 |      @note: Actually IDA uses 3 intervals of a probability: 0..50 not a function,
 |             51..99 a function (IDA needs another proof), 100 a function (no other
 |             proofs needed)
 |  
 |  ev_may_show_sreg(self, *args)
 |      ev_may_show_sreg(self, current_ea) -> int
 |      The kernel wants to display the segment registers in the messages window.
 |      
 |      @param current_ea: (::ea_t)
 |      @retval <0: if the kernel should not show the segment registers. (assuming that
 |                  the module has done it)
 |      @retval 0: not implemented
 |  
 |  ev_moving_segm(self, s, to_ea, flags)
 |      ev_moving_segm(self, seg, to, flags) -> int
 |      May the kernel move the segment?
 |      
 |      @param seg: (segment_t *) segment to move
 |      @param to: (::ea_t) new segment start address
 |      @param flags: (int) combination of Move segment flags
 |      @retval 0: yes
 |      @retval <0: the kernel should stop
 |  
 |  ev_newbinary(self, *args)
 |      ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
 |      IDA is about to load a binary file.
 |      
 |      @param filename: (char *) binary file name
 |      @param fileoff: (qoff64_t) offset in the file
 |      @param basepara: (::ea_t) base loading paragraph
 |      @param binoff: (::ea_t) loader offset
 |      @param nbytes: (::uint64) number of bytes to load
 |  
 |  ev_newfile(self, *args)
 |      ev_newfile(self, fname) -> int
 |      A new file has been loaded.
 |      
 |      @param fname: (char *) input file name
 |  
 |  ev_newprc(self, *args)
 |      ev_newprc(self, pnum, keep_cfg) -> int
 |      Before changing processor type.
 |      
 |      @param pnum: (int) processor number in the array of processor names
 |      @param keep_cfg: (bool) true: do not modify kernel configuration
 |      @retval 1: ok
 |      @retval <0: prohibit
 |  
 |  ev_oldfile(self, *args)
 |      ev_oldfile(self, fname) -> int
 |      An old file has been loaded.
 |      
 |      @param fname: (char *) input file name
 |  
 |  ev_out_assumes(self, *args)
 |      ev_out_assumes(self, outctx) -> int
 |      Function to produce assume directives when segment register value changes.
 |      
 |      @param outctx: (outctx_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_data(self, *args)
 |      ev_out_data(self, outctx, analyze_only) -> int
 |      Generate text representation of data items This function may change the database
 |      and create cross-references if analyze_only is set
 |      
 |      @param outctx: (outctx_t *)
 |      @param analyze_only: (bool)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_footer(self, *args)
 |      ev_out_footer(self, outctx) -> int
 |      Function to produce end of disassembled text
 |      
 |      @param outctx: (outctx_t *)
 |      @retval void
 |  
 |  ev_out_header(self, *args)
 |      ev_out_header(self, outctx) -> int
 |      Function to produce start of disassembled text
 |      
 |      @param outctx: (outctx_t *)
 |      @retval void
 |  
 |  ev_out_insn(self, *args)
 |      ev_out_insn(self, outctx) -> bool
 |      Generate text representation of an instruction in 'ctx.insn' outctx_t provides
 |      functions to output the generated text. This function shouldn't change the
 |      database, flags or anything else. All these actions should be performed only by
 |      emu_insn() function.
 |      
 |      @param outctx: (outctx_t *)
 |      @retval void
 |  
 |  ev_out_label(self, *args)
 |      ev_out_label(self, outctx, colored_name) -> int
 |      The kernel is going to generate an instruction label line or a function header.
 |      
 |      @param outctx: (outctx_t *)
 |      @param colored_name: (const char *)
 |      @retval <0: if the kernel should not generate the label
 |      @retval 0: not implemented or continue
 |  
 |  ev_out_mnem(self, *args)
 |      ev_out_mnem(self, outctx) -> int
 |      Generate instruction mnemonics. This callback should append the colored
 |      mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be
 |      called.
 |      
 |      @param outctx: (outctx_t *)
 |      @retval 1: if appended the mnemonics
 |      @retval 0: not implemented
 |  
 |  ev_out_operand(self, *args)
 |      ev_out_operand(self, outctx, op) -> bool
 |      Generate text representation of an instruction operand outctx_t provides
 |      functions to output the generated text. All these actions should be performed
 |      only by emu_insn() function.
 |      
 |      @param outctx: (outctx_t *)
 |      @param op: (const op_t *)
 |      @retval 1: ok
 |      @retval -1: operand is hidden
 |  
 |  ev_out_segend(self, ctx, s)
 |      ev_out_segend(self, outctx, seg) -> int
 |      Function to produce end of segment
 |      
 |      @param outctx: (outctx_t *)
 |      @param seg: (segment_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_segstart(self, ctx, s)
 |      ev_out_segstart(self, outctx, seg) -> int
 |      Function to produce start of segment
 |      
 |      @param outctx: (outctx_t *)
 |      @param seg: (segment_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_out_special_item(self, *args)
 |      ev_out_special_item(self, outctx, segtype) -> int
 |      Generate text representation of an item in a special segment i.e. absolute
 |      symbols, externs, communal definitions etc
 |      
 |      @param outctx: (outctx_t *)
 |      @param segtype: (uchar)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |      @retval -1: overflow
 |  
 |  ev_rename(self, *args)
 |      ev_rename(self, ea, new_name) -> int
 |      The kernel is going to rename a byte.
 |      
 |      @param ea: (::ea_t)
 |      @param new_name: (const char *)
 |      @retval <0: if the kernel should not rename it.
 |      @retval 2: to inhibit the notification. I.e., the kernel should not rename, but
 |                 'set_name()' should return 'true'. also see renamed the return value
 |                 is ignored when kernel is going to delete name
 |  
 |  ev_set_idp_options(self, keyword, value_type, value, idb_loaded)
 |      ev_set_idp_options(self, keyword, value_type, value, idb_loaded) -> int
 |      Set IDP-specific configuration option Also see set_options_t in config.hpp
 |      
 |      @param keyword: (const char *)
 |      @param value_type: (int)
 |      @param value: (const void *)
 |      @param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been
 |                         generated
 |      @retval 1: ok
 |      @retval 0: not implemented
 |      @retval -1: error (and message in errbuf)
 |  
 |  ev_set_proc_options(self, *args)
 |      ev_set_proc_options(self, options, confidence) -> int
 |      Called if the user specified an option string in the command line: -p<processor
 |      name>:<options>. Can be used for setting a processor subtype. Also called if
 |      option string is passed to set_processor_type() and IDC's SetProcessorType().
 |      
 |      @param options: (const char *)
 |      @param confidence: (int) 0: loader's suggestion 1: user's decision
 |      @retval <0: if bad option string
 |  
 |  ev_str2reg(self, *args)
 |      ev_str2reg(self, regname) -> int
 |      Convert a register name to a register number. The register number is the
 |      register index in the processor_t::reg_names array Most processor modules do not
 |      need to implement this callback It is useful only if processor_t::reg_names[reg]
 |      does not provide the correct register names
 |      
 |      @param regname: (const char *)
 |      @retval register: number + 1
 |      @retval 0: not implemented or could not be decoded
 |  
 |  ev_treat_hindering_item(self, *args)
 |      ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
 |      An item hinders creation of another item.
 |      
 |      @param hindering_item_ea: (::ea_t)
 |      @param new_item_flags: (flags_t) (0 for code)
 |      @param new_item_ea: (::ea_t)
 |      @param new_item_length: (::asize_t)
 |      @retval 0: no reaction
 |      @retval !=0: the kernel may delete the hindering item
 |  
 |  ev_undefine(self, *args)
 |      ev_undefine(self, ea) -> int
 |      An item in the database (insn or data) is being deleted.
 |      
 |      @param ea: (ea_t)
 |      @retval 1: do not delete srranges at the item end
 |      @retval 0: srranges can be deleted
 |  
 |  ev_validate_flirt_func(self, *args)
 |      ev_validate_flirt_func(self, start_ea, funcname) -> int
 |      Flirt has recognized a library function. This callback can be used by a plugin
 |      or proc module to intercept it and validate such a function.
 |      
 |      @param start_ea: (::ea_t)
 |      @param funcname: (const char *)
 |      @retval -1: do not create a function,
 |      @retval 0: function is validated
 |  
 |  ev_verify_noreturn(self, pfn)
 |      ev_verify_noreturn(self, pfn) -> int
 |      The kernel wants to set 'noreturn' flags for a function.
 |      
 |      @param pfn: (func_t *)
 |      @retval 0: ok. any other value: do not set 'noreturn' flag
 |  
 |  ev_verify_sp(self, pfn)
 |      ev_verify_sp(self, pfn) -> int
 |      All function instructions have been analyzed. Now the processor module can
 |      analyze the stack pointer for the whole function
 |      
 |      @param pfn: (func_t *)
 |      @retval 0: ok
 |      @retval <0: bad stack pointer
 |  
 |  func_added(self, pfn)
 |  
 |  get_auxpref(self, insn)
 |      This function returns insn.auxpref value
 |  
 |  get_idpdesc(self)
 |      This function must be present and should return the list of
 |      short processor names similar to the one in ph.psnames.
 |      This method can be overridden to return to the kernel a different IDP description.
 |  
 |  get_uFlag(self)
 |      Use this utility function to retrieve the 'uFlag' global variable
 |  
 |  idasgn_loaded(self, *args)
 |  
 |  kernel_config_loaded(self, *args)
 |  
 |  make_code(self, *args)
 |  
 |  make_data(self, *args)
 |  
 |  renamed(self, *args)
 |  
 |  savebase(self, *args)
 |  
 |  segm_moved(self, from_ea, to_ea, size, changed_netmap)
 |  
 |  set_func_end(self, *args)
 |  
 |  set_func_start(self, *args)
 |  
 |  sgr_changed(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __idc_cvt_id__ = 2
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from IDP_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_IDP_Hooks(...)
 |      delete_IDP_Hooks(self)
 |  
 |  ev_add_cref(self, *args) -> 'int'
 |      ev_add_cref(self, _from, to, type) -> int
 |      A code reference is being created.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param type: (cref_t)
 |      @retval <0: cancel cref creation
 |      @retval 0: not implemented or continue
 |  
 |  ev_add_dref(self, *args) -> 'int'
 |      ev_add_dref(self, _from, to, type) -> int
 |      A data reference is being created.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param type: (dref_t)
 |      @retval <0: cancel dref creation
 |      @retval 0: not implemented or continue
 |  
 |  ev_adjust_argloc(self, *args) -> 'int'
 |      ev_adjust_argloc(self, argloc, optional_type, size) -> int
 |      Adjust argloc according to its type/size and platform endianess
 |      
 |      @param argloc: (argloc_t *), inout
 |      @param type: (const tinfo_t *), may be nullptr nullptr means primitive type of
 |                   given size
 |      @param size: (int) 'size' makes no sense if type != nullptr (type->get_size()
 |                   should be used instead)
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: error
 |  
 |  ev_adjust_libfunc_ea(self, *args) -> 'int'
 |      ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
 |      Called when a signature module has been matched against bytes in the database.
 |      This is used to compute the offset at which a particular module's libfunc should
 |      be applied.
 |      
 |      @param sig: (const idasgn_t *)
 |      @param libfun: (const libfunc_t *)
 |      @param ea: (::ea_t *)
 |      @note: 'ea' initially contains the ea_t of the start of the pattern match
 |      @retval 1: the ea_t pointed to by the third argument was modified.
 |      @retval <=0: not modified. use default algorithm.
 |  
 |  ev_adjust_refinfo(self, *args) -> 'int'
 |      ev_adjust_refinfo(self, ri, ea, n, fd) -> int
 |      Called from apply_fixup before converting operand to reference. Can be used for
 |      changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some
 |      references)
 |      
 |      @param ri: (refinfo_t *)
 |      @param ea: (::ea_t) instruction address
 |      @param n: (int) operand number
 |      @param fd: (const fixup_data_t *)
 |      @retval <0: do not create an offset
 |      @retval 0: not implemented or refinfo adjusted
 |  
 |  ev_analyze_prolog(self, *args) -> 'int'
 |      ev_analyze_prolog(self, ea) -> int
 |      Analyzes function prolog, epilog, and updates purge, and function attributes
 |      
 |      @param ea: (::ea_t) start of function
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_arch_changed(self, *args) -> 'int'
 |      ev_arch_changed(self) -> int
 |      The loader is done parsing arch-related information, which the processor module
 |      might want to use to finish its initialization.
 |      @retval 1: if success
 |      @retval 0: not implemented or failed
 |  
 |  ev_arg_addrs_ready(self, *args) -> 'int'
 |      ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
 |      Argument address info is ready.
 |      
 |      @param caller: (::ea_t)
 |      @param n: (int) number of formal arguments
 |      @param tif: (tinfo_t *) call prototype
 |      @param addrs: (::ea_t *) argument intilization addresses
 |      @retval <0: do not save into idb; other values mean "ok to save"
 |  
 |  ev_asm_installed(self, *args) -> 'int'
 |      ev_asm_installed(self, asmnum) -> int
 |      After setting a new assembler
 |      
 |      @param asmnum: (int) See also ev_newasm
 |  
 |  ev_calc_arglocs(self, *args) -> 'int'
 |      ev_calc_arglocs(self, fti) -> int
 |      Calculate function argument locations. This callback should fill retloc, all
 |      arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions.
 |      
 |      @param fti: (func_type_data_t *) points to the func type info
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: error
 |  
 |  ev_calc_cdecl_purged_bytes(self, *args) -> 'int'
 |      ev_calc_cdecl_purged_bytes(self, ea) -> int
 |      Calculate number of purged bytes after call.
 |      
 |      @param ea: (::ea_t) address of the call instruction
 |      @return: number of purged bytes (usually add sp, N)
 |  
 |  ev_calc_next_eas(self, *args) -> 'int'
 |      ev_calc_next_eas(self, res, insn, over) -> int
 |      Calculate list of addresses the instruction in 'insn' may pass control to. This
 |      callback is required for source level debugging.
 |      
 |      @param res: (eavec_t *), out: array for the results.
 |      @param insn: (const insn_t*) the instruction
 |      @param over: (bool) calculate for step over (ignore call targets)
 |      @retval <0: incalculable (indirect jumps, for example)
 |      @retval >=0: number of addresses of called functions in the array. They must be
 |                   put at the beginning of the array (0 if over=true)
 |  
 |  ev_calc_purged_bytes(self, *args) -> 'int'
 |      ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
 |      Calculate number of purged bytes by the given function type.
 |      
 |      @param p_purged_bytes: (int *) ptr to output
 |      @param fti: (const func_type_data_t *) func type details
 |      @retval 1
 |      @retval 0: not implemented
 |  
 |  ev_calc_retloc(self, *args) -> 'int'
 |      ev_calc_retloc(self, retloc, rettype, cc) -> int
 |      Calculate return value location.
 |      
 |      @param retloc: (argloc_t *)
 |      @param rettype: (const tinfo_t *)
 |      @param cc: (cm_t)
 |      @retval 0: not implemented
 |      @retval 1: ok,
 |      @retval -1: error
 |  
 |  ev_calc_spdelta(self, *args) -> 'int'
 |      ev_calc_spdelta(self, spdelta, insn) -> int
 |      Calculate amount of change to sp for the given insn. This event is required to
 |      decompile code snippets.
 |      
 |      @param spdelta: (sval_t *)
 |      @param insn: (const insn_t *)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_calc_switch_cases(self, *args) -> 'int'
 |      ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
 |      Calculate case values and targets for a custom jump table.
 |      
 |      @param casevec: (::casevec_t *) vector of case values (may be nullptr)
 |      @param targets: (eavec_t *) corresponding target addresses (my be nullptr)
 |      @param insn_ea: (::ea_t) address of the 'indirect jump' instruction
 |      @param si: (switch_info_t *) switch information
 |      @retval 1: ok
 |      @retval <=0: failed
 |  
 |  ev_calc_varglocs(self, *args) -> 'int'
 |      ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
 |      Calculate locations of the arguments that correspond to '...'.
 |      
 |      @param ftd: (func_type_data_t *), inout: info about all arguments (including
 |                  varargs)
 |      @param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be
 |                       nullptr
 |      @param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be
 |                          nullptr
 |      @param nfixed: (int) number of fixed arguments
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval -1: error On some platforms variadic calls require passing additional
 |                  information: for example, number of floating variadic arguments must
 |                  be passed in rax on gcc-x64. The locations and values that
 |                  constitute this additional information are returned in the buffers
 |                  pointed by aux_regs and aux_stkargs
 |  
 |  ev_calcrel(self, *args) -> 'int'
 |      ev_calcrel(self) -> int
 |      Reserved.
 |  
 |  ev_clean_tbit(self, *args) -> 'int'
 |      ev_clean_tbit(self, ea, getreg, regvalues) -> int
 |      Clear the TF bit after an insn like pushf stored it in memory.
 |      
 |      @param ea: (::ea_t) instruction address
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 1: ok
 |      @retval 0: failed
 |  
 |  ev_create_flat_group(self, *args) -> 'int'
 |      ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
 |      Create special segment representing the flat group.
 |      
 |      @param image_base: (::ea_t)
 |      @param bitness: (int)
 |      @param dataseg_sel: (::sel_t) return value is ignored
 |  
 |  ev_create_merge_handlers(self, *args) -> 'int'
 |      ev_create_merge_handlers(self, md) -> int
 |      Create merge handlers, if needed
 |      
 |      @param md: (merge_data_t *) This event is generated immediately after opening
 |                 idbs.
 |      @return: must be 0
 |  
 |  ev_decorate_name(self, *args) -> 'PyObject *'
 |      ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
 |      Decorate/undecorate a C symbol name.
 |      
 |      @param name: (const char *) name of symbol
 |      @param mangle: (bool) true-mangle, false-unmangle
 |      @param cc: (cm_t) calling convention
 |      @param optional_type: tinfo_t const *
 |      @retval 1: if success
 |      @retval 0: not implemented or failed
 |  
 |  ev_del_cref(self, *args) -> 'int'
 |      ev_del_cref(self, _from, to, expand) -> int
 |      A code reference is being deleted.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @param expand: (bool)
 |      @retval <0: cancel cref deletion
 |      @retval 0: not implemented or continue
 |  
 |  ev_del_dref(self, *args) -> 'int'
 |      ev_del_dref(self, _from, to) -> int
 |      A data reference is being deleted.
 |      
 |      @param from: (::ea_t)
 |      @param to: (::ea_t)
 |      @retval <0: cancel dref deletion
 |      @retval 0: not implemented or continue
 |  
 |  ev_delay_slot_insn(self, *args) -> 'PyObject *'
 |      ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
 |      Get delay slot instruction
 |      
 |      @param ea: (::ea_t *) in: instruction address in question, out: (if the answer
 |                 is positive) if the delay slot contains valid insn: the address of
 |                 the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
 |      @param bexec: (bool *) execute slot if jumping, initially set to 'true'
 |      @param fexec: (bool *) execute slot if not jumping, initally set to 'true'
 |      @retval 1: positive answer
 |      @retval <=0: ordinary insn
 |      @note: Input EA may point to the instruction with a delay slot or to the delay
 |             slot instruction itself.
 |  
 |  ev_demangle_name(self, *args) -> 'PyObject *'
 |      ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
 |      Demangle a C++ (or another language) name into a user-readable string. This
 |      event is called by demangle_name()
 |      
 |      @param name: (const char *) mangled name
 |      @param disable_mask: (uint32) flags to inhibit parts of output or compiler
 |                           info/other (see MNG_)
 |      @param demreq: (demreq_type_t) operation to perform
 |      @retval 1: if success
 |      @retval 0: not implemented
 |      @note: if you call demangle_name() from the handler, protect against recursion!
 |  
 |  ev_ending_undo(self, *args) -> 'int'
 |      ev_ending_undo(self, action_name, is_undo) -> int
 |      Ended undoing/redoing an action
 |      
 |      @param action_name: (const char *) action that we finished undoing/redoing. is
 |                          not nullptr.
 |      @param is_undo: (bool) true if performing undo, false if performing redo
 |  
 |  ev_equal_reglocs(self, *args) -> 'int'
 |      ev_equal_reglocs(self, a1, a2) -> int
 |      Are 2 register arglocs the same?. We need this callback for the pc module.
 |      
 |      @param a1: (argloc_t *)
 |      @param a2: (argloc_t *)
 |      @retval 1: yes
 |      @retval -1: no
 |      @retval 0: not implemented
 |  
 |  ev_extract_address(self, *args) -> 'int'
 |      ev_extract_address(self, out_ea, screen_ea, string, position) -> int
 |      Extract address from a string.
 |      
 |      @param out_ea: (ea_t *), out
 |      @param screen_ea: (ea_t)
 |      @param string: (const char *)
 |      @param position: (size_t)
 |      @retval 1: ok
 |      @retval 0: kernel should use the standard algorithm
 |      @retval -1: error
 |  
 |  ev_find_op_value(self, *args) -> 'PyObject *'
 |      ev_find_op_value(self, pinsn, opn) -> PyObject *
 |      Find operand value via a register tracker. The returned value in 'out' is valid
 |      before executing the instruction.
 |      
 |      @param pinsn: (const insn_t *) instruction
 |      @param opn: (int) operand index
 |      @retval 1: if implemented, and value was found
 |      @retval 0: not implemented, -1 decoding failed, or no value found
 |  
 |  ev_find_reg_value(self, *args) -> 'PyObject *'
 |      ev_find_reg_value(self, pinsn, reg) -> PyObject *
 |      Find register value via a register tracker. The returned value in 'out' is valid
 |      before executing the instruction.
 |      
 |      @param pinsn: (const insn_t *) instruction
 |      @param reg: (int) register index
 |      @retval 1: if implemented, and value was found
 |      @retval 0: not implemented, -1 decoding failed, or no value found
 |  
 |  ev_gen_asm_or_lst(self, *args) -> 'int'
 |      ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -> int
 |      
 |      @param starting: (bool) beginning listing generation
 |      @param fp: (FILE *) output file
 |      @param is_asm: (bool) true:assembler, false:listing
 |      @param flags: (int) flags passed to gen_file()
 |      @param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this
 |                      callback is defined for this code, it will be used by the kernel
 |                      to output the generated lines
 |      @retval void
 |  
 |  ev_gen_stkvar_def(self, *args) -> 'int'
 |      ev_gen_stkvar_def(self, outctx, mptr, v) -> int
 |      Generate stack variable definition line Default line is varname = type ptr
 |      value, where 'type' is one of byte,word,dword,qword,tbyte
 |      
 |      @param outctx: (outctx_t *)
 |      @param mptr: (const member_t *)
 |      @param v: (sval_t)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |  
 |  ev_get_abi_info(self, *args) -> 'int'
 |      ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
 |      Get all possible ABI names and optional extensions for given compiler
 |      abiname/option is a string entirely consisting of letters, digits and underscore
 |      
 |      @param abi_names: (qstrvec_t *) - all possible ABis each in form abiname-
 |                        opt1-opt2-...
 |      @param abi_opts: (qstrvec_t *) - array of all possible options in form
 |                       "opt:description" or opt:hint-line#description
 |      @param comp: (comp_t) - compiler ID
 |      @retval 0: not implemented
 |      @retval 1: ok
 |  
 |  ev_get_bg_color(self, *args) -> 'int'
 |      ev_get_bg_color(self, color, ea) -> int
 |      Get item background color. Plugins can hook this callback to color disassembly
 |      lines dynamically
 |      
 |      @param color: (bgcolor_t *), out
 |      @param ea: (::ea_t)
 |      @retval 0: not implemented
 |      @retval 1: color set
 |  
 |  ev_get_cc_regs(self, *args) -> 'int'
 |      ev_get_cc_regs(self, regs, cc) -> int
 |      Get register allocation convention for given calling convention
 |      
 |      @param regs: (callregs_t *), out
 |      @param cc: (cm_t)
 |      @retval 1
 |      @retval 0: not implemented
 |  
 |  ev_get_code16_mode(self, *args) -> 'int'
 |      ev_get_code16_mode(self, ea) -> int
 |      Get ISA 16-bit mode
 |      
 |      @param ea: (ea_t) address to get the ISA mode
 |      @retval 1: 16-bit mode
 |      @retval 0: not implemented or 32-bit mode
 |  
 |  ev_get_dbr_opnum(self, *args) -> 'int'
 |      ev_get_dbr_opnum(self, opnum, insn) -> int
 |      Get the number of the operand to be displayed in the debugger reference view
 |      (text mode).
 |      
 |      @param opnum: (int *) operand number (out, -1 means no such operand)
 |      @param insn: (const insn_t*) the instruction
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_get_default_enum_size(self, *args) -> 'int'
 |      ev_get_default_enum_size(self) -> int
 |      Get default enum size. Not generated anymore. inf_get_cc_size_e() is used
 |      instead
 |  
 |  ev_get_macro_insn_head(self, *args) -> 'int'
 |      ev_get_macro_insn_head(self, head, ip) -> int
 |      Calculate the start of a macro instruction. This notification is called if IP
 |      points to the middle of an instruction
 |      
 |      @param head: (::ea_t *), out: answer, BADADDR means normal instruction
 |      @param ip: (::ea_t) instruction address
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_get_procmod(self, *args) -> 'int'
 |      ev_get_procmod(self) -> int
 |      Get pointer to the processor module object. All processor modules must implement
 |      this. The pointer is returned as size_t.
 |  
 |  ev_get_reg_accesses(self, *args) -> 'int'
 |      ev_get_reg_accesses(self, accvec, insn, flags) -> int
 |      Get info about the registers that are used/changed by an instruction.
 |      
 |      @param accvec: (reg_accesses_t*) out: info about accessed registers
 |      @param insn: (const insn_t *) instruction in question
 |      @param flags: (int) reserved, must be 0
 |      @retval -1: if accvec is nullptr
 |      @retval 1: found the requested access (and filled accvec)
 |      @retval 0: not implemented
 |  
 |  ev_get_reg_info(self, *args) -> 'int'
 |      ev_get_reg_info(self, main_regname, bitrange, regname) -> int
 |      Get register information by its name. example: "ah" returns:
 |      * main_regname="eax"
 |      * bitrange_t = { offset==8, nbits==8 }
 |      
 |      This callback may be unimplemented if the register names are all present in
 |      processor_t::reg_names and they all have the same size
 |      
 |      @param main_regname: (const char **), out
 |      @param bitrange: (bitrange_t *), out: position and size of the value within
 |                       'main_regname' (empty bitrange == whole register)
 |      @param regname: (const char *)
 |      @retval 1: ok
 |      @retval -1: failed (not found)
 |      @retval 0: unimplemented
 |  
 |  ev_get_reg_name(self, *args) -> 'PyObject *'
 |      ev_get_reg_name(self, reg, width, reghi) -> PyObject *
 |      Generate text representation of a register. Most processor modules do not need
 |      to implement this callback. It is useful only if processor_t::reg_names[reg]
 |      does not provide the correct register name.
 |      
 |      @param reg: (int) internal register number as defined in the processor module
 |      @param width: (size_t) register width in bytes
 |      @param reghi: (int) if not -1 then this function will return the register pair
 |      @retval -1: if error
 |      @retval strlen(buf): if success
 |  
 |  ev_get_simd_types(self, *args) -> 'int'
 |      ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
 |      Get SIMD-related types according to given attributes ant/or argument location
 |      
 |      @param out: (::simd_info_vec_t *)
 |      @param simd_attrs: (const simd_info_t *), may be nullptr
 |      @param argloc: (const argloc_t *), may be nullptr
 |      @param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
 |      @retval number: of found types
 |      @retval -1: error If name==nullptr, initialize all SIMD types
 |  
 |  ev_get_stkarg_area_info(self, *args) -> 'int'
 |      ev_get_stkarg_area_info(self, out, cc) -> int
 |      Get some metrics of the stack argument area.
 |      
 |      @param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
 |      @param cc: (cm_t) calling convention
 |      @retval 1: if success
 |      @retval 0: not implemented
 |  
 |  ev_get_stkvar_scale_factor(self, *args) -> 'int'
 |      ev_get_stkvar_scale_factor(self) -> int
 |      Should stack variable references be multiplied by a coefficient before being
 |      used in the stack frame?. Currently used by TMS320C55 because the references
 |      into the stack should be multiplied by 2
 |      
 |      @return: scaling factor
 |      @retval 0: not implemented
 |      @note: PR_SCALE_STKVARS should be set to use this callback
 |  
 |  ev_getreg(self, *args) -> 'int'
 |      ev_getreg(self, regval, regnum) -> int
 |      IBM PC only internal request, should never be used for other purpose Get
 |      register value by internal index
 |      
 |      @param regval: (uval_t *), out
 |      @param regnum: (int)
 |      @retval 1: ok
 |      @retval 0: not implemented
 |      @retval -1: failed (undefined value or bad regnum)
 |  
 |  ev_init(self, *args) -> 'int'
 |      ev_init(self, idp_modname) -> int
 |      The IDP module is just loaded.
 |      
 |      @param idp_modname: (const char *) processor module name
 |      @retval <0: on failure
 |  
 |  ev_insn_reads_tbit(self, *args) -> 'int'
 |      ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
 |      Check if insn will read the TF bit.
 |      
 |      @param insn: (const insn_t*) the instruction
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 2: yes, will generate 'step' exception
 |      @retval 1: yes, will store the TF bit in memory
 |      @retval 0: no
 |  
 |  ev_is_cond_insn(self, *args) -> 'int'
 |      ev_is_cond_insn(self, insn) -> int
 |      Is conditional instruction?
 |      
 |      @param insn: (const insn_t *) instruction address
 |      @retval 1: yes
 |      @retval -1: no
 |      @retval 0: not implemented or not instruction
 |  
 |  ev_is_control_flow_guard(self, *args) -> 'int'
 |      ev_is_control_flow_guard(self, p_reg, insn) -> int
 |      Detect if an instruction is a "thunk call" to a flow guard function (equivalent
 |      to call reg/return/nop)
 |      
 |      @param p_reg: (int *) indirect register number, may be -1
 |      @param insn: (const insn_t *) call/jump instruction
 |      @retval -1: no thunk detected
 |      @retval 1: indirect call
 |      @retval 2: security check routine call (NOP)
 |      @retval 3: return thunk
 |      @retval 0: not implemented
 |  
 |  ev_is_jump_func(self, *args) -> 'int'
 |      ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
 |      Is the function a trivial "jump" function?.
 |      
 |      @param pfn: (func_t *)
 |      @param jump_target: (::ea_t *)
 |      @param func_pointer: (::ea_t *)
 |      @retval <0: no
 |      @retval 0: don't know
 |      @retval 1: yes, see 'jump_target' and 'func_pointer'
 |  
 |  ev_last_cb_before_loader(self, *args) -> 'int'
 |      ev_last_cb_before_loader(self) -> int
 |  
 |  ev_loader(self, *args) -> 'int'
 |      ev_loader(self) -> int
 |      This code and higher ones are reserved for the loaders. The arguments and the
 |      return values are defined by the loaders
 |  
 |  ev_lower_func_type(self, *args) -> 'int'
 |      ev_lower_func_type(self, argnums, fti) -> int
 |      Get function arguments which should be converted to pointers when lowering
 |      function prototype. The processor module can also modify 'fti' in order to make
 |      non-standard conversion of some arguments.
 |      
 |      @param argnums: (intvec_t *), out - numbers of arguments to be converted to
 |                      pointers in acsending order
 |      @param fti: (func_type_data_t *), inout func type details (special values -1/-2
 |                  for return value - position of hidden 'retstr' argument: -1 - at the
 |                  beginning, -2 - at the end)
 |      @retval 0: not implemented
 |      @retval 1: argnums was filled
 |      @retval 2: argnums was filled and made substantial changes to fti
 |  
 |  ev_max_ptr_size(self, *args) -> 'int'
 |      ev_max_ptr_size(self) -> int
 |      Get maximal size of a pointer in bytes.
 |      
 |      @return: max possible size of a pointer
 |  
 |  ev_newasm(self, *args) -> 'int'
 |      ev_newasm(self, asmnum) -> int
 |      Before setting a new assembler.
 |      
 |      @param asmnum: (int) See also ev_asm_installed
 |  
 |  ev_next_exec_insn(self, *args) -> 'int'
 |      ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
 |      Get next address to be executed This function must return the next address to be
 |      executed. If the instruction following the current one is executed, then it must
 |      return BADADDR Usually the instructions to consider are: jumps, branches, calls,
 |      returns. This function is essential if the 'single step' is not supported in
 |      hardware.
 |      
 |      @param target: (::ea_t *), out: pointer to the answer
 |      @param ea: (::ea_t) instruction address
 |      @param tid: (int) current therad id
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 0: unimplemented
 |      @retval 1: implemented
 |  
 |  ev_privrange_changed(self, *args) -> 'int'
 |      ev_privrange_changed(self, old_privrange, delta) -> int
 |      Privrange interval has been moved to a new location. Most common actions to be
 |      done by module in this case: fix indices of netnodes used by module
 |      
 |      @param old_privrange: (const range_t *) - old privrange interval
 |      @param delta: (::adiff_t)
 |      @return: 0 Ok
 |      -1 error (and message in errbuf)
 |  
 |  ev_realcvt(self, *args) -> 'int'
 |      ev_realcvt(self, m, e, swt) -> int
 |      Floating point -> IEEE conversion
 |      
 |      @param m: (void *) ptr to processor-specific floating point value
 |      @param e: (fpvalue_t *) IDA representation of a floating point value
 |      @param swt: (uint16) operation (see realcvt() in ieee.h)
 |      @retval 0: not implemented
 |      @retval 1: ok
 |      @retval unknown
 |  
 |  ev_replaying_undo(self, *args) -> 'int'
 |      ev_replaying_undo(self, action_name, vec, is_undo) -> int
 |      Replaying an undo/redo buffer
 |      
 |      @param action_name: (const char *) action that we perform undo/redo for. may be
 |                          nullptr for intermediary buffers.
 |      @param vec: (const undo_records_t *)
 |      @param is_undo: (bool) true if performing undo, false if performing redo This
 |                      event may be generated multiple times per undo/redo
 |  
 |  ev_set_code16_mode(self, *args) -> 'int'
 |      ev_set_code16_mode(self, ea, code16) -> int
 |      Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set
 |      ISA 16-bit mode
 |      
 |      @param ea: (ea_t) address to set new ISA mode
 |      @param code16: (bool) true for 16-bit mode, false for 32-bit mode
 |  
 |  ev_setup_til(self, *args) -> 'int'
 |      ev_setup_til(self) -> int
 |      Setup default type libraries. (called after loading a new file into the
 |      database). The processor module may load tils, setup memory model and perform
 |      other actions required to set up the type system. This is an optional callback.
 |      @retval void
 |  
 |  ev_term(self, *args) -> 'int'
 |      ev_term(self) -> int
 |      The IDP module is being unloaded.
 |  
 |  ev_update_call_stack(self, *args) -> 'int'
 |      ev_update_call_stack(self, stack, tid, getreg, regvalues) -> int
 |      Calculate the call stack trace for the given thread. This callback is invoked
 |      when the process is suspended and should fill the 'trace' object with the
 |      information about the current call stack. Note that this callback is NOT invoked
 |      if the current debugger backend implements stack tracing via
 |      debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes
 |      priority. Implementing this callback in the processor module is useful when
 |      multiple debugging platforms follow similar patterns, and thus the same
 |      processor-specific algorithm can be used for different platforms.
 |      
 |      @param stack: (call_stack_t *) result
 |      @param tid: (int) thread id
 |      @param getreg: (::processor_t::regval_getter_t *) function to get register
 |                     values
 |      @param regvalues: (const regval_t *) register values array
 |      @retval 1: ok
 |      @retval -1: failed
 |      @retval 0: unimplemented
 |  
 |  ev_use_arg_types(self, *args) -> 'int'
 |      ev_use_arg_types(self, ea, fti, rargs) -> int
 |      Use information about callee arguments.
 |      
 |      @param ea: (::ea_t) address of the call instruction
 |      @param fti: (func_type_data_t *) info about function type
 |      @param rargs: (funcargvec_t *) array of register arguments
 |      @retval 1: (and removes handled arguments from fti and rargs)
 |      @retval 0: not implemented
 |  
 |  ev_use_regarg_type(self, *args) -> 'PyObject *'
 |      ev_use_regarg_type(self, ea, rargs) -> PyObject *
 |      Use information about register argument.
 |      
 |      @param ea: (::ea_t) address of the instruction
 |      @param rargs: (const funcargvec_t *) vector of register arguments (including
 |                    regs extracted from scattered arguments)
 |      @retval 1
 |      @retval 0: not implemented
 |  
 |  ev_use_stkarg_type(self, *args) -> 'int'
 |      ev_use_stkarg_type(self, ea, arg) -> int
 |      Use information about a stack argument.
 |      
 |      @param ea: (::ea_t) address of the push instruction which pushes the function
 |                 argument into the stack
 |      @param arg: (const funcarg_t *) argument info
 |      @retval 1: ok
 |      @retval <=0: failed, the kernel will create a comment with the argument name or
 |                   type for the instruction
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from IDP_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class reg_access_t in module ida_idp:

class reg_access_t(builtins.object)
 |  Proxy of C++ reg_access_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: reg_access_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_access_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: reg_access_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_reg_access_t(...)
 |      delete_reg_access_t(self)
 |  
 |  have_common_bits(self, *args) -> 'bool'
 |      have_common_bits(self, r) -> bool
 |      
 |      @param r: reg_access_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  access_type
 |      access_type
 |  
 |  opnum
 |      opnum
 |  
 |  range
 |      range
 |  
 |  regnum
 |      regnum
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class reg_access_vec_t in module ida_idp:

class reg_access_vec_t(builtins.object)
 |  Proxy of C++ qvector< reg_access_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< reg_access_t > const &
 |  
 |  __getitem__(self, *args) -> 'reg_access_t const &'
 |      __getitem__(self, i) -> reg_access_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_access_vec_t
 |      __init__(self, x) -> reg_access_vec_t
 |      
 |      @param x: qvector< reg_access_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< reg_access_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: reg_access_t const &
 |  
 |  __swig_destroy__ = delete_reg_access_vec_t(...)
 |      delete_reg_access_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: reg_access_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: reg_access_t const &
 |  
 |  at(self, *args) -> 'reg_access_t const &'
 |      at(self, _idx) -> reg_access_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< reg_access_t >::const_iterator'
 |      begin(self) -> reg_access_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< reg_access_t >::const_iterator'
 |      end(self) -> reg_access_t
 |  
 |  erase(self, *args) -> 'qvector< reg_access_t >::iterator'
 |      erase(self, it) -> reg_access_t
 |      
 |      @param it: qvector< reg_access_t >::iterator
 |      
 |      erase(self, first, last) -> reg_access_t
 |      
 |      @param first: qvector< reg_access_t >::iterator
 |      @param last: qvector< reg_access_t >::iterator
 |  
 |  extract(self, *args) -> 'reg_access_t *'
 |      extract(self) -> reg_access_t
 |  
 |  find(self, *args) -> 'qvector< reg_access_t >::const_iterator'
 |      find(self, x) -> reg_access_t
 |      
 |      @param x: reg_access_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=reg_access_t())
 |      
 |      @param x: reg_access_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: reg_access_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: reg_access_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< reg_access_t >::iterator'
 |      insert(self, it, x) -> reg_access_t
 |      
 |      @param it: qvector< reg_access_t >::iterator
 |      @param x: reg_access_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'reg_access_t &'
 |      push_back(self, x)
 |      
 |      @param x: reg_access_t const &
 |      
 |      push_back(self) -> reg_access_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: reg_access_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< reg_access_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class reg_accesses_t in module ida_idp:

class reg_accesses_t(reg_access_vec_t)
 |  Proxy of C++ reg_accesses_t class.
 |  
 |  Method resolution order:
 |      reg_accesses_t
 |      reg_access_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_accesses_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_reg_accesses_t(...)
 |      delete_reg_accesses_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from reg_access_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< reg_access_t > const &
 |  
 |  __getitem__(self, *args) -> 'reg_access_t const &'
 |      __getitem__(self, i) -> reg_access_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< reg_access_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: reg_access_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: reg_access_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: reg_access_t const &
 |  
 |  at(self, *args) -> 'reg_access_t const &'
 |      at(self, _idx) -> reg_access_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< reg_access_t >::const_iterator'
 |      begin(self) -> reg_access_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< reg_access_t >::const_iterator'
 |      end(self) -> reg_access_t
 |  
 |  erase(self, *args) -> 'qvector< reg_access_t >::iterator'
 |      erase(self, it) -> reg_access_t
 |      
 |      @param it: qvector< reg_access_t >::iterator
 |      
 |      erase(self, first, last) -> reg_access_t
 |      
 |      @param first: qvector< reg_access_t >::iterator
 |      @param last: qvector< reg_access_t >::iterator
 |  
 |  extract(self, *args) -> 'reg_access_t *'
 |      extract(self) -> reg_access_t
 |  
 |  find(self, *args) -> 'qvector< reg_access_t >::const_iterator'
 |      find(self, x) -> reg_access_t
 |      
 |      @param x: reg_access_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=reg_access_t())
 |      
 |      @param x: reg_access_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: reg_access_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: reg_access_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< reg_access_t >::iterator'
 |      insert(self, it, x) -> reg_access_t
 |      
 |      @param it: qvector< reg_access_t >::iterator
 |      @param x: reg_access_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'reg_access_t &'
 |      push_back(self, x)
 |      
 |      @param x: reg_access_t const &
 |      
 |      push_back(self) -> reg_access_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: reg_access_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< reg_access_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from reg_access_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from reg_access_vec_t:
 |  
 |  __hash__ = None

Help on class reg_info_t in module ida_idp:

class reg_info_t(builtins.object)
 |  Proxy of C++ reg_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: reg_info_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: reg_info_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: reg_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reg_info_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: reg_info_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: reg_info_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: reg_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_reg_info_t(...)
 |      delete_reg_info_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: reg_info_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reg
 |      reg
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function register_cfgopts in module ida_idp:

register_cfgopts(*args) -> 'bool'
    register_cfgopts(opts, nopts, cb=None, obj=None) -> bool
    
    @param opts: cfgopt_t const []
    @param nopts: size_t
    @param cb: config_changed_cb_t *
    @param obj: void *

Help on function set_processor_type in module ida_idp:

set_processor_type(*args) -> 'bool'
    set_processor_type(procname, level) -> bool
    Set target processor type. Once a processor module is loaded, it cannot be
    replaced until we close the idb.
    
    @param procname: (C++: const char *) name of processor type (one of names present in
                     processor_t::psnames)
    @param level: (C++: setproc_level_t) SETPROC_
    @return: success

Help on function set_target_assembler in module ida_idp:

set_target_assembler(*args) -> 'bool'
    set_target_assembler(asmnum) -> bool
    Set target assembler.
    
    @param asmnum: (C++: int) number of assembler in the current processor module
    @return: success

Help on function sizeof_ldbl in module ida_idp:

sizeof_ldbl(*args) -> 'size_t'
    sizeof_ldbl() -> size_t

Help on function str2reg in module ida_idp:

str2reg(*args) -> 'int'
    str2reg(p) -> int
    Get any reg number (-1 on error)
    
    @param p: (C++: const char *) char const *

Module "ida_ieee"s docstring:
"""
IEEE floating point functions."""

Help on function ecleaz in module ida_ieee:

ecleaz(*args) -> 'void'
    ecleaz(x)
    
    @param x: unsigned short [(6+3)]

Help on class fpvalue_shorts_array_t in module ida_ieee:

class fpvalue_shorts_array_t(builtins.object)
 |  Proxy of C++ wrapped_array_t< uint16,FPVAL_NWORDS > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'unsigned short const &'
 |      __getitem__(self, i) -> unsigned short const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> fpvalue_shorts_array_t
 |      
 |      @param data: unsigned short (&)[FPVAL_NWORDS]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned short const &
 |  
 |  __swig_destroy__ = delete_fpvalue_shorts_array_t(...)
 |      delete_fpvalue_shorts_array_t(self)
 |  
 |  _get_bytes(self, *args) -> 'bytevec_t'
 |      _get_bytes(self) -> bytevec_t
 |  
 |  _set_bytes(self, *args) -> 'void'
 |      _set_bytes(self, bts)
 |      
 |      Parameters
 |      ----------
 |      bts: bytevec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      _get_bytes(self) -> bytevec_t
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class fpvalue_t in module ida_ieee:

class fpvalue_t(builtins.object)
 |  Proxy of C++ fpvalue_t class.
 |  
 |  Methods defined here:
 |  
 |  __add__(self, *args) -> 'fpvalue_t'
 |      __add__(self, o) -> fpvalue_t
 |      
 |      @param o: fpvalue_t const &
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: fpvalue_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: fpvalue_t const &
 |  
 |  __getitem__(self, i)
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: fpvalue_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> fpvalue_t
 |      __init__(self, _in) -> fpvalue_t
 |      
 |      @param in: bytevec12_t const &
 |  
 |  __iter__(self)
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: fpvalue_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: fpvalue_t const &
 |  
 |  __mul__(self, *args) -> 'fpvalue_t'
 |      __mul__(self, o) -> fpvalue_t
 |      
 |      @param o: fpvalue_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: fpvalue_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, i, v)
 |  
 |  __str__(self, *args) -> 'qstring'
 |      __str__(self) -> qstring
 |  
 |  __sub__(self, *args) -> 'fpvalue_t'
 |      __sub__(self, o) -> fpvalue_t
 |      
 |      @param o: fpvalue_t const &
 |  
 |  __swig_destroy__ = delete_fpvalue_t(...)
 |      delete_fpvalue_t(self)
 |  
 |  __truediv__(self, *args) -> 'fpvalue_t'
 |      __truediv__(self, o) -> fpvalue_t
 |      
 |      @param o: fpvalue_t const &
 |  
 |  _get_10bytes(self, *args) -> 'void'
 |      _get_10bytes(self)
 |  
 |  _get_bytes(self, *args) -> 'void'
 |      _get_bytes(self)
 |  
 |  _get_float(self, *args) -> 'double'
 |      _get_float(self) -> double
 |  
 |  _get_shorts(self, *args) -> 'wrapped_array_t< uint16,FPVAL_NWORDS >'
 |      _get_shorts(self) -> fpvalue_shorts_array_t
 |  
 |  _set_10bytes(self, *args) -> 'void'
 |      _set_10bytes(self, _in)
 |      
 |      Parameters
 |      ----------
 |      in: bytevec10_t const &
 |  
 |  _set_bytes(self, *args) -> 'void'
 |      _set_bytes(self, _in)
 |      
 |      Parameters
 |      ----------
 |      in: bytevec12_t const &
 |  
 |  _set_float(self, *args) -> 'void'
 |      _set_float(self, v)
 |      
 |      Parameters
 |      ----------
 |      v: double
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, r)
 |      
 |      @param r: fpvalue_t const &
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: fpvalue_t const &
 |  
 |  eabs(self, *args) -> 'void'
 |      eabs(self)
 |      Calculate absolute value.
 |  
 |  fadd(self, *args) -> 'fpvalue_error_t'
 |      fadd(self, y) -> fpvalue_error_t
 |      Arithmetic operations.
 |      
 |      @param y: (C++: const fpvalue_t &) fpvalue_t const &
 |  
 |  fdiv(self, *args) -> 'fpvalue_error_t'
 |      fdiv(self, y) -> fpvalue_error_t
 |      
 |      @param y: fpvalue_t const &
 |  
 |  fmul(self, *args) -> 'fpvalue_error_t'
 |      fmul(self, y) -> fpvalue_error_t
 |      
 |      @param y: fpvalue_t const &
 |  
 |  from_10bytes(self, *args) -> 'fpvalue_error_t'
 |      from_10bytes(self, fpval) -> fpvalue_error_t
 |      Conversions for 10-byte floating point values.
 |      
 |      @param fpval: (C++: const void *) void const *
 |  
 |  from_12bytes(self, *args) -> 'fpvalue_error_t'
 |      from_12bytes(self, fpval) -> fpvalue_error_t
 |      Conversions for 12-byte floating point values.
 |      
 |      @param fpval: (C++: const void *) void const *
 |  
 |  from_int64(self, *args) -> 'void'
 |      from_int64(self, x)
 |      
 |      @param x: int64
 |  
 |  from_str(self, *args) -> 'fpvalue_error_t'
 |      from_str(self, p) -> fpvalue_error_t
 |      Convert string to IEEE.
 |      
 |      @param p_str: (C++: const char **) pointer to pointer to string. it will advanced.
 |  
 |  from_sval(self, *args) -> 'void'
 |      from_sval(self, x)
 |      Convert integer to IEEE.
 |      
 |      @param x: (C++: sval_t)
 |  
 |  from_uint64(self, *args) -> 'void'
 |      from_uint64(self, x)
 |      
 |      @param x: uint64
 |  
 |  fsub(self, *args) -> 'fpvalue_error_t'
 |      fsub(self, y) -> fpvalue_error_t
 |      
 |      @param y: fpvalue_t const &
 |  
 |  get_kind(self, *args) -> 'fpvalue_kind_t'
 |      get_kind(self) -> fpvalue_kind_t
 |      Get value kind.
 |  
 |  is_negative(self, *args) -> 'bool'
 |      is_negative(self) -> bool
 |      Is negative value?
 |  
 |  mul_pow2(self, *args) -> 'fpvalue_error_t'
 |      mul_pow2(self, power_of_2) -> fpvalue_error_t
 |      Multiply by a power of 2.
 |      
 |      @param power_of_2: (C++: int32)
 |  
 |  negate(self, *args) -> 'void'
 |      negate(self)
 |      Negate.
 |  
 |  to_10bytes(self, *args) -> 'fpvalue_error_t'
 |      to_10bytes(self, fpval) -> fpvalue_error_t
 |      
 |      @param fpval: void *
 |  
 |  to_12bytes(self, *args) -> 'fpvalue_error_t'
 |      to_12bytes(self, fpval) -> fpvalue_error_t
 |      
 |      @param fpval: void *
 |  
 |  to_int64(self, *args) -> 'fpvalue_error_t'
 |      to_int64(self, round=False) -> fpvalue_error_t
 |      
 |      @param round: bool
 |  
 |  to_str(self, *args) -> 'void'
 |      to_str(self, mode)
 |      Convert IEEE to string.
 |      
 |      @param mode: (C++: uint) broken down into:
 |      * low byte: number of digits after '.'
 |      * second byte: FPNUM_LENGTH
 |      * third byte: FPNUM_DIGITS
 |  
 |  to_sval(self, *args) -> 'fpvalue_error_t'
 |      to_sval(self, round=False) -> fpvalue_error_t
 |      Convert IEEE to integer (+-0.5 if round)
 |      
 |      @param round: (C++: bool)
 |  
 |  to_uint64(self, *args) -> 'fpvalue_error_t'
 |      to_uint64(self, round=False) -> fpvalue_error_t
 |      
 |      @param round: bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  _10bytes
 |      _get_10bytes(self)
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      _get_bytes(self)
 |  
 |  float
 |      _get_float(self) -> double
 |  
 |  int64
 |  
 |  shorts
 |      _get_shorts(self) -> fpvalue_shorts_array_t
 |  
 |  sval
 |  
 |  thisown
 |      The membership flag
 |  
 |  uint64
 |  
 |  w
 |      w
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Module "ida_kernwin"s docstring:
"""
Defines the interface between the kernel and the UI.

It contains:
* the UI dispatcher notification codes (ui_notification_t)
* convenience functions for UI services
* structures which hold information about the lines (disassembly, structures,
enums) generated by the kernel
* functions to interact with the user (dialog boxes)
* some string and conversion functions."""

Help on class Choose in module ida_kernwin:

class Choose(builtins.object)
 |  Chooser wrapper class.
 |  
 |  Some constants are defined in this class.
 |  Please refer to kernwin.hpp for more information.
 |  
 |  Methods defined here:
 |  
 |  Activate(self)
 |      Activates a visible chooser
 |  
 |  AddCommand(self, caption, flags=4, menu_index=-1, icon=-1, emb=None, shortcut=None)
 |  
 |  Close(self)
 |      Closes the chooser
 |  
 |  Embedded(self, create_chobj=False)
 |      Creates an embedded chooser (as opposed to Show())
 |      @return: Returns 0 on success or NO_ATTR
 |  
 |  GetEmbSelection(self)
 |      Deprecated. For embedded choosers, the selection is
 |      available through 'Form.EmbeddedChooserControl.selection'
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  OnPopup(self, widget, popup_handle)
 |  
 |  Refresh(self)
 |      Causes the refresh callback to trigger
 |  
 |  Show(self, modal=False)
 |      Activates or creates a chooser window
 |      @param modal: Display as modal dialog
 |      @return: For all choosers it will return NO_ATTR if some mandatory
 |               attribute is missing. The mandatory attributes are: flags,
 |               title, cols, OnGetSize(), OnGetLine();
 |               For modal choosers it will return the selected item index (0-based),
 |               or NO_SELECTION if no selection,
 |               or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
 |               For non-modal choosers it will return 0
 |               or ALREADY_EXISTS if the chooser was already open and is active now;
 |  
 |  __init__(self, title, cols, flags=0, popup_names=None, icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=None, embedded=False, width=None, height=None, forbidden_cb=0)
 |      Constructs a chooser window.
 |      @param title: The chooser title
 |      @param cols: a list of colums; each list item is a list of two items
 |          example: [ ["Address", 10 | Choose.CHCOL_HEX],
 |                     ["Name",    30 | Choose.CHCOL_PLAIN] ]
 |      @param flags: One of CH_XXXX constants
 |      @param deflt: The index of the default item (0-based) for single
 |          selection choosers or the list of indexes for multi selection
 |          chooser
 |      @param popup_names: List of new captions to replace this list
 |          ["Insert", "Delete", "Edit", "Refresh"]
 |      @param icon: Icon index (the icon should exist in ida resources or
 |          an index to a custom loaded icon)
 |      @param x1: , y1, x2, y2: The default location (for txt-version)
 |      @param embedded: Create as embedded chooser
 |      @param width: Embedded chooser width
 |      @param height: Embedded chooser height
 |      @param forbidden_cb: Explicitly forbidden callbacks
 |  
 |  adjust_last_item(self, n)
 |      Helper for OnDeleteLine() and OnRefresh() callbacks.
 |      They can be finished by the following line:
 |      return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
 |      @param line: number of the remaining select item
 |      @return: list of selected lines numbers (one element or empty)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ALL_CHANGED = 1
 |  
 |  ALREADY_EXISTS = -3
 |  
 |  CHCOL_DEC = 196608
 |  
 |  CHCOL_DEFHIDDEN = 1048576
 |  
 |  CHCOL_DRAGHINT = 2097152
 |  
 |  CHCOL_EA = 262144
 |  
 |  CHCOL_FNAME = 327680
 |  
 |  CHCOL_FORMAT = 458752
 |  
 |  CHCOL_HEX = 131072
 |  
 |  CHCOL_INODENAME = 4194304
 |  
 |  CHCOL_PATH = 65536
 |  
 |  CHCOL_PLAIN = 0
 |  
 |  CHOOSE_HAVE_DEL = 16
 |  
 |  CHOOSE_HAVE_EDIT = 32
 |  
 |  CHOOSE_HAVE_ENTER = 64
 |  
 |  CHOOSE_HAVE_GETATTR = 4
 |  
 |  CHOOSE_HAVE_GETICON = 2
 |  
 |  CHOOSE_HAVE_INIT = 1
 |  
 |  CHOOSE_HAVE_INS = 8
 |  
 |  CHOOSE_HAVE_ONCLOSE = 512
 |  
 |  CHOOSE_HAVE_REFRESH = 128
 |  
 |  CHOOSE_HAVE_SELECT = 256
 |  
 |  CH_ATTRS = 32
 |  
 |  CH_BUILTIN_MASK = 33030144
 |  
 |  CH_BUILTIN_SHIFT = 19
 |  
 |  CH_CAN_DEL = 512
 |  
 |  CH_CAN_EDIT = 1024
 |  
 |  CH_CAN_INS = 256
 |  
 |  CH_CAN_REFRESH = 2048
 |  
 |  CH_FORCE_DEFAULT = 128
 |  
 |  CH_HAS_DIFF = 268435456
 |  
 |  CH_HAS_DIRTREE = 33554432
 |  
 |  CH_MODAL = 1
 |  
 |  CH_MULTI = 4
 |  
 |  CH_NOBTNS = 16
 |  
 |  CH_NOIDB = 64
 |  
 |  CH_NO_STATUS_BAR = 65536
 |  
 |  CH_QFLT = 4096
 |  
 |  CH_QFTYP_DEFAULT = 0
 |  
 |  CH_QFTYP_FUZZY = 32768
 |  
 |  CH_QFTYP_MASK = 57344
 |  
 |  CH_QFTYP_NORMAL = 8192
 |  
 |  CH_QFTYP_REGEX = 24576
 |  
 |  CH_QFTYP_SHIFT = 13
 |  
 |  CH_QFTYP_WHOLE_WORDS = 16384
 |  
 |  CH_RENAME_IS_EDIT = 262144
 |  
 |  CH_RESTORE = 131072
 |  
 |  EMPTY_CHOOSER = -2
 |  
 |  NOTHING_CHANGED = 0
 |  
 |  NO_ATTR = -4
 |  
 |  NO_SELECTION = -1
 |  
 |  SELECTION_CHANGED = 2
 |  
 |  UI_Hooks_Trampoline = <class 'ida_kernwin.Choose.UI_Hooks_Trampoline'>
 |      Proxy of C++ UI_Hooks class.

Help on class CustomIDAMemo in module ida_kernwin:

class CustomIDAMemo(View_Hooks)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Method resolution order:
 |      CustomIDAMemo
 |      View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  __init__(self)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> View_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |      A view is activated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |      Click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |      View closed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |      Cursor position changed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |      Double click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |      A view is deactivated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |      Key down event
 |      
 |      @param view: (TWidget *)
 |      @param key: (int)
 |      @param state: (::view_event_state_t)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |      The location for the view has changed (can be either the place_t, the
 |      renderer_info_t, or both.)
 |      
 |      @param view: (TWidget *)
 |      @param now: (const lochist_entry_t *)
 |      @param was: (const lochist_entry_t *)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |      The mouse moved on the view
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |      The user moved the mouse over (or out of) a node or an edge. This is only
 |      relevant in a graph view.
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |      A view's renderer has changed.
 |      
 |      @param view: (TWidget *)
 |      @param rt: (tcc_renderer_type_t)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |      A view is being created.
 |      
 |      @param view: (TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class Form in module ida_kernwin:

class Form(builtins.object)
 |  # -----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  Add(self, name, ctrl, mkattr=True)
 |      Low level function. Prefer AddControls() to this function.
 |      This function adds one control to the form.
 |      
 |      @param name: Control name
 |      @param ctrl: Control object
 |      @param mkattr: Create control name / control object as a form attribute
 |  
 |  AddControls(self, controls, mkattr=True)
 |      Adds controls from a dictionary.
 |      The dictionary key is the control name and the value is a Form.Control object
 |      @param controls: The control dictionary
 |  
 |  Close(self, close_normally)
 |      Close the form
 |      @param close_normally
 |                 1: form is closed normally as if the user pressed Enter
 |                 0: form is closed abnormally as if the user pressed Esc
 |      @return: None
 |  
 |  Compile(self)
 |      Compiles a form and returns the form object (self) and the argument list.
 |      The form object will contain object names corresponding to the form elements
 |      
 |      @return: It will raise an exception on failure. Otherwise the return value is ignored
 |  
 |  CompileEx(self, form)
 |      Low level function.
 |      Compiles (parses the form syntax and adds the control) the form string and
 |      returns the argument list to be passed the argument list to ask_form().
 |      
 |      The form controls are wrapped inside curly braces: {ControlName}.
 |      
 |      A special operator can be used to return the index of a given control by its name: {id:ControlName}.
 |      This is useful when you use the STARTITEM form keyword to set the initially focused control.
 |      (note that, technically, the index is not the same as the ID; that's because STARTITEM
 |      uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
 |      
 |      @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
 |  
 |  Compiled(self)
 |      Checks if the form has already been compiled
 |      
 |      @return: Boolean
 |  
 |  EnableField(self, ctrl, enable)
 |      Enable or disable an input field
 |      @return: False - no such control
 |  
 |  Execute(self)
 |      Displays a modal dialog containing the compiled form.
 |      @return: 1 - ok ; 0 - cancel
 |  
 |  FindControlById(self, id)
 |      Finds a control instance given its id
 |  
 |  Free(self)
 |      Frees all resources associated with a compiled form.
 |      Make sure you call this function when you finish using the form.
 |  
 |  GetControlValue(self, ctrl)
 |      Returns the control's value depending on its type
 |      @param ctrl: Form control instance
 |      @return:     - color button, radio controls: integer
 |          - file/dir input, string input and string label: string
 |          - embedded chooser control (0-based indices of selected items): integer list
 |          - for multilinetext control: textctrl_info_t
 |          - dropdown list controls: string (when editable) or index (when readonly)
 |          - None: on failure
 |  
 |  GetFocusedField(self)
 |      Get currently focused input field.
 |      @return: None if no field is selected otherwise the control ID
 |  
 |  MoveField(self, ctrl, x, y, w, h)
 |      Move/resize an input field
 |      
 |      @return: False - no such fiel
 |  
 |  Open(self)
 |      Opens a widget containing the compiled form.
 |  
 |  RefreshField(self, ctrl)
 |      Refresh a field
 |      @return: False - no such control
 |  
 |  SetControlValue(self, ctrl, value)
 |      Set the control's value depending on its type
 |      @param ctrl: Form control instance
 |      @param value
 |          - embedded chooser: a 0-base indices list to select embedded chooser items
 |          - multilinetext: a textctrl_info_t
 |          - dropdown list: an integer designating the selection index if readonly
 |                           a string designating the edit control value if not readonly
 |      @return: Boolean true on success
 |  
 |  SetFocusedField(self, ctrl)
 |      Set currently focused input field
 |      @return: False - no such control
 |  
 |  ShowField(self, ctrl, show)
 |      Show or hide an input field
 |      @return: False - no such control
 |  
 |  _AddGroup(self, Group, mkattr=True)
 |      Internal function.
 |      This function expands the group item names and creates individual group item controls
 |      
 |      @param Group: The group class (checkbox or radio group class)
 |  
 |  _ChkCompiled(self)
 |  
 |  __getitem__(self, name)
 |      Returns a control object by name
 |  
 |  __init__(self, form, controls)
 |      Contruct a Form class.
 |      This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
 |      The form control names are wrapped inside the opening and closing curly braces and the control themselves are
 |      defined and instantiated via various form controls (subclasses of Form).
 |      
 |      @param form: The form string
 |      @param controls: A dictionary containing the control name as a _key_ and control object as _value_
 |  
 |  _reset(self)
 |      Resets the Form class state variables
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  ControlToFieldTypeIdAndSize(ctrl)
 |      Converts a control object to a tuple containing the field id
 |      and the associated buffer size
 |  
 |  _ParseFormTitle(form)
 |      Parses the form's title from the form text
 |  
 |  create_string_buffer(value, size=None)
 |  
 |  fieldtype_to_ctype(tp, i64=False)
 |      Factory method returning a ctype class corresponding to the field type string
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  ButtonInput = <class 'ida_kernwin.Form.ButtonInput'>
 |      Button control.
 |      A handler along with a 'code' (numeric value) can be associated with the button.
 |      This way one handler can handle many buttons based on the button code (or in other terms id or tag)
 |  
 |  ChkGroupControl = <class 'ida_kernwin.Form.ChkGroupControl'>
 |      Checkbox group control class.
 |      It holds a set of checkbox controls
 |  
 |  ChkGroupItemControl = <class 'ida_kernwin.Form.ChkGroupItemControl'>
 |      Checkbox group item control
 |  
 |  ColorInput = <class 'ida_kernwin.Form.ColorInput'>
 |      Color button input control
 |  
 |  Control = <class 'ida_kernwin.Form.Control'>
 |  
 |  
 |  DirInput = <class 'ida_kernwin.Form.DirInput'>
 |      Directory browsing control
 |  
 |  DropdownListControl = <class 'ida_kernwin.Form.DropdownListControl'>
 |      Dropdown control
 |      This control allows manipulating a dropdown control
 |  
 |  EmbeddedChooserControl = <class 'ida_kernwin.Form.EmbeddedChooserContr...
 |      Embedded chooser control.
 |      This control links to a Chooser2 control created with the 'embedded=True'
 |  
 |  FT_ADDR = '$'
 |  
 |  FT_ASCII = 'A'
 |  
 |  FT_BIN = 'Y'
 |  
 |  FT_BUTTON = 'B'
 |  
 |  FT_CHAR = 'H'
 |  
 |  FT_CHKGRP = 'C'
 |  
 |  FT_CHKGRP2 = 'c'
 |  
 |  FT_COLOR = 'K'
 |  
 |  FT_DEC = 'D'
 |  
 |  FT_DIR = 'F'
 |  
 |  FT_DROPDOWN_LIST = 'b'
 |  
 |  FT_ECHOOSER = 'E'
 |  
 |  FT_FILE = 'f'
 |  
 |  FT_FORMCHG = '%/'
 |  
 |  FT_HEX = 'N'
 |  
 |  FT_HTML_LABEL = 'h'
 |  
 |  FT_IDENT = 'I'
 |  
 |  FT_INT64 = 'l'
 |  
 |  FT_MULTI_LINE_TEXT = 't'
 |  
 |  FT_OCT = 'O'
 |  
 |  FT_RADGRP = 'R'
 |  
 |  FT_RADGRP2 = 'r'
 |  
 |  FT_RAWHEX = 'M'
 |  
 |  FT_SEG = 'S'
 |  
 |  FT_SHEX = 'n'
 |  
 |  FT_TYPE = 'T'
 |  
 |  FT_UINT64 = 'L'
 |  
 |  FileInput = <class 'ida_kernwin.Form.FileInput'>
 |      File Open/Save input control
 |  
 |  FormChangeCb = <class 'ida_kernwin.Form.FormChangeCb'>
 |      Form change handler.
 |      This can be thought of like a dialog procedure.
 |      Everytime a form action occurs, this handler will be called along with the control id.
 |      The programmer can then call various form actions accordingly:
 |        - EnableField
 |        - ShowField
 |        - MoveField
 |        - GetFieldValue
 |        - etc...
 |      
 |      Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)
 |  
 |  GroupControl = <class 'ida_kernwin.Form.GroupControl'>
 |      Base class for group controls
 |  
 |  GroupItemControl = <class 'ida_kernwin.Form.GroupItemControl'>
 |      Base class for group control items
 |  
 |  InputControl = <class 'ida_kernwin.Form.InputControl'>
 |      Generic form input control.
 |      It could be numeric control, string control, directory/file browsing, etc...
 |  
 |  LabelControl = <class 'ida_kernwin.Form.LabelControl'>
 |      Base class for static label control
 |  
 |  MultiLineTextControl = <class 'ida_kernwin.Form.MultiLineTextControl'>
 |      Multi line text control.
 |      This class inherits from textctrl_info_t. Thus the attributes are also inherited
 |      This control allows manipulating a multilinetext control
 |  
 |  NumericArgument = <class 'ida_kernwin.Form.NumericArgument'>
 |      Argument representing various integer arguments (ushort, uint32, uint64, etc...)
 |      @param tp: One of Form.FT_XXX
 |  
 |  NumericInput = <class 'ida_kernwin.Form.NumericInput'>
 |      A composite class serving as a base numeric input control class
 |  
 |  NumericLabel = <class 'ida_kernwin.Form.NumericLabel'>
 |      Numeric label control
 |  
 |  RadGroupControl = <class 'ida_kernwin.Form.RadGroupControl'>
 |      Radiobox group control class.
 |      It holds a set of radiobox controls
 |  
 |  RadGroupItemControl = <class 'ida_kernwin.Form.RadGroupItemControl'>
 |      Radiobox group item control
 |  
 |  StringArgument = <class 'ida_kernwin.Form.StringArgument'>
 |      Argument representing a character buffer
 |  
 |  StringInput = <class 'ida_kernwin.Form.StringInput'>
 |      Base string input control class.
 |      This class also constructs a StringArgument
 |  
 |  StringLabel = <class 'ida_kernwin.Form.StringLabel'>
 |      String label control
 |  
 |  _FT_USHORT = '_US'

Help on class IDAViewWrapper in module ida_kernwin:

class IDAViewWrapper(CustomIDAMemo)
 |  Deprecated. Use View_Hooks instead.
 |  
 |  Because the lifecycle of an IDAView is not trivial to track (e.g., a user
 |  might close, then re-open the same disassembly view), this wrapper doesn't
 |  bring anything superior to the View_Hooks: quite the contrary, as the
 |  latter is much more generic (and better maps IDA's internal model.)
 |  
 |  Method resolution order:
 |      IDAViewWrapper
 |      CustomIDAMemo
 |      View_Hooks
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  Bind(self)
 |  
 |  Unbind(self)
 |  
 |  __init__(self, title)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> View_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from CustomIDAMemo:
 |  
 |  CreateGroups(self, groups_infos)
 |      Send a request to modify the graph by creating a
 |      (set of) group(s), and perform an animation.
 |      
 |      Each object in the 'groups_infos' list must be of the format:
 |      {
 |        "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
 |        "text" : <string>                    # The synthetic text for that group
 |      }
 |      
 |      @param groups_infos: A list of objects that describe those groups.
 |      @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
 |  
 |  DelNodesInfos(self, *nodes)
 |      Delete the properties for the given node(s).
 |      
 |      @param nodes: A list of node IDs
 |  
 |  DeleteGroups(self, groups, new_current=-1)
 |      Send a request to delete the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param new_current: A node to focus on after the groups have been deleted
 |      @return: True on success, False otherwise.
 |  
 |  GetCurrentRendererType(self)
 |  
 |  GetNodeInfo(self, *args)
 |      Get the properties for the given node.
 |      
 |      @param ni: A node_info_t instance
 |      @param node: The index of the node.
 |      @return: success
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  GetWidgetAsGraphViewer(self)
 |      Return the graph_viewer_t underlying this view.
 |      
 |      @return: The graph_viewer_t underlying this view, or None.
 |  
 |  Refresh(self)
 |      Refreshes the view. This causes the OnRefresh() to be called
 |  
 |  SetCurrentRendererType(self, rtype)
 |      Set the current view's renderer.
 |      
 |      @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
 |  
 |  SetGroupsVisibility(self, groups, expand, new_current=-1)
 |      Send a request to expand/collapse the specified groups in the graph,
 |      and perform an animation.
 |      
 |      @param groups: A list of group node numbers.
 |      @param expand: True to expand the group, False otherwise.
 |      @param new_current: A node to focus on after the groups have been expanded/collapsed.
 |      @return: True on success, False otherwise.
 |  
 |  SetNodeInfo(self, node_index, node_info, flags)
 |      Set the properties for the given node.
 |      
 |      Example usage (set second nodes's bg color to red):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff0000
 |        inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
 |      
 |      @param node_index: The node index.
 |      @param node_info: An idaapi.node_info_t instance.
 |      @param flags: An OR'ed value of NIF_* values.
 |  
 |  SetNodesInfos(self, values)
 |      Set the properties for the given nodes.
 |      
 |      Example usage (set first three nodes's bg color to purple):
 |        inst = ...
 |        p = idaapi.node_info_t()
 |        p.bg_color = 0x00ff00ff
 |        inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
 |      
 |      @param values: A dictionary of 'int -> node_info_t' objects.
 |  
 |  _get_cb(self, view, cb_name)
 |  
 |  _get_cb_arity(self, cb)
 |  
 |  _graph_item_tuple(self, ve)
 |  
 |  view_activated(self, view)
 |      view_activated(self, view)
 |      A view is activated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_click(self, view, ve)
 |      view_click(self, view, event)
 |      Click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_close(self, view, *args)
 |      view_close(self, view)
 |      View closed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_curpos(self, view, *args)
 |      view_curpos(self, view)
 |      Cursor position changed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_dblclick(self, view, ve)
 |      view_dblclick(self, view, event)
 |      Double click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_deactivated(self, view)
 |      view_deactivated(self, view)
 |      A view is deactivated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_keydown(self, view, key, state)
 |      view_keydown(self, view, key, state)
 |      Key down event
 |      
 |      @param view: (TWidget *)
 |      @param key: (int)
 |      @param state: (::view_event_state_t)
 |  
 |  view_loc_changed(self, view, now, was)
 |      view_loc_changed(self, view, now, was)
 |      The location for the view has changed (can be either the place_t, the
 |      renderer_info_t, or both.)
 |      
 |      @param view: (TWidget *)
 |      @param now: (const lochist_entry_t *)
 |      @param was: (const lochist_entry_t *)
 |  
 |  view_mouse_moved(self, view, ve)
 |      view_mouse_moved(self, view, event)
 |      The mouse moved on the view
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_mouse_over(self, view, ve)
 |      view_mouse_over(self, view, event)
 |      The user moved the mouse over (or out of) a node or an edge. This is only
 |      relevant in a graph view.
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_switched(self, view, rt)
 |      view_switched(self, view, rt)
 |      A view's renderer has changed.
 |      
 |      @param view: (TWidget *)
 |      @param rt: (tcc_renderer_type_t)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from CustomIDAMemo:
 |  
 |  _dummy_cb(*args)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from View_Hooks:
 |  
 |  __disown__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |      A view is being created.
 |      
 |      @param view: (TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from View_Hooks:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class PluginForm in module ida_kernwin:

class PluginForm(builtins.object)
 |  PluginForm class.
 |  
 |  This form can be used to host additional controls. Please check the PyQt example.
 |  
 |  Methods defined here:
 |  
 |  Close(self, options)
 |      Closes the form.
 |      
 |      @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
 |      
 |      @return: None
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  OnClose(self, form)
 |      Called when the plugin form is closed
 |      
 |      @return: None
 |  
 |  OnCreate(self, form)
 |      This event is called when the plugin form is created.
 |      The programmer should populate the form when this event is triggered.
 |      
 |      @return: None
 |  
 |  Show(self, caption, options=0)
 |      Creates the form if not was not created or brings to front if it was already created
 |      
 |      @param caption: The form caption
 |      @param options: One of PluginForm.WOPN_ constants
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  FormToPyQtWidget = TWidgetToPyQtWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Convert a TWidget* to a QWidget to be used by PyQt
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  FormToPySideWidget = TWidgetToPySideWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Use this method to convert a TWidget* to a QWidget to be used by PySide
 |      
 |      @param ctx: Context. Reference to a module that already imported QtWidgets module
 |  
 |  QtWidgetToTWidget(w, ctx=<module '__main__' (built-in)>)
 |      Convert a QWidget to a TWidget* to be used by IDA
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  TWidgetToPyQtWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Convert a TWidget* to a QWidget to be used by PyQt
 |      
 |      @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
 |  
 |  TWidgetToPySideWidget(tw, ctx=<module '__main__' (built-in)>)
 |      Use this method to convert a TWidget* to a QWidget to be used by PySide
 |      
 |      @param ctx: Context. Reference to a module that already imported QtWidgets module
 |  
 |  _ensure_widget_deps(ctx)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  VALID_CAPSULE_NAME = b'$valid$'
 |  
 |  WCLS_CLOSE_LATER = 8
 |  
 |  WCLS_DELETE_LATER = 8
 |  
 |  WCLS_DONT_SAVE_SIZE = 4
 |  
 |  WCLS_NO_CONTEXT = 2
 |  
 |  WCLS_SAVE = 1
 |  
 |  WOPN_CENTERED = 32
 |  
 |  WOPN_CREATE_ONLY = {}
 |  
 |  WOPN_DP_BEFORE = 2097152
 |  
 |  WOPN_DP_BOTTOM = 524288
 |  
 |  WOPN_DP_FLOATING = 8388608
 |  
 |  WOPN_DP_INSIDE = 1048576
 |  
 |  WOPN_DP_INSIDE_BEFORE = 3145728
 |  
 |  WOPN_DP_LEFT = 65536
 |  
 |  WOPN_DP_RIGHT = 262144
 |  
 |  WOPN_DP_SZHINT = 16777216
 |  
 |  WOPN_DP_TAB = 4194304
 |  
 |  WOPN_DP_TAB_BEFORE = 6291456
 |  
 |  WOPN_DP_TOP = 131072
 |  
 |  WOPN_MDI = 1
 |  
 |  WOPN_MENU = 16
 |  
 |  WOPN_ONTOP = 8
 |  
 |  WOPN_PERSIST = 64
 |  
 |  WOPN_RESTORE = 4
 |  
 |  WOPN_TAB = 2

Help on function TWidget__from_ptrval__ in module ida_kernwin:

TWidget__from_ptrval__(*args) -> 'TWidget *'
    TWidget__from_ptrval__(ptrval) -> TWidget *
    
    @param ptrval: size_t

Help on class UI_Hooks in module ida_kernwin:

class UI_Hooks(builtins.object)
 |  Proxy of C++ UI_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> UI_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  __real_database_closed = database_closed(self, *args) -> 'void'
 |      database_closed(self)
 |      The database has been closed. See also processor_t::closebase, it occurs
 |      earlier. See also ui_initing_database. This is not the same as IDA exiting. If
 |      you need to perform cleanup at the exiting time, use qatexit().
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_UI_Hooks(...)
 |      delete_UI_Hooks(self)
 |  
 |  create_desktop_widget(self, *args) -> 'PyObject *'
 |      create_desktop_widget(self, title, cfg) -> PyObject *
 |      create a widget, to be placed in the widget tree (at desktop-creation time.)
 |      
 |      @param title: (const char *)
 |      @param cfg: (const jobj_t *)
 |      @return: TWidget * the created widget, or null
 |  
 |  current_widget_changed(self, *args) -> 'void'
 |      current_widget_changed(self, widget, prev_widget)
 |      The currently-active TWidget changed.
 |      
 |      @param widget: (TWidget *)
 |      @param prev_widget: (TWidget *)
 |  
 |  database_closed = __wrapper(self, *args)
 |      database_closed(self)
 |      The database has been closed. See also processor_t::closebase, it occurs
 |      earlier. See also ui_initing_database. This is not the same as IDA exiting. If
 |      you need to perform cleanup at the exiting time, use qatexit().
 |  
 |  database_inited(self, *args) -> 'void'
 |      database_inited(self, is_new_database, idc_script)
 |      database initialization has completed. the kernel is about to run idc
 |      scripts
 |      
 |      @param is_new_database: (int)
 |      @param idc_script: (const char *) - may be nullptr
 |      @return: void See also ui_initing_database. This event is called for both new
 |               and old databases.
 |  
 |  debugger_menu_change(self, *args) -> 'void'
 |      debugger_menu_change(self, enable)
 |      debugger menu modification detected
 |      
 |      @param enable: (bool) true: debugger menu has been added, or a different
 |                     debugger has been selected false: debugger menu will be removed
 |                     (user switched to "No debugger")
 |  
 |  desktop_applied(self, *args) -> 'void'
 |      desktop_applied(self, name, from_idb, type)
 |      a desktop has been applied
 |      
 |      @param name: (const char *) the desktop name
 |      @param from_idb: (bool) the desktop was stored in the IDB (false if it comes
 |                       from the registry)
 |      @param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)
 |  
 |  destroying_plugmod(self, *args) -> 'void'
 |      destroying_plugmod(self, plugmod, entry)
 |      The plugin object is about to be destroyed
 |      
 |      @param plugmod: (const plugmod_t *)
 |      @param entry: (const plugin_t *)
 |  
 |  destroying_procmod(self, *args) -> 'void'
 |      destroying_procmod(self, procmod)
 |      The processor module is about to be destroyed
 |      
 |      @param procmod: (const procmod_t *)
 |  
 |  finish_populating_widget_popup(self, *args) -> 'void'
 |      finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
 |      IDA is about to be done populating the context menu for a widget. This is
 |      your chance to attach_action_to_popup().
 |      
 |      @param widget: (TWidget *)
 |      @param popup_handle: (TPopupMenu *)
 |      @param ctx: (const action_activation_ctx_t *)
 |  
 |  get_chooser_item_attrs(self, *args) -> 'void'
 |      get_chooser_item_attrs(self, chooser, n, attrs)
 |      get item-specific attributes for a chooser. This callback is generated only
 |      after enable_chooser_attrs()
 |      
 |      @param chooser: (const chooser_base_t *)
 |      @param n: (::size_t)
 |      @param attrs: (chooser_item_attrs_t *)
 |  
 |  get_custom_viewer_hint(self, *args) -> 'PyObject *'
 |      get_custom_viewer_hint(self, viewer, place) -> PyObject *
 |      ui wants to display a hint for a viewer (idaview or custom). Every
 |      subscriber is supposed to append the hint lines to HINT and increment
 |      IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT
 |      is possible but not recommended. If the REG_HINTS_MARKER sequence is found in
 |      the returned hints string, it will be replaced with the contents of the
 |      "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned
 |      hints string, it will be replaced with the contents of the source-level
 |      debugger-generated hints. The following keywords might appear at the beginning
 |      of the returned hints: HIGHLIGHT text
 |      where text will be highlighted CAPTION caption
 |      caption for the hint widget
 |      
 |      @param viewer: (TWidget*) viewer
 |      @param place: (place_t *) current position in the viewer
 |      @retval 0: continue collecting hints with other subscribers
 |      @retval 1: stop collecting hints
 |  
 |  get_ea_hint(self, *args) -> 'PyObject *'
 |      get_ea_hint(self, ea) -> PyObject *
 |      ui wants to display a simple hint for an address. Use this event to generate
 |      a custom hint See also more generic ui_get_item_hint
 |      
 |      @param ea: (::ea_t)
 |      @return: true if generated a hint
 |  
 |  get_item_hint(self, *args) -> 'PyObject *'
 |      get_item_hint(self, ea, max_lines) -> PyObject *
 |      ui wants to display multiline hint for an item. See also more generic
 |      ui_get_custom_viewer_hint
 |      
 |      @param ea: (ea_t) or item id like a structure or enum member
 |      @param max_lines: (int) maximal number of lines
 |      @return: true if generated a hint
 |  
 |  get_lines_rendering_info(self, *args) -> 'void'
 |      get_lines_rendering_info(self, out, widget, info)
 |      get lines rendering information
 |      
 |      @param out: (lines_rendering_output_t *)
 |      @param widget: (const TWidget *)
 |      @param info: (const lines_rendering_input_t *)
 |  
 |  get_widget_config(self, *args) -> 'PyObject *'
 |      get_widget_config(self, widget, cfg) -> PyObject *
 |      retrieve the widget configuration (it will be passed back at
 |      ui_create_desktop_widget-, and ui_set_widget_config-time)
 |      
 |      @param widget: (const TWidget *)
 |      @param cfg: (jobj_t *)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  idcstart(self, *args) -> 'void'
 |      idcstart(self)
 |      Start of IDC engine work.
 |  
 |  idcstop(self, *args) -> 'void'
 |      idcstop(self)
 |      Stop of IDC engine work.
 |  
 |  initing_database(self, *args) -> 'void'
 |      initing_database(self)
 |      database initialization has started.
 |      
 |      @return: void See also ui_database_inited. This event is called for both new and
 |               old databases.
 |  
 |  plugin_loaded(self, *args) -> 'void'
 |      plugin_loaded(self, plugin_info)
 |      The plugin was loaded in memory.
 |      
 |      @param plugin_info: (const plugin_info_t *)
 |  
 |  plugin_unloading(self, *args) -> 'void'
 |      plugin_unloading(self, plugin_info)
 |      The plugin is about to be unloaded
 |      
 |      @param plugin_info: (const plugin_info_t *)
 |  
 |  populating_widget_popup(self, *args) -> 'void'
 |      populating_widget_popup(self, widget, popup_handle, ctx=None)
 |      IDA is populating the context menu for a widget. This is your chance to
 |      attach_action_to_popup().
 |      
 |      Have a look at ui_finish_populating_widget_popup, if you want to augment the
 |      context menu with your own actions after the menu has had a chance to be
 |      properly populated by the owning component or plugin (which typically does it on
 |      ui_populating_widget_popup.)
 |      
 |      @param widget: (TWidget *)
 |      @param popup_handle: (TPopupMenu *)
 |      @param ctx: (const action_activation_ctx_t *)
 |  
 |  postprocess_action(self, *args) -> 'void'
 |      postprocess_action(self)
 |      an ida ui action has been handled
 |  
 |  preprocess_action(self, *args) -> 'int'
 |      preprocess_action(self, name) -> int
 |      ida ui is about to handle a user action.
 |      
 |      @param name: (const char *) ui action name. these names can be looked up in
 |                   ida[tg]ui.cfg
 |      @retval 0: ok
 |      @retval nonzero: a plugin has handled the command
 |  
 |  range(self, *args) -> 'void'
 |      range(self)
 |      The disassembly range has been changed ( idainfo::min_ea ...
 |      idainfo::max_ea). UI should redraw the scrollbars. See also:
 |      ui_lock_range_refresh
 |  
 |  ready_to_run(self, *args) -> 'void'
 |      ready_to_run(self)
 |      all UI elements have been initialized. Automatic plugins may hook to this
 |      event to perform their tasks.
 |  
 |  resume(self, *args) -> 'void'
 |      resume(self)
 |      Resume the suspended graphical interface. Only the text version. Interface
 |      should respond to it
 |  
 |  saved(self, *args) -> 'void'
 |      saved(self, path)
 |      The kernel has saved the database. This callback just informs the interface.
 |      Note that at the time this notification is sent, the internal paths are not
 |      updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path.
 |      
 |      @param path: (const char *) the database path
 |  
 |  saving(self, *args) -> 'void'
 |      saving(self)
 |      The kernel is flushing its buffers to the disk. The user interface should
 |      save its state. Parameters: none Returns: none
 |  
 |  screen_ea_changed(self, *args) -> 'void'
 |      screen_ea_changed(self, ea, prev_ea)
 |      The "current address" changed
 |      
 |      @param ea: (ea_t)
 |      @param prev_ea: (ea_t)
 |  
 |  set_widget_config(self, *args) -> 'void'
 |      set_widget_config(self, widget, cfg)
 |      set the widget configuration
 |      
 |      @param widget: (const TWidget *)
 |      @param cfg: (const jobj_t *)
 |  
 |  suspend(self, *args) -> 'void'
 |      suspend(self)
 |      Suspend graphical interface. Only the text version. Interface should respond
 |      to it.
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  updated_actions(self, *args) -> 'void'
 |      updated_actions(self)
 |      IDA is done updating actions.
 |  
 |  updating_actions(self, *args) -> 'void'
 |      updating_actions(self, ctx)
 |      IDA is about to update all actions. If your plugin needs to perform
 |      expensive operations more than once (e.g., once per action it registers), you
 |      should do them only once, right away.
 |      
 |      @param ctx: (action_update_ctx_t *)
 |  
 |  widget_closing(self, *args) -> 'void'
 |      widget_closing(self, widget)
 |      TWidget is about to close. This event precedes ui_widget_invisible. Use this to
 |      perform some possible actions relevant to the lifecycle of this widget
 |      
 |      @param widget: (TWidget *)
 |  
 |  widget_invisible(self, *args) -> 'void'
 |      widget_invisible(self, widget)
 |      TWidget is being closed. Use this event to destroy the window controls
 |      
 |      @param widget: (TWidget *)
 |  
 |  widget_visible(self, *args) -> 'void'
 |      widget_visible(self, widget)
 |      TWidget is displayed on the screen. Use this event to populate the window with
 |      controls
 |      
 |      @param widget: (TWidget *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class View_Hooks in module ida_kernwin:

class View_Hooks(builtins.object)
 |  Proxy of C++ View_Hooks class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _flags=0, _hkcb_flags=0x0001) -> View_Hooks
 |      
 |      @param _flags: uint32
 |      @param _hkcb_flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_View_Hooks(...)
 |      delete_View_Hooks(self)
 |  
 |  hook(self, *args) -> 'bool'
 |      hook(self) -> bool
 |  
 |  unhook(self, *args) -> 'bool'
 |      unhook(self) -> bool
 |  
 |  view_activated(self, *args) -> 'void'
 |      view_activated(self, view)
 |      A view is activated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_click(self, *args) -> 'void'
 |      view_click(self, view, event)
 |      Click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_close(self, *args) -> 'void'
 |      view_close(self, view)
 |      View closed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_created(self, *args) -> 'void'
 |      view_created(self, view)
 |      A view is being created.
 |      
 |      @param view: (TWidget *)
 |  
 |  view_curpos(self, *args) -> 'void'
 |      view_curpos(self, view)
 |      Cursor position changed
 |      
 |      @param view: (TWidget *)
 |  
 |  view_dblclick(self, *args) -> 'void'
 |      view_dblclick(self, view, event)
 |      Double click event
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_deactivated(self, *args) -> 'void'
 |      view_deactivated(self, view)
 |      A view is deactivated
 |      
 |      @param view: (TWidget *)
 |  
 |  view_keydown(self, *args) -> 'void'
 |      view_keydown(self, view, key, state)
 |      Key down event
 |      
 |      @param view: (TWidget *)
 |      @param key: (int)
 |      @param state: (::view_event_state_t)
 |  
 |  view_loc_changed(self, *args) -> 'void'
 |      view_loc_changed(self, view, now, was)
 |      The location for the view has changed (can be either the place_t, the
 |      renderer_info_t, or both.)
 |      
 |      @param view: (TWidget *)
 |      @param now: (const lochist_entry_t *)
 |      @param was: (const lochist_entry_t *)
 |  
 |  view_mouse_moved(self, *args) -> 'void'
 |      view_mouse_moved(self, view, event)
 |      The mouse moved on the view
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_mouse_over(self, *args) -> 'void'
 |      view_mouse_over(self, view, event)
 |      The user moved the mouse over (or out of) a node or an edge. This is only
 |      relevant in a graph view.
 |      
 |      @param view: (TWidget *)
 |      @param event: (const view_mouse_event_t *)
 |  
 |  view_switched(self, *args) -> 'void'
 |      view_switched(self, view, rt)
 |      A view's renderer has changed.
 |      
 |      @param view: (TWidget *)
 |      @param rt: (tcc_renderer_type_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function __call_form_callable in module ida_kernwin:

__call_form_callable(call, *args)

Help on class __qtimer_t in module ida_kernwin:

class __qtimer_t(builtins.object)
 |  Proxy of C++ __qtimer_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qtimer_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qtimer_t(...)
 |      delete___qtimer_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function _ask_addr in module ida_kernwin:

_ask_addr(*args) -> 'ea_t *'
    _ask_addr(addr, format) -> bool
    
    Parameters
    ----------
    addr: ea_t *
    format: char const *

Help on function _ask_long in module ida_kernwin:

_ask_long(*args) -> 'sval_t *'
    _ask_long(value, format) -> bool
    
    Parameters
    ----------
    value: sval_t *
    format: char const *

Help on function _ask_seg in module ida_kernwin:

_ask_seg(*args) -> 'sel_t *'
    _ask_seg(sel, format) -> bool
    
    Parameters
    ----------
    sel: sel_t *
    format: char const *

Help on function _kludge_force_declare_dirspec_t in module ida_kernwin:

_kludge_force_declare_dirspec_t(*args) -> 'void'
    _kludge_force_declare_dirspec_t(arg1)
    
    Parameters
    ----------
    arg1: dirspec_t const *

Help on function _kludge_force_declare_dirtree_t in module ida_kernwin:

_kludge_force_declare_dirtree_t(*args) -> 'void'
    _kludge_force_declare_dirtree_t(arg1)
    
    Parameters
    ----------
    arg1: dirtree_t const *

Help on class action_ctx_base_cur_sel_t in module ida_kernwin:

class action_ctx_base_cur_sel_t(builtins.object)
 |  Proxy of C++ action_ctx_base_cur_sel_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> action_ctx_base_cur_sel_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_action_ctx_base_cur_sel_t(...)
 |      delete_action_ctx_base_cur_sel_t(self)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _from
 |      _from
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      to

Help on class action_ctx_base_source_t in module ida_kernwin:

class action_ctx_base_source_t(builtins.object)
 |  Proxy of C++ action_ctx_base_source_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> action_ctx_base_source_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_action_ctx_base_source_t(...)
 |      delete_action_ctx_base_source_t(self)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  chooser
 |      chooser
 |  
 |  thisown
 |      The membership flag

Help on class action_ctx_base_t in module ida_kernwin:

class action_ctx_base_t(builtins.object)
 |  Proxy of C++ action_ctx_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> action_ctx_base_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_action_ctx_base_t(...)
 |      delete_action_ctx_base_t(self)
 |  
 |  has_flag(self, *args) -> 'bool'
 |      has_flag(self, flag) -> bool
 |      Check if the given flag is set.
 |      
 |      @param flag: (C++: uint32)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |      Invalidate all context info.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  action
 |      action
 |  
 |  chooser_selection
 |      chooser_selection
 |  
 |  cur_ea
 |      cur_ea
 |  
 |  cur_enum
 |      cur_enum
 |  
 |  cur_enum_member
 |      cur_enum_member
 |  
 |  cur_extracted_ea
 |      cur_value
 |  
 |  cur_fchunk
 |      cur_fchunk
 |  
 |  cur_flags
 |      cur_flags
 |  
 |  cur_func
 |      cur_func
 |  
 |  cur_seg
 |      cur_seg
 |  
 |  cur_sel
 |      cur_sel
 |  
 |  cur_strmem
 |      cur_strmem
 |  
 |  cur_struc
 |      cur_struc
 |  
 |  cur_value
 |      cur_value
 |  
 |  dirtree_selection
 |      dirtree_selection
 |  
 |  focus
 |      focus
 |  
 |  form
 |  
 |  form_title
 |  
 |  form_type
 |  
 |  graph_selection
 |      graph_selection
 |  
 |  regname
 |      regname
 |  
 |  source
 |      source
 |  
 |  thisown
 |      The membership flag
 |  
 |  widget
 |      widget
 |  
 |  widget_title
 |      widget_title
 |  
 |  widget_type
 |      widget_type

Help on class action_desc_t in module ida_kernwin:

class action_desc_t(builtins.object)
 |  Proxy of C++ action_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t
 |      
 |      @param name: char const *
 |      @param label: char const *
 |      @param handler: PyObject *
 |      @param shortcut: char const *
 |      @param tooltip: char const *
 |      @param icon: int
 |      @param flags: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_action_desc_t(...)
 |      delete_action_desc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      cb
 |  
 |  flags
 |      flags
 |  
 |  icon
 |      icon
 |  
 |  label
 |      label
 |  
 |  name
 |      name
 |  
 |  owner
 |      owner
 |  
 |  shortcut
 |      shortcut
 |  
 |  thisown
 |      The membership flag
 |  
 |  tooltip
 |      tooltip

Help on class action_handler_t in module ida_kernwin:

class action_handler_t(builtins.object)
 |  # ----------------------------------------------------------------------
 |  
 |  Methods defined here:
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  activate(self, ctx)
 |      Activate an action. This function implements the core behavior of an action. It
 |      is called when the action is triggered, from a menu, from a popup menu, from the
 |      toolbar, or programmatically.
 |      
 |      @return: non-zero: all IDA windows will be refreshed
 |  
 |  update(self, ctx)
 |      Update an action. This is called when the context of the UI changed, and we need
 |      to let the action update some of its properties if needed (label, icon, ...)
 |      
 |      In addition, this lets IDA know whether the action is enabled, and when it
 |      should be queried for availability again.
 |      
 |      Note: This callback is not meant to change anything in the application's state,
 |      except by calling one (or many) of the "update_action_*()" functions on this
 |      very action.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function activate_widget in module ida_kernwin:

activate_widget(*args) -> 'void'
    activate_widget(widget, take_focus)
    Activate widget (only gui version) (ui_activate_widget).
    
    @param widget: (C++: TWidget *) existing widget to display
    @param take_focus: (C++: bool) give focus to given widget

Help on function add_hotkey in module ida_kernwin:

add_hotkey(*args) -> 'PyObject *'
    add_hotkey(hotkey, pyfunc) -> PyCapsule
    Associates a function call with a hotkey.
    Callable pyfunc will be called each time the hotkey is pressed
    
    @param hotkey: The hotkey
    @param pyfunc: Callable
    
    @return: Context object on success or None on failure.

Help on function add_idc_hotkey in module ida_kernwin:

add_idc_hotkey(*args) -> 'int'
    add_idc_hotkey(hotkey, idcfunc) -> int
    Add hotkey for IDC function (ui_add_idckey).
    
    @param hotkey: (C++: const char *) hotkey name
    @param idcfunc: (C++: const char *) IDC function name
    @return: IDC hotkey error codes

Help on function add_spaces in module ida_kernwin:

add_spaces(*args) -> 'PyObject *'
    add_spaces(s, len) -> str
    Add space characters to the colored string so that its length will be at least
    'len' characters. Don't trim the string if it is longer than 'len'.
    
    @param str: (C++: char *) pointer to colored string to modify (may not be nullptr)
    @param len: (C++: ssize_t) the desired length of the string
    @return: pointer to the end of input string

Help on function addon_count in module ida_kernwin:

addon_count(*args) -> 'int'
    addon_count() -> int
    Get number of installed addons.

Help on class addon_info_t in module ida_kernwin:

class addon_info_t(builtins.object)
 |  Proxy of C++ addon_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> addon_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_addon_info_t(...)
 |      delete_addon_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      cb
 |  
 |  custom_data
 |      custom_data
 |  
 |  custom_size
 |      custom_size
 |  
 |  freeform
 |      freeform
 |  
 |  id
 |      id
 |  
 |  name
 |      name
 |  
 |  producer
 |      producer
 |  
 |  thisown
 |      The membership flag
 |  
 |  url
 |      url
 |  
 |  version
 |      version

Help on function analyzer_options in module ida_kernwin:

analyzer_options(*args) -> 'void'
    analyzer_options()
    Allow the user to set analyzer options. (show a dialog box)
    (ui_analyzer_options)

Help on function ask_addr in module ida_kernwin:

ask_addr(defval, format)
    Output a formatted string to the output window (msg) preprended with "**DATABASE
    IS CORRUPTED: " Display a dialog box and wait for the user to input an address
    (ui_ask_addr).
    
    @retval 0: the user pressed Esc.
    @retval 1: ok, the user entered an address

Help on function ask_buttons in module ida_kernwin:

ask_buttons(*args) -> 'int'
    ask_buttons(Yes, No, Cancel, deflt, format) -> int
    Display a dialog box and get choice from maximum three possibilities
    (ui_ask_buttons).
    @note: for all buttons:
    * use "" or nullptr to take the default name for the button.
    * prepend "HIDECANCEL\n" in 'format' to hide the Cancel button
    
    @param Yes: (C++: const char *) text for the first button
    @param No: (C++: const char *) text for the second button
    @param Cancel: (C++: const char *) text for the third button
    @param deflt: (C++: int) default choice: one of Button IDs
    @param format: (C++: const char *) printf-style format string for question. It may have some
                   prefixes, see below.
    @return: one of Button IDs specifying the selected button (Esc key returns
             Cancel/3rd button value)

Help on function ask_file in module ida_kernwin:

ask_file(*args) -> 'char *'
    ask_file(for_saving, defval, format) -> char *
    
    @param for_saving: bool
    @param defval: char const *
    @param format: char const *

Help on function ask_for_feedback in module ida_kernwin:

ask_for_feedback(*args) -> 'void'
    ask_for_feedback(format)
    Show a message box asking to send the input file to \link{mailto:support@hex-
    rays.com,support@hex-rays.com}.
    
    @param format: (C++: const char *) the reason why the input file is bad

Help on function ask_form in module ida_kernwin:

ask_form(*args)
    Display a dialog box and wait for the user. If the form contains the "BUTTON NO
    <title>" keyword, then the return values are the same as in the ask_yn()
    function (Button IDs)
    
    @retval 0: no memory to display or form syntax error (a warning is displayed in
               this case). the user pressed the 'No' button (if the form has it) or
               the user cancelled the dialog otherwise. all variables retain their
               original values.
    @retval 1: ok, all input fields are filled and validated.
    @retval -1: the form has the 'No' button and the user cancelled the dialog

Help on function ask_ident in module ida_kernwin:

ask_ident(defval, format)
    Display a dialog box and wait for the user to input an identifier. If the user
    enters a non-valid identifier, this function displays a warning and allows the
    user to correct it.
    
    @return: false if the user cancelled the dialog, otherwise returns true.

Help on function ask_long in module ida_kernwin:

ask_long(defval, format)
    Display a dialog box and wait for the user to input an number (ui_ask_long). The
    number is represented in C-style. This function allows to enter any IDC
    expression and properly calculates it.
    
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered a valid number.

Help on function ask_seg in module ida_kernwin:

ask_seg(defval, format)
    Display a dialog box and wait for the user to input an segment name
    (ui_ask_seg). This function allows to enter segment register names, segment base
    paragraphs, segment names to denote a segment.
    
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered an segment name

Help on function ask_str in module ida_kernwin:

ask_str(*args) -> 'PyObject *'
    ask_str(defval, hist, prompt) -> str or None
    Asks for a long text
    
    @param defval: The default value
    @param hist: history id
    @param prompt: The prompt value
    @return: None or the entered string

Help on function ask_text in module ida_kernwin:

ask_text(*args) -> 'PyObject *'
    ask_text(max_size, defval, prompt) -> str
    Asks for a long text
    
    @param max_size: Maximum text length, 0 for unlimited
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string

Help on function ask_yn in module ida_kernwin:

ask_yn(*args) -> 'int'
    ask_yn(deflt, format) -> int
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    @param deflt: (C++: int) default choice: one of Button IDs
    @param format: (C++: const char *) The question in printf() style format
    @return: the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.

Help on function attach_action_to_menu in module ida_kernwin:

attach_action_to_menu(*args) -> 'bool'
    attach_action_to_menu(menupath, name, flags=0) -> bool
    Attach a previously-registered action to the menu (ui_attach_action_to_menu).
    @note: You should not change top level menu, or the Edit,Plugins submenus If you
           want to modify the debugger menu, do it at the ui_debugger_menu_change
           event (ida might destroy your menu item if you do it elsewhere).
    
    @param menupath: (C++: const char *) path to the menu item after or before which the insertion will
                     take place.
    * Example: Debug/StartProcess
    * Whitespace, punctuation are ignored.
    * It is allowed to specify only the prefix of the menu item.
    * Comparison is case insensitive.
    * menupath may start with the following prefixes:
    * [S] - modify the main menu of the structure window
    * [E] - modify the main menu of the enum window
    @param name: (C++: const char *) the action name
    @param flags: (C++: int) a combination of Set menu flags, to determine menu item position
    @return: success

Help on function attach_action_to_popup in module ida_kernwin:

attach_action_to_popup(*args) -> 'bool'
    attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
    Insert a previously-registered action into the widget's popup menu
    (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and
    'permanent'.
    
    @param widget: (C++: TWidget *) target widget
    @param popup_handle: (C++: TPopupMenu *) target popup menu
    * if non-nullptr, the action is added to this popup menu invocation (i.e.,
    'single-shot')
    * if nullptr, the action is added to a list of actions that should always be
    present in context menus for this widget (i.e., 'permanent'.)
    @param name: (C++: const char *) action name
    @param popuppath: (C++: const char *) can be nullptr
    @param flags: (C++: int) a combination of SETMENU_ flags (see Set menu flags)
    @return: success

Help on function attach_action_to_toolbar in module ida_kernwin:

attach_action_to_toolbar(*args) -> 'bool'
    attach_action_to_toolbar(toolbar_name, name) -> bool
    Attach an action to an existing toolbar (ui_attach_action_to_toolbar).
    
    @param toolbar_name: (C++: const char *) the name of the toolbar
    @param name: (C++: const char *) the action name
    @return: success

Help on function attach_dynamic_action_to_popup in module ida_kernwin:

attach_dynamic_action_to_popup(*args) -> 'bool'
    attach_dynamic_action_to_popup(unused, popup_handle, desc, popuppath=None, flags=0) -> bool
    Create & insert an action into the widget's popup menu
    (ui_attach_dynamic_action_to_popup).
    @note: action_desc_t::handler for 'desc' must be instantiated using 'new', as it
           will be 'delete'd when the action is unregistered.
    
    @param unused: (C++: TWidget *) deprecated; should be nullptr
    @param popup_handle: (C++: TPopupMenu *) target popup
    @param desc: (C++: const action_desc_t &) created with DYNACTION_DESC_LITERAL
    @param popuppath: (C++: const char *) can be nullptr
    @param flags: (C++: int) a combination of SETMENU_ constants (see Set menu flags)
    @return: success

Help on function banner in module ida_kernwin:

banner(*args) -> 'bool'
    banner(wait) -> bool
    Show a banner dialog box (ui_banner).
    
    @param wait: (C++: int) time to wait before closing
    @retval 1: ok
    @retval 0: esc was pressed

Help on function beep in module ida_kernwin:

beep(*args) -> 'void'
    beep(beep_type=beep_default)
    Issue a beeping sound (ui_beep).
    
    @param beep_type: (C++: beep_t)

Help on function call_nav_colorizer in module ida_kernwin:

call_nav_colorizer(*args) -> 'uint32'
    call_nav_colorizer(dict, ea, nbytes) -> uint32
    To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().
    
    @param dict: PyObject *
    @param ea: ea_t
    @param nbytes: asize_t

Help on function cancel_exec_request in module ida_kernwin:

cancel_exec_request(*args) -> 'bool'
    cancel_exec_request(req_id) -> bool
    Try to cancel an asynchronous exec request (ui_cancel_exec_request).
    
    @param req_id: (C++: int) request id
    @retval true: successfully canceled
    @retval false: request has already been processed.

Help on function cancel_thread_exec_requests in module ida_kernwin:

cancel_thread_exec_requests(*args) -> 'int'
    cancel_thread_exec_requests(tid) -> int
    Try to cancel asynchronous exec requests created by the specified thread.
    
    @param tid: (C++: qthread_t) thread id
    @return: number of the canceled requests.

Help on function choose_activate in module ida_kernwin:

choose_activate(*args) -> 'void'
    choose_activate(_self)
    
    @param self: PyObject *

Help on function choose_choose in module ida_kernwin:

choose_choose(*args) -> 'PyObject *'
    choose_choose(_self) -> PyObject *
    
    @param self: PyObject *

Help on function choose_close in module ida_kernwin:

choose_close(*args) -> 'void'
    choose_close(_self)
    
    @param self: PyObject *

Help on function choose_create_embedded_chobj in module ida_kernwin:

choose_create_embedded_chobj(*args) -> 'PyObject *'
    choose_create_embedded_chobj(_self) -> PyObject *
    
    @param self: PyObject *

Help on function choose_entry in module ida_kernwin:

choose_entry(*args) -> 'ea_t'
    choose_entry(title) -> ea_t
    Choose an entry point (ui_choose, chtype_entry).
    
    @param title: (C++: const char *) chooser title
    @return: ea of selected entry point, BADADDR if none selected

Help on function choose_enum in module ida_kernwin:

choose_enum(*args) -> 'enum_t'
    choose_enum(title, default_id) -> enum_t
    Choose an enum (ui_choose, chtype_enum).
    
    @param title: (C++: const char *) chooser title
    @param default_id: (C++: enum_t) id of enum to select by default
    @return: enum id of selected enum, BADNODE if none selected

Help on function choose_enum_by_value in module ida_kernwin:

choose_enum_by_value(*args) -> 'uchar *'
    choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
    Choose an enum, restricted by value & size (ui_choose,
    chtype_enum_by_value_and_size). If the given value cannot be found initially,
    this function will ask if the user would like to import a standard enum.
    
    @param title: (C++: const char *) chooser title
    @param default_id: (C++: enum_t) id of enum to select by default
    @param value: (C++: uint64) value to search for
    @param nbytes: (C++: int) size of value
    @return: enum id of selected (or imported) enum, BADNODE if none was found

Help on function choose_find in module ida_kernwin:

choose_find(*args) -> 'PyObject *'
    choose_find(title) -> MyChoose or None
    
    @param title: char const *

Help on function choose_func in module ida_kernwin:

choose_func(*args) -> 'func_t *'
    choose_func(title, default_ea) -> func_t *
    Choose a function (ui_choose, chtype_func).
    
    @param title: (C++: const char *) chooser title
    @param default_ea: (C++: ea_t) ea of function to select by default
    @return: pointer to function that was selected, nullptr if none selected

Help on function choose_get_widget in module ida_kernwin:

choose_get_widget(*args) -> 'TWidget *'
    choose_get_widget(_self) -> TWidget *
    
    @param self: PyObject *

Help on function choose_idasgn in module ida_kernwin:

choose_idasgn(*args) -> 'PyObject *'
    choose_idasgn() -> PyObject *
    Opens the signature chooser
    
    @return: None or the selected signature name

Help on function choose_name in module ida_kernwin:

choose_name(*args) -> 'ea_t'
    choose_name(title) -> ea_t
    Choose a name (ui_choose, chtype_name).
    
    @param title: (C++: const char *) chooser title
    @return: ea of selected name, BADADDR if none selected

Help on function choose_refresh in module ida_kernwin:

choose_refresh(*args) -> 'void'
    choose_refresh(_self)
    
    @param self: PyObject *

Help on function choose_segm in module ida_kernwin:

choose_segm(*args) -> 'segment_t *'
    choose_segm(title, default_ea) -> segment_t *
    Choose a segment (ui_choose, chtype_segm).
    
    @param title: (C++: const char *) chooser title
    @param default_ea: (C++: ea_t) ea of segment to select by default
    @return: pointer to segment that was selected, nullptr if none selected

Help on function choose_srcp in module ida_kernwin:

choose_srcp(*args) -> 'sreg_range_t *'
    choose_srcp(title) -> sreg_range_t *
    Choose a segment register change point (ui_choose, chtype_srcp).
    
    @param title: (C++: const char *) chooser title
    @return: pointer to segment register range of selected change point, nullptr if
             none selected

Help on function choose_stkvar_xref in module ida_kernwin:

choose_stkvar_xref(*args) -> 'ea_t'
    choose_stkvar_xref(pfn, mptr) -> ea_t
    Choose an xref to a stack variable (ui_choose, chtype_name).
    
    @param pfn: (C++: func_t *) function
    @param mptr: (C++: member_t *) variable
    @return: ea of the selected xref, BADADDR if none selected

Help on function choose_struc in module ida_kernwin:

choose_struc(*args) -> 'struc_t *'
    choose_struc(title) -> struc_t *
    Choose a structure (ui_choose, chtype_segm).
    
    @param title: (C++: const char *) chooser title;
    @return: pointer to structure that was selected, nullptr if none selected

Help on function choose_til in module ida_kernwin:

choose_til(*args) -> 'qstring *'
    choose_til() -> str
    Choose a type library (ui_choose, chtype_idatil).
    
    @retval true: 'buf' was filled with the name of the selected til
    @retval false: otherwise

Help on function choose_xref in module ida_kernwin:

choose_xref(*args) -> 'ea_t'
    choose_xref(to) -> ea_t
    Choose an xref to an address (ui_choose, chtype_xref).
    
    @param to: (C++: ea_t) referenced address
    @return: ea of selected xref, BADADDR if none selected

Help on class chooser_base_t in module ida_kernwin:

class chooser_base_t(builtins.object)
 |  Proxy of C++ chooser_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ask_item_attrs(self, *args) -> 'bool'
 |      ask_item_attrs(self) -> bool
 |      should chooser generate ui_get_chooser_item_attrs events?
 |  
 |  can_del(self, *args) -> 'bool'
 |      can_del(self) -> bool
 |  
 |  can_edit(self, *args) -> 'bool'
 |      can_edit(self) -> bool
 |  
 |  can_filter(self, *args) -> 'bool'
 |      can_filter(self) -> bool
 |  
 |  can_ins(self, *args) -> 'bool'
 |      can_ins(self) -> bool
 |      is an operation allowed?
 |  
 |  can_refresh(self, *args) -> 'bool'
 |      can_refresh(self) -> bool
 |  
 |  can_sort(self, *args) -> 'bool'
 |      can_sort(self) -> bool
 |  
 |  get_builtin_number(self, *args) -> 'uint'
 |      get_builtin_number(self) -> uint
 |      get number of the built-in chooser
 |  
 |  get_count(self, *args) -> 'size_t'
 |      get_count(self) -> size_t
 |      get the number of elements in the chooser
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self, arg2) -> ea_t
 |      get an address of an element. Used to set breakpoint in any chooser which
 |      implements this callback.
 |      
 |      @param arg2: size_t
 |      @return: the effective address, BADADDR if the element has no address
 |  
 |  get_quick_filter_initial_mode(self, *args) -> 'int'
 |      get_quick_filter_initial_mode(self) -> int
 |  
 |  get_row(self, *args) -> 'PyObject *'
 |      get_row(self, n) -> ([str, ...], int, chooser_item_attrs_t)
 |      get a description of an element.
 |      
 |      @param n: (C++: size_t) element number (0..get_count()-1)
 |  
 |  has_diff_capability(self, *args) -> 'bool'
 |      has_diff_capability(self) -> bool
 |  
 |  has_dirtree(self, *args) -> 'bool'
 |      has_dirtree(self) -> bool
 |  
 |  is_dirtree_persisted(self, *args) -> 'bool'
 |      is_dirtree_persisted(self) -> bool
 |  
 |  is_force_default(self, *args) -> 'bool'
 |      is_force_default(self) -> bool
 |      should selection of the already opened non-modal chooser be changed?
 |  
 |  is_modal(self, *args) -> 'bool'
 |      is_modal(self) -> bool
 |      is choose modal?
 |  
 |  is_multi(self, *args) -> 'bool'
 |      is_multi(self) -> bool
 |      is multi-selection allowed?
 |  
 |  is_noidb(self, *args) -> 'bool'
 |      is_noidb(self) -> bool
 |      can use the chooser before opening the database?
 |  
 |  is_quick_filter_visible_initially(self, *args) -> 'bool'
 |      is_quick_filter_visible_initially(self) -> bool
 |  
 |  is_same(self, *args) -> 'bool'
 |      is_same(self, other) -> bool
 |      do the current and the given objects hold the same data?
 |      
 |      @param other: (C++: const chooser_base_t *) chooser_base_t const *
 |  
 |  is_status_bar_hidden(self, *args) -> 'bool'
 |      is_status_bar_hidden(self) -> bool
 |  
 |  popup_allowed(self, *args) -> 'bool'
 |      popup_allowed(self, stdact_idx) -> bool
 |      is a standard action allowed?
 |      
 |      @param stdact_idx: (C++: int)
 |  
 |  should_rename_trigger_edit(self, *args) -> 'bool'
 |      should_rename_trigger_edit(self) -> bool
 |  
 |  should_restore_geometry(self, *args) -> 'bool'
 |      should_restore_geometry(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  columns
 |      columns
 |  
 |  deflt_col
 |      deflt_col
 |  
 |  header
 |      header
 |  
 |  height
 |      height
 |  
 |  icon
 |      icon
 |  
 |  popup_names
 |      popup_names
 |  
 |  thisown
 |      The membership flag
 |  
 |  title
 |      title
 |  
 |  width
 |      width
 |  
 |  widths
 |      widths
 |  
 |  x0
 |      x0
 |  
 |  x1
 |      x1
 |  
 |  y0
 |      y0
 |  
 |  y1
 |      y1
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  NSTDPOPUPS = 4
 |  
 |  POPUP_DEL = 1
 |  
 |  POPUP_EDIT = 2
 |  
 |  POPUP_INS = 0
 |  
 |  POPUP_REFRESH = 3

Help on class chooser_item_attrs_t in module ida_kernwin:

class chooser_item_attrs_t(builtins.object)
 |  Proxy of C++ chooser_item_attrs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> chooser_item_attrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chooser_item_attrs_t(...)
 |      delete_chooser_item_attrs_t(self)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  color
 |      color
 |  
 |  flags
 |      flags
 |  
 |  thisown
 |      The membership flag

Help on class chooser_stdact_desc_t in module ida_kernwin:

class chooser_stdact_desc_t(builtins.object)
 |  Proxy of C++ chooser_stdact_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _label=None, _tooltip=None, _icon=-1) -> chooser_stdact_desc_t
 |      
 |      @param _label: char const *
 |      @param _tooltip: char const *
 |      @param _icon: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_chooser_stdact_desc_t(...)
 |      delete_chooser_stdact_desc_t(self)
 |  
 |  ucb(self, *args) -> 'action_state_t'
 |      ucb(self, arg0) -> action_state_t
 |      the update callback, see action_handler_t::update() When the update callback is
 |      called from the chooser UI engine, it can be sure that ctx.source.chooser is a
 |      valid pointer to chooser_base_t and that there are selected items for the Delete
 |      and Edit actions.
 |      
 |      @param arg0: action_update_ctx_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  icon
 |      icon
 |  
 |  label
 |      label
 |  
 |  thisown
 |      The membership flag
 |  
 |  tooltip
 |      tooltip
 |  
 |  version
 |      version

Help on function clear_refresh_request in module ida_kernwin:

clear_refresh_request(*args) -> 'void'
    clear_refresh_request(mask)
    
    @param mask: uint64

Help on class cli_t in module ida_kernwin:

class cli_t(ida_idaapi.pyidc_opaque_object_t)
 |  cli_t wrapper class.
 |  
 |  This class allows you to implement your own command line interface handlers.
 |  
 |  Method resolution order:
 |      cli_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  OnCompleteLine(self, prefix, n, line, prefix_start)
 |      The user pressed Tab. Find a completion number N for prefix PREFIX
 |      
 |      This callback is optional.
 |      
 |      @param prefix: Line prefix at prefix_start (string)
 |      @param n: completion number (int)
 |      @param line: the current line (string)
 |      @param prefix_start: the index where PREFIX starts in LINE (int)
 |      
 |      @return: None if no completion could be generated otherwise a String with the completion suggestion
 |  
 |  OnExecuteLine(self, line)
 |      The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
 |      
 |      This callback is mandatory.
 |      
 |      @param line: typed line(s)
 |      @return: Boolean: True-executed line, False-ask for more lines
 |  
 |  OnKeydown(self, line, x, sellen, vkey, shift)
 |      A keyboard key has been pressed
 |      This is a generic callback and the CLI is free to do whatever it wants.
 |      
 |      This callback is optional.
 |      
 |      @param line: current input line
 |      @param x: current x coordinate of the cursor
 |      @param sellen: current selection length (usually 0)
 |      @param vkey: virtual key code. if the key has been handled, it should be returned as zero
 |      @param shift: shift state
 |      
 |      @return:     None - Nothing was changed
 |          tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
 |          It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
 |  
 |  __del__(self)
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  register(self, flags=0, sname=None, lname=None, hint=None)
 |      Registers the CLI.
 |      
 |      @param flags: Feature bits. No bits are defined yet, must be 0
 |      @param sname: Short name (displayed on the button)
 |      @param lname: Long name (displayed in the menu)
 |      @param hint: Hint for the input line
 |      
 |      @return: Boolean: True-Success, False-Failed
 |  
 |  unregister(self)
 |      Unregisters the CLI (if it was registered)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function close_chooser in module ida_kernwin:

close_chooser(*args) -> 'bool'
    close_chooser(title) -> bool
    Close a non-modal chooser (ui_close_chooser).
    
    @param title: (C++: const char *) window title of chooser to close
    @return: success

Help on function close_widget in module ida_kernwin:

close_widget(*args) -> 'void'
    close_widget(widget, options)
    Close widget (ui_close_widget, only gui version).
    
    @param widget: (C++: TWidget *) pointer to the widget to close
    @param options: (C++: int) Form close flags

Help on function clr_cancelled in module ida_kernwin:

clr_cancelled(*args) -> 'void'
    clr_cancelled()
    Clear "Cancelled" flag (ui_clr_cancelled)

Help on function create_code_viewer in module ida_kernwin:

create_code_viewer(*args) -> 'TWidget *'
    create_code_viewer(custview, flags=0, parent=None) -> TWidget *
    Create a code viewer (ui_create_code_viewer). A code viewer contains on the left
    side a widget representing the line numbers, and on the right side, the child
    widget passed as parameter. It will inherit its title from the child widget.
    
    @param custview: (C++: TWidget *) the custom view to be added
    @param flags: (C++: int) Code viewer flags
    @param parent: (C++: TWidget *) widget to contain the new code viewer

Help on function create_empty_widget in module ida_kernwin:

create_empty_widget(*args) -> 'TWidget *'
    create_empty_widget(title, icon=-1) -> TWidget *
    Create an empty widget, serving as a container for custom user widgets
    
    @param title: (C++: const char *) char const *
    @param icon: (C++: int)

Help on function create_menu in module ida_kernwin:

create_menu(*args) -> 'bool'
    create_menu(name, label, menupath=None) -> bool
    Create a menu with the given name, label and optional position, either in the
    menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information
    about where the menu should be positioned. First, IDA will try and resolve the
    corresponding menu by its name. If such an existing menu is found and is present
    in the menubar, then the new menu will be inserted in the menubar before it.
    Otherwise, IDA will try to resolve 'menupath' as it would for
    attach_action_to_menu() and, if found, add the new menu like so:
    // The new 'My menu' submenu will appear in the 'Comments' submenu
    // before the 'Enter comment..." command
    create_menu("(...)", "My menu", "Edit/Comments/Enter comment...");
    or
    // The new 'My menu' submenu will appear at the end of the
    // 'Comments' submenu.
    create_menu("(...)", "My menu", "Edit/Comments/");
    If the above fails, the new menu will be appended to the menubar.
    
    @param name: (C++: const char *) name of menu (must be unique)
    @param label: (C++: const char *) label of menu
    @param menupath: (C++: const char *) where should the menu be inserted
    @return: success

Help on function create_toolbar in module ida_kernwin:

create_toolbar(*args) -> 'bool'
    create_toolbar(name, label, before=None, flags=0) -> bool
    Create a toolbar with the given name, label and optional position
    
    @param name: (C++: const char *) name of toolbar (must be unique)
    @param label: (C++: const char *) label of toolbar
    @param before: (C++: const char *) if non-nullptr, the toolbar before which the new toolbar will be
                   inserted
    @param flags: (C++: int) a combination of create toolbar flags, to determine toolbar
                  position
    @return: success

Help on function custom_viewer_jump in module ida_kernwin:

custom_viewer_jump(*args) -> 'bool'
    custom_viewer_jump(v, loc, flags=0) -> bool
    Append 'loc' to the viewer's history, and cause the viewer to display it.
    
    @param v: (C++: TWidget *) (TWidget *)
    @param loc: (C++: const lochist_entry_t &) (const lochist_entry_t &)
    @param flags: (C++: uint32) (uint32) or'ed combination of CVNF_* values
    @return: success

Help on function del_hotkey in module ida_kernwin:

del_hotkey(*args) -> 'bool'
    del_hotkey(pyctx) -> bool
    Deletes a previously registered function hotkey
    
    @param ctx: Hotkey context previously returned by add_hotkey()
    
    @return: Boolean.

Help on function del_idc_hotkey in module ida_kernwin:

del_idc_hotkey(*args) -> 'bool'
    del_idc_hotkey(hotkey) -> bool
    
    @param hotkey: char const *

Help on function delete_menu in module ida_kernwin:

delete_menu(*args) -> 'bool'
    delete_menu(name) -> bool
    Delete an existing menu
    
    @param name: (C++: const char *) name of menu
    @return: success

Help on function delete_toolbar in module ida_kernwin:

delete_toolbar(*args) -> 'bool'
    delete_toolbar(name) -> bool
    Delete an existing toolbar
    
    @param name: (C++: const char *) name of toolbar
    @return: success

Help on function detach_action_from_menu in module ida_kernwin:

detach_action_from_menu(*args) -> 'bool'
    detach_action_from_menu(menupath, name) -> bool
    Detach an action from the menu (ui_detach_action_from_menu).
    
    @param menupath: (C++: const char *) path to the menu item
    @param name: (C++: const char *) the action name
    @return: success

Help on function detach_action_from_popup in module ida_kernwin:

detach_action_from_popup(*args) -> 'bool'
    detach_action_from_popup(widget, name) -> bool
    Remove a previously-registered action, from the list of 'permanent' context menu
    actions for this widget (ui_detach_action_from_popup). This only makes sense if
    the action has been added to 'widget's list of permanent popup actions by
    calling attach_action_to_popup in 'permanent' mode.
    
    @param widget: (C++: TWidget *) target widget
    @param name: (C++: const char *) action name

Help on function detach_action_from_toolbar in module ida_kernwin:

detach_action_from_toolbar(*args) -> 'bool'
    detach_action_from_toolbar(toolbar_name, name) -> bool
    Detach an action from the toolbar (ui_detach_action_from_toolbar).
    
    @param toolbar_name: (C++: const char *) the name of the toolbar
    @param name: (C++: const char *) the action name
    @return: success

Help on class disabled_script_timeout_t in module ida_kernwin:

class disabled_script_timeout_t(builtins.object)
 |  Methods defined here:
 |  
 |  __enter__(self)
 |  
 |  __exit__(self, type, value, tb)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class disasm_line_t in module ida_kernwin:

class disasm_line_t(builtins.object)
 |  Proxy of C++ disasm_line_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> disasm_line_t
 |      __init__(self, other) -> disasm_line_t
 |      
 |      @param other: disasm_line_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_disasm_line_t(...)
 |      delete_disasm_line_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      at
 |  
 |  bg_color
 |      bg_color
 |  
 |  is_default
 |      is_default
 |  
 |  line
 |      line
 |  
 |  prefix_color
 |      prefix_color
 |  
 |  thisown
 |      The membership flag

Help on class disasm_text_t in module ida_kernwin:

class disasm_text_t(builtins.object)
 |  Proxy of C++ qvector< disasm_line_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'disasm_line_t const &'
 |      __getitem__(self, i) -> disasm_line_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> disasm_text_t
 |      __init__(self, x) -> disasm_text_t
 |      
 |      @param x: qvector< disasm_line_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: disasm_line_t const &
 |  
 |  __swig_destroy__ = delete_disasm_text_t(...)
 |      delete_disasm_text_t(self)
 |  
 |  at(self, *args) -> 'disasm_line_t const &'
 |      at(self, _idx) -> disasm_line_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< disasm_line_t >::const_iterator'
 |      begin(self) -> disasm_line_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< disasm_line_t >::const_iterator'
 |      end(self) -> disasm_line_t
 |  
 |  erase(self, *args) -> 'qvector< disasm_line_t >::iterator'
 |      erase(self, it) -> disasm_line_t
 |      
 |      @param it: qvector< disasm_line_t >::iterator
 |      
 |      erase(self, first, last) -> disasm_line_t
 |      
 |      @param first: qvector< disasm_line_t >::iterator
 |      @param last: qvector< disasm_line_t >::iterator
 |  
 |  extract(self, *args) -> 'disasm_line_t *'
 |      extract(self) -> disasm_line_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=disasm_line_t())
 |      
 |      @param x: disasm_line_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: disasm_line_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< disasm_line_t >::iterator'
 |      insert(self, it, x) -> disasm_line_t
 |      
 |      @param it: qvector< disasm_line_t >::iterator
 |      @param x: disasm_line_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'disasm_line_t &'
 |      push_back(self, x)
 |      
 |      @param x: disasm_line_t const &
 |      
 |      push_back(self) -> disasm_line_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: disasm_line_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< disasm_line_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function display_copyright_warning in module ida_kernwin:

display_copyright_warning(*args) -> 'bool'
    display_copyright_warning() -> bool
    Display copyright warning (ui_copywarn).
    
    @return: yes/no

Help on function display_widget in module ida_kernwin:

display_widget(*args) -> 'void'
    display_widget(widget, options, dest_ctrl=None)
    Display a widget, dock it if not done before
    
    @param widget: (C++: TWidget *) widget to display
    @param options: (C++: uint32) Widget open flags
    @param dest_ctrl: (C++: const char *) where to dock: if nullptr or invalid then use the active
                      docker if there is not create a new tab relative to current
                      active tab

Help on function ea2str in module ida_kernwin:

ea2str(*args) -> 'size_t'
    ea2str(ea) -> str
    Convert linear address to UTF-8 string.
    
    @param ea: (C++: ea_t)

Help on function ea_viewer_history_push_and_jump in module ida_kernwin:

ea_viewer_history_push_and_jump(*args) -> 'bool'
    ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
    Push current location in the history and jump to the given location
    (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and
    also in other synchronized views.
    
    @param v: (C++: TWidget *) ea viewer
    @param ea: (C++: ea_t) jump destination
    @param x: (C++: int) ,y: coords on screen
    @param lnnum: (C++: int) desired line number of given address
    @param lnnum: (C++: int) desired line number of given address

Help on function enable_chooser_item_attrs in module ida_kernwin:

enable_chooser_item_attrs(*args) -> 'bool'
    enable_chooser_item_attrs(chooser_caption, enable) -> bool
    Enable item-specific attributes for chooser items
    (ui_enable_chooser_item_attrs). For example: color list items differently
    depending on a criterium.
    If enabled, the chooser will generate ui_get_chooser_item_attrs
    events that can be intercepted by a plugin to modify the item attributes.
    This event is generated only in the GUI version of IDA.
    Specifying CH_ATTRS bit at the chooser creation time has the same effect.
    
    @param chooser_caption: (C++: const char *) char const *
    @param enable: (C++: bool)
    @return: success

Help on class enumplace_t in module ida_kernwin:

class enumplace_t(place_t)
 |  Proxy of C++ enumplace_t class.
 |  
 |  Method resolution order:
 |      enumplace_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enumplace_t(...)
 |      delete_enumplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bmask
 |      bmask
 |  
 |  idx
 |      idx
 |  
 |  serial
 |      serial
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, ud)
 |      
 |      Parameters
 |      ----------
 |      ud: void *
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |      Adjust the current location to point to a displayable object. This function
 |      validates the location and makes sure that it points to an existing object. For
 |      example, if the location points to the middle of an instruction, it will be
 |      adjusted to point to the beginning of the instruction.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |      Are we at the first displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the first displayable object
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |      Clone the location.
 |      
 |      @return: a pointer to a copy of the current location in dynamic memory
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      @param t2: (C++: const place_t *) place_t const *
 |  
 |  compare2(self, *args) -> 'int'
 |      compare2(self, t2, arg3) -> int
 |      Compare two locations except line numbers (lnnum). This function is used to
 |      organize loops. For example, if the user has selected an range, its boundaries
 |      are remembered as location objects. Any operation within the selection will have
 |      the following look: for ( loc=starting_location; loc < ending_location;
 |      loc.next() ) In this loop, the comparison function is used.
 |      
 |      @param t2: (C++: const place_t *) the place to compare this one to.
 |      @param arg3: void *
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |      Copy the specified location object to the current object.
 |      
 |      @param from: (C++: const place_t *) place_t const *
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |      De-serialize into this instance. 'pptr' should be incremented by as many bytes
 |      as de-serialization consumed.
 |      
 |      @param pptr: (C++: const uchar **) pointer to a serialized representation of a place_t of this type.
 |      @return: whether de-serialization was successful
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |      Are we at the last displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the last displayable object
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |      Visit this place, possibly 'unhiding' a section of text. If entering that place
 |      required some expanding, a place_t should be returned that represents that
 |      section, plus some flags for later use by 'leave()'.
 |      
 |      @param out_flags: flags to be used together with the place_t that is returned,
 |                        in order to restore the section to its original state when
 |                        leave() is called.
 |      @return: a place_t corresponding to the beginning of the section of text that
 |               had to be expanded. That place_t's leave() will be called with the
 |               flags contained in 'out_flags' when the user navigates away from it.
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> ([str, ...], int, int, int)
 |      Generate text lines for the current location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param maxsize: (C++: int) the maximum number of lines to generate
 |      @return: number of generated lines
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |      Get the place's ID (i.e., the value returned by register_place_class())
 |      
 |      @return: the id
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |      Leave this place, possibly 'hiding' a section of text that was previously
 |      expanded (at enter()-time.)
 |      
 |      @param arg2: uint32
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |      Map a number to a location. When the user clicks on the scrollbar and drags it,
 |      we need to determine the location corresponding to the new scrollbar position.
 |      This function is used to determine it. It builds a location object for the
 |      specified 'x' and returns a pointer to it.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param x: (C++: uval_t) number to map
 |      @param lnnum: (C++: int) line number to initialize 'lnnum'
 |      @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |      Get this place type name. All instances of a given class must return the same
 |      string.
 |      
 |      @return: the place type name. Please try and pick something that is not too
 |               generic, as it might clash w/ other plugins. A good practice is to
 |               prefix the class name with the name of your plugin. E.g.,
 |               "myplugin:srcplace_t".
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |      Move to the next displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |      Move to the previous displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |      Rebase the place instance
 |      
 |      @param arg2: segm_move_infos_t const &
 |      @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |      Serialize this instance. It is fundamental that all instances of a particular
 |      subclass of of place_t occupy the same number of bytes when serialized.
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |      Map the location to an ea_t.
 |      
 |      @return: the corresponding ea_t, or BADADDR;
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |      Map the location to a number. This mapping is used to draw the vertical
 |      scrollbar.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |      
 |      @param p: place_t *
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |      
 |      @param p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum

Help on function error in module ida_kernwin:

error(*args) -> 'void'
    error(format)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

Help on function execute_sync in module ida_kernwin:

execute_sync(*args) -> 'int'
    execute_sync(py_callable, reqf) -> int
    Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    @param py_callable: A python callable object, must return an integer value
    @param reqf: one of MFF_ flags
    @return: -1 or the return value of the callable

Help on function execute_ui_requests in module ida_kernwin:

execute_ui_requests(*args) -> 'bool'
    execute_ui_requests(py_list) -> bool
    Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    @param callable_list: A list of python callable objects.
    @note: A callable should return True if it wants to be called more than once.
    @return: Boolean. False if the list contains a non callable item

Help on function find_widget in module ida_kernwin:

find_widget(*args) -> 'TWidget *'
    find_widget(caption) -> TWidget *
    Find widget with the specified caption (only gui version) (ui_find_widget). NB:
    this callback works only with the tabbed widgets!
    
    @param caption: (C++: const char *) title of tab, or window title if widget is not tabbed
    @return: pointer to the TWidget, nullptr if none is found

Help on function formchgcbfa_close in module ida_kernwin:

formchgcbfa_close(*args) -> 'void'
    formchgcbfa_close(p_fa, close_normally)
    
    @param p_fa: size_t
    @param close_normally: int

Help on function formchgcbfa_enable_field in module ida_kernwin:

formchgcbfa_enable_field(*args) -> 'bool'
    formchgcbfa_enable_field(p_fa, fid, enable) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param enable: bool

Help on function formchgcbfa_get_field_value in module ida_kernwin:

formchgcbfa_get_field_value(*args) -> 'PyObject *'
    formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *
    
    @param p_fa: size_t
    @param fid: int
    @param ft: int
    @param sz: size_t

Help on function formchgcbfa_get_focused_field in module ida_kernwin:

formchgcbfa_get_focused_field(*args) -> 'int'
    formchgcbfa_get_focused_field(p_fa) -> int
    
    @param p_fa: size_t

Help on function formchgcbfa_move_field in module ida_kernwin:

formchgcbfa_move_field(*args) -> 'bool'
    formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param x: int
    @param y: int
    @param w: int
    @param h: int

Help on function formchgcbfa_refresh_field in module ida_kernwin:

formchgcbfa_refresh_field(*args) -> 'void'
    formchgcbfa_refresh_field(p_fa, fid)
    
    @param p_fa: size_t
    @param fid: int

Help on function formchgcbfa_set_field_value in module ida_kernwin:

formchgcbfa_set_field_value(*args) -> 'bool'
    formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param ft: int
    @param py_val: PyObject *

Help on function formchgcbfa_set_focused_field in module ida_kernwin:

formchgcbfa_set_focused_field(*args) -> 'bool'
    formchgcbfa_set_focused_field(p_fa, fid) -> bool
    
    @param p_fa: size_t
    @param fid: int

Help on function formchgcbfa_show_field in module ida_kernwin:

formchgcbfa_show_field(*args) -> 'bool'
    formchgcbfa_show_field(p_fa, fid, show) -> bool
    
    @param p_fa: size_t
    @param fid: int
    @param show: bool

Help on function free_custom_icon in module ida_kernwin:

free_custom_icon(*args) -> 'void'
    free_custom_icon(icon_id)
    Frees an icon loaded with load_custom_icon()
    
    @param icon_id: int

Help on function gen_disasm_text in module ida_kernwin:

gen_disasm_text(*args) -> 'void'
    gen_disasm_text(text, ea1, ea2, truncate_lines)
    Generate disassembly text for a range.
    
    @param text: (C++: text_t &) result
    @param ea1: (C++: ea_t) start address
    @param ea2: (C++: ea_t) end address
    @param truncate_lines: (C++: bool) (on idainfo::margin)

Help on function get_action_checkable in module ida_kernwin:

get_action_checkable(*args) -> 'bool *'
    get_action_checkable(name) -> bool
    Get an action's checkability (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_checked in module ida_kernwin:

get_action_checked(*args) -> 'bool *'
    get_action_checked(name) -> bool
    Get an action's checked state (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_icon in module ida_kernwin:

get_action_icon(*args) -> 'int *'
    get_action_icon(name) -> bool
    Get an action's icon (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_label in module ida_kernwin:

get_action_label(*args) -> 'qstring *'
    get_action_label(name) -> str
    Get an action's label (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_shortcut in module ida_kernwin:

get_action_shortcut(*args) -> 'qstring *'
    get_action_shortcut(name) -> str
    Get an action's shortcut (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_state in module ida_kernwin:

get_action_state(*args) -> 'action_state_t *'
    get_action_state(name) -> bool
    Get an action's state (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_tooltip in module ida_kernwin:

get_action_tooltip(*args) -> 'qstring *'
    get_action_tooltip(name) -> str
    Get an action's tooltip (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_action_visibility in module ida_kernwin:

get_action_visibility(*args) -> 'bool *'
    get_action_visibility(name) -> bool
    Get an action's visibility (ui_get_action_attr).
    
    @param name: (C++: const char *) the action name
    @return: success

Help on function get_active_modal_widget in module ida_kernwin:

get_active_modal_widget(*args) -> 'TWidget *'
    get_active_modal_widget() -> TWidget *
    Get the current, active modal TWidget instance. Note that in this context, the
    "wait dialog" is not considered: this function will return nullptr even if it is
    currently shown.
    
    @return: TWidget * the active modal widget, or nullptr

Help on function get_addon_info in module ida_kernwin:

get_addon_info(*args) -> 'bool'
    get_addon_info(id, info) -> bool
    Get info about a registered addon with a given product code. info->cb must be
    valid! NB: all pointers are invalidated by next call to register_addon or
    get_addon_info
    
    @param id: (C++: const char *) char const *
    @param info: (C++: addon_info_t *)
    @return: false if not found

Help on function get_addon_info_idx in module ida_kernwin:

get_addon_info_idx(*args) -> 'bool'
    get_addon_info_idx(index, info) -> bool
    Get info about a registered addon with specific index. info->cb must be valid!
    NB: all pointers are invalidated by next call to register_addon or
    get_addon_info
    
    @param index: (C++: int)
    @param info: (C++: addon_info_t *)
    @return: false if index is out of range

Help on function get_chooser_data in module ida_kernwin:

get_chooser_data(*args) -> 'PyObject *'
    get_chooser_data(chooser_caption, n) -> [str, ...]
    Get the text corresponding to the index N in the chooser data. Use -1 to get the
    header.
    
    @param chooser_caption: (C++: const char *) char const *
    @param n: (C++: int)

Help on function get_chooser_obj in module ida_kernwin:

get_chooser_obj(*args) -> 'void *'
    get_chooser_obj(chooser_caption) -> void *
    Get the underlying object of the specified chooser (ui_get_chooser_obj).
    
    This attemps to find the choser by its title and, if found, returns the result
    of calling its chooser_base_t::get_chooser_obj() method.
    
    @note: This is object is chooser-specific.
    
    @param chooser_caption: (C++: const char *) char const *
    @return: the object that was used to create the chooser

Help on function get_curline in module ida_kernwin:

get_curline(*args) -> 'char const *'
    get_curline() -> char const *
    Get current line from the disassemble window (ui_get_curline).
    
    @return: cptr current line with the color codes (use tag_remove() to remove the
             color codes)

Help on function get_current_viewer in module ida_kernwin:

get_current_viewer(*args) -> 'TWidget *'
    get_current_viewer() -> TWidget *
    Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)

Help on function get_current_widget in module ida_kernwin:

get_current_widget(*args) -> 'TWidget *'
    get_current_widget() -> TWidget *
    Get a pointer to the current widget (ui_get_current_widget).

Help on function get_cursor in module ida_kernwin:

get_cursor(*args) -> 'int *, int *'
    get_cursor() -> bool
    Get the cursor position on the screen (ui_get_cursor).
    @note: coordinates are 0-based
    
    @retval true: pointers are filled
    @retval false: no disassembly window open

Help on function get_custom_viewer_curline in module ida_kernwin:

get_custom_viewer_curline(*args) -> 'char const *'
    get_custom_viewer_curline(custom_viewer, mouse) -> char const *
    Get current line of custom viewer (ui_get_custom_viewer_curline). The returned
    line contains color codes
    
    @param custom_viewer: (C++: TWidget *) view
    @param mouse: (C++: bool) mouse position (otherwise cursor position)
    @return: pointer to contents of current line

Help on function get_custom_viewer_location in module ida_kernwin:

get_custom_viewer_location(*args) -> 'bool'
    get_custom_viewer_location(out, custom_viewer, mouse=False) -> bool
    Get the current location in a custom viewer (ui_get_custom_viewer_location).
    
    @param out: (C++: lochist_entry_t *)
    @param custom_viewer: (C++: TWidget *)
    @param mouse: (C++: bool)

Help on function get_custom_viewer_place in module ida_kernwin:

get_custom_viewer_place(*args) -> 'int *, int *'
    get_custom_viewer_place(custom_viewer, mouse) -> place_t
    Get current place in a custom viewer (ui_get_curplace).
    
    See also the more complete get_custom_viewer_location()
    
    @param custom_viewer: (C++: TWidget *) view
    @param mouse: (C++: bool) mouse position (otherwise cursor position)

Help on function get_custom_viewer_place_xcoord in module ida_kernwin:

get_custom_viewer_place_xcoord(*args) -> 'int'
    get_custom_viewer_place_xcoord(custom_viewer, pline, pitem) -> int
    Get the X position of the item, in the line
    
    @param custom_viewer: (C++: TWidget *) the widget
    @param pline: (C++: const place_t *) a place corresponding to the line
    @param pitem: (C++: const place_t *) a place corresponding to the item
    @return: -1 if 'pitem' is not included in the line
    -2 if 'pitem' points at the entire line
    >= 0 for the X coordinate within the pline, where pitem points

Help on function get_ea_viewer_history_info in module ida_kernwin:

get_ea_viewer_history_info(*args) -> 'bool'
    get_ea_viewer_history_info(nback, nfwd, v) -> bool
    Get information about what's in the history (ui_ea_viewer_history_info).
    
    @param nback: (C++: int *) number of available back steps
    @param nfwd: (C++: int *) number of available forward steps
    @param v: (C++: TWidget *) ea viewer
    @retval false: if the given ea viewer does not exist
    @retval true: otherwise

Help on function get_hexdump_ea in module ida_kernwin:

get_hexdump_ea(*args) -> 'ea_t'
    get_hexdump_ea(hexdump_num) -> ea_t
    Get the current address in a hex view.
    
    @param hexdump_num: (C++: int) number of hexview window

Help on function get_highlight in module ida_kernwin:

get_highlight(*args) -> 'PyObject *'
    get_highlight(v, in_flags=0) -> (str, int) or None
    Returns the currently highlighted identifier and flags
    
    @param v: The UI widget to operate on
    @param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
    @return: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.

Help on function get_kernel_version in module ida_kernwin:

get_kernel_version(*args) -> 'size_t'
    get_kernel_version() -> str
    Get IDA kernel version (in a string like "5.1").

Help on function get_key_code in module ida_kernwin:

get_key_code(*args) -> 'ushort'
    get_key_code(keyname) -> ushort
    Get keyboard key code by its name (ui_get_key_code)
    
    @param keyname: (C++: const char *) char const *

Help on function get_navband_ea in module ida_kernwin:

get_navband_ea(*args) -> 'ea_t'
    get_navband_ea(pixel) -> ea_t
    Translate the pixel position on the navigation band, into an address.
    
    @param pixel: (C++: int)

Help on function get_navband_pixel in module ida_kernwin:

get_navband_pixel(*args) -> 'bool *'
    get_navband_pixel(ea) -> int
    Maps an address, onto a pixel coordinate within the navband
    
    @param ea: The address to map
    @return: a list [pixel, is_vertical]

Help on function get_opnum in module ida_kernwin:

get_opnum(*args) -> 'int'
    get_opnum() -> int
    Get current operand number, -1 means no operand (ui_get_opnum)

Help on function get_output_curline in module ida_kernwin:

get_output_curline(*args) -> 'qstring *'
    get_output_curline(mouse) -> str
    Get current line of output window (ui_get_output_curline).
    
    @param mouse: (C++: bool) current for mouse pointer?
    @return: false if output contains no text

Help on function get_output_cursor in module ida_kernwin:

get_output_cursor(*args) -> 'int *, int *'
    get_output_cursor() -> bool
    Get coordinates of the output window's cursor (ui_get_output_cursor).
    @note: coordinates are 0-based
    @note: this function will succeed even if the output window is not visible
    
    @retval false: the output window has been destroyed.
    @retval true: pointers are filled

Help on function get_output_selected_text in module ida_kernwin:

get_output_selected_text(*args) -> 'qstring *'
    get_output_selected_text() -> str
    Returns selected text from output window (ui_get_output_selected_text).
    
    @return: true if there is a selection

Help on function get_place_class in module ida_kernwin:

get_place_class(*args) -> 'place_t const *'
    get_place_class(out_flags, out_sdk_version, id) -> place_t
    Get information about a previously-registered place_t class. See also
    register_place_class().
    
    @param out_flags: (C++: int *) output flags (can be nullptr)
    @param out_sdk_version: (C++: int *) sdk version the place was created with (can be nullptr)
    @param id: (C++: int) place class ID
    @return: the place_t template, or nullptr if not found

Help on function get_place_class_id in module ida_kernwin:

get_place_class_id(*args) -> 'int'
    get_place_class_id(name) -> int
    Get the place class ID for the place that has been registered as 'name'.
    
    @param name: (C++: const char *) the class name
    @return: the place class ID, or -1 if not found

Help on function get_place_class_template in module ida_kernwin:

get_place_class_template(*args) -> 'place_t const *'
    get_place_class_template(id) -> place_t
    See get_place_class()
    
    @param id: (C++: int)

Help on function get_registered_actions in module ida_kernwin:

get_registered_actions(*args) -> 'PyObject *'
    get_registered_actions() -> [str, ...]
    Get a list of all currently-registered actions

Help on function get_screen_ea in module ida_kernwin:

get_screen_ea(*args) -> 'ea_t'
    get_screen_ea() -> ea_t
    Get the address at the screen cursor (ui_screenea)

Help on function get_synced_group in module ida_kernwin:

get_synced_group(*args) -> 'synced_group_t const *'
    get_synced_group(w) -> synced_group_t
    Get the group of widgets/registers this view is synchronized with
    
    @param w: (C++: const TWidget *) the widget
    @return: the group of widgets/registers, or nullptr

Help on function get_tab_size in module ida_kernwin:

get_tab_size(*args) -> 'int'
    get_tab_size(path) -> int
    Get the size of a tab in spaces (ui_get_tab_size).
    
    @param path: (C++: const char *) the path of the source view for which the tab size is requested.
    * if nullptr, the default size is returned.

Help on function get_user_input_event in module ida_kernwin:

get_user_input_event(*args) -> 'bool'
    get_user_input_event(out) -> bool
    Get the current user input event (mouse button press, key press, ...) It is
    sometimes desirable to be able to tell when a certain situation happens (e.g.,
    'view_curpos' gets triggered); this function exists to provide that context (GUI
    version only)
    
    @param out: (C++: input_event_t *) the input event data
    @return: false if we are not currently processing a user input event

Help on function get_user_strlist_options in module ida_kernwin:

get_user_strlist_options(*args) -> 'void'
    get_user_strlist_options(out)
    
    @param out: strwinsetup_t *

Help on function get_view_renderer_type in module ida_kernwin:

get_view_renderer_type(*args) -> 'tcc_renderer_type_t'
    get_view_renderer_type(v) -> tcc_renderer_type_t
    Get the type of renderer currently in use in the given view
    (ui_get_renderer_type)
    
    @param v: (C++: TWidget *)

Help on function get_viewer_place_type in module ida_kernwin:

get_viewer_place_type(*args) -> 'tcc_place_type_t'
    get_viewer_place_type(viewer) -> tcc_place_type_t
    Get the type of place_t instances a viewer uses & creates
    (ui_get_viewer_place_type).
    
    @param viewer: (C++: TWidget *)

Help on function get_viewer_user_data in module ida_kernwin:

get_viewer_user_data(*args) -> 'void *'
    get_viewer_user_data(viewer) -> void *
    Get the user data from a custom viewer (ui_get_viewer_user_data)
    
    @param viewer: (C++: TWidget *)

Help on function get_widget_title in module ida_kernwin:

get_widget_title(*args) -> 'qstring *'
    get_widget_title(widget) -> str
    Get the TWidget's title (ui_get_widget_title).
    
    @param widget: (C++: TWidget *)

Help on function get_widget_type in module ida_kernwin:

get_widget_type(*args) -> 'twidget_type_t'
    get_widget_type(widget) -> twidget_type_t
    Get the type of the TWidget * (ui_get_widget_type).
    
    @param widget: (C++: TWidget *)

Help on function get_window_id in module ida_kernwin:

get_window_id(*args) -> 'void *'
    get_window_id(name=None) -> void *
    Get the system-specific window ID (GUI version only)
    
    @param name: (C++: const char *) name of the window (nullptr means the main IDA window)
    @return: the low-level window ID

Help on function hide_wait_box in module ida_kernwin:

hide_wait_box(*args) -> 'void'
    hide_wait_box()
    Hide the "Please wait dialog box".

Help on class idaplace_t in module ida_kernwin:

class idaplace_t(place_t)
 |  Proxy of C++ idaplace_t class.
 |  
 |  Method resolution order:
 |      idaplace_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idaplace_t(...)
 |      delete_idaplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ea
 |      ea
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, ud)
 |      
 |      Parameters
 |      ----------
 |      ud: void *
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |      Adjust the current location to point to a displayable object. This function
 |      validates the location and makes sure that it points to an existing object. For
 |      example, if the location points to the middle of an instruction, it will be
 |      adjusted to point to the beginning of the instruction.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |      Are we at the first displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the first displayable object
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |      Clone the location.
 |      
 |      @return: a pointer to a copy of the current location in dynamic memory
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      @param t2: (C++: const place_t *) place_t const *
 |  
 |  compare2(self, *args) -> 'int'
 |      compare2(self, t2, arg3) -> int
 |      Compare two locations except line numbers (lnnum). This function is used to
 |      organize loops. For example, if the user has selected an range, its boundaries
 |      are remembered as location objects. Any operation within the selection will have
 |      the following look: for ( loc=starting_location; loc < ending_location;
 |      loc.next() ) In this loop, the comparison function is used.
 |      
 |      @param t2: (C++: const place_t *) the place to compare this one to.
 |      @param arg3: void *
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |      Copy the specified location object to the current object.
 |      
 |      @param from: (C++: const place_t *) place_t const *
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |      De-serialize into this instance. 'pptr' should be incremented by as many bytes
 |      as de-serialization consumed.
 |      
 |      @param pptr: (C++: const uchar **) pointer to a serialized representation of a place_t of this type.
 |      @return: whether de-serialization was successful
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |      Are we at the last displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the last displayable object
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |      Visit this place, possibly 'unhiding' a section of text. If entering that place
 |      required some expanding, a place_t should be returned that represents that
 |      section, plus some flags for later use by 'leave()'.
 |      
 |      @param out_flags: flags to be used together with the place_t that is returned,
 |                        in order to restore the section to its original state when
 |                        leave() is called.
 |      @return: a place_t corresponding to the beginning of the section of text that
 |               had to be expanded. That place_t's leave() will be called with the
 |               flags contained in 'out_flags' when the user navigates away from it.
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> ([str, ...], int, int, int)
 |      Generate text lines for the current location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param maxsize: (C++: int) the maximum number of lines to generate
 |      @return: number of generated lines
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |      Get the place's ID (i.e., the value returned by register_place_class())
 |      
 |      @return: the id
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |      Leave this place, possibly 'hiding' a section of text that was previously
 |      expanded (at enter()-time.)
 |      
 |      @param arg2: uint32
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |      Map a number to a location. When the user clicks on the scrollbar and drags it,
 |      we need to determine the location corresponding to the new scrollbar position.
 |      This function is used to determine it. It builds a location object for the
 |      specified 'x' and returns a pointer to it.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param x: (C++: uval_t) number to map
 |      @param lnnum: (C++: int) line number to initialize 'lnnum'
 |      @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |      Get this place type name. All instances of a given class must return the same
 |      string.
 |      
 |      @return: the place type name. Please try and pick something that is not too
 |               generic, as it might clash w/ other plugins. A good practice is to
 |               prefix the class name with the name of your plugin. E.g.,
 |               "myplugin:srcplace_t".
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |      Move to the next displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |      Move to the previous displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |      Rebase the place instance
 |      
 |      @param arg2: segm_move_infos_t const &
 |      @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |      Serialize this instance. It is fundamental that all instances of a particular
 |      subclass of of place_t occupy the same number of bytes when serialized.
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |      Map the location to an ea_t.
 |      
 |      @return: the corresponding ea_t, or BADADDR;
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |      Map the location to a number. This mapping is used to draw the vertical
 |      scrollbar.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |      
 |      @param p: place_t *
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |      
 |      @param p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum

Help on function info in module ida_kernwin:

info(*args) -> 'void'
    info(format)
    
    @param format: char const *

Help on class input_event_keyboard_data_t in module ida_kernwin:

class input_event_keyboard_data_t(builtins.object)
 |  Proxy of C++ input_event_t::input_event_keyboard_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> input_event_keyboard_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_input_event_keyboard_data_t(...)
 |      delete_input_event_keyboard_data_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  key
 |      key
 |  
 |  text
 |      text
 |  
 |  thisown
 |      The membership flag

Help on class input_event_mouse_data_t in module ida_kernwin:

class input_event_mouse_data_t(builtins.object)
 |  Proxy of C++ input_event_t::input_event_mouse_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> input_event_mouse_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_input_event_mouse_data_t(...)
 |      delete_input_event_mouse_data_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  button
 |      button
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  y
 |      y

Help on class input_event_shortcut_data_t in module ida_kernwin:

class input_event_shortcut_data_t(builtins.object)
 |  Proxy of C++ input_event_t::input_event_shortcut_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> input_event_shortcut_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_input_event_shortcut_data_t(...)
 |      delete_input_event_shortcut_data_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  action_name
 |      action_name
 |  
 |  thisown
 |      The membership flag

Help on class input_event_t in module ida_kernwin:

class input_event_t(builtins.object)
 |  Proxy of C++ input_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> input_event_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_input_event_t(...)
 |      delete_input_event_t(self)
 |  
 |  _source_as_size(self, *args) -> 'size_t'
 |      _source_as_size(self) -> size_t
 |  
 |  _target_as_size(self, *args) -> 'size_t'
 |      _target_as_size(self) -> size_t
 |  
 |  get_source_QEvent(self)
 |  
 |  get_target_QWidget(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      cb
 |  
 |  keyboard
 |      keyboard
 |  
 |  kind
 |      kind
 |  
 |  modifiers
 |      modifiers
 |  
 |  mouse
 |      mouse
 |  
 |  shortcut
 |      shortcut
 |  
 |  source
 |      source
 |  
 |  target
 |      target
 |  
 |  thisown
 |      The membership flag

Help on function install_command_interpreter in module ida_kernwin:

install_command_interpreter(*args) -> 'int'
    install_command_interpreter(py_obj) -> int
    Install command line interpreter (ui_install_cli)
    
    @param py_obj: PyObject *

Help on function internal_register_place_class in module ida_kernwin:

internal_register_place_class(*args) -> 'int'
    internal_register_place_class(tmplate, flags, owner, sdk_version) -> int
    
    @param tmplate: place_t const *
    @param flags: int
    @param owner: plugin_t const *
    @param sdk_version: int

Help on function is_action_enabled in module ida_kernwin:

is_action_enabled(*args) -> 'bool'
    is_action_enabled(s) -> bool
    Check if the given action state is one of AST_ENABLE*.
    
    @param s: (C++: action_state_t) enum action_state_t

Help on function is_chooser_widget in module ida_kernwin:

is_chooser_widget(*args) -> 'bool'
    is_chooser_widget(t) -> bool
    Does the given widget type specify a chooser widget?
    
    @param t: (C++: twidget_type_t)

Help on function is_idaq in module ida_kernwin:

is_idaq(*args) -> 'bool'
    is_idaq() -> bool
    Returns True or False depending if IDAPython is hosted by IDAQ

Help on function is_idaview in module ida_kernwin:

is_idaview(*args) -> 'bool'
    is_idaview(v) -> bool
    Is the given custom view an idaview? (ui_is_idaview)
    
    @param v: (C++: TWidget *)

Help on function is_msg_inited in module ida_kernwin:

is_msg_inited(*args) -> 'bool'
    is_msg_inited() -> bool
    Can we use msg() functions?

Help on function is_place_class_ea_capable in module ida_kernwin:

is_place_class_ea_capable(*args) -> 'bool'
    is_place_class_ea_capable(id) -> bool
    See get_place_class()
    
    @param id: (C++: int)

Help on function is_refresh_requested in module ida_kernwin:

is_refresh_requested(*args) -> 'bool'
    is_refresh_requested(mask) -> bool
    Get a refresh request state
    
    @param mask: (C++: uint64) Window refresh flags
    @return: the state (set or cleared)

Help on class jobj_wrapper_t in module ida_kernwin:

class jobj_wrapper_t(builtins.object)
 |  Proxy of C++ jobj_wrapper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  get_dict(self, *args) -> 'PyObject *'
 |      get_dict(self) -> dict
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function jumpto in module ida_kernwin:

jumpto(*args) -> 'bool'
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    Set cursor position in custom ida viewer.
    
    @param custom_viewer: (C++: TWidget *) view
    @param place: (C++: place_t *) target position
    @param uijmp_flags: int
    
    @return: success
    jumpto(custom_viewer, place, x, y) -> bool
    
    @param custom_viewer: TWidget *
    @param place: place_t *
    @param x: int

Help on function l_compare2 in module ida_kernwin:

l_compare2(*args) -> 'int'
    l_compare2(t1, t2, ud) -> int
    
    @param t1: place_t const *
    @param t2: place_t const *
    @param ud: void *

Help on class line_rendering_output_entries_refs_t in module ida_kernwin:

class line_rendering_output_entries_refs_t(builtins.object)
 |  Proxy of C++ qvector< line_rendering_output_entry_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< line_rendering_output_entry_t * > const &
 |  
 |  __getitem__(self, *args) -> 'line_rendering_output_entry_t *const &'
 |      __getitem__(self, i) -> line_rendering_output_entry_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> line_rendering_output_entries_refs_t
 |      __init__(self, x) -> line_rendering_output_entries_refs_t
 |      
 |      @param x: qvector< line_rendering_output_entry_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< line_rendering_output_entry_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: line_rendering_output_entry_t *const &
 |  
 |  __swig_destroy__ = delete_line_rendering_output_entries_refs_t(...)
 |      delete_line_rendering_output_entries_refs_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: line_rendering_output_entry_t *const &
 |  
 |  _internal_push_back(self, *args) -> 'void'
 |      _internal_push_back(self, e)
 |      
 |      Parameters
 |      ----------
 |      e: line_rendering_output_entry_t *
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: line_rendering_output_entry_t *const &
 |  
 |  at(self, *args) -> 'line_rendering_output_entry_t *const &'
 |      at(self, _idx) -> line_rendering_output_entry_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< line_rendering_output_entry_t * >::const_iterator'
 |      begin(self) -> qvector< line_rendering_output_entry_t * >::iterator
 |      begin(self) -> qvector< line_rendering_output_entry_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< line_rendering_output_entry_t * >::const_iterator'
 |      end(self) -> qvector< line_rendering_output_entry_t * >::iterator
 |      end(self) -> qvector< line_rendering_output_entry_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< line_rendering_output_entry_t * >::iterator'
 |      erase(self, it) -> qvector< line_rendering_output_entry_t * >::iterator
 |      
 |      @param it: qvector< line_rendering_output_entry_t * >::iterator
 |      
 |      erase(self, first, last) -> qvector< line_rendering_output_entry_t * >::iterator
 |      
 |      @param first: qvector< line_rendering_output_entry_t * >::iterator
 |      @param last: qvector< line_rendering_output_entry_t * >::iterator
 |  
 |  extract(self, *args) -> 'line_rendering_output_entry_t **'
 |      extract(self) -> line_rendering_output_entry_t **
 |  
 |  find(self, *args) -> 'qvector< line_rendering_output_entry_t * >::const_iterator'
 |      find(self, x) -> qvector< line_rendering_output_entry_t * >::iterator
 |      
 |      @param x: line_rendering_output_entry_t *const &
 |      
 |      find(self, x) -> qvector< line_rendering_output_entry_t * >::const_iterator
 |      
 |      @param x: line_rendering_output_entry_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: line_rendering_output_entry_t *const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: line_rendering_output_entry_t **
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< line_rendering_output_entry_t * >::iterator'
 |      insert(self, it, x) -> qvector< line_rendering_output_entry_t * >::iterator
 |      
 |      @param it: qvector< line_rendering_output_entry_t * >::iterator
 |      @param x: line_rendering_output_entry_t *const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, e)
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: line_rendering_output_entry_t *const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< line_rendering_output_entry_t * > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class line_rendering_output_entry_t in module ida_kernwin:

class line_rendering_output_entry_t(builtins.object)
 |  Proxy of C++ line_rendering_output_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: line_rendering_output_entry_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _line, _flags=0, _bg_color=0) -> line_rendering_output_entry_t
 |      
 |      @param _line: twinline_t const *
 |      @param _flags: uint32
 |      @param _bg_color: bgcolor_t
 |      
 |      __init__(self, _line, _cpx, _nchars, _flags, _bg_color) -> line_rendering_output_entry_t
 |      
 |      @param _line: twinline_t const *
 |      @param _cpx: int
 |      @param _nchars: int
 |      @param _flags: uint32
 |      @param _bg_color: bgcolor_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: line_rendering_output_entry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_line_rendering_output_entry_t(...)
 |      delete_line_rendering_output_entry_t(self)
 |  
 |  is_bg_color_direct(self, *args) -> 'bool'
 |      is_bg_color_direct(self) -> bool
 |  
 |  is_bg_color_empty(self, *args) -> 'bool'
 |      is_bg_color_empty(self) -> bool
 |  
 |  is_bg_color_key(self, *args) -> 'bool'
 |      is_bg_color_key(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bg_color
 |      bg_color
 |  
 |  cpx
 |      cpx
 |  
 |  flags
 |      flags
 |  
 |  line
 |      line
 |  
 |  nchars
 |      nchars
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class linearray_t in module ida_kernwin:

class linearray_t(builtins.object)
 |  Proxy of C++ linearray_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ud) -> linearray_t
 |      
 |      @param _ud: void *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_linearray_t(...)
 |      delete_linearray_t(self)
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self) -> bool
 |      Are we at the beginning?
 |  
 |  down(self, *args) -> 'qstring const *'
 |      down(self) -> qstring const *
 |      Get a line from down direction. place is ok BEFORE
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self) -> bool
 |  
 |  get_bg_color(self, *args) -> 'bgcolor_t'
 |      get_bg_color(self) -> bgcolor_t
 |      Get current background color. (the same behavior as with get_place(): good
 |      before down() and after up())
 |  
 |  get_dlnnum(self, *args) -> 'int'
 |      get_dlnnum(self) -> int
 |      Get default line number. (the same behavior as with get_place(): good before
 |      down() and after up())
 |  
 |  get_linecnt(self, *args) -> 'int'
 |      get_linecnt(self) -> int
 |      Get number of lines for the current place. (the same behavior as with
 |      get_place(): good before down() and after up())
 |  
 |  get_pfx_color(self, *args) -> 'bgcolor_t'
 |      get_pfx_color(self) -> bgcolor_t
 |      Get current prefix color. (the same behavior as with get_place(): good before
 |      down() and after up())
 |  
 |  get_place(self, *args) -> 'place_t *'
 |      get_place(self) -> place_t
 |      Get the current place. If called before down(), then returns place of line which
 |      will be returned by down(). If called after up(), then returns place if line
 |      returned by up().
 |  
 |  set_place(self, *args) -> 'int'
 |      set_place(self, new_at) -> int
 |      Position the array. This function must be called before calling any other member
 |      functions.
 |      
 |      linearray_t doesn't own place_t structures. The caller must take care of place_t
 |      objects.
 |      
 |      @param new_at: (C++: const place_t *) new position of the array
 |      @return: the delta of lines that the linearray_t had to adjust the place by.
 |      For example, if the place_t has a lnnum of 5, but it turns out, upon generating
 |      lines,
 |      that the number of lines for that particular place is only 2, then 3 will be
 |      returned.
 |  
 |  set_userdata(self, *args) -> 'void'
 |      set_userdata(self, userd)
 |      Change the user data.
 |      
 |      @param userd: (C++: void *)
 |  
 |  up(self, *args) -> 'qstring const *'
 |      up(self) -> qstring const *
 |      Get a line from up direction. place is ok AFTER
 |  
 |  userdata(self, *args) -> 'void *'
 |      userdata(self) -> void *
 |      Get pointer to user data.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class lines_rendering_input_t in module ida_kernwin:

class lines_rendering_input_t(builtins.object)
 |  Proxy of C++ lines_rendering_input_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lines_rendering_input_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lines_rendering_input_t(...)
 |      delete_lines_rendering_input_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      cb
 |  
 |  sections_lines
 |      sections_lines
 |  
 |  sync_group
 |      sync_group
 |  
 |  thisown
 |      The membership flag

Help on class lines_rendering_output_t in module ida_kernwin:

class lines_rendering_output_t(builtins.object)
 |  Proxy of C++ lines_rendering_output_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: lines_rendering_output_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lines_rendering_output_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: lines_rendering_output_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lines_rendering_output_t(...)
 |      delete_lines_rendering_output_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: lines_rendering_output_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  entries
 |      entries
 |  
 |  flags
 |      flags
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function load_custom_icon in module ida_kernwin:

load_custom_icon(file_name=None, data=None, format=None)
    Loads a custom icon and returns an identifier that can be used with other APIs
    
    If file_name is passed then the other two arguments are ignored.
    
    Load an icon and return its id (ui_load_custom_icon).
    
    @return: icon id

Help on function load_dbg_dbginfo in module ida_kernwin:

load_dbg_dbginfo(*args) -> 'bool'
    load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
    Load debugging information from a file.
    
    @param path: (C++: const char *) path to file
    @param li: (C++: linput_t *) loader input. if nullptr, check DBG_NAME_KEY
    @param base: (C++: ea_t) loading address
    @param verbose: (C++: bool) dump status to message window

Help on function lookup_key_code in module ida_kernwin:

lookup_key_code(*args) -> 'ushort'
    lookup_key_code(key, shift, is_qt) -> ushort
    Get shortcut code previously created by ui_get_key_code.
    
    @param key: (C++: int) key constant
    @param shift: (C++: int) modifiers
    @param is_qt: (C++: bool) are we using gui version?

Help on function msg in module ida_kernwin:

msg(*args) -> 'PyObject *'
    msg(o) -> int
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

Help on function msg_clear in module ida_kernwin:

msg_clear(*args) -> 'void'
    msg_clear()
    Clear the "Output" window.

Help on function msg_get_lines in module ida_kernwin:

msg_get_lines(*args) -> 'PyObject *'
    msg_get_lines(count=-1) -> [str, ...]
    Retrieve the last 'count' lines from the output window, in reverse order (from
    most recent, to least recent)
    
    @param count: (C++: int) The number of lines to retrieve. -1 means: all

Help on function msg_save in module ida_kernwin:

msg_save(*args) -> 'bool'
    msg_save(path) -> bool
    Save the "Output" window contents into a file
    
    @param path: (C++: qstring &) The path of the file to save the contents into. An empty path means
                 that the user will be prompted for the destination and, if the file
                 already exists, the user will be asked to confirm before overriding
                 its contents. Upon return, 'path' will contain the path that the
                 user chose.
    @return: success

Help on function nomem in module ida_kernwin:

nomem(*args) -> 'void'
    nomem(format)
    
    @param format: char const *

Help on function open_bookmarks_window in module ida_kernwin:

open_bookmarks_window(*args) -> 'TWidget *'
    open_bookmarks_window(w) -> TWidget *
    Open the bookmarks window (ui_open_builtin).
    
    @param w: (C++: TWidget *) The widget for which the bookmarks will open. For example, this can be
              an IDAView, or Enums view, etc.
    @return: pointer to resulting window

Help on function open_bpts_window in module ida_kernwin:

open_bpts_window(*args) -> 'TWidget *'
    open_bpts_window(ea) -> TWidget *
    Open the breakpoints window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_calls_window in module ida_kernwin:

open_calls_window(*args) -> 'TWidget *'
    open_calls_window(ea) -> TWidget *
    Open the function calls window (ui_open_builtin).
    
    @param ea: (C++: ea_t)
    @return: pointer to resulting window

Help on function open_disasm_window in module ida_kernwin:

open_disasm_window(*args) -> 'TWidget *'
    open_disasm_window(window_title, ranges=None) -> TWidget *
    Open a disassembly view (ui_open_builtin).
    
    @param window_title: (C++: const char *) title of view to open
    @param ranges: (C++: const rangevec_t *) if != nullptr, then display a flow chart with the specified
                   ranges
    @return: pointer to resulting window

Help on function open_enums_window in module ida_kernwin:

open_enums_window(*args) -> 'TWidget *'
    open_enums_window(const_id=BADADDR) -> TWidget *
    Open the enums window (ui_open_builtin).
    
    @param const_id: (C++: tid_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_exports_window in module ida_kernwin:

open_exports_window(*args) -> 'TWidget *'
    open_exports_window(ea) -> TWidget *
    Open the exports window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_form in module ida_kernwin:

open_form(*args)
    Display a dockable modeless dialog box and return a handle to it. The modeless
    form can be closed in the following ways:
    * by pressing the small 'x' in the window title
    * by calling form_actions_t::close() from the form callback (form_actions_t)
    @note: pressing the 'Yes/No/Cancel' buttons does not close the modeless form,
           except if the form callback explicitly calls close().
    
    @return: handle to the form or nullptr. the handle can be used with TWidget

Help on function open_frame_window in module ida_kernwin:

open_frame_window(*args) -> 'TWidget *'
    open_frame_window(pfn, offset) -> TWidget *
    Open the frame window for the given function (ui_open_builtin).
    
    @param pfn: (C++: func_t *) function to analyze
    @param offset: (C++: uval_t) offset where the cursor is placed
    @return: pointer to resulting window if 'pfn' is a valid function and the window
             was displayed,
    nullptr otherwise

Help on function open_funcs_window in module ida_kernwin:

open_funcs_window(*args) -> 'TWidget *'
    open_funcs_window(ea) -> TWidget *
    Open the 'Functions' window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_hexdump_window in module ida_kernwin:

open_hexdump_window(*args) -> 'TWidget *'
    open_hexdump_window(window_title) -> TWidget *
    Open a hexdump view (ui_open_builtin).
    
    @param window_title: (C++: const char *) title of view to open
    @return: pointer to resulting window

Help on function open_imports_window in module ida_kernwin:

open_imports_window(*args) -> 'TWidget *'
    open_imports_window(ea) -> TWidget *
    Open the exports window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_loctypes_window in module ida_kernwin:

open_loctypes_window(*args) -> 'TWidget *'
    open_loctypes_window(ordinal) -> TWidget *
    Open the local types window (ui_open_builtin).
    
    @param ordinal: (C++: int) ordinal of type to select by default
    @return: pointer to resulting window

Help on function open_modules_window in module ida_kernwin:

open_modules_window(*args) -> 'TWidget *'
    open_modules_window() -> TWidget *
    Open the modules window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_names_window in module ida_kernwin:

open_names_window(*args) -> 'TWidget *'
    open_names_window(ea) -> TWidget *
    Open the names window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_navband_window in module ida_kernwin:

open_navband_window(*args) -> 'TWidget *'
    open_navband_window(ea, zoom) -> TWidget *
    Open the navigation band window (ui_open_builtin).
    
    @param ea: (C++: ea_t) sets the address of the navband arrow
    @param zoom: (C++: int) sets the navband zoom level
    @return: pointer to resulting window

Help on function open_notepad_window in module ida_kernwin:

open_notepad_window(*args) -> 'TWidget *'
    open_notepad_window() -> TWidget *
    Open the notepad window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_problems_window in module ida_kernwin:

open_problems_window(*args) -> 'TWidget *'
    open_problems_window(ea) -> TWidget *
    Open the problems window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_segments_window in module ida_kernwin:

open_segments_window(*args) -> 'TWidget *'
    open_segments_window(ea) -> TWidget *
    Open the segments window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_segregs_window in module ida_kernwin:

open_segregs_window(*args) -> 'TWidget *'
    open_segregs_window(ea) -> TWidget *
    Open the segment registers window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on function open_selectors_window in module ida_kernwin:

open_selectors_window(*args) -> 'TWidget *'
    open_selectors_window() -> TWidget *
    Open the selectors window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_signatures_window in module ida_kernwin:

open_signatures_window(*args) -> 'TWidget *'
    open_signatures_window() -> TWidget *
    Open the signatures window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_stack_window in module ida_kernwin:

open_stack_window(*args) -> 'TWidget *'
    open_stack_window() -> TWidget *
    Open the call stack window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_strings_window in module ida_kernwin:

open_strings_window(*args) -> 'TWidget *'
    open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
    Open the 'Strings' window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @param selstart: (C++: ea_t) ,selend: only display strings that occur within this range
    @param selend: (C++: ea_t)
    @return: pointer to resulting window

Help on function open_structs_window in module ida_kernwin:

open_structs_window(*args) -> 'TWidget *'
    open_structs_window(id=BADADDR, offset=0) -> TWidget *
    Open the structs window (ui_open_builtin).
    
    @param id: (C++: tid_t) index of entry to select by default
    @param offset: (C++: uval_t) offset where the cursor is placed
    @return: pointer to resulting window

Help on function open_threads_window in module ida_kernwin:

open_threads_window(*args) -> 'TWidget *'
    open_threads_window() -> TWidget *
    Open the threads window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_tils_window in module ida_kernwin:

open_tils_window(*args) -> 'TWidget *'
    open_tils_window() -> TWidget *
    Open the type libraries window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_trace_window in module ida_kernwin:

open_trace_window(*args) -> 'TWidget *'
    open_trace_window() -> TWidget *
    Open the tracing window (ui_open_builtin).
    
    @return: pointer to resulting window

Help on function open_url in module ida_kernwin:

open_url(*args) -> 'void'
    open_url(url)
    Open the given url (ui_open_url)
    
    @param url: (C++: const char *) char const *

Help on function open_xrefs_window in module ida_kernwin:

open_xrefs_window(*args) -> 'TWidget *'
    open_xrefs_window(ea) -> TWidget *
    Open the cross references window (ui_open_builtin).
    
    @param ea: (C++: ea_t) index of entry to select by default
    @return: pointer to resulting window

Help on class place_t in module ida_kernwin:

class place_t(builtins.object)
 |  Proxy of C++ place_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_place_t(...)
 |      delete_place_t(self)
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, ud)
 |      
 |      Parameters
 |      ----------
 |      ud: void *
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |      Adjust the current location to point to a displayable object. This function
 |      validates the location and makes sure that it points to an existing object. For
 |      example, if the location points to the middle of an instruction, it will be
 |      adjusted to point to the beginning of the instruction.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |      Are we at the first displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the first displayable object
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |      Clone the location.
 |      
 |      @return: a pointer to a copy of the current location in dynamic memory
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      @param t2: (C++: const place_t *) place_t const *
 |  
 |  compare2(self, *args) -> 'int'
 |      compare2(self, t2, arg3) -> int
 |      Compare two locations except line numbers (lnnum). This function is used to
 |      organize loops. For example, if the user has selected an range, its boundaries
 |      are remembered as location objects. Any operation within the selection will have
 |      the following look: for ( loc=starting_location; loc < ending_location;
 |      loc.next() ) In this loop, the comparison function is used.
 |      
 |      @param t2: (C++: const place_t *) the place to compare this one to.
 |      @param arg3: void *
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |      Copy the specified location object to the current object.
 |      
 |      @param from: (C++: const place_t *) place_t const *
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |      De-serialize into this instance. 'pptr' should be incremented by as many bytes
 |      as de-serialization consumed.
 |      
 |      @param pptr: (C++: const uchar **) pointer to a serialized representation of a place_t of this type.
 |      @return: whether de-serialization was successful
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |      Are we at the last displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the last displayable object
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |      Visit this place, possibly 'unhiding' a section of text. If entering that place
 |      required some expanding, a place_t should be returned that represents that
 |      section, plus some flags for later use by 'leave()'.
 |      
 |      @param out_flags: flags to be used together with the place_t that is returned,
 |                        in order to restore the section to its original state when
 |                        leave() is called.
 |      @return: a place_t corresponding to the beginning of the section of text that
 |               had to be expanded. That place_t's leave() will be called with the
 |               flags contained in 'out_flags' when the user navigates away from it.
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> ([str, ...], int, int, int)
 |      Generate text lines for the current location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param maxsize: (C++: int) the maximum number of lines to generate
 |      @return: number of generated lines
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |      Get the place's ID (i.e., the value returned by register_place_class())
 |      
 |      @return: the id
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |      Leave this place, possibly 'hiding' a section of text that was previously
 |      expanded (at enter()-time.)
 |      
 |      @param arg2: uint32
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |      Map a number to a location. When the user clicks on the scrollbar and drags it,
 |      we need to determine the location corresponding to the new scrollbar position.
 |      This function is used to determine it. It builds a location object for the
 |      specified 'x' and returns a pointer to it.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param x: (C++: uval_t) number to map
 |      @param lnnum: (C++: int) line number to initialize 'lnnum'
 |      @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |      Get this place type name. All instances of a given class must return the same
 |      string.
 |      
 |      @return: the place type name. Please try and pick something that is not too
 |               generic, as it might clash w/ other plugins. A good practice is to
 |               prefix the class name with the name of your plugin. E.g.,
 |               "myplugin:srcplace_t".
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |      Move to the next displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |      Move to the previous displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |      Rebase the place instance
 |      
 |      @param arg2: segm_move_infos_t const &
 |      @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |      Serialize this instance. It is fundamental that all instances of a particular
 |      subclass of of place_t occupy the same number of bytes when serialized.
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |      Map the location to an ea_t.
 |      
 |      @return: the corresponding ea_t, or BADADDR;
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |      Map the location to a number. This mapping is used to draw the vertical
 |      scrollbar.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |      
 |      @param p: place_t *
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |      
 |      @param p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum
 |  
 |  thisown
 |      The membership flag

Help on function place_t_as_enumplace_t in module ida_kernwin:

place_t_as_enumplace_t(*args) -> 'enumplace_t *'
    place_t_as_enumplace_t(p) -> enumplace_t
    
    @param p: place_t *

Help on function place_t_as_idaplace_t in module ida_kernwin:

place_t_as_idaplace_t(*args) -> 'idaplace_t *'
    place_t_as_idaplace_t(p) -> idaplace_t
    
    @param p: place_t *

Help on function place_t_as_simpleline_place_t in module ida_kernwin:

place_t_as_simpleline_place_t(*args) -> 'simpleline_place_t *'
    place_t_as_simpleline_place_t(p) -> simpleline_place_t
    
    @param p: place_t *

Help on function place_t_as_structplace_t in module ida_kernwin:

place_t_as_structplace_t(*args) -> 'structplace_t *'
    place_t_as_structplace_t(p) -> structplace_t
    
    @param p: place_t *

Help on function plgform_close in module ida_kernwin:

plgform_close(*args) -> 'void'
    plgform_close(py_link, options)
    
    @param py_link: PyObject *
    @param options: int

Help on function plgform_get_widget in module ida_kernwin:

plgform_get_widget(*args) -> 'TWidget *'
    plgform_get_widget(py_link) -> TWidget *
    
    @param py_link: PyObject *

Help on function plgform_new in module ida_kernwin:

plgform_new(*args) -> 'PyObject *'
    plgform_new() -> PyObject *

Help on function plgform_show in module ida_kernwin:

plgform_show(*args) -> 'bool'
    plgform_show(py_link, py_obj, caption, options=(0x0040 << 16)|0x00000004u) -> bool
    
    @param py_link: PyObject *
    @param py_obj: PyObject *
    @param caption: char const *
    @param options: int

Help on function process_ui_action in module ida_kernwin:

process_ui_action(*args) -> 'bool'
    process_ui_action(name, flags=0) -> bool
    Invokes an IDA UI action by name
    
    @param name: action name
    @param flags: int
    @return: Boolean

Help on function py_chooser_base_t_get_row in module ida_kernwin:

py_chooser_base_t_get_row(*args) -> 'PyObject *'
    py_chooser_base_t_get_row(chobj, n) -> PyObject *
    
    @param chobj: chooser_base_t const *
    @param n: size_t

Help on function py_get_ask_form in module ida_kernwin:

py_get_ask_form(*args) -> 'size_t'
    py_get_ask_form() -> size_t

Help on function py_get_open_form in module ida_kernwin:

py_get_open_form(*args) -> 'size_t'
    py_get_open_form() -> size_t

Help on function py_load_custom_icon_data in module ida_kernwin:

py_load_custom_icon_data(*args) -> 'int'
    py_load_custom_icon_data(data, format) -> int
    
    @param data: PyObject *
    @param format: char const *

Help on function py_load_custom_icon_fn in module ida_kernwin:

py_load_custom_icon_fn(*args) -> 'int'
    py_load_custom_icon_fn(filename) -> int
    
    @param filename: char const *

Help on function py_register_compiled_form in module ida_kernwin:

py_register_compiled_form(*args) -> 'void'
    py_register_compiled_form(py_form)
    
    @param py_form: PyObject *

Help on function py_unregister_compiled_form in module ida_kernwin:

py_unregister_compiled_form(*args) -> 'void'
    py_unregister_compiled_form(py_form)
    
    @param py_form: PyObject *

Help on function pyidag_bind in module ida_kernwin:

pyidag_bind(*args) -> 'bool'
    pyidag_bind(_self) -> bool
    
    @param self: PyObject *

Help on function pyidag_unbind in module ida_kernwin:

pyidag_unbind(*args) -> 'bool'
    pyidag_unbind(_self) -> bool
    
    @param self: PyObject *

Help on function pyscv_add_line in module ida_kernwin:

pyscv_add_line(*args) -> 'bool'
    pyscv_add_line(py_this, py_sl) -> bool
    
    @param py_this: PyObject *
    @param py_sl: PyObject *

Help on function pyscv_clear_lines in module ida_kernwin:

pyscv_clear_lines(*args) -> 'PyObject *'
    pyscv_clear_lines(py_this) -> PyObject *
    
    @param py_this: PyObject *

Help on function pyscv_close in module ida_kernwin:

pyscv_close(*args) -> 'void'
    pyscv_close(py_this)
    
    @param py_this: PyObject *

Help on function pyscv_count in module ida_kernwin:

pyscv_count(*args) -> 'size_t'
    pyscv_count(py_this) -> size_t
    
    @param py_this: PyObject *

Help on function pyscv_del_line in module ida_kernwin:

pyscv_del_line(*args) -> 'bool'
    pyscv_del_line(py_this, nline) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t

Help on function pyscv_edit_line in module ida_kernwin:

pyscv_edit_line(*args) -> 'bool'
    pyscv_edit_line(py_this, nline, py_sl) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t
    @param py_sl: PyObject *

Help on function pyscv_get_current_line in module ida_kernwin:

pyscv_get_current_line(*args) -> 'PyObject *'
    pyscv_get_current_line(py_this, mouse, notags) -> PyObject *
    
    @param py_this: PyObject *
    @param mouse: bool
    @param notags: bool

Help on function pyscv_get_current_word in module ida_kernwin:

pyscv_get_current_word(*args) -> 'PyObject *'
    pyscv_get_current_word(py_this, mouse) -> PyObject *
    
    @param py_this: PyObject *
    @param mouse: bool

Help on function pyscv_get_line in module ida_kernwin:

pyscv_get_line(*args) -> 'PyObject *'
    pyscv_get_line(py_this, nline) -> PyObject *
    
    @param py_this: PyObject *
    @param nline: size_t

Help on function pyscv_get_pos in module ida_kernwin:

pyscv_get_pos(*args) -> 'PyObject *'
    pyscv_get_pos(py_this, mouse) -> PyObject *
    
    @param py_this: PyObject *
    @param mouse: bool

Help on function pyscv_get_selection in module ida_kernwin:

pyscv_get_selection(*args) -> 'PyObject *'
    pyscv_get_selection(py_this) -> PyObject *
    
    @param py_this: PyObject *

Help on function pyscv_get_widget in module ida_kernwin:

pyscv_get_widget(*args) -> 'TWidget *'
    pyscv_get_widget(py_this) -> TWidget *
    
    @param py_this: PyObject *

Help on function pyscv_init in module ida_kernwin:

pyscv_init(*args) -> 'PyObject *'
    pyscv_init(py_link, title) -> PyObject *
    
    @param py_link: PyObject *
    @param title: char const *

Help on function pyscv_insert_line in module ida_kernwin:

pyscv_insert_line(*args) -> 'bool'
    pyscv_insert_line(py_this, nline, py_sl) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t
    @param py_sl: PyObject *

Help on function pyscv_is_focused in module ida_kernwin:

pyscv_is_focused(*args) -> 'bool'
    pyscv_is_focused(py_this) -> bool
    
    @param py_this: PyObject *

Help on function pyscv_jumpto in module ida_kernwin:

pyscv_jumpto(*args) -> 'bool'
    pyscv_jumpto(py_this, ln, x, y) -> bool
    
    @param py_this: PyObject *
    @param ln: size_t
    @param x: int
    @param y: int

Help on function pyscv_patch_line in module ida_kernwin:

pyscv_patch_line(*args) -> 'bool'
    pyscv_patch_line(py_this, nline, offs, value) -> bool
    
    @param py_this: PyObject *
    @param nline: size_t
    @param offs: size_t
    @param value: int

Help on function pyscv_refresh in module ida_kernwin:

pyscv_refresh(*args) -> 'bool'
    pyscv_refresh(py_this) -> bool
    
    @param py_this: PyObject *

Help on function pyscv_show in module ida_kernwin:

pyscv_show(*args) -> 'bool'
    pyscv_show(py_this) -> bool
    
    @param py_this: PyObject *

Help on function qcleanline in module ida_kernwin:

qcleanline(*args) -> 'qstring *'
    qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> str
    Performs some cleanup operations to a line.
    
    @param cmt_char: (C++: char) character that denotes the start of a comment:
    * the entire text is removed if the line begins with this character (ignoring
    leading spaces)
    * all text after (and including) this character is removed if flag CLNL_FINDCMT
    is set
    @param flags: (C++: uint32) a combination of line cleanup flags. defaults to CLNL_TRIM
    @return: length of line

Help on class quick_widget_commands_t in module ida_kernwin:

class quick_widget_commands_t(builtins.object)
 |  # ----------------------------------------------------------------------
 |  # This provides an alternative to register_action()+attach_action_to_popup_menu()
 |  
 |  Methods defined here:
 |  
 |  __init__(self, callback)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  add(self, caption, flags, menu_index, icon, emb, shortcut)
 |  
 |  populate_popup(self, widget, popup)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  _ah_t = <class 'ida_kernwin.quick_widget_commands_t._ah_t'>
 |  
 |  
 |  _cmd_t = <class 'ida_kernwin.quick_widget_commands_t._cmd_t'>

Help on function read_range_selection in module ida_kernwin:

read_range_selection(*args) -> 'ea_t *, ea_t *'
    read_range_selection(v) -> bool
    Get the address range for the selected range boundaries, this is the convenient
    function for read_selection()
    
    @param v: (C++: TWidget *) view, nullptr means the last active window containing addresses
    @retval 0: no range is selected
    @retval 1: ok, start ea and end ea are filled

Help on function read_selection in module ida_kernwin:

read_selection(*args) -> 'bool'
    read_selection(v, p1, p2) -> bool
    Read the user selection, and store its information in p0 (from) and p1 (to).
    
    This can be used as follows:
    
    
    >>> p0 = idaapi.twinpos_t()
    p1 = idaapi.twinpos_t()
    view = idaapi.get_current_viewer()
    idaapi.read_selection(view, p0, p1)
    
    
    At that point, p0 and p1 hold information for the selection.
    But, the 'at' property of p0 and p1 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p0.place(view)
    place1 = p1.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    @param view: The view to retrieve the selection for.
    @param p1: Storage for the "to" part of the selection.
    @param p1: Storage for the "to" part of the selection.
    @return: a bool value indicating success.

Help on function refresh_chooser in module ida_kernwin:

refresh_chooser(*args) -> 'bool'
    refresh_chooser(title) -> bool
    Mark a non-modal custom chooser for a refresh (ui_refresh_chooser).
    
    @param title: (C++: const char *) title of chooser
    @return: success

Help on function refresh_choosers in module ida_kernwin:

refresh_choosers(*args) -> 'void'
    refresh_choosers()

Help on function refresh_custom_viewer in module ida_kernwin:

refresh_custom_viewer(*args) -> 'void'
    refresh_custom_viewer(custom_viewer)
    Refresh custom ida viewer (ui_refresh_custom_viewer)
    
    @param custom_viewer: (C++: TWidget *)

Help on function refresh_idaview in module ida_kernwin:

refresh_idaview(*args) -> 'void'
    refresh_idaview()
    Refresh marked windows (ui_refreshmarked)

Help on function refresh_idaview_anyway in module ida_kernwin:

refresh_idaview_anyway(*args) -> 'void'
    refresh_idaview_anyway()
    Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please
    consider request_refresh() instead

Help on function refresh_navband in module ida_kernwin:

refresh_navband(*args) -> 'void'
    refresh_navband(force)
    Refresh navigation band if changed (ui_refresh_navband).
    
    @param force: (C++: bool) refresh regardless

Help on function register_action in module ida_kernwin:

register_action(*args) -> 'bool'
    register_action(desc) -> bool
    Create a new action (ui_register_action). After an action has been created, it
    is possible to attach it to menu items (attach_action_to_menu()), or to popup
    menus (attach_action_to_popup()).
    
    Because the actions will need to call the handler's activate() and update()
    methods at any time, you shouldn't build your action handler on the stack.
    
    Please see the SDK's "ht_view" plugin for an example how to register actions.
    
    @param desc: (C++: const action_desc_t &) action to register
    @return: success

Help on function register_addon in module ida_kernwin:

register_addon(*args) -> 'int'
    register_addon(info) -> int
    Register an add-on. Show its info in the About box. For plugins, should be
    called from init() function (repeated calls with the same product code overwrite
    previous entries) returns: index of the add-on in the list, or -1 on error
    
    @param info: (C++: const addon_info_t *) addon_info_t const *

Help on function register_and_attach_to_menu in module ida_kernwin:

register_and_attach_to_menu(*args) -> 'bool'
    register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner, action_desc_t_flags) -> bool
    Helper.
    
    You are not encouraged to use this, as it mixes flags for both
    register_action(), and attach_action_to_menu().
    
    The only reason for its existence is to make it simpler to port existing plugins
    to the new actions API.
    
    @param menupath: (C++: const char *) char const *
    @param name: (C++: const char *) char const *
    @param label: (C++: const char *) char const *
    @param shortcut: (C++: const char *) char const *
    @param flags: (C++: int)
    @param handler: (C++: action_handler_t *)
    @param owner: (C++: void *)
    @param action_desc_t_flags: (C++: int)

Help on function register_timer in module ida_kernwin:

register_timer(*args) -> 'PyObject *'
    register_timer(interval, py_callback) -> PyCapsule
    Register a timer
    
    @param interval: Interval in milliseconds
    @param py_callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    @return: None or a timer object

Help on function remove_command_interpreter in module ida_kernwin:

remove_command_interpreter(*args) -> 'void'
    remove_command_interpreter(cli_idx)
    Remove command line interpreter (ui_install_cli)
    
    @param cli_idx: int

Help on class renderer_pos_info_t in module ida_kernwin:

class renderer_pos_info_t(builtins.object)
 |  Proxy of C++ renderer_pos_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: renderer_pos_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_pos_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: renderer_pos_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_renderer_pos_info_t(...)
 |      delete_renderer_pos_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cx
 |      cx
 |  
 |  cy
 |      cy
 |  
 |  node
 |      node
 |  
 |  sx
 |      sx
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function repaint_custom_viewer in module ida_kernwin:

repaint_custom_viewer(*args) -> 'void'
    repaint_custom_viewer(custom_viewer)
    Repaint the given widget immediately (ui_repaint_qwidget)
    
    @param custom_viewer: (C++: TWidget *)

Help on function replace_wait_box in module ida_kernwin:

replace_wait_box(*args) -> 'void'
    replace_wait_box(format)
    Replace the label of "Please wait dialog box".
    
    @param format: (C++: const char *) char const *

Help on function request_refresh in module ida_kernwin:

request_refresh(*args) -> 'void'
    request_refresh(mask, cnd=True)
    Request a refresh of a builtin window.
    
    @param mask: (C++: uint64) Window refresh flags
    @param cnd: (C++: bool) set if true or clear flag otherwise

Help on function restore_database_snapshot in module ida_kernwin:

restore_database_snapshot(*args) -> 'PyObject *'
    restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> bool
    Restore a database snapshot. Note: This call is asynchronous. When it is
    completed, the callback will be triggered.
    
    @param ss: (C++: const snapshot_t *) snapshot instance (see build_snapshot_tree())
    @param pyfunc_or_none: PyObject *
    @param pytuple_or_none: PyObject *
    @return: false if restoration could not be started (snapshot file was not
             found).
    If the returned value is True then check if the operation succeeded from the
    callback.

Help on class section_lines_refs_t in module ida_kernwin:

class section_lines_refs_t(builtins.object)
 |  Proxy of C++ qvector< twinline_t const * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< twinline_t const * > const &
 |  
 |  __getitem__(self, *args) -> 'twinline_t const *const &'
 |      __getitem__(self, i) -> twinline_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> section_lines_refs_t
 |      __init__(self, x) -> section_lines_refs_t
 |      
 |      @param x: qvector< twinline_t const * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< twinline_t const * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: twinline_t const *const &
 |  
 |  __swig_destroy__ = delete_section_lines_refs_t(...)
 |      delete_section_lines_refs_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: twinline_t const *const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: twinline_t const *const &
 |  
 |  at(self, *args) -> 'twinline_t const *const &'
 |      at(self, _idx) -> twinline_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< twinline_t const * >::const_iterator'
 |      begin(self) -> qvector< twinline_t const * >::iterator
 |      begin(self) -> qvector< twinline_t const * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< twinline_t const * >::const_iterator'
 |      end(self) -> qvector< twinline_t const * >::iterator
 |      end(self) -> qvector< twinline_t const * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< twinline_t const * >::iterator'
 |      erase(self, it) -> qvector< twinline_t const * >::iterator
 |      
 |      @param it: qvector< twinline_t const * >::iterator
 |      
 |      erase(self, first, last) -> qvector< twinline_t const * >::iterator
 |      
 |      @param first: qvector< twinline_t const * >::iterator
 |      @param last: qvector< twinline_t const * >::iterator
 |  
 |  extract(self, *args) -> 'twinline_t const **'
 |      extract(self) -> twinline_t const **
 |  
 |  find(self, *args) -> 'qvector< twinline_t const * >::const_iterator'
 |      find(self, x) -> qvector< twinline_t const * >::iterator
 |      
 |      @param x: twinline_t const *const &
 |      
 |      find(self, x) -> qvector< twinline_t const * >::const_iterator
 |      
 |      @param x: twinline_t const *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: twinline_t const *const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: twinline_t const **
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< twinline_t const * >::iterator'
 |      insert(self, it, x) -> qvector< twinline_t const * >::iterator
 |      
 |      @param it: qvector< twinline_t const * >::iterator
 |      @param x: twinline_t const *const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'twinline_t const *&'
 |      push_back(self, x)
 |      
 |      @param x: twinline_t const *const &
 |      
 |      push_back(self) -> twinline_t const *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: twinline_t const *const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< twinline_t const * > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class sections_lines_refs_t in module ida_kernwin:

class sections_lines_refs_t(builtins.object)
 |  Proxy of C++ qvector< section_lines_refs_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< section_lines_refs_t > const &
 |  
 |  __getitem__(self, *args) -> 'section_lines_refs_t const &'
 |      __getitem__(self, i) -> section_lines_refs_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sections_lines_refs_t
 |      __init__(self, x) -> sections_lines_refs_t
 |      
 |      @param x: qvector< section_lines_refs_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< section_lines_refs_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: section_lines_refs_t const &
 |  
 |  __swig_destroy__ = delete_sections_lines_refs_t(...)
 |      delete_sections_lines_refs_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: section_lines_refs_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: section_lines_refs_t const &
 |  
 |  at(self, *args) -> 'section_lines_refs_t const &'
 |      at(self, _idx) -> section_lines_refs_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< section_lines_refs_t >::const_iterator'
 |      begin(self) -> qvector< section_lines_refs_t >::iterator
 |      begin(self) -> qvector< section_lines_refs_t >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< section_lines_refs_t >::const_iterator'
 |      end(self) -> qvector< section_lines_refs_t >::iterator
 |      end(self) -> qvector< section_lines_refs_t >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< section_lines_refs_t >::iterator'
 |      erase(self, it) -> qvector< section_lines_refs_t >::iterator
 |      
 |      @param it: qvector< section_lines_refs_t >::iterator
 |      
 |      erase(self, first, last) -> qvector< section_lines_refs_t >::iterator
 |      
 |      @param first: qvector< section_lines_refs_t >::iterator
 |      @param last: qvector< section_lines_refs_t >::iterator
 |  
 |  extract(self, *args) -> 'section_lines_refs_t *'
 |      extract(self) -> section_lines_refs_t
 |  
 |  find(self, *args) -> 'qvector< section_lines_refs_t >::const_iterator'
 |      find(self, x) -> qvector< section_lines_refs_t >::iterator
 |      
 |      @param x: section_lines_refs_t const &
 |      
 |      find(self, x) -> qvector< section_lines_refs_t >::const_iterator
 |      
 |      @param x: section_lines_refs_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=section_lines_refs_t())
 |      
 |      @param x: section_lines_refs_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: section_lines_refs_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: section_lines_refs_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< section_lines_refs_t >::iterator'
 |      insert(self, it, x) -> qvector< section_lines_refs_t >::iterator
 |      
 |      @param it: qvector< section_lines_refs_t >::iterator
 |      @param x: section_lines_refs_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'section_lines_refs_t &'
 |      push_back(self, x)
 |      
 |      @param x: section_lines_refs_t const &
 |      
 |      push_back(self) -> section_lines_refs_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: section_lines_refs_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< section_lines_refs_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function set_cancelled in module ida_kernwin:

set_cancelled(*args) -> 'void'
    set_cancelled()
    Set "Cancelled" flag (ui_set_cancelled)

Help on function set_code_viewer_handler in module ida_kernwin:

set_code_viewer_handler(*args) -> 'void *'
    set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
    Set a handler for a code viewer event (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *) the code viewer
    @param handler_id: (C++: custom_viewer_handler_id_t) one of CDVH_ in custom_viewer_handler_id_t
    @param handler_or_data: (C++: void *) can be a handler or data. see examples in Functions:
                            custom viewer handlers
    @return: old value of the handler or data

Help on function set_code_viewer_is_source in module ida_kernwin:

set_code_viewer_is_source(*args) -> 'bool'
    set_code_viewer_is_source(code_viewer) -> bool
    Specify that the given code viewer is used to display source code
    (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)

Help on function set_code_viewer_line_handlers in module ida_kernwin:

set_code_viewer_line_handlers(*args) -> 'void'
    set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
    Set handlers for code viewer line events. Any of these handlers may be nullptr
    
    @param code_viewer: (C++: TWidget *)
    @param click_handler: (C++: code_viewer_lines_click_t *)
    @param popup_handler: (C++: code_viewer_lines_click_t *)
    @param dblclick_handler: (C++: code_viewer_lines_click_t *)
    @param drawicon_handler: (C++: code_viewer_lines_icon_t *)
    @param linenum_handler: (C++: code_viewer_lines_linenum_t *)

Help on function set_code_viewer_lines_alignment in module ida_kernwin:

set_code_viewer_lines_alignment(*args) -> 'bool'
    set_code_viewer_lines_alignment(code_viewer, align) -> bool
    Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param align: (C++: int)

Help on function set_code_viewer_lines_icon_margin in module ida_kernwin:

set_code_viewer_lines_icon_margin(*args) -> 'bool'
    set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
    Set space allowed for icons in the margin of a code viewer
    (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param margin: (C++: int)

Help on function set_code_viewer_lines_radix in module ida_kernwin:

set_code_viewer_lines_radix(*args) -> 'bool'
    set_code_viewer_lines_radix(code_viewer, radix) -> bool
    Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param radix: (C++: int)

Help on function set_code_viewer_user_data in module ida_kernwin:

set_code_viewer_user_data(*args) -> 'bool'
    set_code_viewer_user_data(code_viewer, ud) -> bool
    Set the user data on a code viewer (ui_set_custom_viewer_handler).
    
    @param code_viewer: (C++: TWidget *)
    @param ud: (C++: void *)

Help on function set_custom_viewer_qt_aware in module ida_kernwin:

set_custom_viewer_qt_aware(*args) -> 'bool'
    set_custom_viewer_qt_aware(custom_viewer) -> bool
    Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)
    
    @param custom_viewer: (C++: TWidget *)

Help on function set_dock_pos in module ida_kernwin:

set_dock_pos(*args) -> 'bool'
    set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool
    Sets the dock orientation of a window relatively to another window.
    
    Use the left, top, right, bottom parameters if DP_FLOATING is used,
    or if you want to specify the width of docked windows.
    
    @param src_ctrl: char const *
    @param dest_ctrl: char const *
    @param orient: One of DP_XXXX constants
    @param left: int
    @param top: int
    @param right: int
    @param bottom: int
    @return: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window

Help on function set_highlight in module ida_kernwin:

set_highlight(*args) -> 'bool'
    set_highlight(viewer, str, flags) -> bool
    Set the highlighted identifier in the viewer (ui_set_highlight).
    
    @param viewer: (C++: TWidget *) the viewer
    @param str: (C++: const char *) the text to match, or nullptr to remove current
    @param flags: (C++: int) combination of HIF_... bits (see set_highlight flags)
    @return: false if an error occurred

Help on function set_nav_colorizer in module ida_kernwin:

set_nav_colorizer(*args) -> 'PyObject *'
    set_nav_colorizer(new_py_colorizer) -> dict or None
    Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)
    
    @param new_py_colorizer: PyObject *

Help on function set_view_renderer_type in module ida_kernwin:

set_view_renderer_type(*args) -> 'void'
    set_view_renderer_type(v, rt)
    Set the type of renderer to use in a view (ui_set_renderer_type)
    
    @param v: (C++: TWidget *)
    @param rt: (C++: tcc_renderer_type_t) enum tcc_renderer_type_t

Help on function show_wait_box in module ida_kernwin:

show_wait_box(*args) -> 'void'
    show_wait_box(message)
    Display a dialog box with "Please wait...". If the text message starts with
    "HIDECANCEL\n", the cancel button
    won't be added to the dialog box and user_cancelled() will always
    return false (but can be caled to refresh UI).
    Plugins must call hide_wait_box() to close the dialog box, otherwise
    the user interface will remain disabled.
    Note that, if the wait dialog is already visible, show_wait_box() will
    1) push the currently-displayed text on a stack
    2) display the new text
    Then, when hide_wait_box() is called, if that stack isn't empty its top
    label will be popped and restored in the wait dialog.
    This implies that a plugin should call hide_wait_box() exactly as many
    times as it called show_wait_box(), or the wait dialog might remain
    visible and block the UI.
    Also, in case the plugin knows the wait dialog is currently displayed,
    alternatively it can call replace_wait_box(), to replace the text of the
    dialog without pushing the currently-displayed text on the stack.
    
    @param message: char const *

Help on class simplecustviewer_t in module ida_kernwin:

class simplecustviewer_t(builtins.object)
 |  The base class for implementing simple custom viewers
 |  
 |  Methods defined here:
 |  
 |  AddLine(self, line, fgcolor=None, bgcolor=None)
 |      Adds a colored line to the view
 |      @return: Boolean
 |  
 |  ClearLines(self)
 |      Clears all the lines
 |  
 |  Close(self)
 |      Destroys the view.
 |      One has to call Create() afterwards.
 |      Show() can be called and it will call Create() internally.
 |      @return: Boolean
 |  
 |  Count(self)
 |      Returns the number of lines in the view
 |  
 |  Create(self, title)
 |      Creates the custom view. This should be the first method called after instantiation
 |      
 |      @param title: The title of the view
 |      @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
 |               In this case better close existing windows
 |  
 |  DelLine(self, lineno)
 |      Deletes an existing line
 |      @return: Boolean
 |  
 |  EditLine(self, lineno, line, fgcolor=None, bgcolor=None)
 |      Edits an existing line.
 |      @return: Boolean
 |  
 |  GetCurrentLine(self, mouse=0, notags=0)
 |      Returns the current line.
 |      @param mouse: Current line at mouse pos
 |      @param notags: If True then tag_remove() will be called before returning the line
 |      @return: Returns the current line (colored or uncolored) or None on failure
 |  
 |  GetCurrentWord(self, mouse=0)
 |      Returns the current word
 |      @param mouse: Use mouse position or cursor position
 |      @return: None if failed or a String containing the current word at mouse or cursor
 |  
 |  GetLine(self, lineno)
 |      Returns a line
 |      @param lineno: The line number
 |      @return:     Returns a tuple (colored_line, fgcolor, bgcolor) or None
 |  
 |  GetLineNo(self, mouse=0)
 |      Calls GetPos() and returns the current line number or -1 on failure
 |  
 |  GetPos(self, mouse=0)
 |      Returns the current cursor or mouse position.
 |      @param mouse: return mouse position
 |      @return: Returns a tuple (lineno, x, y)
 |  
 |  GetSelection(self)
 |      Returns the selected range or None
 |      @return:     - tuple(x1, y1, x2, y2)
 |          - None if no selection
 |  
 |  GetWidget(self)
 |      Return the TWidget underlying this view.
 |      
 |      @return: The TWidget underlying this view, or None.
 |  
 |  InsertLine(self, lineno, line, fgcolor=None, bgcolor=None)
 |      Inserts a line in the given position
 |      @return: Boolean
 |  
 |  IsFocused(self)
 |      Returns True if the current view is the focused view
 |  
 |  Jump(self, lineno, x=0, y=0)
 |  
 |  OnPopup(self, form, popup_handle)
 |      Context menu popup is about to be shown. Create items dynamically if you wish
 |      @return: Boolean. True if you handled the event
 |  
 |  PatchLine(self, lineno, offs, value)
 |      Patches an existing line character at the given offset. This is a low level function. You must know what you're doing
 |  
 |  Refresh(self)
 |  
 |  RefreshCurrent(self)
 |      Refreshes the current line only
 |  
 |  Show(self)
 |      Shows an already created view. It the view was close, then it will call Create() for you
 |      @return: Boolean
 |  
 |  __init__(self)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  _simplecustviewer_t__make_sl_arg = __make_sl_arg(line, fgcolor=None, bgcolor=None)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  UI_Hooks_Trampoline = <class 'ida_kernwin.simplecustviewer_t.UI_Hooks_...
 |      Proxy of C++ UI_Hooks class.

Help on class simpleline_place_t in module ida_kernwin:

class simpleline_place_t(place_t)
 |  Proxy of C++ simpleline_place_t class.
 |  
 |  Method resolution order:
 |      simpleline_place_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simpleline_place_t(...)
 |      delete_simpleline_place_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  n
 |      n
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, ud)
 |      
 |      Parameters
 |      ----------
 |      ud: void *
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |      Adjust the current location to point to a displayable object. This function
 |      validates the location and makes sure that it points to an existing object. For
 |      example, if the location points to the middle of an instruction, it will be
 |      adjusted to point to the beginning of the instruction.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |      Are we at the first displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the first displayable object
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |      Clone the location.
 |      
 |      @return: a pointer to a copy of the current location in dynamic memory
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      @param t2: (C++: const place_t *) place_t const *
 |  
 |  compare2(self, *args) -> 'int'
 |      compare2(self, t2, arg3) -> int
 |      Compare two locations except line numbers (lnnum). This function is used to
 |      organize loops. For example, if the user has selected an range, its boundaries
 |      are remembered as location objects. Any operation within the selection will have
 |      the following look: for ( loc=starting_location; loc < ending_location;
 |      loc.next() ) In this loop, the comparison function is used.
 |      
 |      @param t2: (C++: const place_t *) the place to compare this one to.
 |      @param arg3: void *
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |      Copy the specified location object to the current object.
 |      
 |      @param from: (C++: const place_t *) place_t const *
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |      De-serialize into this instance. 'pptr' should be incremented by as many bytes
 |      as de-serialization consumed.
 |      
 |      @param pptr: (C++: const uchar **) pointer to a serialized representation of a place_t of this type.
 |      @return: whether de-serialization was successful
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |      Are we at the last displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the last displayable object
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |      Visit this place, possibly 'unhiding' a section of text. If entering that place
 |      required some expanding, a place_t should be returned that represents that
 |      section, plus some flags for later use by 'leave()'.
 |      
 |      @param out_flags: flags to be used together with the place_t that is returned,
 |                        in order to restore the section to its original state when
 |                        leave() is called.
 |      @return: a place_t corresponding to the beginning of the section of text that
 |               had to be expanded. That place_t's leave() will be called with the
 |               flags contained in 'out_flags' when the user navigates away from it.
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> ([str, ...], int, int, int)
 |      Generate text lines for the current location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param maxsize: (C++: int) the maximum number of lines to generate
 |      @return: number of generated lines
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |      Get the place's ID (i.e., the value returned by register_place_class())
 |      
 |      @return: the id
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |      Leave this place, possibly 'hiding' a section of text that was previously
 |      expanded (at enter()-time.)
 |      
 |      @param arg2: uint32
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |      Map a number to a location. When the user clicks on the scrollbar and drags it,
 |      we need to determine the location corresponding to the new scrollbar position.
 |      This function is used to determine it. It builds a location object for the
 |      specified 'x' and returns a pointer to it.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param x: (C++: uval_t) number to map
 |      @param lnnum: (C++: int) line number to initialize 'lnnum'
 |      @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |      Get this place type name. All instances of a given class must return the same
 |      string.
 |      
 |      @return: the place type name. Please try and pick something that is not too
 |               generic, as it might clash w/ other plugins. A good practice is to
 |               prefix the class name with the name of your plugin. E.g.,
 |               "myplugin:srcplace_t".
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |      Move to the next displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |      Move to the previous displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |      Rebase the place instance
 |      
 |      @param arg2: segm_move_infos_t const &
 |      @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |      Serialize this instance. It is fundamental that all instances of a particular
 |      subclass of of place_t occupy the same number of bytes when serialized.
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |      Map the location to an ea_t.
 |      
 |      @return: the corresponding ea_t, or BADADDR;
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |      Map the location to a number. This mapping is used to draw the vertical
 |      scrollbar.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |      
 |      @param p: place_t *
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |      
 |      @param p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum

Help on class simpleline_t in module ida_kernwin:

class simpleline_t(builtins.object)
 |  Proxy of C++ simpleline_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> simpleline_t
 |      __init__(self, c, str) -> simpleline_t
 |      
 |      @param c: color_t
 |      @param str: char const *
 |      
 |      __init__(self, str) -> simpleline_t
 |      
 |      @param str: char const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simpleline_t(...)
 |      delete_simpleline_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bgcolor
 |      bgcolor
 |  
 |  color
 |      color
 |  
 |  line
 |      line
 |  
 |  thisown
 |      The membership flag

Help on function str2ea in module ida_kernwin:

str2ea(*args) -> 'ea_t'
    str2ea(str, screenEA=BADADDR) -> ea_t
    Converts a string express to EA. The expression evaluator may be called as well.
    
    @param str: char const *
    @param screenEA: ea_t
    @return: BADADDR or address value

Help on function str2user in module ida_pro:

str2user(*args) -> 'PyObject *'
    str2user(str) -> str or None
    Insert C-style escape characters to string
    
    @param str: char const *
    @return: new string with escape characters inserted

Help on function strarray in module ida_kernwin:

strarray(*args) -> 'char const *'
    strarray(array, array_size, code) -> char const *
    Find a line with the specified code in the strarray_t array. If the last element
    of the array has code==0 then it is considered as the default entry.
    If no default entry exists and the code is not found, strarray() returns "".
    
    @param array: (C++: const strarray_t *) strarray_t const *
    @param array_size: (C++: size_t)
    @param code: (C++: int)

Help on class strarray_t in module ida_kernwin:

class strarray_t(builtins.object)
 |  Proxy of C++ strarray_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strarray_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_strarray_t(...)
 |      delete_strarray_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  code
 |      code
 |  
 |  text
 |      text
 |  
 |  thisown
 |      The membership flag

Help on class structplace_t in module ida_kernwin:

class structplace_t(place_t)
 |  Proxy of C++ structplace_t class.
 |  
 |  Method resolution order:
 |      structplace_t
 |      place_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_structplace_t(...)
 |      delete_structplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  idx
 |      idx
 |  
 |  offset
 |      offset
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from place_t:
 |  
 |  _print(self, *args) -> 'void'
 |      _print(self, ud)
 |      
 |      Parameters
 |      ----------
 |      ud: void *
 |  
 |  adjust(self, *args) -> 'void'
 |      adjust(self, ud)
 |      Adjust the current location to point to a displayable object. This function
 |      validates the location and makes sure that it points to an existing object. For
 |      example, if the location points to the middle of an instruction, it will be
 |      adjusted to point to the beginning of the instruction.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  beginning(self, *args) -> 'bool'
 |      beginning(self, ud) -> bool
 |      Are we at the first displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the first displayable object
 |  
 |  clone(self, *args) -> 'place_t *'
 |      clone(self) -> place_t
 |      Clone the location.
 |      
 |      @return: a pointer to a copy of the current location in dynamic memory
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, t2) -> int
 |      Deprecated. Please consider compare2(const place_t *, void *) instead.
 |      
 |      @param t2: (C++: const place_t *) place_t const *
 |  
 |  compare2(self, *args) -> 'int'
 |      compare2(self, t2, arg3) -> int
 |      Compare two locations except line numbers (lnnum). This function is used to
 |      organize loops. For example, if the user has selected an range, its boundaries
 |      are remembered as location objects. Any operation within the selection will have
 |      the following look: for ( loc=starting_location; loc < ending_location;
 |      loc.next() ) In this loop, the comparison function is used.
 |      
 |      @param t2: (C++: const place_t *) the place to compare this one to.
 |      @param arg3: void *
 |  
 |  copyfrom(self, *args) -> 'void'
 |      copyfrom(self, _from)
 |      Copy the specified location object to the current object.
 |      
 |      @param from: (C++: const place_t *) place_t const *
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, _in) -> bool
 |      De-serialize into this instance. 'pptr' should be incremented by as many bytes
 |      as de-serialization consumed.
 |      
 |      @param pptr: (C++: const uchar **) pointer to a serialized representation of a place_t of this type.
 |      @return: whether de-serialization was successful
 |  
 |  ending(self, *args) -> 'bool'
 |      ending(self, ud) -> bool
 |      Are we at the last displayable object?.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: true if the current location points to the last displayable object
 |  
 |  enter(self, *args) -> 'place_t *'
 |      enter(self, arg2) -> place_t
 |      Visit this place, possibly 'unhiding' a section of text. If entering that place
 |      required some expanding, a place_t should be returned that represents that
 |      section, plus some flags for later use by 'leave()'.
 |      
 |      @param out_flags: flags to be used together with the place_t that is returned,
 |                        in order to restore the section to its original state when
 |                        leave() is called.
 |      @return: a place_t corresponding to the beginning of the section of text that
 |               had to be expanded. That place_t's leave() will be called with the
 |               flags contained in 'out_flags' when the user navigates away from it.
 |  
 |  generate(self, *args) -> 'PyObject *'
 |      generate(self, ud, maxsize) -> ([str, ...], int, int, int)
 |      Generate text lines for the current location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param maxsize: (C++: int) the maximum number of lines to generate
 |      @return: number of generated lines
 |  
 |  id(self, *args) -> 'int'
 |      id(self) -> int
 |      Get the place's ID (i.e., the value returned by register_place_class())
 |      
 |      @return: the id
 |  
 |  leave(self, *args) -> 'void'
 |      leave(self, arg2)
 |      Leave this place, possibly 'hiding' a section of text that was previously
 |      expanded (at enter()-time.)
 |      
 |      @param arg2: uint32
 |  
 |  makeplace(self, *args) -> 'place_t *'
 |      makeplace(self, ud, x, lnnum) -> place_t
 |      Map a number to a location. When the user clicks on the scrollbar and drags it,
 |      we need to determine the location corresponding to the new scrollbar position.
 |      This function is used to determine it. It builds a location object for the
 |      specified 'x' and returns a pointer to it.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @param x: (C++: uval_t) number to map
 |      @param lnnum: (C++: int) line number to initialize 'lnnum'
 |      @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
 |  
 |  name(self, *args) -> 'char const *'
 |      name(self) -> char const *
 |      Get this place type name. All instances of a given class must return the same
 |      string.
 |      
 |      @return: the place type name. Please try and pick something that is not too
 |               generic, as it might clash w/ other plugins. A good practice is to
 |               prefix the class name with the name of your plugin. E.g.,
 |               "myplugin:srcplace_t".
 |  
 |  next(self, *args) -> 'bool'
 |      next(self, ud) -> bool
 |      Move to the next displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self, ud) -> bool
 |      Move to the previous displayable location.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |      @return: success
 |  
 |  rebase(self, *args) -> 'bool'
 |      rebase(self, arg2) -> bool
 |      Rebase the place instance
 |      
 |      @param arg2: segm_move_infos_t const &
 |      @return: true if place was rebased, false otherwise
 |  
 |  serialize(self, *args) -> 'void'
 |      serialize(self)
 |      Serialize this instance. It is fundamental that all instances of a particular
 |      subclass of of place_t occupy the same number of bytes when serialized.
 |  
 |  toea(self, *args) -> 'ea_t'
 |      toea(self) -> ea_t
 |      Map the location to an ea_t.
 |      
 |      @return: the corresponding ea_t, or BADADDR;
 |  
 |  touval(self, *args) -> 'uval_t'
 |      touval(self, ud) -> uval_t
 |      Map the location to a number. This mapping is used to draw the vertical
 |      scrollbar.
 |      
 |      @param ud: (C++: void *) pointer to user-defined context data. Is supplied by linearray_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from place_t:
 |  
 |  as_enumplace_t(*args) -> 'enumplace_t *'
 |      as_enumplace_t(p) -> enumplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_idaplace_t(*args) -> 'idaplace_t *'
 |      as_idaplace_t(p) -> idaplace_t
 |      
 |      @param p: place_t *
 |  
 |  as_simpleline_place_t(*args) -> 'simpleline_place_t *'
 |      as_simpleline_place_t(p) -> simpleline_place_t
 |      
 |      @param p: place_t *
 |  
 |  as_structplace_t(*args) -> 'structplace_t *'
 |      as_structplace_t(p) -> structplace_t
 |      
 |      @param p: place_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from place_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  lnnum
 |      lnnum

Help on class sync_source_t in module ida_kernwin:

class sync_source_t(builtins.object)
 |  Proxy of C++ sync_source_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, _o) -> bool
 |      
 |      @param _o: sync_source_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _view) -> sync_source_t
 |      
 |      @param _view: TWidget const *
 |      
 |      __init__(self, _regname) -> sync_source_t
 |      
 |      @param _regname: char const *
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, _o) -> bool
 |      
 |      @param _o: sync_source_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sync_source_t(...)
 |      delete_sync_source_t(self)
 |  
 |  get_register(self, *args) -> 'char const *'
 |      get_register(self) -> char const *
 |  
 |  get_widget(self, *args) -> 'TWidget const *'
 |      get_widget(self) -> TWidget const *
 |  
 |  is_register(self, *args) -> 'bool'
 |      is_register(self) -> bool
 |  
 |  is_widget(self, *args) -> 'bool'
 |      is_widget(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class sync_source_vec_t in module ida_kernwin:

class sync_source_vec_t(builtins.object)
 |  Proxy of C++ qvector< sync_source_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< sync_source_t > const &
 |  
 |  __getitem__(self, *args) -> 'sync_source_t const &'
 |      __getitem__(self, i) -> sync_source_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sync_source_vec_t
 |      __init__(self, x) -> sync_source_vec_t
 |      
 |      @param x: qvector< sync_source_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< sync_source_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: sync_source_t const &
 |  
 |  __swig_destroy__ = delete_sync_source_vec_t(...)
 |      delete_sync_source_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: sync_source_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: sync_source_t const &
 |  
 |  at(self, *args) -> 'sync_source_t const &'
 |      at(self, _idx) -> sync_source_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< sync_source_t >::const_iterator'
 |      begin(self) -> sync_source_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< sync_source_t >::const_iterator'
 |      end(self) -> sync_source_t
 |  
 |  erase(self, *args) -> 'qvector< sync_source_t >::iterator'
 |      erase(self, it) -> sync_source_t
 |      
 |      @param it: qvector< sync_source_t >::iterator
 |      
 |      erase(self, first, last) -> sync_source_t
 |      
 |      @param first: qvector< sync_source_t >::iterator
 |      @param last: qvector< sync_source_t >::iterator
 |  
 |  extract(self, *args) -> 'sync_source_t *'
 |      extract(self) -> sync_source_t
 |  
 |  find(self, *args) -> 'qvector< sync_source_t >::const_iterator'
 |      find(self, x) -> sync_source_t
 |      
 |      @param x: sync_source_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: sync_source_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: sync_source_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< sync_source_t >::iterator'
 |      insert(self, it, x) -> sync_source_t
 |      
 |      @param it: qvector< sync_source_t >::iterator
 |      @param x: sync_source_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'void'
 |      push_back(self, x)
 |      
 |      @param x: sync_source_t const &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< sync_source_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function sync_sources in module ida_kernwin:

sync_sources(*args) -> 'bool'
    sync_sources(what, _with, sync) -> bool
    [Un]synchronize sources
    
    @param what: (C++: const sync_source_t &)
    @param with: (C++: const sync_source_t &)
    @param sync: (C++: bool)
    @return: success

Help on class synced_group_t in module ida_kernwin:

class synced_group_t(sync_source_vec_t)
 |  Proxy of C++ synced_group_t class.
 |  
 |  Method resolution order:
 |      synced_group_t
 |      sync_source_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> synced_group_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_synced_group_t(...)
 |      delete_synced_group_t(self)
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, ss) -> bool
 |      
 |      @param ss: sync_source_t const &
 |  
 |  has_register(self, *args) -> 'bool'
 |      has_register(self, r) -> bool
 |      
 |      @param r: char const *
 |  
 |  has_widget(self, *args) -> 'bool'
 |      has_widget(self, v) -> bool
 |      
 |      @param v: TWidget const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sync_source_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< sync_source_t > const &
 |  
 |  __getitem__(self, *args) -> 'sync_source_t const &'
 |      __getitem__(self, i) -> sync_source_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< sync_source_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: sync_source_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: sync_source_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: sync_source_t const &
 |  
 |  at(self, *args) -> 'sync_source_t const &'
 |      at(self, _idx) -> sync_source_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< sync_source_t >::const_iterator'
 |      begin(self) -> sync_source_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< sync_source_t >::const_iterator'
 |      end(self) -> sync_source_t
 |  
 |  erase(self, *args) -> 'qvector< sync_source_t >::iterator'
 |      erase(self, it) -> sync_source_t
 |      
 |      @param it: qvector< sync_source_t >::iterator
 |      
 |      erase(self, first, last) -> sync_source_t
 |      
 |      @param first: qvector< sync_source_t >::iterator
 |      @param last: qvector< sync_source_t >::iterator
 |  
 |  extract(self, *args) -> 'sync_source_t *'
 |      extract(self) -> sync_source_t
 |  
 |  find(self, *args) -> 'qvector< sync_source_t >::const_iterator'
 |      find(self, x) -> sync_source_t
 |      
 |      @param x: sync_source_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: sync_source_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< sync_source_t >::iterator'
 |      insert(self, it, x) -> sync_source_t
 |      
 |      @param it: qvector< sync_source_t >::iterator
 |      @param x: sync_source_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'void'
 |      push_back(self, x)
 |      
 |      @param x: sync_source_t const &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< sync_source_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from sync_source_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from sync_source_vec_t:
 |  
 |  __hash__ = None

Help on function take_database_snapshot in module ida_kernwin:

take_database_snapshot(*args) -> 'PyObject *'
    take_database_snapshot(ss) -> (bool, NoneType)
    Take a database snapshot (ui_take_database_snapshot).
    
    @param ss: (C++: snapshot_t *) in/out parameter.
    * in: description, flags
    * out: filename, id
    @return: success

Help on class text_t in module ida_kernwin:

class text_t(builtins.object)
 |  Proxy of C++ qvector< twinline_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'twinline_t const &'
 |      __getitem__(self, i) -> twinline_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> text_t
 |      __init__(self, x) -> text_t
 |      
 |      @param x: qvector< twinline_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: twinline_t const &
 |  
 |  __swig_destroy__ = delete_text_t(...)
 |      delete_text_t(self)
 |  
 |  at(self, *args) -> 'twinline_t const &'
 |      at(self, _idx) -> twinline_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< twinline_t >::const_iterator'
 |      begin(self) -> twinline_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< twinline_t >::const_iterator'
 |      end(self) -> twinline_t
 |  
 |  erase(self, *args) -> 'qvector< twinline_t >::iterator'
 |      erase(self, it) -> twinline_t
 |      
 |      @param it: qvector< twinline_t >::iterator
 |      
 |      erase(self, first, last) -> twinline_t
 |      
 |      @param first: qvector< twinline_t >::iterator
 |      @param last: qvector< twinline_t >::iterator
 |  
 |  extract(self, *args) -> 'twinline_t *'
 |      extract(self) -> twinline_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=twinline_t())
 |      
 |      @param x: twinline_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: twinline_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< twinline_t >::iterator'
 |      insert(self, it, x) -> twinline_t
 |      
 |      @param it: qvector< twinline_t >::iterator
 |      @param x: twinline_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'twinline_t &'
 |      push_back(self, x)
 |      
 |      @param x: twinline_t const &
 |      
 |      push_back(self) -> twinline_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: twinline_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< twinline_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class textctrl_info_t in module ida_kernwin:

class textctrl_info_t(ida_idaapi.py_clinked_object_t)
 |  Class representing textctrl_info_t
 |  
 |  Method resolution order:
 |      textctrl_info_t
 |      ida_idaapi.py_clinked_object_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __get_flags__(self)
 |      Returns the flags value
 |  
 |  __get_tabsize__(self)
 |      Returns the tabsize value
 |  
 |  __init__(self, text='', flags=0, tabsize=0)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __set_flags__(self, flags)
 |      Sets the flags value
 |  
 |  __set_tabsize__(self, tabsize)
 |      Sets the tabsize value
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  _textctrl_info_t__get_text = __get_text(self)
 |      Sets the text value
 |  
 |  _textctrl_info_t__set_text = __set_text(self, s)
 |      Sets the text value
 |  
 |  assign(self, other)
 |      Copies the contents of 'other' to 'self'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  flags
 |      Returns the flags value
 |  
 |  tabsize
 |      Returns the tabsize value
 |  
 |  text
 |      Sets the text value
 |  
 |  value
 |      Sets the text value
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  TXTF_ACCEPTTABS = 2
 |  
 |  TXTF_AUTOINDENT = 1
 |  
 |  TXTF_FIXEDFONT = 32
 |  
 |  TXTF_MODIFIED = 16
 |  
 |  TXTF_READONLY = 4
 |  
 |  TXTF_SELECTED = 8
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on function textctrl_info_t_assign in module ida_kernwin:

textctrl_info_t_assign(*args) -> 'bool'
    textctrl_info_t_assign(_self, other) -> bool
    
    @param self: PyObject *
    @param other: PyObject *

Help on function textctrl_info_t_create in module ida_kernwin:

textctrl_info_t_create(*args) -> 'PyObject *'
    textctrl_info_t_create() -> PyObject *

Help on function textctrl_info_t_destroy in module ida_kernwin:

textctrl_info_t_destroy(*args) -> 'bool'
    textctrl_info_t_destroy(py_obj) -> bool
    
    @param py_obj: PyObject *

Help on function textctrl_info_t_get_clink in module ida_kernwin:

textctrl_info_t_get_clink(*args) -> 'textctrl_info_t *'
    textctrl_info_t_get_clink(_self) -> textctrl_info_t *
    
    @param self: PyObject *

Help on function textctrl_info_t_get_clink_ptr in module ida_kernwin:

textctrl_info_t_get_clink_ptr(*args) -> 'PyObject *'
    textctrl_info_t_get_clink_ptr(_self) -> PyObject *
    
    @param self: PyObject *

Help on function textctrl_info_t_get_flags in module ida_kernwin:

textctrl_info_t_get_flags(*args) -> 'unsigned int'
    textctrl_info_t_get_flags(_self) -> unsigned int
    
    @param self: PyObject *

Help on function textctrl_info_t_get_tabsize in module ida_kernwin:

textctrl_info_t_get_tabsize(*args) -> 'unsigned int'
    textctrl_info_t_get_tabsize(_self) -> unsigned int
    
    @param self: PyObject *

Help on function textctrl_info_t_get_text in module ida_kernwin:

textctrl_info_t_get_text(*args) -> 'char const *'
    textctrl_info_t_get_text(_self) -> char const *
    
    @param self: PyObject *

Help on function textctrl_info_t_set_flags in module ida_kernwin:

textctrl_info_t_set_flags(*args) -> 'bool'
    textctrl_info_t_set_flags(_self, flags) -> bool
    
    @param self: PyObject *
    @param flags: unsigned int

Help on function textctrl_info_t_set_tabsize in module ida_kernwin:

textctrl_info_t_set_tabsize(*args) -> 'bool'
    textctrl_info_t_set_tabsize(_self, tabsize) -> bool
    
    @param self: PyObject *
    @param tabsize: unsigned int

Help on function textctrl_info_t_set_text in module ida_kernwin:

textctrl_info_t_set_text(*args) -> 'bool'
    textctrl_info_t_set_text(_self, s) -> bool
    
    @param self: PyObject *
    @param s: char const *

Help on class twinline_t in module ida_kernwin:

class twinline_t(builtins.object)
 |  Proxy of C++ twinline_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> twinline_t
 |      __init__(self, t, pc, bc) -> twinline_t
 |      
 |      @param t: place_t *
 |      @param pc: color_t
 |      @param bc: bgcolor_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_twinline_t(...)
 |      delete_twinline_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      at
 |  
 |  bg_color
 |      bg_color
 |  
 |  is_default
 |      is_default
 |  
 |  line
 |      line
 |  
 |  prefix_color
 |      prefix_color
 |  
 |  thisown
 |      The membership flag

Help on class twinpos_t in module ida_kernwin:

class twinpos_t(builtins.object)
 |  Proxy of C++ twinpos_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> twinpos_t
 |      __init__(self, t) -> twinpos_t
 |      
 |      @param t: place_t *
 |      
 |      __init__(self, t, x0) -> twinpos_t
 |      
 |      @param t: place_t *
 |      @param x0: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_twinpos_t(...)
 |      delete_twinpos_t(self)
 |  
 |  place(self, view)
 |  
 |  place_as_enumplace_t(self)
 |  
 |  place_as_idaplace_t(self)
 |  
 |  place_as_simpleline_place_t(self)
 |  
 |  place_as_structplace_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  at
 |      at
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x

Help on function ui_load_new_file in module ida_kernwin:

ui_load_new_file(*args) -> 'bool'
    ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
    Display a load file dialog and load file (ui_load_file).
    
    @param temp_file: (C++: qstring *) name of the file with the extracted archive member.
    @param filename: (C++: qstring *) the name of input file as is, library or archive name
    @param pli: (C++: linput_t **) loader input source, may be changed to point to temp_file
    @param neflags: (C++: ushort) combination of NEF_... bits (see Load file flags)
    @param ploaders: (C++: load_info_t **) list of loaders which accept file, may be changed for loaders
                     of temp_file
    @retval true: file was successfully loaded
    @retval false: otherwise

Help on class ui_requests_t in module ida_kernwin:

class ui_requests_t(builtins.object)
 |  Proxy of C++ ui_requests_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ui_requests_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ui_requests_t(...)
 |      delete_ui_requests_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function ui_run_debugger in module ida_kernwin:

ui_run_debugger(*args) -> 'bool'
    ui_run_debugger(dbgopts, exename, argc, argv) -> bool
    Load a debugger plugin and run the specified program (ui_run_dbg).
    
    @param dbgopts: (C++: const char *) value of the -r command line switch
    @param exename: (C++: const char *) name of the file to run
    @param argc: (C++: int) number of arguments for the executable
    @param argv: (C++: const char *const *) argument vector
    @return: success

Help on function unmark_selection in module ida_kernwin:

unmark_selection(*args) -> 'void'
    unmark_selection()
    Unmark selection (ui_unmarksel)

Help on function unregister_action in module ida_kernwin:

unregister_action(*args) -> 'bool'
    unregister_action(name) -> bool
    Delete a previously-registered action (ui_unregister_action).
    
    @param name: (C++: const char *) name of action
    @return: success

Help on function unregister_timer in module ida_kernwin:

unregister_timer(*args) -> 'bool'
    unregister_timer(py_timerctx) -> bool
    Unregister a timer
    
    @param timer_obj: a timer object previously returned by a register_timer()
    @return: Boolean
    @note: After the timer has been deleted, the timer_obj will become invalid.

Help on function update_action_checkable in module ida_kernwin:

update_action_checkable(*args) -> 'bool'
    update_action_checkable(name, checkable) -> bool
    Update an action's checkability (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param checkable: (C++: bool) new checkability
    @return: success

Help on function update_action_checked in module ida_kernwin:

update_action_checked(*args) -> 'bool'
    update_action_checked(name, checked) -> bool
    Update an action's checked state (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param checked: (C++: bool) new checked state
    @return: success

Help on function update_action_icon in module ida_kernwin:

update_action_icon(*args) -> 'bool'
    update_action_icon(name, icon) -> bool
    Update an action's icon (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param icon: (C++: int) new icon id
    @return: success

Help on function update_action_label in module ida_kernwin:

update_action_label(*args) -> 'bool'
    update_action_label(name, label) -> bool
    Update an action's label (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param label: (C++: const char *) new label
    @return: success

Help on function update_action_shortcut in module ida_kernwin:

update_action_shortcut(*args) -> 'bool'
    update_action_shortcut(name, shortcut) -> bool
    Update an action's shortcut (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param shortcut: (C++: const char *) new shortcut
    @return: success

Help on function update_action_state in module ida_kernwin:

update_action_state(*args) -> 'bool'
    update_action_state(name, state) -> bool
    Update an action's state (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param state: (C++: action_state_t) new state
    @return: success

Help on function update_action_tooltip in module ida_kernwin:

update_action_tooltip(*args) -> 'bool'
    update_action_tooltip(name, tooltip) -> bool
    Update an action's tooltip (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param tooltip: (C++: const char *) new tooltip
    @return: success

Help on function update_action_visibility in module ida_kernwin:

update_action_visibility(*args) -> 'bool'
    update_action_visibility(name, visible) -> bool
    Update an action's visibility (ui_update_action_attr).
    
    @param name: (C++: const char *) action name
    @param visible: (C++: bool) new visibility
    @return: success

Help on function user_cancelled in module ida_kernwin:

user_cancelled(*args) -> 'bool'
    user_cancelled() -> bool
    Test the ctrl-break flag (ui_test_cancelled).
    @retval 1: Ctrl-Break is detected, a message is displayed
    @retval 2: Ctrl-Break is detected again, a message is not displayed
    @retval 0: Ctrl-Break is not detected

Help on class view_mouse_event_location_t in module ida_kernwin:

class view_mouse_event_location_t(builtins.object)
 |  Proxy of C++ view_mouse_event_location_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> view_mouse_event_location_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_view_mouse_event_location_t(...)
 |      delete_view_mouse_event_location_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  item
 |      item
 |  
 |  thisown
 |      The membership flag

Help on class view_mouse_event_t in module ida_kernwin:

class view_mouse_event_t(builtins.object)
 |  Proxy of C++ view_mouse_event_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> view_mouse_event_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_view_mouse_event_t(...)
 |      delete_view_mouse_event_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  button
 |      button
 |  
 |  location
 |      location
 |  
 |  renderer_pos
 |      renderer_pos
 |  
 |  rtype
 |      rtype
 |  
 |  state
 |      state
 |  
 |  thisown
 |      The membership flag
 |  
 |  x
 |      x
 |  
 |  y
 |      y

Help on function warning in module ida_kernwin:

warning(*args) -> 'void'
    warning(format)
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

Module "ida_lines"s docstring:
"""
High level functions that deal with the generation of the disassembled text
lines.

This file also contains definitions for the syntax highlighting.

Finally there are functions that deal with anterior/posterior user-defined
lines."""

Help on function COLSTR in module ida_lines:

COLSTR(str, tag)
    Utility function to create a colored line
    @param str: The string
    @param tag: Color tag constant. One of SCOLOR_XXXX

Help on function add_extra_cmt in module ida_lines:

add_extra_cmt(*args) -> 'bool'
    add_extra_cmt(ea, isprev, format) -> bool
    Add anterior/posterior comment line(s).
    
    @param ea: (C++: ea_t) linear address
    @param isprev: (C++: bool) do we add anterior lines? (0-no, posterior)
    @param format: (C++: const char *) printf() style format string. may contain \n to denote new lines.
                   The resulting string should not contain comment characters (;),
                   the kernel will add them automatically.
    @return: true if success

Help on function add_extra_line in module ida_lines:

add_extra_line(*args) -> 'bool'
    add_extra_line(ea, isprev, format) -> bool
    Add anterior/posterior non-comment line(s).
    
    @param ea: (C++: ea_t) linear address
    @param isprev: (C++: bool) do we add anterior lines? (0-no, posterior)
    @param format: (C++: const char *) printf() style format string. may contain \n to denote new lines.
    @return: true if success

Help on function add_pgm_cmt in module ida_lines:

add_pgm_cmt(*args) -> 'bool'
    add_pgm_cmt(format) -> bool
    Add anterior comment line(s) at the start of program.
    
    @param format: (C++: const char *) printf() style format string. may contain \n to denote new lines.
                   The resulting string should not contain comment characters (;),
                   the kernel will add them automatically.
    @return: true if success

Help on function add_sourcefile in module ida_lines:

add_sourcefile(*args) -> 'bool'
    add_sourcefile(ea1, ea2, filename) -> bool
    Mark a range of address as belonging to a source file. An address range may
    belong only to one source file. A source file may be represented by several
    address ranges.
    
    @param ea1: (C++: ea_t) linear address of start of the address range
    @param ea2: (C++: ea_t) linear address of end of the address range (excluded)
    @param filename: (C++: const char *) name of source file.
    @return: success

Help on function calc_bg_color in module ida_lines:

calc_bg_color(*args) -> 'bgcolor_t'
    calc_bg_color(ea) -> bgcolor_t
    Get background color for line at 'ea'
    
    @param ea: (C++: ea_t)
    @return: RGB color

Help on function calc_prefix_color in module ida_lines:

calc_prefix_color(*args) -> 'color_t'
    calc_prefix_color(ea) -> color_t
    Get prefix color for line at 'ea'
    
    @param ea: (C++: ea_t)
    @return: Line prefix colors

Help on function create_encoding_helper in module ida_lines:

create_encoding_helper(*args) -> 'encoder_t *'
    create_encoding_helper(encidx=-1, nr=nr_once) -> encoder_t *
    
    @param encidx: int
    @param nr: enum encoder_t::notify_recerr_t

Help on function del_extra_cmt in module ida_lines:

del_extra_cmt(*args) -> 'void'
    del_extra_cmt(ea, what)
    
    @param ea: ea_t
    @param what: int

Help on function del_sourcefile in module ida_lines:

del_sourcefile(*args) -> 'bool'
    del_sourcefile(ea) -> bool
    Delete information about the source file.
    
    @param ea: (C++: ea_t) linear address
    @return: success

Help on function delete_extra_cmts in module ida_lines:

delete_extra_cmts(*args) -> 'void'
    delete_extra_cmts(ea, what)
    
    @param ea: ea_t
    @param what: int

Help on function generate_disasm_line in module ida_lines:

generate_disasm_line(*args) -> 'qstring *'
    generate_disasm_line(ea, flags=0) -> str
    
    @param ea: ea_t
    @param flags: int

Help on function generate_disassembly in module ida_lines:

generate_disassembly(*args) -> 'PyObject *'
    generate_disassembly(ea, max_lines, as_stack, notags) -> (int, [str, ...])
    Generate disassembly lines (many lines) and put them into a buffer
    
    @param ea: address to generate disassembly for
    @param max_lines: how many lines max to generate
    @param as_stack: Display undefined items as 2/4/8 bytes
    @param notags: bool
    @return:     - None on failure
        - tuple(most_important_line_number, list(lines)) : Returns a tuple containing
          the most important line number and a list of generated lines

Help on function get_extra_cmt in module ida_lines:

get_extra_cmt(*args) -> 'int'
    get_extra_cmt(ea, what) -> ssize_t
    
    @param ea: ea_t
    @param what: int

Help on function get_first_free_extra_cmtidx in module ida_lines:

get_first_free_extra_cmtidx(*args) -> 'int'
    get_first_free_extra_cmtidx(ea, start) -> int
    
    @param ea: ea_t
    @param start: int

Help on function get_sourcefile in module ida_lines:

get_sourcefile(*args) -> 'char const *'
    get_sourcefile(ea, bounds=None) -> char const *
    Get name of source file occupying the given address.
    
    @param ea: (C++: ea_t) linear address
    @param bounds: (C++: range_t *) pointer to the output buffer with the address range for the
                   current file. May be nullptr.
    @return: nullptr if source file information is not found, otherwise returns
             pointer to file name

Help on function install_user_defined_prefix in module ida_lines:

install_user_defined_prefix(*args) -> 'bool'
    install_user_defined_prefix(prefix_len, udp, owner) -> bool
    User-defined line-prefixes are displayed just after the autogenerated line
    prefixes in the disassembly listing. There is no need to call this function
    explicitly. Use the user_defined_prefix_t class.
    
    @param prefix_len: (C++: size_t) prefixed length. if 0, then uninstall UDP
    @param udp: (C++: struct user_defined_prefix_t *) object to generate user-defined prefix
    @param owner: (C++: const void *) pointer to the plugin_t that owns UDP if non-nullptr, then the
                  object will be uninstalled and destroyed when the plugin gets
                  unloaded

Help on function requires_color_esc in module ida_lines:

requires_color_esc(c)
    Checks if the given character requires escaping
    Is the given char a color escape character?

Help on function set_user_defined_prefix in module ida_lines:

set_user_defined_prefix(*args) -> 'PyObject *'
    set_user_defined_prefix(width, pycb) -> bool
    Deprecated. Please use install_user_defined_prefix() instead
    
    @param width: size_t
    @param pycb: PyObject *

Help on function tag_addr in module ida_lines:

tag_addr(*args) -> 'PyObject *'
    tag_addr(ea) -> PyObject *
    Insert an address mark into a string.
    
    @param ea: (C++: ea_t) address to include

Help on function tag_advance in module ida_lines:

tag_advance(*args) -> 'int'
    tag_advance(line, cnt) -> int
    Move pointer to a 'line' to 'cnt' positions right. Take into account escape
    sequences.
    
    @param line: (C++: const char *) pointer to string
    @param cnt: (C++: int) number of positions to move right
    @return: moved pointer

Help on function tag_remove in module ida_lines:

tag_remove(*args) -> 'PyObject *'
    tag_remove(nonnul_instr) -> str
    
    @param nonnul_instr: char const *

Help on function tag_skipcode in module ida_lines:

tag_skipcode(*args) -> 'int'
    tag_skipcode(line) -> int
    Skip one color code. This function should be used if you are interested in color
    codes and want to analyze all of them. Otherwise tag_skipcodes() function is
    better since it will skip all colors at once. This function will skip the
    current color code if there is one. If the current symbol is not a color code,
    it will return the input.
    
    @param line: (C++: const char *) char const *
    @return: moved pointer

Help on function tag_skipcodes in module ida_lines:

tag_skipcodes(*args) -> 'int'
    tag_skipcodes(line) -> int
    Move the pointer past all color codes.
    
    @param line: (C++: const char *) can't be nullptr
    @return: moved pointer, can't be nullptr

Help on function tag_strlen in module ida_lines:

tag_strlen(*args) -> 'ssize_t'
    tag_strlen(line) -> ssize_t
    Calculate length of a colored string This function computes the length in
    unicode codepoints of a line
    
    @param line: (C++: const char *) char const *
    @return: the number of codepoints in the line, or -1 on error

Help on function update_extra_cmt in module ida_lines:

update_extra_cmt(*args) -> 'void'
    update_extra_cmt(ea, what, str)
    
    @param ea: ea_t
    @param what: int
    @param str: char const *

Help on class user_defined_prefix_t in module ida_lines:

class user_defined_prefix_t(builtins.object)
 |  Proxy of C++ user_defined_prefix_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, prefix_len, owner) -> user_defined_prefix_t
 |      
 |      @param prefix_len: size_t
 |      @param owner: void const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_user_defined_prefix_t(...)
 |      delete_user_defined_prefix_t(self)
 |  
 |  get_user_defined_prefix(self, *args) -> 'void'
 |      get_user_defined_prefix(self, ea, insn, lnnum, indent, line)
 |      This callback must be overridden by the derived class.
 |      
 |      @param ea: (C++: ea_t) the current address
 |      @param insn: (C++: const class insn_t &) the current instruction. if the current item is not an instruction,
 |                   then insn.itype is zero.
 |      @param lnnum: (C++: int) number of the current line (each address may have several listing
 |                    lines for it). 0 means the very first line for the current
 |                    address.
 |      @param indent: (C++: int) see explanations for gen_printf()
 |      @param line: (C++: const char *) the line to be generated. the line usually contains color tags.
 |                   this argument can be examined to decide whether to generate the
 |                   prefix.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Module "ida_loader"s docstring:
"""
Definitions of IDP, LDR, PLUGIN module interfaces.

This file also contains:
* functions to load files into the database
* functions to generate output files
* high level functions to work with the database (open, save, close)

The LDR interface consists of one structure: loader_t
The IDP interface consists of one structure: processor_t
The PLUGIN interface consists of one structure: plugin_t

Modules can't use standard FILE* functions. They must use functions from
<fpro.h>

Modules can't use standard memory allocation functions. They must use functions
from <pro.h>

The exported entry #1 in the module should point to the the appropriate
structure. (loader_t for LDR module, for example)"""

Help on function base2file in module ida_loader:

base2file(*args) -> 'int'
    base2file(fp, pos, ea1, ea2) -> int
    Unload database to a binary file. This function works for wide byte processors
    too.
    
    @param fp: (C++: FILE *) pointer to file
    @param pos: (C++: qoff64_t) position in the file
    @param ea1: (C++: ea_t) ,ea2: range of source linear addresses
    @param ea2: (C++: ea_t)
    @return: 1-ok(always), write error leads to immediate exit

Help on function build_snapshot_tree in module ida_loader:

build_snapshot_tree(*args) -> 'bool'
    build_snapshot_tree(root) -> bool
    Build the snapshot tree.
    
    @param root: (C++: snapshot_t *) snapshot root that will contain the snapshot tree elements.
    @return: success

Help on function clr_database_flag in module ida_loader:

clr_database_flag(*args) -> 'void'
    clr_database_flag(dbfl)
    
    @param dbfl: uint32

Help on function extract_module_from_archive in module ida_loader:

extract_module_from_archive(*args) -> 'PyObject *'
    extract_module_from_archive(fname, is_remote=False) -> (NoneType, NoneType), (str, str)
    Extract a module for an archive file. Parse an archive file, show the list of
    modules to the user, allow him to select a module, extract the selected module
    to a file (if the extract module is an archive, repeat the process). This
    function can handle ZIP, AR, AIXAR, OMFLIB files. The temporary file will be
    automatically deleted by IDA at the end.
    
    @param filename: (C++: char *) in: input file. out: name of the selected module.
    @param is_remote: (C++: bool) is the input file remote?
    @retval true: ok
    @retval false: something bad happened (error message has been displayed to the
                   user)

Help on function file2base in module ida_loader:

file2base(*args) -> 'int'
    file2base(li, pos, ea1, ea2, patchable) -> int
    Load portion of file into the database. This function will include (ea1..ea2)
    into the addressing space of the program (make it enabled).
    
    @param li: (C++: linput_t *) pointer of input source
    @param pos: (C++: qoff64_t) position in the file
    @param ea1: (C++: ea_t) ,ea2: range of destination linear addresses
    @param patchable: (C++: int) should the kernel remember correspondence of file offsets to
                      linear addresses.
    @retval 1: ok
    @retval 0: read error, a warning is displayed
    @note: The storage type of the specified range will be changed to STT_VA.
    @param patchable: (C++: int) should the kernel remember correspondence of file offsets to
                      linear addresses.
    @retval 1: ok
    @retval 0: read error, a warning is displayed
    @note: The storage type of the specified range will be changed to STT_VA.

Help on function find_plugin in module ida_loader:

find_plugin(*args) -> 'plugin_t *'
    find_plugin(name, load_if_needed=False) -> plugin_t *
    Find a user-defined plugin and optionally load it.
    
    @param name: (C++: const char *) short plugin name without path and extension, or absolute path to
                 the file name
    @param load_if_needed: (C++: bool) if the plugin is not present in the memory, try to load
                           it
    @return: pointer to plugin description block

Help on function flush_buffers in module ida_loader:

flush_buffers(*args) -> 'int'
    flush_buffers() -> int
    Flush buffers to the disk.

Help on function gen_exe_file in module ida_loader:

gen_exe_file(*args) -> 'int'
    gen_exe_file(fp) -> int
    Generate an exe file (unload the database in binary form).
    
    @param fp: (C++: FILE *)
    @return: fp the output file handle. if fp == nullptr then return:
    * 1: can generate an executable file
    * 0: can't generate an executable file
    @retval 1: ok
    @retval 0: failed

Help on function gen_file in module ida_loader:

gen_file(*args) -> 'int'
    gen_file(otype, fp, ea1, ea2, flags) -> int
    Generate an output file.
    
    @param otype: (C++: ofile_type_t) type of output file.
    @param fp: (C++: FILE *) the output file handle
    @param ea1: (C++: ea_t) start address. For some file types this argument is ignored
    @param ea2: (C++: ea_t) end address. For some file types this argument is ignored as usual
                in ida, the end address of the range is not included
    @param flags: (C++: int) Generate file flagsOFILE_EXE:
    @retval 0: can't generate exe file
    @retval 1: ok
    @return: number of the generated lines. -1 if an error occurred

Help on function get_basic_file_type in module ida_loader:

get_basic_file_type(*args) -> 'filetype_t'
    get_basic_file_type(li) -> filetype_t
    Get the input file type. This function can recognize libraries and zip files.
    
    @param li: (C++: linput_t *)

Help on function get_elf_debug_file_directory in module ida_loader:

get_elf_debug_file_directory(*args) -> 'char const *'
    get_elf_debug_file_directory() -> char const *
    Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive.

Help on function get_file_type_name in module ida_loader:

get_file_type_name(*args) -> 'size_t'
    get_file_type_name() -> str
    Get name of the current file type. The current file type is kept in
    idainfo::filetype.
    
    @return: size of answer, this function always succeeds

Help on function get_fileregion_ea in module ida_loader:

get_fileregion_ea(*args) -> 'ea_t'
    get_fileregion_ea(offset) -> ea_t
    Get linear address which corresponds to the specified input file offset. If
    can't be found, return BADADDR
    
    @param offset: (C++: qoff64_t)

Help on function get_fileregion_offset in module ida_loader:

get_fileregion_offset(*args) -> 'qoff64_t'
    get_fileregion_offset(ea) -> qoff64_t
    Get offset in the input file which corresponds to the given ea. If the specified
    ea can't be mapped into the input file offset, return -1.
    
    @param ea: (C++: ea_t)

Help on function get_path in module ida_loader:

get_path(*args) -> 'char const *'
    get_path(pt) -> char const *
    Get the file path
    
    @param pt: (C++: path_type_t) file path type Types of the file pathes
    @return: file path, never returns nullptr

Help on function get_plugin_options in module ida_loader:

get_plugin_options(*args) -> 'char const *'
    get_plugin_options(plugin) -> char const *
    Get plugin options from the command line. If the user has specified the options
    in the -Oplugin_name:options format, them this function will return the
    'options' part of it The 'plugin' parameter should denote the plugin name
    Returns nullptr if there we no options specified
    
    @param plugin: (C++: const char *) char const *

Help on class idp_desc_t in module ida_loader:

class idp_desc_t(builtins.object)
 |  Proxy of C++ idp_desc_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idp_desc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idp_desc_t(...)
 |      delete_idp_desc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  checked
 |      checked
 |  
 |  family
 |      family
 |  
 |  is_script
 |      is_script
 |  
 |  mtime
 |      mtime
 |  
 |  names
 |      names
 |  
 |  path
 |      path
 |  
 |  thisown
 |      The membership flag

Help on class idp_name_t in module ida_loader:

class idp_name_t(builtins.object)
 |  Proxy of C++ idp_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> idp_name_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_idp_name_t(...)
 |      delete_idp_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  hidden
 |      hidden
 |  
 |  lname
 |      lname
 |  
 |  sname
 |      sname
 |  
 |  thisown
 |      The membership flag

Help on function is_database_flag in module ida_loader:

is_database_flag(*args) -> 'bool'
    is_database_flag(dbfl) -> bool
    Get the current database flag
    
    @param dbfl: (C++: uint32) flag Database flags
    @return: the state of the flag (set or cleared)

Help on function is_trusted_idb in module ida_loader:

is_trusted_idb(*args) -> 'bool'
    is_trusted_idb() -> bool
    Is the database considered as trusted?

Help on function load_and_run_plugin in module ida_loader:

load_and_run_plugin(*args) -> 'bool'
    load_and_run_plugin(name, arg) -> bool
    Load & run a plugin.
    
    @param name: (C++: const char *) char const *
    @param arg: (C++: size_t)

Help on function load_binary_file in module ida_loader:

load_binary_file(*args) -> 'bool'
    load_binary_file(filename, li, _neflags, fileoff, basepara, binoff, nbytes) -> bool
    Load a binary file into the database. This function usually is called from ui.
    
    @param filename: (C++: const char *) the name of input file as is (if the input file is from
                     library, then this is the name from the library)
    @param li: (C++: linput_t *) loader input source
    @param _neflags: (C++: ushort) Load file flags. For the first file, the flag NEF_FIRST must be
                     set.
    @param fileoff: (C++: qoff64_t) Offset in the input file
    @param basepara: (C++: ea_t) Load address in paragraphs
    @param binoff: (C++: ea_t) Load offset (load_address=(basepara<<4)+binoff)
    @param nbytes: (C++: uint64) Number of bytes to load from the file.
    * 0: up to the end of the file
    @retval true: ok
    @retval false: failed (couldn't open the file)

Help on function load_ids_module in module ida_loader:

load_ids_module(*args) -> 'int'
    load_ids_module(fname) -> int
    Load and apply IDS file. This function loads the specified IDS file and applies
    it to the database. If the program imports functions from a module with the same
    name as the name of the ids file being loaded, then only functions from this
    module will be affected. Otherwise (i.e. when the program does not import a
    module with this name) any function in the program may be affected.
    
    @param fname: (C++: char *) name of file to apply
    @retval 1: ok
    @retval 0: some error (a message is displayed). if the ids file does not exist,
               no message is displayed

Help on function load_plugin in module ida_loader:

load_plugin(*args) -> 'PyObject *'
    load_plugin(name) -> PyCapsule or None
    Loads a plugin
    
    @param name: char const *
    @return:     - None if plugin could not be loaded
        - An opaque object representing the loaded plugin

Help on class loader_t in module ida_loader:

class loader_t(builtins.object)
 |  Proxy of C++ loader_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> loader_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_loader_t(...)
 |      delete_loader_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  flags
 |      flags
 |  
 |  thisown
 |      The membership flag
 |  
 |  version
 |      version

Help on function mem2base in module ida_loader:

mem2base(*args) -> 'int'
    mem2base(py_mem, ea, fpos=-1) -> int
    Load database from the memory.
    
    @param py_mem: the buffer
    @param ea: start linear addresses
    @param fpos: position in the input file the data is taken from.
                 if == -1, then no file position correspond to the data.
    @return:     - Returns zero if the passed buffer was not a string
        - Otherwise 1 is returned

Help on class plugin_info_t in module ida_loader:

class plugin_info_t(builtins.object)
 |  Proxy of C++ plugin_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> plugin_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_plugin_info_t(...)
 |      delete_plugin_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  arg
 |      arg
 |  
 |  comment
 |      comment
 |  
 |  dllmem
 |      dllmem
 |  
 |  entry
 |      entry
 |  
 |  flags
 |      flags
 |  
 |  hotkey
 |      hotkey
 |  
 |  name
 |      name
 |  
 |  next
 |      next
 |  
 |  org_hotkey
 |      org_hotkey
 |  
 |  org_name
 |      org_name
 |  
 |  path
 |      path
 |  
 |  thisown
 |      The membership flag

Help on function process_archive in module ida_loader:

process_archive(*args) -> 'qstring *'
    process_archive(temp_file, li, module_name, neflags, defmember, loader) -> str
    Calls loader_t::process_archive() For parameters and return value description
    look at loader_t::process_archive(). Additional parameter 'loader' is a pointer
    to load_info_t structure.
    
    @param temp_file: (C++: qstring *)
    @param li: (C++: linput_t *)
    @param module_name: (C++: qstring *)
    @param neflags: (C++: ushort *)
    @param defmember: (C++: const char *) char const *
    @param loader: (C++: const load_info_t *) load_info_t const *

Help on class qvector_snapshotvec_t in module ida_loader:

class qvector_snapshotvec_t(builtins.object)
 |  Proxy of C++ qvector< snapshot_t * > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< snapshot_t * > const &
 |  
 |  __getitem__(self, *args) -> 'snapshot_t *const &'
 |      __getitem__(self, i) -> snapshot_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> qvector_snapshotvec_t
 |      __init__(self, x) -> qvector_snapshotvec_t
 |      
 |      @param x: qvector< snapshot_t * > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< snapshot_t * > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: snapshot_t *const &
 |  
 |  __swig_destroy__ = delete_qvector_snapshotvec_t(...)
 |      delete_qvector_snapshotvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: snapshot_t *const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: snapshot_t *const &
 |  
 |  at(self, *args) -> 'snapshot_t *const &'
 |      at(self, _idx) -> snapshot_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< snapshot_t * >::const_iterator'
 |      begin(self) -> qvector< snapshot_t * >::iterator
 |      begin(self) -> qvector< snapshot_t * >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< snapshot_t * >::const_iterator'
 |      end(self) -> qvector< snapshot_t * >::iterator
 |      end(self) -> qvector< snapshot_t * >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< snapshot_t * >::iterator'
 |      erase(self, it) -> qvector< snapshot_t * >::iterator
 |      
 |      @param it: qvector< snapshot_t * >::iterator
 |      
 |      erase(self, first, last) -> qvector< snapshot_t * >::iterator
 |      
 |      @param first: qvector< snapshot_t * >::iterator
 |      @param last: qvector< snapshot_t * >::iterator
 |  
 |  extract(self, *args) -> 'snapshot_t **'
 |      extract(self) -> snapshot_t **
 |  
 |  find(self, *args) -> 'qvector< snapshot_t * >::const_iterator'
 |      find(self, x) -> qvector< snapshot_t * >::iterator
 |      
 |      @param x: snapshot_t *const &
 |      
 |      find(self, x) -> qvector< snapshot_t * >::const_iterator
 |      
 |      @param x: snapshot_t *const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: snapshot_t *const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: snapshot_t **
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< snapshot_t * >::iterator'
 |      insert(self, it, x) -> qvector< snapshot_t * >::iterator
 |      
 |      @param it: qvector< snapshot_t * >::iterator
 |      @param x: snapshot_t *const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'snapshot_t *&'
 |      push_back(self, x)
 |      
 |      @param x: snapshot_t *const &
 |      
 |      push_back(self) -> snapshot_t *&
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: snapshot_t *const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< snapshot_t * > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function reload_file in module ida_loader:

reload_file(*args) -> 'bool'
    reload_file(file, is_remote) -> bool
    Reload the input file. This function reloads the byte values from the input
    file. It doesn't modify the segmentation, names, comments, etc.
    
    @param file: (C++: const char *) name of the input file. if file == nullptr then returns:
    * 1: can reload the input file
    * 0: can't reload the input file
    @param is_remote: (C++: bool) is the file located on a remote computer with the debugger
                      server?
    @return: success

Help on function run_plugin in module ida_loader:

run_plugin(*args) -> 'bool'
    run_plugin(plg, arg) -> bool
    Runs a plugin
    
    @param plg: A plugin object (returned by load_plugin())
    @param arg: size_t
    @return: Boolean

Help on function save_database in module ida_loader:

save_database(*args) -> 'bool'
    save_database(outfile, flags, root=None, attr=None) -> bool
    Save current database using a new file name.
    
    @param outfile: (C++: const char *) output database file name
    @param flags: (C++: uint32) Database flags
    @param root: (C++: const snapshot_t *) optional: snapshot tree root.
    @param attr: (C++: const snapshot_t *) optional: snapshot attributes
    @note: when both root and attr are not nullptr then the snapshot attributes will
           be updated, otherwise the snapshot attributes will be inherited from the
           current database.
    @return: success

Help on function set_database_flag in module ida_loader:

set_database_flag(*args) -> 'void'
    set_database_flag(dbfl, cnd=True)
    Set or clear database flag
    
    @param dbfl: (C++: uint32) flag Database flags
    @param cnd: (C++: bool) set if true or clear flag otherwise

Help on function set_import_name in module ida_loader:

set_import_name(*args) -> 'void'
    set_import_name(modnode, ea, name)
    Set information about the named import entry. This function performs
    'modnode.supset_ea(ea, name);'
    
    @param modnode: (C++: uval_t) node with information about imported entries
    @param ea: (C++: ea_t) linear address of the entry
    @param name: (C++: const char *) name of the entry

Help on function set_import_ordinal in module ida_loader:

set_import_ordinal(*args) -> 'void'
    set_import_ordinal(modnode, ea, ord)
    Set information about the ordinal import entry. This function performs
    'modnode.altset(ord, ea2node(ea));'
    
    @param modnode: (C++: uval_t) node with information about imported entries
    @param ea: (C++: ea_t) linear address of the entry
    @param ord: (C++: uval_t) ordinal number of the entry

Help on function set_path in module ida_loader:

set_path(*args) -> 'void'
    set_path(pt, path)
    Set the file path
    
    @param pt: (C++: path_type_t) file path type Types of the file pathes
    @param path: (C++: const char *) new file path, use nullptr or empty string to clear the file path

Help on class snapshot_t in module ida_loader:

class snapshot_t(builtins.object)
 |  Proxy of C++ snapshot_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: snapshot_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: snapshot_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: snapshot_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> snapshot_t
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: snapshot_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: snapshot_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: snapshot_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_snapshot_t(...)
 |      delete_snapshot_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  children
 |      children
 |  
 |  desc
 |      desc
 |  
 |  filename
 |      filename
 |  
 |  flags
 |      flags
 |  
 |  id
 |      id
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Module "ida_merge"s docstring:
"""
Merge functionality.

NOTE: this functionality is available in IDA Teams (not IDA Pro)

There are 3 databases involved in merging: base_idb, local_db, and remote_idb.
* base_idb: the common base ancestor of 'local_db' and 'remote_db'. in the UI
this database is located in the middle.
* local_idb: local database that will contain the result of the merging. in the
UI this database is located on the left.
* remote_idb: remote database that will merge into local_idb. It may reside
locally on the current computer, despite its name. in the UI this database is
located on the right. base_idb and remote_idb are opened for reading only.
base_idb may be absent, in this case a 2-way merging is performed.

Conflicts can be resolved automatically or interactively. The automatic
resolving scores the conflicting blocks and takes the better one. The
interactive resolving displays the full rendered contents side by side, and
expects the user to select the better side for each conflict.

Since IDB files contain various kinds of information, there are many merging
phases. The entire list can be found in merge.cpp. Below are just some selected
examples:
* merge global database settings (inf and other global vars)
* merge segmentation and changes to the database bytes
* merge various lists: exports, imports, loaded tils, etc
* merge names, functions, function frames
* merge debugger settings, breakpoints
* merge struct/enum views
* merge local type libraries
* merge the disassembly items (i.e. the segment contents) this includes operand
types, code/data separation, etc
* merge plugin specific info like decompiler types, dwarf mappings, etc

To unify UI elements of each merge phase, we use merger views:
* A view that consists of 2 or 3 panes: left (local_idb) and right (remote_idb).
The common base is in the middle, if present.
* Rendering of the panes depends on the phase, different phases show different
contents.
* The conflicts are highlighted by a colored background. Also, the detail pane
can be consulted for additional info.
* The user can select a conflict (or a bunch of conflicts) and say "use this
block".
* The user can browse the panes as he wishes. He will not be forced to handle
conflicts in any particular order. However, once he finishes working with a
merge handler and proceeds to the next one, he cannot go back.
* Scrolling the left pane will synchronously scroll the right pane and vice
versa.
* There are the navigation commands like "go to the prev/next conflict"
* The number of remaining conflicts to resolve is printed in the "Progress"
chooser.
* The user may manually modify local database inside the merger view. For that
he may use the regular hotkeys. However, editing the database may lead to new
conflicts, so we better restrict the available actions to some reasonable
minimum. Currently, this is not implemented.

IDA works in a new "merge" mode during merging. In this mode most events are not
generated. We forbid them to reduce the risk that a rogue third-party plugin
that is not aware of the "merge" mode would spoil something.

For example, normally renaming a function causes a cascade of events and may
lead to other database modifications. Some of them may be desired, some - not.
Since there are some undesired events, it is better to stop generating them.
However, some events are required to render the disassembly listing. For
example, ev_ana_insn, av_out_insn. This is why some events are still generated
in the "merge" mode.

To let processor modules and plugins merge their data, we introduce a new event:
ev_create_merge_handlers. It is generated immediately after opening all three
idbs. The interested modules should react to this event by creating new merge
handlers, if they need them.

While the kernel can create arbitrary merge handlers, modules can create only
the standard ones returned by:

create_nodeval_merge_handler() create_nodeval_merge_handlers()
create_std_modmerge_handlers()

We do not document merge_handler_t because once a merge handler is created, it
is used exclusively by the kernel.

See mergemod.hpp for more information about the merge mode for modules."""

Help on function create_nodeval_merge_handler in module ida_merge:

create_nodeval_merge_handler(*args) -> 'merge_handler_t *'
    create_nodeval_merge_handler(mhp, label, nodename, tag, nds_flags, node_helper=None, skip_empty_nodes=True) -> merge_handler_t *
    Create a merge handler for netnode scalar/string values
    
    @param mhp: (C++: const merge_handler_params_t &) merging parameters
    @param label: (C++: const char *) handler short name (to be be appended to mhp.label)
    @param nodename: (C++: const char *) netnode name
    @param tag: (C++: uchar) a tag used to access values in the netnode
    @param nds_flags: (C++: uint32) netnode value attributes (a combination of nds_flags_t)
    @param node_helper: merge_node_helper_t *
    @param skip_empty_nodes: (C++: bool) do not create handler in case of empty netnode
    @return: diff source object (normally should be attahced to a merge handler)

Help on function create_nodeval_merge_handlers in module ida_merge:

create_nodeval_merge_handlers(*args) -> 'void'
    create_nodeval_merge_handlers(out, mhp, nodename, valdesc, skip_empty_nodes=True)
    Create a serie of merge handlers for netnode scalar/string values (call
    create_nodeval_merge_handler() for each member of VALDESC)
    
    @param out: (C++: merge_handlers_t *) [out] created handlers will be placed here
    @param mhp: (C++: const merge_handler_params_t &) merging parameters
    @param nodename: (C++: const char *) netnode name
    @param valdesc: (C++: const merge_node_info_t *) array of handler descriptions
    @param skip_empty_nodes: (C++: bool) do not create handlers for empty netnodes
    @return: diff source object (normally should be attahced to a merge handler)

Help on function destroy_moddata_merge_handlers in module ida_merge:

destroy_moddata_merge_handlers(*args) -> 'void'
    destroy_moddata_merge_handlers(data_id)
    
    @param data_id: int

Help on function get_ea_diffpos_name in module ida_merge:

get_ea_diffpos_name(*args) -> 'qstring *'
    get_ea_diffpos_name(ea) -> str
    Get nice name for EA diffpos
    
    @param ea: (C++: ea_t) diffpos
    @note
    @see: get_nice_colored_name

Help on function is_diff_merge_mode in module ida_merge:

is_diff_merge_mode(*args) -> 'bool'
    is_diff_merge_mode() -> bool
    Return TRUE if IDA is running in diff mode (MERGE_POLICY_DIFF)

Help on class item_block_locator_t in module ida_merge:

class item_block_locator_t(builtins.object)
 |  Proxy of C++ merge_data_t::item_block_locator_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> item_block_locator_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_item_block_locator_t(...)
 |      delete_item_block_locator_t(self)
 |  
 |  get_block_head(self, *args) -> 'ea_t'
 |      get_block_head(self, md, idx, item_head) -> ea_t
 |      
 |      @param md: merge_data_t &
 |      @param idx: diff_source_idx_t
 |      @param item_head: ea_t
 |  
 |  setup_blocks(self, *args) -> 'bool'
 |      setup_blocks(self, md, _from, to, region) -> bool
 |      
 |      @param md: merge_data_t &
 |      @param from: diff_source_idx_t
 |      @param to: diff_source_idx_t
 |      @param region: diff_range_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class merge_data_t in module ida_merge:

class merge_data_t(builtins.object)
 |  Proxy of C++ merge_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  add_event_handler(self, *args) -> 'void'
 |      add_event_handler(self, handler)
 |      
 |      @param handler: merge_handler_t *
 |  
 |  base_id(self, *args) -> 'int'
 |      base_id(self) -> int
 |  
 |  compare_merging_tifs(self, *args) -> 'int'
 |      compare_merging_tifs(self, tif1, diffidx1, tif2, diffidx2) -> int
 |      compare types from two databases
 |      
 |      @param tif1: (C++: const tinfo_t &) type
 |      @param diffidx1: (C++: diff_source_idx_t) database index, diff_source_idx_t
 |      @param tif2: (C++: const tinfo_t &) type
 |      @param diffidx2: (C++: diff_source_idx_t) database index, diff_source_idx_t
 |      @return: -1, 0, 1
 |  
 |  get_block_head(self, *args) -> 'ea_t'
 |      get_block_head(self, idx, item_head) -> ea_t
 |      
 |      @param idx: diff_source_idx_t
 |      @param item_head: ea_t
 |  
 |  has_existing_node(self, *args) -> 'bool'
 |      has_existing_node(self, nodename) -> bool
 |      check that node exists in any of databases
 |      
 |      @param nodename: (C++: const char *) char const *
 |  
 |  local_id(self, *args) -> 'int'
 |      local_id(self) -> int
 |  
 |  map_privrange_id(self, *args) -> 'bool'
 |      map_privrange_id(self, tid, ea, _from, to, strict=True) -> bool
 |      map IDs of structures, enumerations and their members
 |      
 |      @param tid: (C++: tid_t *) item ID in TO database
 |      @param ea: (C++: ea_t) item ID to find counterpart
 |      @param from: (C++: diff_source_idx_t) source database index, diff_source_idx_t
 |      @param to: (C++: diff_source_idx_t) destination database index, diff_source_idx_t
 |      @param strict: (C++: bool) raise interr if could not map
 |      @return: success
 |  
 |  map_tinfo(self, *args) -> 'bool'
 |      map_tinfo(self, tif, _from, to, strict=True) -> bool
 |      migrate type, replaces type references into FROM database to references into TO
 |      database
 |      
 |      @param tif: (C++: tinfo_t *) type to migrate, will be cleared in case of fail
 |      @param from: (C++: diff_source_idx_t) source database index, diff_source_idx_t
 |      @param to: (C++: diff_source_idx_t) destination database index, diff_source_idx_t
 |      @param strict: (C++: bool) raise interr if could not map
 |      @return: success
 |  
 |  remote_id(self, *args) -> 'int'
 |      remote_id(self) -> int
 |  
 |  remove_event_handler(self, *args) -> 'void'
 |      remove_event_handler(self, handler)
 |      
 |      @param handler: merge_handler_t *
 |  
 |  set_dbctx_ids(self, *args) -> 'void'
 |      set_dbctx_ids(self, local, remote, base)
 |      
 |      @param local: int
 |      @param remote: int
 |      @param base: int
 |  
 |  setup_blocks(self, *args) -> 'bool'
 |      setup_blocks(self, dst_idx, src_idx, region) -> bool
 |      
 |      @param dst_idx: diff_source_idx_t
 |      @param src_idx: diff_source_idx_t
 |      @param region: diff_range_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dbctx_ids
 |      dbctx_ids
 |  
 |  ev_handlers
 |      ev_handlers
 |  
 |  item_block_locator
 |      item_block_locator
 |  
 |  last_udt_related_merger
 |      last_udt_related_merger
 |  
 |  nbases
 |      nbases
 |  
 |  thisown
 |      The membership flag

Help on class merge_handler_params_t in module ida_merge:

class merge_handler_params_t(builtins.object)
 |  Proxy of C++ merge_handler_params_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _md, _label, _kind, _insert_after, _mh_flags) -> merge_handler_params_t
 |      
 |      @param _md: merge_data_t &
 |      @param _label: qstring const &
 |      @param _kind: enum merge_kind_t
 |      @param _insert_after: enum merge_kind_t
 |      @param _mh_flags: uint32
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_merge_handler_params_t(...)
 |      delete_merge_handler_params_t(self)
 |  
 |  ui_complex_details(self, *args) -> 'bool'
 |      ui_complex_details(self, _mh_flags) -> bool
 |      Do not display the diffpos details in the chooser. For example, the
 |      MERGE_KIND_SCRIPTS handler puts the script body as the diffpos detail. It would
 |      not be great to show them as part of the chooser.
 |      
 |      @param _mh_flags: (C++: uint32)
 |      
 |      ui_complex_details(self) -> bool
 |  
 |  ui_complex_name(self, *args) -> 'bool'
 |      ui_complex_name(self, _mh_flags) -> bool
 |      It customary to create long diffpos names having many components that are
 |      separated by any 7-bit ASCII character (besides of '\0'). In this case it is
 |      possible to instruct IDA to use this separator to create a multi-column chooser.
 |      For example the MERGE_KIND_ENUMS handler has the following diffpos name:
 |      enum_1,enum_2 If MH_UI_COMMANAME is specified, IDA will create 2 columns for
 |      these names.
 |      
 |      @param _mh_flags: (C++: uint32)
 |      
 |      ui_complex_name(self) -> bool
 |  
 |  ui_dp_shortname(self, *args) -> 'bool'
 |      ui_dp_shortname(self, _mh_flags) -> bool
 |      The detail pane shows the diffpos details for the current diffpos range as a
 |      tree-like view. In this pane the diffpos names are used as tree node names and
 |      the diffpos details as their children. Sometimes, for complex diffpos names, the
 |      first part of the name looks better than the entire name. For example, the
 |      MERGE_KIND_SEGMENTS handler has the following diffpos name:
 |      <range>,<segm1>,<segm2>,<segm3> if MH_UI_DP_SHORTNAME is specified, IDA will use
 |      <range> as a tree node name
 |      
 |      @param _mh_flags: (C++: uint32)
 |      
 |      ui_dp_shortname(self) -> bool
 |  
 |  ui_has_details(self, *args) -> 'bool'
 |      ui_has_details(self, _mh_flags) -> bool
 |      Should IDA display the diffpos detail pane?
 |      
 |      @param _mh_flags: (C++: uint32)
 |      
 |      ui_has_details(self) -> bool
 |  
 |  ui_indent(self, *args) -> 'bool'
 |      ui_indent(self, _mh_flags) -> bool
 |      In the ordinary situation the spaces from the both sides of diffpos name are
 |      trimmed. Use this UI hint to preserve the leading spaces.
 |      
 |      @param _mh_flags: (C++: uint32)
 |      
 |      ui_indent(self) -> bool
 |  
 |  ui_linediff(self, *args) -> 'bool'
 |      ui_linediff(self, _mh_flags) -> bool
 |      In detail pane IDA shows difference between diffpos details. IDA marks added or
 |      deleted detail by color. In the modified detail the changes are marked. Use this
 |      UI hint if you do not want to show the differences inside detail.
 |      
 |      @param _mh_flags: (C++: uint32)
 |      
 |      ui_linediff(self) -> bool
 |  
 |  ui_split_char(self, *args) -> 'char'
 |      ui_split_char(self, _mh_flags) -> char
 |      
 |      @param _mh_flags: uint32
 |      
 |      ui_split_char(self) -> char
 |  
 |  ui_split_str(self, *args) -> 'qstring'
 |      ui_split_str(self, _mh_flags) -> qstring
 |      
 |      @param _mh_flags: uint32
 |      
 |      ui_split_str(self) -> qstring
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  insert_after
 |      insert_after
 |  
 |  kind
 |      kind
 |  
 |  label
 |      label
 |  
 |  md
 |      md
 |  
 |  mh_flags
 |      mh_flags
 |  
 |  thisown
 |      The membership flag

Help on class merge_node_helper_t in module ida_merge:

class merge_node_helper_t(builtins.object)
 |  Proxy of C++ merge_node_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> merge_node_helper_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_merge_node_helper_t(...)
 |      delete_merge_node_helper_t(self)
 |  
 |  get_column_headers(self, *args) -> 'void'
 |      get_column_headers(self, arg0, arg1, arg2)
 |      get column headers for chooser (to be used in
 |      linear_diff_source_t::get_column_headers)
 |      
 |      @param arg0: qstrvec_t *
 |      @param arg1: uchar
 |      @param arg2: void *
 |  
 |  get_netnode(self, *args) -> 'netnode'
 |      get_netnode(self) -> netnode
 |      return netnode to be used as source. If this function returns BADNODE netnode
 |      will be created using netnode name passed to create_nodeval_diff_source
 |  
 |  is_mergeable(self, *args) -> 'bool'
 |      is_mergeable(self, arg0, arg1) -> bool
 |      
 |      @param filter: check if we should perform merging for given record
 |      @param arg1: nodeidx_t
 |  
 |  map_scalar(self, *args) -> 'void'
 |      map_scalar(self, arg0, arg1, arg2, arg3)
 |      map scalar/string/buffered value
 |      
 |      @param arg0: nodeidx_t *
 |      @param arg1: void *
 |      @param arg2: diff_source_idx_t
 |      @param arg3: diff_source_idx_t
 |  
 |  map_string(self, *args) -> 'void'
 |      map_string(self, arg0, arg1, arg2, arg3)
 |      
 |      @param arg0: qstring *
 |      @param arg1: void *
 |      @param arg2: diff_source_idx_t
 |      @param arg3: diff_source_idx_t
 |  
 |  print_entry_details(self, *args) -> 'void'
 |      print_entry_details(self, arg0, arg1, arg2, arg3)
 |      print the details of the specified entry usually contains multiple lines, one
 |      for each attribute or detail. (to be used in print_diffpos_details)
 |      
 |      @param arg0: qstrvec_t *
 |      @param arg1: uchar
 |      @param arg2: nodeidx_t
 |      @param arg3: void *
 |  
 |  print_entry_name(self, *args) -> 'qstring'
 |      print_entry_name(self, arg0, arg1, arg2) -> qstring
 |      print the name of the specified entry (to be used in print_diffpos_name)
 |      
 |      @param arg0: uchar
 |      @param arg1: nodeidx_t
 |      @param arg2: void *
 |  
 |  refresh(self, *args) -> 'void'
 |      refresh(self, arg0, arg1)
 |      notify helper that some data was changed in the database and internal structures
 |      (e.g. caches) should be refreshed
 |      
 |      @param arg0: uchar
 |      @param arg1: void *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  append_eavec(*args) -> 'void'
 |      append_eavec(s, prefix, eas)
 |      can be used by derived classes
 |      
 |      @param s: (C++: qstring *)
 |      @param prefix: (C++: const char *) char const *
 |      @param eas: (C++: const eavec_t &) eavec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function merge_node_helper_t_append_eavec in module ida_merge:

merge_node_helper_t_append_eavec(*args) -> 'void'
    merge_node_helper_t_append_eavec(s, prefix, eas)
    
    @param s: qstring *
    @param prefix: char const *
    @param eas: eavec_t const &

Help on class merge_node_info_t in module ida_merge:

class merge_node_info_t(builtins.object)
 |  Proxy of C++ merge_node_info2_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, name, tag, nds_flags, node_helper=None) -> merge_node_info_t
 |      
 |      @param name: char const *
 |      @param tag: uchar
 |      @param nds_flags: uint32
 |      @param node_helper: merge_node_helper_t *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_merge_node_info_t(...)
 |      delete_merge_node_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  nds_flags
 |      nds_flags
 |  
 |  node_helper
 |      node_helper
 |  
 |  tag
 |      tag
 |  
 |  thisown
 |      The membership flag

Help on class moddata_diff_helper_t in module ida_merge:

class moddata_diff_helper_t(builtins.object)
 |  Proxy of C++ moddata_diff_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, _module_name, _netnode_name, _fields) -> moddata_diff_helper_t
 |      
 |      @param _module_name: char const *
 |      @param _netnode_name: char const *
 |      @param _fields: idbattr_info_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_moddata_diff_helper_t(...)
 |      delete_moddata_diff_helper_t(self)
 |  
 |  get_struc_ptr(self, *args) -> 'void *'
 |      get_struc_ptr(self, arg0, arg1, arg2) -> void *
 |      
 |      @param arg0: merge_data_t &
 |      @param arg1: diff_source_idx_t
 |      @param arg2: idbattr_info_t const &
 |  
 |  merge_ending(self, *args) -> 'void'
 |      merge_ending(self, arg0, arg1)
 |      
 |      @param arg0: diff_source_idx_t
 |      @param arg1: void *
 |  
 |  merge_starting(self, *args) -> 'void'
 |      merge_starting(self, arg0, arg1)
 |      
 |      @param arg0: diff_source_idx_t
 |      @param arg1: void *
 |  
 |  print_diffpos_details(self, *args) -> 'void'
 |      print_diffpos_details(self, arg0, arg1)
 |      
 |      @param arg0: qstrvec_t *
 |      @param arg1: idbattr_info_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  additional_mh_flags
 |      additional_mh_flags
 |  
 |  fields
 |      fields
 |  
 |  module_name
 |      module_name
 |  
 |  netnode_name
 |      netnode_name
 |  
 |  nfields
 |      nfields
 |  
 |  thisown
 |      The membership flag

Module "ida_mergemod"s docstring:
"""
Merge functionality for modules.

NOTE: this functionality is available in IDA Teams (not IDA Pro)

This file contains helper classes and convenience functions for module (plugin
or processor module) merging.

Each module is responsible for merging the data it owns (the module data). At
the very beginning, the merging engine generates the ev_create_merge_handlers
event. Modules should hook to this event to create merge handlers (mergers) that
are responsible for the module data.

We assume that each module may have:

* its data structure, derived from plugmod_t or procmod_t. we call this
structure moddata.
* a dedicated netnode (module node), modnode for short.

Moddata is registered with the IDA kernel using the set_module_data() function,
which returns an integer, moddata_id. moddata_id is used to access the module
data structure during merging, so it is mandatory for all modules that support
merging.

The following sources of mergeable data are supported:

1. Data fields inside moddata 2. Values (scalar or binary, including blobs)
stored in the module node 3. Values (scalar or binary, including blobs) stored
in arbitrary netnodes 4. Data fields inside an auxiliary structure (provided by
a special helper) 5. Indexed arrays of data stored in netnodes

Usually the sources #1-4 are handled by a single merger, which can be
parameterized using the folowing information:

* moddata_id
* module name
* module node name
* array of field descriptors (idbattr_info_t idpopts_info[], see ida.hpp)

See plugins/mex1 for an example of such a merger.

These parameters are stored in a helper class (moddata_diff_helper_t or
derived). The helper class can override the following virtual methods:

merge_starting - prepare module data for merging (e.g. load data from idb)
merge_ending - opposite to merge_starting (e.g. save merged data to idb)
get_struc_ptr - get pointer to the auxiliary structure (to handle source #4);
this method will be called only if the fields with the IDI_HLPSTRUC bit are
present in the idpopts_info[] array

For most plugins, the default implementation of moddata_diff_helper_t or the
std_moddata_diff_helper_t helper (presented below) is sufficient. You can find
examples of non-standard helpers in plugins/mex2 and plugins/callgraph.

The source #5 is handled by a different set of mergers described by an array of
merge_node_info_t entries: a merger per entry. A non-trivial example can be
found in plugins/mex3 and plugins/ex_merge_ldrdata.

A module can use the create_std_modmerge_handlers() function to create necessary
merge handlers. Please pay attention to the following arguments:

helper - a helper class responsible for access to the internal module data for
the sources #1-4. It can be used to prepare a pointer to the internal module
structure and load/save data before/after merging (example: plugins/mex2). Im
most cases the default helper class moddata_diff_helper_t can be used.
merge_node_info - array of descriptions for the source #5. Note that the same
module node is used for all array elements. If you need this kind of mergers for
other netnodes, you should add them manually using the
create_nodeval_merge_handler() function (example: plugins/mex3)

See also module/mergecmn.cpp for procmod-specific functions and macros.

Glossary:

modmerger = module merger moddata = module data moddata_id = module data id"""

Help on function create_std_modmerge_handlers in module ida_mergemod:

create_std_modmerge_handlers(*args) -> 'void'
    create_std_modmerge_handlers(mhp, helper, merge_node_info=None)
    convinience function to create merge handlers for modules/plugins
    
    @param mhp: (C++: merge_handler_params_t &)
    @param helper: (C++: moddata_diff_helper_t &)
    @param merge_node_info: (C++: const merge_node_info_t *) merge_node_info2_t const *

Module "ida_moves"s docstring:
"""
"""

Help on class bookmarks_t in module ida_moves:

class bookmarks_t(builtins.object)
 |  Proxy of C++ bookmarks_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  erase(*args) -> 'bool'
 |      erase(e, index, ud) -> bool
 |      
 |      @param e: lochist_entry_t const &
 |      @param index: uint32
 |      @param ud: void *
 |  
 |  find_index(*args) -> 'uint32'
 |      find_index(e, ud) -> uint32
 |      
 |      @param e: lochist_entry_t const &
 |      @param ud: void *
 |  
 |  get(*args) -> 'bool'
 |      get(out_entry, out_desc, index, ud) -> bool
 |      
 |      @param out_entry: lochist_entry_t *
 |      @param out_desc: qstring *
 |      @param index: uint32 *
 |      @param ud: void *
 |  
 |  get_desc(*args) -> 'qstring *'
 |      get_desc(e, index, ud) -> bool
 |      
 |      @param e: lochist_entry_t const &
 |      @param index: uint32
 |      @param ud: void *
 |  
 |  get_dirtree_id(*args) -> 'dirtree_id_t'
 |      get_dirtree_id(e, ud) -> dirtree_id_t
 |      
 |      @param e: lochist_entry_t const &
 |      @param ud: void *
 |  
 |  mark(*args) -> 'uint32'
 |      mark(e, index, title, desc, ud) -> uint32
 |      
 |      @param e: lochist_entry_t const &
 |      @param index: uint32
 |      @param title: char const *
 |      @param desc: char const *
 |      @param ud: void *
 |  
 |  size(*args) -> 'uint32'
 |      size(e, ud) -> uint32
 |      
 |      @param e: lochist_entry_t const &
 |      @param ud: void *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function bookmarks_t_erase in module ida_moves:

bookmarks_t_erase(*args) -> 'bool'
    bookmarks_t_erase(e, index, ud) -> bool
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param ud: void *

Help on function bookmarks_t_find_index in module ida_moves:

bookmarks_t_find_index(*args) -> 'uint32'
    bookmarks_t_find_index(e, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param ud: void *

Help on function bookmarks_t_get in module ida_moves:

bookmarks_t_get(*args) -> 'bool'
    bookmarks_t_get(out_entry, out_desc, index, ud) -> bool
    
    @param out_entry: lochist_entry_t *
    @param out_desc: qstring *
    @param index: uint32 *
    @param ud: void *

Help on function bookmarks_t_get_desc in module ida_moves:

bookmarks_t_get_desc(*args) -> 'qstring *'
    bookmarks_t_get_desc(e, index, ud) -> str
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param ud: void *

Help on function bookmarks_t_get_dirtree_id in module ida_moves:

bookmarks_t_get_dirtree_id(*args) -> 'dirtree_id_t'
    bookmarks_t_get_dirtree_id(e, ud) -> dirtree_id_t
    
    @param e: lochist_entry_t const &
    @param ud: void *

Help on function bookmarks_t_mark in module ida_moves:

bookmarks_t_mark(*args) -> 'uint32'
    bookmarks_t_mark(e, index, title, desc, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param index: uint32
    @param title: char const *
    @param desc: char const *
    @param ud: void *

Help on function bookmarks_t_size in module ida_moves:

bookmarks_t_size(*args) -> 'uint32'
    bookmarks_t_size(e, ud) -> uint32
    
    @param e: lochist_entry_t const &
    @param ud: void *

Help on class graph_location_info_t in module ida_moves:

class graph_location_info_t(builtins.object)
 |  Proxy of C++ graph_location_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: graph_location_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> graph_location_info_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: graph_location_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_graph_location_info_t(...)
 |      delete_graph_location_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  orgx
 |      orgx
 |  
 |  orgy
 |      orgy
 |  
 |  thisown
 |      The membership flag
 |  
 |  zoom
 |      zoom
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class lochist_entry_t in module ida_moves:

class lochist_entry_t(builtins.object)
 |  Proxy of C++ lochist_entry_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lochist_entry_t
 |      __init__(self, p, r) -> lochist_entry_t
 |      
 |      @param p: place_t const *
 |      @param r: renderer_info_t const &
 |      
 |      __init__(self, other) -> lochist_entry_t
 |      
 |      @param other: lochist_entry_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lochist_entry_t(...)
 |      delete_lochist_entry_t(self)
 |  
 |  acquire_place(self, *args) -> 'void'
 |      acquire_place(self, in_p)
 |      
 |      @param in_p: place_t *
 |  
 |  is_valid(self, *args) -> 'bool'
 |      is_valid(self) -> bool
 |  
 |  place(self, *args) -> 'place_t *'
 |      place(self) -> place_t
 |  
 |  renderer_info(self, *args) -> 'renderer_info_t &'
 |      renderer_info(self) -> renderer_info_t
 |  
 |  set_place(self, *args) -> 'void'
 |      set_place(self, p)
 |      
 |      @param p: place_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  plce
 |      plce
 |  
 |  rinfo
 |      rinfo
 |  
 |  thisown
 |      The membership flag

Help on class lochist_t in module ida_moves:

class lochist_t(builtins.object)
 |  Proxy of C++ lochist_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> lochist_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lochist_t(...)
 |      delete_lochist_t(self)
 |  
 |  back(self, *args) -> 'bool'
 |      back(self, cnt, try_to_unhide) -> bool
 |      
 |      @param cnt: uint32
 |      @param try_to_unhide: bool
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  current_index(self, *args) -> 'uint32'
 |      current_index(self) -> uint32
 |  
 |  fwd(self, *args) -> 'bool'
 |      fwd(self, cnt, try_to_unhide) -> bool
 |      
 |      @param cnt: uint32
 |      @param try_to_unhide: bool
 |  
 |  get(self, *args) -> 'bool'
 |      get(self, out, index) -> bool
 |      
 |      @param out: lochist_entry_t *
 |      @param index: uint32
 |  
 |  get_current(self, *args) -> 'lochist_entry_t const &'
 |      get_current(self) -> lochist_entry_t
 |  
 |  get_place_id(self, *args) -> 'int'
 |      get_place_id(self) -> int
 |  
 |  get_template_place(self, *args) -> 'place_t const *'
 |      get_template_place(self) -> place_t
 |  
 |  init(self, *args) -> 'bool'
 |      init(self, stream_name, _defpos, _ud, _flags) -> bool
 |      
 |      @param stream_name: char const *
 |      @param _defpos: place_t const *
 |      @param _ud: void *
 |      @param _flags: uint32
 |  
 |  is_history_enabled(self, *args) -> 'bool'
 |      is_history_enabled(self) -> bool
 |  
 |  jump(self, *args) -> 'void'
 |      jump(self, try_to_unhide, e)
 |      
 |      @param try_to_unhide: bool
 |      @param e: lochist_entry_t const &
 |  
 |  netcode(self, *args) -> 'nodeidx_t'
 |      netcode(self) -> nodeidx_t
 |  
 |  save(self, *args) -> 'void'
 |      save(self)
 |  
 |  seek(self, *args) -> 'bool'
 |      seek(self, index, try_to_unhide) -> bool
 |      
 |      @param index: uint32
 |      @param try_to_unhide: bool
 |  
 |  set(self, *args) -> 'void'
 |      set(self, index, e)
 |      
 |      @param index: uint32
 |      @param e: lochist_entry_t const &
 |  
 |  set_current(self, *args) -> 'void'
 |      set_current(self, e)
 |      
 |      @param e: lochist_entry_t const &
 |  
 |  size(self, *args) -> 'uint32'
 |      size(self) -> uint32
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class renderer_info_pos_t in module ida_moves:

class renderer_info_pos_t(builtins.object)
 |  Proxy of C++ renderer_info_pos_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: renderer_info_pos_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_info_pos_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: renderer_info_pos_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_renderer_info_pos_t(...)
 |      delete_renderer_info_pos_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cx
 |      cx
 |  
 |  cy
 |      cy
 |  
 |  node
 |      node
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class renderer_info_t in module ida_moves:

class renderer_info_t(builtins.object)
 |  Proxy of C++ renderer_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: renderer_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> renderer_info_t
 |      __init__(self, _rtype, cx, cy) -> renderer_info_t
 |      
 |      @param _rtype: enum tcc_renderer_type_t
 |      @param cx: short
 |      @param cy: short
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: renderer_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_renderer_info_t(...)
 |      delete_renderer_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  gli
 |      gli
 |  
 |  pos
 |      pos
 |  
 |  rtype
 |      rtype
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class segm_move_info_t in module ida_moves:

class segm_move_info_t(builtins.object)
 |  Proxy of C++ segm_move_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: segm_move_info_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _from=0, _to=0, _sz=0) -> segm_move_info_t
 |      
 |      @param _from: ea_t
 |      @param _to: ea_t
 |      @param _sz: size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: segm_move_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_segm_move_info_t(...)
 |      delete_segm_move_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _from
 |      _from
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      to
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class segm_move_info_vec_t in module ida_moves:

class segm_move_info_vec_t(builtins.object)
 |  Proxy of C++ qvector< segm_move_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< segm_move_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'segm_move_info_t const &'
 |      __getitem__(self, i) -> segm_move_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segm_move_info_vec_t
 |      __init__(self, x) -> segm_move_info_vec_t
 |      
 |      @param x: qvector< segm_move_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< segm_move_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: segm_move_info_t const &
 |  
 |  __swig_destroy__ = delete_segm_move_info_vec_t(...)
 |      delete_segm_move_info_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: segm_move_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  at(self, *args) -> 'segm_move_info_t const &'
 |      at(self, _idx) -> segm_move_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      begin(self) -> segm_move_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      end(self) -> segm_move_info_t
 |  
 |  erase(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      erase(self, it) -> segm_move_info_t
 |      
 |      @param it: qvector< segm_move_info_t >::iterator
 |      
 |      erase(self, first, last) -> segm_move_info_t
 |      
 |      @param first: qvector< segm_move_info_t >::iterator
 |      @param last: qvector< segm_move_info_t >::iterator
 |  
 |  extract(self, *args) -> 'segm_move_info_t *'
 |      extract(self) -> segm_move_info_t
 |  
 |  find(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      find(self, x) -> segm_move_info_t
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=segm_move_info_t())
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: segm_move_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      insert(self, it, x) -> segm_move_info_t
 |      
 |      @param it: qvector< segm_move_info_t >::iterator
 |      @param x: segm_move_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'segm_move_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: segm_move_info_t const &
 |      
 |      push_back(self) -> segm_move_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: segm_move_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< segm_move_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class segm_move_infos_t in module ida_moves:

class segm_move_infos_t(segm_move_info_vec_t)
 |  Proxy of C++ segm_move_infos_t class.
 |  
 |  Method resolution order:
 |      segm_move_infos_t
 |      segm_move_info_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segm_move_infos_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_segm_move_infos_t(...)
 |      delete_segm_move_infos_t(self)
 |  
 |  find(self, *args) -> 'segm_move_info_t const *'
 |      find(self, ea) -> segm_move_info_t
 |      
 |      @param ea: ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from segm_move_info_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< segm_move_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'segm_move_info_t const &'
 |      __getitem__(self, i) -> segm_move_info_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< segm_move_info_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: segm_move_info_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: segm_move_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  at(self, *args) -> 'segm_move_info_t const &'
 |      at(self, _idx) -> segm_move_info_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      begin(self) -> segm_move_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< segm_move_info_t >::const_iterator'
 |      end(self) -> segm_move_info_t
 |  
 |  erase(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      erase(self, it) -> segm_move_info_t
 |      
 |      @param it: qvector< segm_move_info_t >::iterator
 |      
 |      erase(self, first, last) -> segm_move_info_t
 |      
 |      @param first: qvector< segm_move_info_t >::iterator
 |      @param last: qvector< segm_move_info_t >::iterator
 |  
 |  extract(self, *args) -> 'segm_move_info_t *'
 |      extract(self) -> segm_move_info_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=segm_move_info_t())
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: segm_move_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: segm_move_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< segm_move_info_t >::iterator'
 |      insert(self, it, x) -> segm_move_info_t
 |      
 |      @param it: qvector< segm_move_info_t >::iterator
 |      @param x: segm_move_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'segm_move_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: segm_move_info_t const &
 |      
 |      push_back(self) -> segm_move_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: segm_move_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< segm_move_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from segm_move_info_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from segm_move_info_vec_t:
 |  
 |  __hash__ = None

Module "ida_nalt"s docstring:
"""
Definitions of various information kept in netnodes.

Each address in the program has a corresponding netnode: netnode(ea).

If we have no information about an address, the corresponding netnode is not
created. Otherwise we will create a netnode and save information in it. All
variable length information (names, comments, offset information, etc) is stored
in the netnode.

Don't forget that some information is already stored in the flags (bytes.hpp)

@warning: Many of the functions in this file are very low level (they are marked
          as low level functions). Use them only if you can't find higher level
          function to set/get/del information.netnode."""

Help on function get_switch_info in module ida_nalt:

get_switch_info(*args) -> 'ssize_t'
    get_switch_info(out, ea) -> ssize_t
    
    @param out: switch_info_t *
    @param ea: ea_t

Help on function add_encoding in module ida_nalt:

add_encoding(*args) -> 'int'
    add_encoding(encname) -> int
    Add a new encoding (e.g. "UTF-8"). If it's already in the list, return its
    index.
    
    @param encname: (C++: const char *) the encoding name
    @return: its index (1-based); -1 means error

Help on class array_parameters_t in module ida_nalt:

class array_parameters_t(builtins.object)
 |  Proxy of C++ array_parameters_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_parameters_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_array_parameters_t(...)
 |      delete_array_parameters_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  alignment
 |      alignment
 |  
 |  flags
 |      flags
 |  
 |  lineitems
 |      lineitems
 |  
 |  thisown
 |      The membership flag

Help on function clr__bnot0 in module ida_nalt:

clr__bnot0(*args) -> 'void'
    clr__bnot0(ea)
    
    @param ea: ea_t

Help on function clr__bnot1 in module ida_nalt:

clr__bnot1(*args) -> 'void'
    clr__bnot1(ea)
    
    @param ea: ea_t

Help on function clr__invsign0 in module ida_nalt:

clr__invsign0(*args) -> 'void'
    clr__invsign0(ea)
    
    @param ea: ea_t

Help on function clr__invsign1 in module ida_nalt:

clr__invsign1(*args) -> 'void'
    clr__invsign1(ea)
    
    @param ea: ea_t

Help on function clr_abits in module ida_nalt:

clr_abits(*args) -> 'void'
    clr_abits(ea, bits)
    
    @param ea: ea_t
    @param bits: aflags_t

Help on function clr_align_flow in module ida_nalt:

clr_align_flow(*args) -> 'void'
    clr_align_flow(ea)
    
    @param ea: ea_t

Help on function clr_colored_item in module ida_nalt:

clr_colored_item(*args) -> 'void'
    clr_colored_item(ea)
    
    @param ea: ea_t

Help on function clr_fixed_spd in module ida_nalt:

clr_fixed_spd(*args) -> 'void'
    clr_fixed_spd(ea)
    
    @param ea: ea_t

Help on function clr_has_lname in module ida_nalt:

clr_has_lname(*args) -> 'void'
    clr_has_lname(ea)
    
    @param ea: ea_t

Help on function clr_has_ti in module ida_nalt:

clr_has_ti(*args) -> 'void'
    clr_has_ti(ea)
    
    @param ea: ea_t

Help on function clr_has_ti0 in module ida_nalt:

clr_has_ti0(*args) -> 'void'
    clr_has_ti0(ea)
    
    @param ea: ea_t

Help on function clr_has_ti1 in module ida_nalt:

clr_has_ti1(*args) -> 'void'
    clr_has_ti1(ea)
    
    @param ea: ea_t

Help on function clr_libitem in module ida_nalt:

clr_libitem(*args) -> 'void'
    clr_libitem(ea)
    
    @param ea: ea_t

Help on function clr_lzero0 in module ida_nalt:

clr_lzero0(*args) -> 'void'
    clr_lzero0(ea)
    
    @param ea: ea_t

Help on function clr_lzero1 in module ida_nalt:

clr_lzero1(*args) -> 'void'
    clr_lzero1(ea)
    
    @param ea: ea_t

Help on function clr_noret in module ida_nalt:

clr_noret(*args) -> 'void'
    clr_noret(ea)
    
    @param ea: ea_t

Help on function clr_notcode in module ida_nalt:

clr_notcode(*args) -> 'void'
    clr_notcode(ea)
    Clear not-code mark.
    
    @param ea: (C++: ea_t)

Help on function clr_notproc in module ida_nalt:

clr_notproc(*args) -> 'void'
    clr_notproc(ea)
    
    @param ea: ea_t

Help on function clr_retfp in module ida_nalt:

clr_retfp(*args) -> 'void'
    clr_retfp(ea)
    
    @param ea: ea_t

Help on function clr_terse_struc in module ida_nalt:

clr_terse_struc(*args) -> 'void'
    clr_terse_struc(ea)
    
    @param ea: ea_t

Help on function clr_tilcmt in module ida_nalt:

clr_tilcmt(*args) -> 'void'
    clr_tilcmt(ea)
    
    @param ea: ea_t

Help on function clr_usemodsp in module ida_nalt:

clr_usemodsp(*args) -> 'void'
    clr_usemodsp(ea)
    
    @param ea: ea_t

Help on function clr_usersp in module ida_nalt:

clr_usersp(*args) -> 'void'
    clr_usersp(ea)
    
    @param ea: ea_t

Help on function clr_userti in module ida_nalt:

clr_userti(*args) -> 'void'
    clr_userti(ea)
    
    @param ea: ea_t

Help on function clr_zstroff in module ida_nalt:

clr_zstroff(*args) -> 'void'
    clr_zstroff(ea)
    
    @param ea: ea_t

Help on class custom_data_type_ids_fids_array in module ida_nalt:

class custom_data_type_ids_fids_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< int16,8 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'short const &'
 |      __getitem__(self, i) -> short const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> custom_data_type_ids_fids_array
 |      
 |      @param data: short (&)[8]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: short const &
 |  
 |  __swig_destroy__ = delete_custom_data_type_ids_fids_array(...)
 |      delete_custom_data_type_ids_fids_array(self)
 |  
 |  _get_bytes(self, *args) -> 'bytevec_t'
 |      _get_bytes(self) -> bytevec_t
 |  
 |  _set_bytes(self, *args) -> 'void'
 |      _set_bytes(self, bts)
 |      
 |      Parameters
 |      ----------
 |      bts: bytevec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      _get_bytes(self) -> bytevec_t
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class custom_data_type_ids_t in module ida_nalt:

class custom_data_type_ids_t(builtins.object)
 |  Proxy of C++ custom_data_type_ids_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> custom_data_type_ids_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_custom_data_type_ids_t(...)
 |      delete_custom_data_type_ids_t(self)
 |  
 |  _custom_data_type_ids_t__getFids = __getFids(self, *args) -> 'wrapped_array_t< int16,8 >'
 |      __getFids(self) -> custom_data_type_ids_fids_array
 |  
 |  get_dtid(self, *args) -> 'tid_t'
 |      get_dtid(self) -> tid_t
 |  
 |  set(self, *args) -> 'void'
 |      set(self, tid)
 |      
 |      @param tid: tid_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  dtid
 |      dtid
 |  
 |  fids
 |      __getFids(self) -> custom_data_type_ids_fids_array
 |  
 |  thisown
 |      The membership flag

Help on function dbg_get_input_path in module ida_nalt:

dbg_get_input_path(*args) -> 'size_t'
    dbg_get_input_path() -> str
    Get debugger input file name/path (see LFLG_DBG_NOPATH)

Help on function del_absbase in module ida_nalt:

del_absbase(*args) -> 'void'
    del_absbase(ea)
    
    @param ea: ea_t

Help on function del_aflags in module ida_nalt:

del_aflags(*args) -> 'void'
    del_aflags(ea)
    
    @param ea: ea_t

Help on function del_alignment in module ida_nalt:

del_alignment(*args) -> 'void'
    del_alignment(ea)
    
    @param ea: ea_t

Help on function del_array_parameters in module ida_nalt:

del_array_parameters(*args) -> 'void'
    del_array_parameters(ea)
    
    @param ea: ea_t

Help on function del_custom_data_type_ids in module ida_nalt:

del_custom_data_type_ids(*args) -> 'void'
    del_custom_data_type_ids(ea)
    
    @param ea: ea_t

Help on function del_encoding in module ida_nalt:

del_encoding(*args) -> 'bool'
    del_encoding(idx) -> bool
    Delete an encoding The encoding is not actually removed because its index may be
    used in strtype. So the deletion just clears the encoding name. The default
    encoding cannot be deleted.
    
    @param idx: (C++: int) the encoding index (1-based)

Help on function del_ind_purged in module ida_nalt:

del_ind_purged(*args) -> 'void'
    del_ind_purged(ea)
    
    @param ea: ea_t

Help on function del_item_color in module ida_nalt:

del_item_color(*args) -> 'bool'
    del_item_color(ea) -> bool
    
    @param ea: ea_t

Help on function del_op_tinfo in module ida_nalt:

del_op_tinfo(*args) -> 'void'
    del_op_tinfo(ea, n)
    
    @param ea: ea_t
    @param n: int

Help on function del_refinfo in module ida_nalt:

del_refinfo(*args) -> 'bool'
    del_refinfo(ea, n) -> bool
    
    @param ea: ea_t
    @param n: int

Help on function del_source_linnum in module ida_nalt:

del_source_linnum(*args) -> 'void'
    del_source_linnum(ea)
    
    @param ea: ea_t

Help on function del_str_type in module ida_nalt:

del_str_type(*args) -> 'void'
    del_str_type(ea)
    
    @param ea: ea_t

Help on function del_switch_info in module ida_nalt:

del_switch_info(*args) -> 'void'
    del_switch_info(ea)
    
    @param ea: ea_t

Help on function del_switch_parent in module ida_nalt:

del_switch_parent(*args) -> 'void'
    del_switch_parent(ea)
    
    @param ea: ea_t

Help on function del_tinfo in module ida_nalt:

del_tinfo(*args) -> 'void'
    del_tinfo(ea)
    
    @param ea: ea_t

Help on function delete_imports in module ida_nalt:

delete_imports(*args) -> 'void'
    delete_imports()
    Delete all imported modules information.

Help on function ea2node in module ida_nalt:

ea2node(*args) -> 'nodeidx_t'
    ea2node(ea) -> nodeidx_t
    Get netnode for the specified address.
    
    @param ea: (C++: ea_t)

Help on function encoding_from_strtype in module ida_nalt:

encoding_from_strtype(*args) -> 'char const *'
    encoding_from_strtype(strtype) -> char const *
    Get encoding name for this strtype
    @retval nullptr: if STRTYPE has an incorrent encoding index
    @retval empty: string if the encoding was deleted
    
    @param strtype: (C++: int32)

Help on class enum_const_t in module ida_nalt:

class enum_const_t(builtins.object)
 |  Proxy of C++ enum_const_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_const_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_const_t(...)
 |      delete_enum_const_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  serial
 |      serial
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tid

Help on function enum_import_names in module ida_nalt:

enum_import_names(*args) -> 'int'
    enum_import_names(mod_index, py_cb) -> int
    Enumerate imports from a specific module.
    Please refer to ex_imports.py example.
    
    @param mod_index: The module index
    @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)

Help on function find_custom_refinfo in module ida_nalt:

find_custom_refinfo(*args) -> 'int'
    find_custom_refinfo(name) -> int
    Get id of a custom refinfo type.
    
    @param name: (C++: const char *) char const *

Help on function get_abi_name in module ida_nalt:

get_abi_name()

Help on function get_absbase in module ida_nalt:

get_absbase(*args) -> 'ea_t'
    get_absbase(ea) -> ea_t
    
    @param ea: ea_t

Help on function get_aflags in module ida_nalt:

get_aflags(*args) -> 'aflags_t'
    get_aflags(ea) -> aflags_t
    
    @param ea: ea_t

Help on function get_alignment in module ida_nalt:

get_alignment(*args) -> 'uint32'
    get_alignment(ea) -> uint32
    
    @param ea: ea_t

Help on function get_archive_path in module ida_nalt:

get_archive_path(*args) -> 'qstring *'
    get_archive_path() -> str
    Get archive file path from which input file was extracted.

Help on function get_array_parameters in module ida_nalt:

get_array_parameters(*args) -> 'ssize_t'
    get_array_parameters(out, ea) -> ssize_t
    
    @param out: array_parameters_t *
    @param ea: ea_t

Help on function get_asm_inc_file in module ida_nalt:

get_asm_inc_file(*args) -> 'qstring *'
    get_asm_inc_file() -> str
    Get name of the include file.

Help on function get_custom_data_type_ids in module ida_nalt:

get_custom_data_type_ids(*args) -> 'int'
    get_custom_data_type_ids(cdis, ea) -> int
    
    @param cdis: custom_data_type_ids_t *
    @param ea: ea_t

Help on function get_custom_refinfo in module ida_nalt:

get_custom_refinfo(*args) -> 'custom_refinfo_handler_t const *'
    get_custom_refinfo(crid) -> custom_refinfo_handler_t const *
    Get definition of a registered custom refinfo type.
    
    @param crid: (C++: int)

Help on function get_default_encoding_idx in module ida_nalt:

get_default_encoding_idx(*args) -> 'int'
    get_default_encoding_idx(bpu) -> int
    Get default encoding index for a specific string type.
    
    @param bpu: (C++: int) the amount of bytes per unit (e.g., 1 for ASCII, CP1252, UTF-8..., 2
                for UTF-16, 4 for UTF-32)
    @retval 0: bad BPU argument

Help on function get_elapsed_secs in module ida_nalt:

get_elapsed_secs(*args) -> 'size_t'
    get_elapsed_secs() -> size_t
    Get seconds database stayed open.

Help on function get_encoding_bpu in module ida_nalt:

get_encoding_bpu(*args) -> 'int'
    get_encoding_bpu(idx) -> int
    Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32) for the
    encoding with the given index.
    
    @param idx: (C++: int) the encoding index (1-based)
    @return: the number of bytes per units (1/2/4); -1 means error

Help on function get_encoding_bpu_by_name in module ida_nalt:

get_encoding_bpu_by_name(*args) -> 'int'
    get_encoding_bpu_by_name(encname) -> int
    Get the amount of bytes per unit for the given encoding
    
    @param encname: (C++: const char *) the encoding name
    @return: the number of bytes per units (1/2/4); -1 means error

Help on function get_encoding_name in module ida_nalt:

get_encoding_name(*args) -> 'char const *'
    get_encoding_name(idx) -> char const *
    Get encoding name for specific index (1-based).
    
    @param idx: (C++: int) the encoding index (1-based)
    @retval nullptr: if IDX is out of bounds
    @retval empty: string if the encoding was deleted

Help on function get_encoding_qty in module ida_nalt:

get_encoding_qty(*args) -> 'int'
    get_encoding_qty() -> int
    Get total number of encodings (counted from 0)

Help on function get_gotea in module ida_nalt:

get_gotea(*args) -> 'ea_t'
    get_gotea() -> ea_t

Help on function get_ida_notepad_text in module ida_nalt:

get_ida_notepad_text(*args) -> 'qstring *'
    get_ida_notepad_text() -> str
    Get notepad text.

Help on function get_idb_ctime in module ida_nalt:

get_idb_ctime(*args) -> 'time_t'
    get_idb_ctime() -> time_t
    Get database creation timestamp.

Help on function get_idb_nopens in module ida_nalt:

get_idb_nopens(*args) -> 'size_t'
    get_idb_nopens() -> size_t
    Get number of times the database is opened.

Help on function get_ids_modnode in module ida_nalt:

get_ids_modnode(*args) -> 'netnode'
    get_ids_modnode() -> netnode
    Get ids modnode.

Help on function get_imagebase in module ida_nalt:

get_imagebase(*args) -> 'ea_t'
    get_imagebase() -> ea_t
    Get image base address.

Help on function get_import_module_name in module ida_nalt:

get_import_module_name(*args) -> 'PyObject *'
    get_import_module_name(mod_index) -> str
    Returns the name of an imported module given its index
    
    @param mod_index: int
    @return: None or the module name

Help on function get_import_module_qty in module ida_nalt:

get_import_module_qty(*args) -> 'uint'
    get_import_module_qty() -> uint
    Get number of import modules.

Help on function get_ind_purged in module ida_nalt:

get_ind_purged(*args) -> 'ea_t'
    get_ind_purged(ea) -> ea_t
    
    @param ea: ea_t

Help on function get_initial_ida_version in module ida_nalt:

get_initial_ida_version(*args) -> 'qstring *'
    get_initial_ida_version() -> str
    Get version of ida which created the database (string format like "7.5")

Help on function get_initial_idb_version in module ida_nalt:

get_initial_idb_version(*args) -> 'ushort'
    get_initial_idb_version() -> ushort
    Get initial version of the database (numeric format like 700)

Help on function get_input_file_path in module ida_nalt:

get_input_file_path(*args) -> 'size_t'
    get_input_file_path() -> str
    Get full path of the input file.

Help on function get_item_color in module ida_nalt:

get_item_color(*args) -> 'bgcolor_t'
    get_item_color(ea) -> bgcolor_t
    
    @param ea: ea_t

Help on function get_loader_format_name in module ida_nalt:

get_loader_format_name(*args) -> 'qstring *'
    get_loader_format_name() -> str
    Get file format name for loader modules.

Help on function get_op_tinfo in module ida_nalt:

get_op_tinfo(*args) -> 'bool'
    get_op_tinfo(tif, ea, n) -> bool
    
    @param tif: tinfo_t *
    @param ea: ea_t
    @param n: int

Help on function get_outfile_encoding_idx in module ida_nalt:

get_outfile_encoding_idx(*args) -> 'int'
    get_outfile_encoding_idx() -> int
    Get the index of the encoding used when producing files
    @retval 0: the IDB's default 1 byte-per-unit encoding is used

Help on function get_refinfo in module ida_nalt:

get_refinfo(*args) -> 'bool'
    get_refinfo(ri, ea, n) -> bool
    
    @param ri: refinfo_t *
    @param ea: ea_t
    @param n: int

Help on function get_reftype_by_size in module ida_nalt:

get_reftype_by_size(*args) -> 'reftype_t'
    get_reftype_by_size(size) -> reftype_t
    Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other sizes
    returns reftype_t(-1)
    
    @param size: (C++: size_t)

Help on function get_root_filename in module ida_nalt:

get_root_filename(*args) -> 'size_t'
    get_root_filename() -> str
    Get file name only of the input file.

Help on function get_source_linnum in module ida_nalt:

get_source_linnum(*args) -> 'uval_t'
    get_source_linnum(ea) -> uval_t
    
    @param ea: ea_t

Help on function get_srcdbg_paths in module ida_nalt:

get_srcdbg_paths(*args) -> 'qstring *'
    get_srcdbg_paths() -> str
    Get source debug paths.

Help on function get_srcdbg_undesired_paths in module ida_nalt:

get_srcdbg_undesired_paths(*args) -> 'qstring *'
    get_srcdbg_undesired_paths() -> str
    Get user-closed source files.

Help on function get_str_encoding_idx in module ida_nalt:

get_str_encoding_idx(*args) -> 'uchar'
    get_str_encoding_idx(strtype) -> uchar
    Get index of the string encoding for this string.
    
    @param strtype: (C++: int32)

Help on function get_str_term1 in module ida_nalt:

get_str_term1(*args) -> 'char'
    get_str_term1(strtype) -> char
    
    @param strtype: int32

Help on function get_str_term2 in module ida_nalt:

get_str_term2(*args) -> 'char'
    get_str_term2(strtype) -> char
    
    @param strtype: int32

Help on function get_str_type in module ida_nalt:

get_str_type(*args) -> 'uint32'
    get_str_type(ea) -> uint32
    
    @param ea: ea_t

Help on function get_str_type_code in module ida_nalt:

get_str_type_code(*args) -> 'uchar'
    get_str_type_code(strtype) -> uchar
    
    @param strtype: int32

Help on function get_str_type_prefix_length in module ida_nalt:

get_str_type_prefix_length(*args) -> 'size_t'
    get_str_type_prefix_length(strtype) -> size_t
    
    @param strtype: int32

Help on function get_strid in module ida_nalt:

get_strid(*args) -> 'tid_t'
    get_strid(ea) -> tid_t
    
    @param ea: ea_t

Help on function get_strtype_bpu in module ida_nalt:

get_strtype_bpu(*args) -> 'int'
    get_strtype_bpu(strtype) -> int
    
    @param strtype: int32

Help on function get_switch_info in module ida_nalt:

get_switch_info(*args)

Help on function get_switch_parent in module ida_nalt:

get_switch_parent(*args) -> 'ea_t'
    get_switch_parent(ea) -> ea_t
    
    @param ea: ea_t

Help on function get_tinfo in module ida_nalt:

get_tinfo(*args) -> 'bool'
    get_tinfo(tif, ea) -> bool
    
    @param tif: tinfo_t *
    @param ea: ea_t

Help on function getnode in module ida_nalt:

getnode(*args) -> 'netnode'
    getnode(ea) -> netnode
    
    @param ea: ea_t

Help on function has_aflag_linnum in module ida_nalt:

has_aflag_linnum(*args) -> 'bool'
    has_aflag_linnum(flags) -> bool
    
    @param flags: aflags_t

Help on function has_aflag_lname in module ida_nalt:

has_aflag_lname(*args) -> 'bool'
    has_aflag_lname(flags) -> bool
    
    @param flags: aflags_t

Help on function has_aflag_ti in module ida_nalt:

has_aflag_ti(*args) -> 'bool'
    has_aflag_ti(flags) -> bool
    
    @param flags: aflags_t

Help on function has_aflag_ti0 in module ida_nalt:

has_aflag_ti0(*args) -> 'bool'
    has_aflag_ti0(flags) -> bool
    
    @param flags: aflags_t

Help on function has_aflag_ti1 in module ida_nalt:

has_aflag_ti1(*args) -> 'bool'
    has_aflag_ti1(flags) -> bool
    
    @param flags: aflags_t

Help on function has_lname in module ida_nalt:

has_lname(*args) -> 'bool'
    has_lname(ea) -> bool
    
    @param ea: ea_t

Help on function has_ti in module ida_nalt:

has_ti(*args) -> 'bool'
    has_ti(ea) -> bool
    
    @param ea: ea_t

Help on function has_ti0 in module ida_nalt:

has_ti0(*args) -> 'bool'
    has_ti0(ea) -> bool
    
    @param ea: ea_t

Help on function has_ti1 in module ida_nalt:

has_ti1(*args) -> 'bool'
    has_ti1(ea) -> bool
    
    @param ea: ea_t

Help on function hide_border in module ida_nalt:

hide_border(*args) -> 'void'
    hide_border(ea)
    
    @param ea: ea_t

Help on function hide_item in module ida_nalt:

hide_item(*args) -> 'void'
    hide_item(ea)
    
    @param ea: ea_t

Help on function is__bnot0 in module ida_nalt:

is__bnot0(*args) -> 'bool'
    is__bnot0(ea) -> bool
    
    @param ea: ea_t

Help on function is__bnot1 in module ida_nalt:

is__bnot1(*args) -> 'bool'
    is__bnot1(ea) -> bool
    
    @param ea: ea_t

Help on function is__invsign0 in module ida_nalt:

is__invsign0(*args) -> 'bool'
    is__invsign0(ea) -> bool
    
    @param ea: ea_t

Help on function is__invsign1 in module ida_nalt:

is__invsign1(*args) -> 'bool'
    is__invsign1(ea) -> bool
    
    @param ea: ea_t

Help on function is_aflag__bnot0 in module ida_nalt:

is_aflag__bnot0(*args) -> 'bool'
    is_aflag__bnot0(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag__bnot1 in module ida_nalt:

is_aflag__bnot1(*args) -> 'bool'
    is_aflag__bnot1(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag__invsign0 in module ida_nalt:

is_aflag__invsign0(*args) -> 'bool'
    is_aflag__invsign0(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag__invsign1 in module ida_nalt:

is_aflag__invsign1(*args) -> 'bool'
    is_aflag__invsign1(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_align_flow in module ida_nalt:

is_aflag_align_flow(*args) -> 'bool'
    is_aflag_align_flow(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_colored_item in module ida_nalt:

is_aflag_colored_item(*args) -> 'bool'
    is_aflag_colored_item(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_data_guessed_by_hexrays in module ida_nalt:

is_aflag_data_guessed_by_hexrays(*args) -> 'bool'
    is_aflag_data_guessed_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_fixed_spd in module ida_nalt:

is_aflag_fixed_spd(*args) -> 'bool'
    is_aflag_fixed_spd(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_func_guessed_by_hexrays in module ida_nalt:

is_aflag_func_guessed_by_hexrays(*args) -> 'bool'
    is_aflag_func_guessed_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_hidden_border in module ida_nalt:

is_aflag_hidden_border(*args) -> 'bool'
    is_aflag_hidden_border(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_hidden_item in module ida_nalt:

is_aflag_hidden_item(*args) -> 'bool'
    is_aflag_hidden_item(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_libitem in module ida_nalt:

is_aflag_libitem(*args) -> 'bool'
    is_aflag_libitem(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_lzero0 in module ida_nalt:

is_aflag_lzero0(*args) -> 'bool'
    is_aflag_lzero0(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_lzero1 in module ida_nalt:

is_aflag_lzero1(*args) -> 'bool'
    is_aflag_lzero1(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_manual_insn in module ida_nalt:

is_aflag_manual_insn(*args) -> 'bool'
    is_aflag_manual_insn(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_noret in module ida_nalt:

is_aflag_noret(*args) -> 'bool'
    is_aflag_noret(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_notcode in module ida_nalt:

is_aflag_notcode(*args) -> 'bool'
    is_aflag_notcode(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_notproc in module ida_nalt:

is_aflag_notproc(*args) -> 'bool'
    is_aflag_notproc(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_public_name in module ida_nalt:

is_aflag_public_name(*args) -> 'bool'
    is_aflag_public_name(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_retfp in module ida_nalt:

is_aflag_retfp(*args) -> 'bool'
    is_aflag_retfp(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_terse_struc in module ida_nalt:

is_aflag_terse_struc(*args) -> 'bool'
    is_aflag_terse_struc(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_tilcmt in module ida_nalt:

is_aflag_tilcmt(*args) -> 'bool'
    is_aflag_tilcmt(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_type_determined_by_hexrays in module ida_nalt:

is_aflag_type_determined_by_hexrays(*args) -> 'bool'
    is_aflag_type_determined_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_type_guessed_by_hexrays in module ida_nalt:

is_aflag_type_guessed_by_hexrays(*args) -> 'bool'
    is_aflag_type_guessed_by_hexrays(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_type_guessed_by_ida in module ida_nalt:

is_aflag_type_guessed_by_ida(*args) -> 'bool'
    is_aflag_type_guessed_by_ida(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_usersp in module ida_nalt:

is_aflag_usersp(*args) -> 'bool'
    is_aflag_usersp(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_userti in module ida_nalt:

is_aflag_userti(*args) -> 'bool'
    is_aflag_userti(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_weak_name in module ida_nalt:

is_aflag_weak_name(*args) -> 'bool'
    is_aflag_weak_name(flags) -> bool
    
    @param flags: aflags_t

Help on function is_aflag_zstroff in module ida_nalt:

is_aflag_zstroff(*args) -> 'bool'
    is_aflag_zstroff(flags) -> bool
    
    @param flags: aflags_t

Help on function is_align_flow in module ida_nalt:

is_align_flow(*args) -> 'bool'
    is_align_flow(ea) -> bool
    
    @param ea: ea_t

Help on function is_colored_item in module ida_nalt:

is_colored_item(*args) -> 'bool'
    is_colored_item(ea) -> bool
    
    @param ea: ea_t

Help on function is_data_guessed_by_hexrays in module ida_nalt:

is_data_guessed_by_hexrays(*args) -> 'bool'
    is_data_guessed_by_hexrays(ea) -> bool
    
    @param ea: ea_t

Help on function is_finally_visible_item in module ida_nalt:

is_finally_visible_item(*args) -> 'bool'
    is_finally_visible_item(ea) -> bool
    Is instruction visible?
    
    @param ea: (C++: ea_t)

Help on function is_fixed_spd in module ida_nalt:

is_fixed_spd(*args) -> 'bool'
    is_fixed_spd(ea) -> bool
    
    @param ea: ea_t

Help on function is_func_guessed_by_hexrays in module ida_nalt:

is_func_guessed_by_hexrays(*args) -> 'bool'
    is_func_guessed_by_hexrays(ea) -> bool
    
    @param ea: ea_t

Help on function is_hidden_border in module ida_nalt:

is_hidden_border(*args) -> 'bool'
    is_hidden_border(ea) -> bool
    
    @param ea: ea_t

Help on function is_hidden_item in module ida_nalt:

is_hidden_item(*args) -> 'bool'
    is_hidden_item(ea) -> bool
    
    @param ea: ea_t

Help on function is_libitem in module ida_nalt:

is_libitem(*args) -> 'bool'
    is_libitem(ea) -> bool
    
    @param ea: ea_t

Help on function is_lzero0 in module ida_nalt:

is_lzero0(*args) -> 'bool'
    is_lzero0(ea) -> bool
    
    @param ea: ea_t

Help on function is_lzero1 in module ida_nalt:

is_lzero1(*args) -> 'bool'
    is_lzero1(ea) -> bool
    
    @param ea: ea_t

Help on function is_noret in module ida_nalt:

is_noret(*args) -> 'bool'
    is_noret(ea) -> bool
    
    @param ea: ea_t

Help on function is_notcode in module ida_nalt:

is_notcode(*args) -> 'bool'
    is_notcode(ea) -> bool
    Is the address marked as not-code?
    
    @param ea: (C++: ea_t)

Help on function is_notproc in module ida_nalt:

is_notproc(*args) -> 'bool'
    is_notproc(ea) -> bool
    
    @param ea: ea_t

Help on function is_pascal in module ida_nalt:

is_pascal(*args) -> 'bool'
    is_pascal(strtype) -> bool
    
    @param strtype: int32

Help on function is_reftype_target_optional in module ida_nalt:

is_reftype_target_optional(*args) -> 'bool'
    is_reftype_target_optional(type) -> bool
    Can the target be calculated using operand value?
    
    @param type: (C++: reftype_t)

Help on function is_retfp in module ida_nalt:

is_retfp(*args) -> 'bool'
    is_retfp(ea) -> bool
    
    @param ea: ea_t

Help on function is_terse_struc in module ida_nalt:

is_terse_struc(*args) -> 'bool'
    is_terse_struc(ea) -> bool
    
    @param ea: ea_t

Help on function is_tilcmt in module ida_nalt:

is_tilcmt(*args) -> 'bool'
    is_tilcmt(ea) -> bool
    
    @param ea: ea_t

Help on function is_type_determined_by_hexrays in module ida_nalt:

is_type_determined_by_hexrays(*args) -> 'bool'
    is_type_determined_by_hexrays(ea) -> bool
    
    @param ea: ea_t

Help on function is_type_guessed_by_hexrays in module ida_nalt:

is_type_guessed_by_hexrays(*args) -> 'bool'
    is_type_guessed_by_hexrays(ea) -> bool
    
    @param ea: ea_t

Help on function is_type_guessed_by_ida in module ida_nalt:

is_type_guessed_by_ida(*args) -> 'bool'
    is_type_guessed_by_ida(ea) -> bool
    
    @param ea: ea_t

Help on function is_usersp in module ida_nalt:

is_usersp(*args) -> 'bool'
    is_usersp(ea) -> bool
    
    @param ea: ea_t

Help on function is_userti in module ida_nalt:

is_userti(*args) -> 'bool'
    is_userti(ea) -> bool
    
    @param ea: ea_t

Help on function is_visible_item in module ida_nalt:

is_visible_item(*args) -> 'bool'
    is_visible_item(ea) -> bool
    Test visibility of item at given ea.
    
    @param ea: (C++: ea_t)

Help on function is_zstroff in module ida_nalt:

is_zstroff(*args) -> 'bool'
    is_zstroff(ea) -> bool
    
    @param ea: ea_t

Help on function make_str_type in module ida_nalt:

make_str_type(*args) -> 'int32'
    make_str_type(type_code, encoding_idx, term1=0, term2=0) -> int32
    Get string type for a string in the given encoding.
    
    @param type_code: (C++: uchar)
    @param encoding_idx: (C++: int)
    @param term1: (C++: uchar)
    @param term2: (C++: uchar)

Help on function node2ea in module ida_nalt:

node2ea(*args) -> 'ea_t'
    node2ea(ndx) -> ea_t
    
    @param ndx: nodeidx_t

Help on class opinfo_t in module ida_nalt:

class opinfo_t(builtins.object)
 |  Proxy of C++ opinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> opinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_opinfo_t(...)
 |      delete_opinfo_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cd
 |      cd
 |  
 |  ec
 |      ec
 |  
 |  path
 |      path
 |  
 |  ri
 |      ri
 |  
 |  strtype
 |      strtype
 |  
 |  thisown
 |      The membership flag
 |  
 |  tid
 |      tid

Help on class printop_t in module ida_nalt:

class printop_t(builtins.object)
 |  Proxy of C++ printop_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> printop_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_printop_t(...)
 |      delete_printop_t(self)
 |  
 |  get_ti(self, *args) -> 'opinfo_t const *'
 |      get_ti(self) -> opinfo_t
 |  
 |  is_aflags_initialized(self, *args) -> 'bool'
 |      is_aflags_initialized(self) -> bool
 |  
 |  is_ti_initialized(self, *args) -> 'bool'
 |      is_ti_initialized(self) -> bool
 |  
 |  set_aflags_initialized(self, *args) -> 'void'
 |      set_aflags_initialized(self, v=True)
 |      
 |      @param v: bool
 |  
 |  set_ti_initialized(self, *args) -> 'void'
 |      set_ti_initialized(self, v=True)
 |      
 |      @param v: bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  aflags
 |      aflags
 |  
 |  features
 |      features
 |  
 |  flags
 |      flags
 |  
 |  is_ti_valid
 |      is_ti_initialized(self) -> bool
 |  
 |  suspop
 |      suspop
 |  
 |  thisown
 |      The membership flag
 |  
 |  ti
 |      ti

Help on class refinfo_t in module ida_nalt:

class refinfo_t(builtins.object)
 |  Proxy of C++ refinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> refinfo_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_refinfo_t(...)
 |      delete_refinfo_t(self)
 |  
 |  init(self, *args) -> 'void'
 |      init(self, reft_and_flags, _base=0, _target=BADADDR, _tdelta=0)
 |      
 |      @param reft_and_flags: uint32
 |      @param _base: ea_t
 |      @param _target: ea_t
 |      @param _tdelta: adiff_t
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_no_ones(self, *args) -> 'bool'
 |      is_no_ones(self) -> bool
 |  
 |  is_no_zeros(self, *args) -> 'bool'
 |      is_no_zeros(self) -> bool
 |  
 |  is_pastend(self, *args) -> 'bool'
 |      is_pastend(self) -> bool
 |  
 |  is_rvaoff(self, *args) -> 'bool'
 |      is_rvaoff(self) -> bool
 |  
 |  is_signed(self, *args) -> 'bool'
 |      is_signed(self) -> bool
 |  
 |  is_subtract(self, *args) -> 'bool'
 |      is_subtract(self) -> bool
 |  
 |  is_target_optional(self, *args) -> 'bool'
 |      is_target_optional(self) -> bool
 |      < is_reftype_target_optional()
 |  
 |  no_base_xref(self, *args) -> 'bool'
 |      no_base_xref(self) -> bool
 |  
 |  set_type(self, *args) -> 'void'
 |      set_type(self, rt)
 |      
 |      @param rt: reftype_t
 |  
 |  type(self, *args) -> 'reftype_t'
 |      type(self) -> reftype_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      base
 |  
 |  flags
 |      flags
 |  
 |  target
 |      target
 |  
 |  tdelta
 |      tdelta
 |  
 |  thisown
 |      The membership flag

Help on function rename_encoding in module ida_nalt:

rename_encoding(*args) -> 'bool'
    rename_encoding(idx, encname) -> bool
    Change name for an encoding The number of bytes per unit (BPU) of the new
    encoding must match this number of the existing default encoding. Specifying the
    empty name simply deletes this encoding.
    
    @param idx: (C++: int) the encoding index (1-based)
    @param encname: (C++: const char *) the new encoding name

Help on function retrieve_input_file_crc32 in module ida_nalt:

retrieve_input_file_crc32(*args) -> 'uint32'
    retrieve_input_file_crc32() -> uint32
    Get input file crc32 stored in the database. it can be used to check that the
    input file has not been changed.

Help on function retrieve_input_file_md5 in module ida_nalt:

retrieve_input_file_md5(*args) -> 'uchar [ANY]'
    retrieve_input_file_md5() -> bytes
    Get input file md5.

Help on function retrieve_input_file_sha256 in module ida_nalt:

retrieve_input_file_sha256(*args) -> 'uchar [ANY]'
    retrieve_input_file_sha256() -> bytes
    Get input file sha256.

Help on function retrieve_input_file_size in module ida_nalt:

retrieve_input_file_size(*args) -> 'size_t'
    retrieve_input_file_size() -> size_t
    Get size of input file in bytes.

Help on function set__bnot0 in module ida_nalt:

set__bnot0(*args) -> 'void'
    set__bnot0(ea)
    
    @param ea: ea_t

Help on function set__bnot1 in module ida_nalt:

set__bnot1(*args) -> 'void'
    set__bnot1(ea)
    
    @param ea: ea_t

Help on function set__invsign0 in module ida_nalt:

set__invsign0(*args) -> 'void'
    set__invsign0(ea)
    
    @param ea: ea_t

Help on function set__invsign1 in module ida_nalt:

set__invsign1(*args) -> 'void'
    set__invsign1(ea)
    
    @param ea: ea_t

Help on function set_abits in module ida_nalt:

set_abits(*args) -> 'void'
    set_abits(ea, bits)
    
    @param ea: ea_t
    @param bits: aflags_t

Help on function set_absbase in module ida_nalt:

set_absbase(*args) -> 'void'
    set_absbase(ea, x)
    
    @param ea: ea_t
    @param x: ea_t

Help on function set_aflags in module ida_nalt:

set_aflags(*args) -> 'void'
    set_aflags(ea, flags)
    
    @param ea: ea_t
    @param flags: aflags_t

Help on function set_align_flow in module ida_nalt:

set_align_flow(*args) -> 'void'
    set_align_flow(ea)
    
    @param ea: ea_t

Help on function set_alignment in module ida_nalt:

set_alignment(*args) -> 'void'
    set_alignment(ea, x)
    
    @param ea: ea_t
    @param x: uint32

Help on function set_archive_path in module ida_nalt:

set_archive_path(*args) -> 'bool'
    set_archive_path(file) -> bool
    Set archive file path from which input file was extracted.
    
    @param file: (C++: const char *) char const *

Help on function set_array_parameters in module ida_nalt:

set_array_parameters(*args) -> 'void'
    set_array_parameters(ea, _in)
    
    @param ea: ea_t
    @param in: array_parameters_t const *

Help on function set_asm_inc_file in module ida_nalt:

set_asm_inc_file(*args) -> 'bool'
    set_asm_inc_file(file) -> bool
    Set name of the include file.
    
    @param file: (C++: const char *) char const *

Help on function set_colored_item in module ida_nalt:

set_colored_item(*args) -> 'void'
    set_colored_item(ea)
    
    @param ea: ea_t

Help on function set_custom_data_type_ids in module ida_nalt:

set_custom_data_type_ids(*args) -> 'void'
    set_custom_data_type_ids(ea, cdis)
    
    @param ea: ea_t
    @param cdis: custom_data_type_ids_t const *

Help on function set_data_guessed_by_hexrays in module ida_nalt:

set_data_guessed_by_hexrays(*args) -> 'void'
    set_data_guessed_by_hexrays(ea)
    
    @param ea: ea_t

Help on function set_default_encoding_idx in module ida_nalt:

set_default_encoding_idx(*args) -> 'bool'
    set_default_encoding_idx(bpu, idx) -> bool
    Set default encoding for a string type
    
    @param bpu: (C++: int) the amount of bytes per unit
    @param idx: (C++: int) the encoding index. It cannot be 0

Help on function set_fixed_spd in module ida_nalt:

set_fixed_spd(*args) -> 'void'
    set_fixed_spd(ea)
    
    @param ea: ea_t

Help on function set_func_guessed_by_hexrays in module ida_nalt:

set_func_guessed_by_hexrays(*args) -> 'void'
    set_func_guessed_by_hexrays(ea)
    
    @param ea: ea_t

Help on function set_gotea in module ida_nalt:

set_gotea(*args) -> 'void'
    set_gotea(gotea)
    
    @param gotea: ea_t

Help on function set_has_lname in module ida_nalt:

set_has_lname(*args) -> 'void'
    set_has_lname(ea)
    
    @param ea: ea_t

Help on function set_has_ti in module ida_nalt:

set_has_ti(*args) -> 'void'
    set_has_ti(ea)
    
    @param ea: ea_t

Help on function set_has_ti0 in module ida_nalt:

set_has_ti0(*args) -> 'void'
    set_has_ti0(ea)
    
    @param ea: ea_t

Help on function set_has_ti1 in module ida_nalt:

set_has_ti1(*args) -> 'void'
    set_has_ti1(ea)
    
    @param ea: ea_t

Help on function set_ida_notepad_text in module ida_nalt:

set_ida_notepad_text(*args) -> 'void'
    set_ida_notepad_text(text, size=0)
    Set notepad text.
    
    @param text: (C++: const char *) char const *
    @param size: (C++: size_t)

Help on function set_ids_modnode in module ida_nalt:

set_ids_modnode(*args) -> 'void'
    set_ids_modnode(id)
    Set ids modnode.
    
    @param id: (C++: netnode)

Help on function set_imagebase in module ida_nalt:

set_imagebase(*args) -> 'void'
    set_imagebase(base)
    Set image base address.
    
    @param base: (C++: ea_t)

Help on function set_item_color in module ida_nalt:

set_item_color(*args) -> 'void'
    set_item_color(ea, color)
    
    @param ea: ea_t
    @param color: bgcolor_t

Help on function set_libitem in module ida_nalt:

set_libitem(*args) -> 'void'
    set_libitem(ea)
    
    @param ea: ea_t

Help on function set_loader_format_name in module ida_nalt:

set_loader_format_name(*args) -> 'void'
    set_loader_format_name(name)
    Set file format name for loader modules.
    
    @param name: (C++: const char *) char const *

Help on function set_lzero0 in module ida_nalt:

set_lzero0(*args) -> 'void'
    set_lzero0(ea)
    
    @param ea: ea_t

Help on function set_lzero1 in module ida_nalt:

set_lzero1(*args) -> 'void'
    set_lzero1(ea)
    
    @param ea: ea_t

Help on function set_noret in module ida_nalt:

set_noret(*args) -> 'void'
    set_noret(ea)
    
    @param ea: ea_t

Help on function set_notcode in module ida_nalt:

set_notcode(*args) -> 'void'
    set_notcode(ea)
    Mark address so that it cannot be converted to instruction.
    
    @param ea: (C++: ea_t)

Help on function set_notproc in module ida_nalt:

set_notproc(*args) -> 'void'
    set_notproc(ea)
    
    @param ea: ea_t

Help on function set_op_tinfo in module ida_nalt:

set_op_tinfo(*args) -> 'bool'
    set_op_tinfo(ea, n, tif) -> bool
    
    @param ea: ea_t
    @param n: int
    @param tif: tinfo_t const *

Help on function set_outfile_encoding_idx in module ida_nalt:

set_outfile_encoding_idx(*args) -> 'bool'
    set_outfile_encoding_idx(idx) -> bool
    set encoding to be used when producing files
    
    @param idx: (C++: int) the encoding index IDX can be 0 to use the IDB's default 1-byte-per-
                unit encoding

Help on function set_refinfo in module ida_nalt:

set_refinfo(*args) -> 'bool'
    set_refinfo(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool
    
    @param ea: ea_t
    @param n: int
    @param type: reftype_t
    @param target: ea_t
    @param base: ea_t
    @param tdelta: adiff_t

Help on function set_refinfo_ex in module ida_nalt:

set_refinfo_ex(*args) -> 'bool'
    set_refinfo_ex(ea, n, ri) -> bool
    
    @param ea: ea_t
    @param n: int
    @param ri: refinfo_t const *

Help on function set_retfp in module ida_nalt:

set_retfp(*args) -> 'void'
    set_retfp(ea)
    
    @param ea: ea_t

Help on function set_root_filename in module ida_nalt:

set_root_filename(*args) -> 'void'
    set_root_filename(file)
    Set full path of the input file.
    
    @param file: (C++: const char *) char const *

Help on function set_source_linnum in module ida_nalt:

set_source_linnum(*args) -> 'void'
    set_source_linnum(ea, lnnum)
    
    @param ea: ea_t
    @param lnnum: uval_t

Help on function set_srcdbg_paths in module ida_nalt:

set_srcdbg_paths(*args) -> 'void'
    set_srcdbg_paths(paths)
    Set source debug paths.
    
    @param paths: (C++: const char *) char const *

Help on function set_srcdbg_undesired_paths in module ida_nalt:

set_srcdbg_undesired_paths(*args) -> 'void'
    set_srcdbg_undesired_paths(paths)
    Set user-closed source files.
    
    @param paths: (C++: const char *) char const *

Help on function set_str_encoding_idx in module ida_nalt:

set_str_encoding_idx(*args) -> 'int32'
    set_str_encoding_idx(strtype, encoding_idx) -> int32
    Set index of the string encoding in the string type.
    
    @param strtype: (C++: int32)
    @param encoding_idx: (C++: int)

Help on function set_str_type in module ida_nalt:

set_str_type(*args) -> 'void'
    set_str_type(ea, x)
    
    @param ea: ea_t
    @param x: uint32

Help on function set_switch_info in module ida_nalt:

set_switch_info(*args) -> 'void'
    set_switch_info(ea, _in)
    
    @param ea: ea_t
    @param in: switch_info_t const &

Help on function set_switch_parent in module ida_nalt:

set_switch_parent(*args) -> 'void'
    set_switch_parent(ea, x)
    
    @param ea: ea_t
    @param x: ea_t

Help on function set_terse_struc in module ida_nalt:

set_terse_struc(*args) -> 'void'
    set_terse_struc(ea)
    
    @param ea: ea_t

Help on function set_tilcmt in module ida_nalt:

set_tilcmt(*args) -> 'void'
    set_tilcmt(ea)
    
    @param ea: ea_t

Help on function set_tinfo in module ida_nalt:

set_tinfo(*args) -> 'bool'
    set_tinfo(ea, tif) -> bool
    
    @param ea: ea_t
    @param tif: tinfo_t const *

Help on function set_type_determined_by_hexrays in module ida_nalt:

set_type_determined_by_hexrays(*args) -> 'void'
    set_type_determined_by_hexrays(ea)
    
    @param ea: ea_t

Help on function set_type_guessed_by_ida in module ida_nalt:

set_type_guessed_by_ida(*args) -> 'void'
    set_type_guessed_by_ida(ea)
    
    @param ea: ea_t

Help on function set_usemodsp in module ida_nalt:

set_usemodsp(*args) -> 'void'
    set_usemodsp(ea)
    
    @param ea: ea_t

Help on function set_usersp in module ida_nalt:

set_usersp(*args) -> 'void'
    set_usersp(ea)
    
    @param ea: ea_t

Help on function set_userti in module ida_nalt:

set_userti(*args) -> 'void'
    set_userti(ea)
    
    @param ea: ea_t

Help on function set_visible_item in module ida_nalt:

set_visible_item(*args) -> 'void'
    set_visible_item(ea, visible)
    Change visibility of item at given ea.
    
    @param ea: (C++: ea_t)
    @param visible: (C++: bool)

Help on function set_zstroff in module ida_nalt:

set_zstroff(*args) -> 'void'
    set_zstroff(ea)
    
    @param ea: ea_t

Help on class strpath_ids_array in module ida_nalt:

class strpath_ids_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< tid_t,32 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> strpath_ids_array
 |      
 |      @param data: unsigned-ea-like-numeric-type (&)[32]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned-ea-like-numeric-type const &
 |  
 |  __swig_destroy__ = delete_strpath_ids_array(...)
 |      delete_strpath_ids_array(self)
 |  
 |  _get_bytes(self, *args) -> 'bytevec_t'
 |      _get_bytes(self) -> bytevec_t
 |  
 |  _set_bytes(self, *args) -> 'void'
 |      _set_bytes(self, bts)
 |      
 |      Parameters
 |      ----------
 |      bts: bytevec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      _get_bytes(self) -> bytevec_t
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class strpath_t in module ida_nalt:

class strpath_t(builtins.object)
 |  Proxy of C++ strpath_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strpath_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_strpath_t(...)
 |      delete_strpath_t(self)
 |  
 |  _strpath_t__getIds = __getIds(self, *args) -> 'wrapped_array_t< tid_t,32 >'
 |      __getIds(self) -> strpath_ids_array
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  delta
 |      delta
 |  
 |  ids
 |      __getIds(self) -> strpath_ids_array
 |  
 |  len
 |      len
 |  
 |  thisown
 |      The membership flag

Help on class switch_info_t in module ida_nalt:

class switch_info_t(builtins.object)
 |  Proxy of C++ switch_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> switch_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_switch_info_t(...)
 |      delete_switch_info_t(self)
 |  
 |  _get_values_lowcase(self, *args) -> 'ea_t'
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  _set_values_lowcase(self, *args) -> 'void'
 |      _set_values_lowcase(self, values)
 |      
 |      Parameters
 |      ----------
 |      values: ea_t
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, other)
 |      
 |      @param other: switch_info_t const &
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  get_jrange_vrange(self, *args) -> 'bool'
 |      get_jrange_vrange(self, jrange=None, vrange=None) -> bool
 |      get separate parts of the switch
 |      
 |      @param jrange: (C++: range_t *)
 |      @param vrange: (C++: range_t *)
 |  
 |  get_jtable_element_size(self, *args) -> 'int'
 |      get_jtable_element_size(self) -> int
 |  
 |  get_jtable_size(self, *args) -> 'int'
 |      get_jtable_size(self) -> int
 |  
 |  get_lowcase(self, *args) -> 'sval_t'
 |      get_lowcase(self) -> sval_t
 |  
 |  get_shift(self, *args) -> 'int'
 |      get_shift(self) -> int
 |      See SWI_SHIFT_MASK. possible answers: 0..3.
 |  
 |  get_version(self, *args) -> 'int'
 |      get_version(self) -> int
 |  
 |  get_vtable_element_size(self, *args) -> 'int'
 |      get_vtable_element_size(self) -> int
 |  
 |  has_default(self, *args) -> 'bool'
 |      has_default(self) -> bool
 |  
 |  has_elbase(self, *args) -> 'bool'
 |      has_elbase(self) -> bool
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |  
 |  is_indirect(self, *args) -> 'bool'
 |      is_indirect(self) -> bool
 |  
 |  is_nolowcase(self, *args) -> 'bool'
 |      is_nolowcase(self) -> bool
 |  
 |  is_sparse(self, *args) -> 'bool'
 |      is_sparse(self) -> bool
 |  
 |  is_subtract(self, *args) -> 'bool'
 |      is_subtract(self) -> bool
 |  
 |  is_user_defined(self, *args) -> 'bool'
 |      is_user_defined(self) -> bool
 |  
 |  set_elbase(self, *args) -> 'void'
 |      set_elbase(self, base)
 |      
 |      @param base: ea_t
 |  
 |  set_expr(self, *args) -> 'void'
 |      set_expr(self, r, dt)
 |      
 |      @param r: int
 |      @param dt: op_dtype_t
 |  
 |  set_jtable_element_size(self, *args) -> 'void'
 |      set_jtable_element_size(self, size)
 |      
 |      @param size: int
 |  
 |  set_jtable_size(self, *args) -> 'void'
 |      set_jtable_size(self, size)
 |      
 |      @param size: int
 |  
 |  set_shift(self, *args) -> 'void'
 |      set_shift(self, shift)
 |      See SWI_SHIFT_MASK.
 |      
 |      @param shift: (C++: int)
 |  
 |  set_vtable_element_size(self, *args) -> 'void'
 |      set_vtable_element_size(self, size)
 |      
 |      @param size: int
 |  
 |  use_std_table(self, *args) -> 'bool'
 |      use_std_table(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  custom
 |      custom
 |  
 |  defjump
 |      defjump
 |  
 |  elbase
 |      elbase
 |  
 |  expr_ea
 |      expr_ea
 |  
 |  flags
 |      flags
 |  
 |  ind_lowcase
 |      ind_lowcase
 |  
 |  jcases
 |      jcases
 |  
 |  jumps
 |      jumps
 |  
 |  lowcase
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  marks
 |      marks
 |  
 |  ncases
 |      ncases
 |  
 |  regdtype
 |      regdtype
 |  
 |  regnum
 |      regnum
 |  
 |  startea
 |      startea
 |  
 |  thisown
 |      The membership flag
 |  
 |  values
 |      _get_values_lowcase(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  SWITCH_INFO_VERSION = 2

Help on function switch_info_t__from_ptrval__ in module ida_nalt:

switch_info_t__from_ptrval__(*args) -> 'switch_info_t *'
    switch_info_t__from_ptrval__(ptrval) -> switch_info_t
    
    @param ptrval: size_t

Help on function unhide_border in module ida_nalt:

unhide_border(*args) -> 'void'
    unhide_border(ea)
    
    @param ea: ea_t

Help on function unhide_item in module ida_nalt:

unhide_item(*args) -> 'void'
    unhide_item(ea)
    
    @param ea: ea_t

Help on function upd_abits in module ida_nalt:

upd_abits(*args) -> 'void'
    upd_abits(ea, clr_bits, set_bits)
    
    @param ea: ea_t
    @param clr_bits: aflags_t
    @param set_bits: aflags_t

Help on function uses_aflag_modsp in module ida_nalt:

uses_aflag_modsp(*args) -> 'bool'
    uses_aflag_modsp(flags) -> bool
    
    @param flags: aflags_t

Help on function uses_modsp in module ida_nalt:

uses_modsp(*args) -> 'bool'
    uses_modsp(ea) -> bool
    
    @param ea: ea_t

Help on function validate_idb_names in module ida_nalt:

validate_idb_names(*args) -> 'int'
    validate_idb_names(do_repair) -> int
    
    @param do_repair: bool

Module "ida_name"s docstring:
"""
Functions that deal with names.

A non-tail address of the program may have a name. Tail addresses (i.e. the
addresses in the middle of an instruction or data item) cannot have names."""

Help on class NearestName in module ida_name:

class NearestName(builtins.object)
 |  Utility class to help find the nearest name in a given ea/name dictionary
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, index)
 |      Returns the tupple (ea, name, index)
 |  
 |  __init__(self, ea_names)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __iter__(self)
 |  
 |  _get_item(self, index)
 |  
 |  find(self, ea)
 |      Returns a tupple (ea, name, pos) that is the nearest to the passed ea
 |      If no name is matched then None is returned
 |  
 |  update(self, ea_names)
 |      Updates the ea/names map
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function append_struct_fields in module ida_name:

append_struct_fields(*args) -> 'qstring *, adiff_t *'
    append_struct_fields(disp, n, path, flags, delta, appzero) -> str
    Append names of struct fields to a name if the name is a struct name.
    
    @param disp: (C++: adiff_t *) displacement from the name
    @param n: (C++: int) number of operand n which the name appears
    @param path: (C++: const tid_t *) path in the struct. path is an array of id's. maximal length of
                 array is MAXSTRUCPATH. the first element of the array is the
                 structure id. consecutive elements are id's of used union members
                 (if any).
    @param flags: (C++: flags_t) the input flags. they will be returned if the struct cannot be
                  found.
    @param delta: (C++: adiff_t) delta to add to displacement
    @param appzero: (C++: bool) should append a struct field name if the displacement is zero?
    @return: flags of the innermost struct member or the input flags

Help on function calc_gtn_flags in module ida_name:

calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

Help on function cleanup_name in module ida_name:

cleanup_name(*args) -> 'qstring *'
    cleanup_name(ea, name, flags=0) -> str
    
    @param ea: ea_t
    @param name: char const *
    @param flags: uint32

Help on function del_debug_names in module ida_name:

del_debug_names(*args) -> 'void'
    del_debug_names(ea1, ea2)
    
    @param ea1: ea_t
    @param ea2: ea_t

Help on function del_global_name in module ida_name:

del_global_name(*args) -> 'bool'
    del_global_name(ea) -> bool
    
    @param ea: ea_t

Help on function del_local_name in module ida_name:

del_local_name(*args) -> 'bool'
    del_local_name(ea) -> bool
    
    @param ea: ea_t

Help on function demangle_name in module ida_name:

demangle_name(*args) -> 'qstring *'
    demangle_name(name, disable_mask, demreq=DQT_FULL) -> str
    Demangle a name.
    
    @param name: (C++: const char *) char const *
    @param disable_mask: (C++: uint32)
    @param demreq: (C++: demreq_type_t) enum demreq_type_t

Help on class ea_name_t in module ida_name:

class ea_name_t(builtins.object)
 |  Proxy of C++ ea_name_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_name_t
 |      __init__(self, _ea, _name) -> ea_name_t
 |      
 |      @param _ea: ea_t
 |      @param _name: qstring const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ea_name_t(...)
 |      delete_ea_name_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag

Help on class ea_name_vec_t in module ida_name:

class ea_name_vec_t(builtins.object)
 |  Proxy of C++ qvector< ea_name_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'ea_name_t const &'
 |      __getitem__(self, i) -> ea_name_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_name_vec_t
 |      __init__(self, x) -> ea_name_vec_t
 |      
 |      @param x: qvector< ea_name_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: ea_name_t const &
 |  
 |  __swig_destroy__ = delete_ea_name_vec_t(...)
 |      delete_ea_name_vec_t(self)
 |  
 |  at(self, *args) -> 'ea_name_t const &'
 |      at(self, _idx) -> ea_name_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< ea_name_t >::const_iterator'
 |      begin(self) -> ea_name_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< ea_name_t >::const_iterator'
 |      end(self) -> ea_name_t
 |  
 |  erase(self, *args) -> 'qvector< ea_name_t >::iterator'
 |      erase(self, it) -> ea_name_t
 |      
 |      @param it: qvector< ea_name_t >::iterator
 |      
 |      erase(self, first, last) -> ea_name_t
 |      
 |      @param first: qvector< ea_name_t >::iterator
 |      @param last: qvector< ea_name_t >::iterator
 |  
 |  extract(self, *args) -> 'ea_name_t *'
 |      extract(self) -> ea_name_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=ea_name_t())
 |      
 |      @param x: ea_name_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: ea_name_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< ea_name_t >::iterator'
 |      insert(self, it, x) -> ea_name_t
 |      
 |      @param it: qvector< ea_name_t >::iterator
 |      @param x: ea_name_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'ea_name_t &'
 |      push_back(self, x)
 |      
 |      @param x: ea_name_t const &
 |      
 |      push_back(self) -> ea_name_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: ea_name_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< ea_name_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function extract_name in module ida_name:

extract_name(*args) -> 'qstring *'
    extract_name(line, x) -> str
    Extract a name or address from the specified string.
    
    @param line: (C++: const char *) input string
    @param x: (C++: int) x coordinate of cursor
    @return: -1 if cannot extract. otherwise length of the name

Help on function force_name in module ida_name:

force_name(*args) -> 'bool'
    force_name(ea, name, flags=0) -> bool
    
    @param ea: ea_t
    @param name: char const *
    @param flags: int

Help on function get_colored_demangled_name in module ida_name:

get_colored_demangled_name(*args) -> 'qstring'
    get_colored_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param inhibitor: int32
    @param demform: int
    @param gtn_flags: int

Help on function get_colored_long_name in module ida_name:

get_colored_long_name(*args) -> 'qstring'
    get_colored_long_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

Help on function get_colored_name in module ida_name:

get_colored_name(*args) -> 'qstring'
    get_colored_name(ea) -> qstring
    
    @param ea: ea_t

Help on function get_colored_short_name in module ida_name:

get_colored_short_name(*args) -> 'qstring'
    get_colored_short_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

Help on function get_cp_validity in module ida_name:

get_cp_validity(*args) -> 'bool'
    get_cp_validity(kind, cp, endcp=wchar32_t(-1)) -> bool
    Is the given codepoint (or range) acceptable in the given context? If 'endcp' is
    not BADCP, it is considered to be the end of the range: [cp, endcp), and is not
    included in the range
    
    @param kind: (C++: ucdr_kind_t) enum ucdr_kind_t
    @param cp: (C++: wchar32_t)
    @param endcp: (C++: wchar32_t)

Help on function get_debug_name in module ida_name:

get_debug_name(*args) -> 'qstring *'
    get_debug_name(ea_ptr, how) -> str
    
    @param ea_ptr: ea_t *
    @param how: enum debug_name_how_t

Help on function get_debug_name_ea in module ida_name:

get_debug_name_ea(*args) -> 'ea_t'
    get_debug_name_ea(name) -> ea_t
    
    @param name: char const *

Help on function get_debug_names in module ida_name:

get_debug_names(*args) -> 'PyObject *'
    get_debug_names(names, ea1, ea2)
    
    @param names: ea_name_vec_t *
    @param ea1: ea_t
    @param ea2: ea_t
    
    get_debug_names(ea1, ea2, return_list=False) -> dict or None
    
    @param ea1: ea_t
    @param ea2: ea_t
    @param return_list: bool

Help on function get_demangled_name in module ida_name:

get_demangled_name(*args) -> 'qstring'
    get_demangled_name(ea, inhibitor, demform, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param inhibitor: int32
    @param demform: int
    @param gtn_flags: int

Help on function get_ea_name in module ida_name:

get_ea_name(*args) -> 'qstring'
    get_ea_name(ea, gtn_flags=0) -> qstring
    Get name at the specified address.
    
    @param ea: (C++: ea_t) linear address
    @param gtn_flags: (C++: int) how exactly the name should be retrieved. combination of bits
                      for get_ea_name() function. There is a convenience bits
    @return: success

Help on function get_long_name in module ida_name:

get_long_name(*args) -> 'qstring'
    get_long_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

Help on function get_mangled_name_type in module ida_name:

get_mangled_name_type(*args) -> 'mangled_name_type_t'
    get_mangled_name_type(name) -> mangled_name_type_t
    
    @param name: char const *

Help on function get_name in module ida_name:

get_name(*args) -> 'qstring'
    get_name(ea) -> qstring
    
    @param ea: ea_t

Help on function get_name_base_ea in module ida_name:

get_name_base_ea(*args) -> 'ea_t'
    get_name_base_ea(_from, to) -> ea_t
    Get address of the name used in the expression for the address
    
    @param from: (C++: ea_t) address of the operand which references to the address
    @param to: (C++: ea_t) the referenced address
    @return: address of the name used to represent the operand

Help on function get_name_color in module ida_name:

get_name_color(*args) -> 'color_t'
    get_name_color(_from, ea) -> color_t
    Calculate flags for get_ea_name() function.
    
    Get name color.
    
    @param from: (C++: ea_t) linear address where the name is used. if not applicable, then
                 should be BADADDR. The kernel returns a local name color if the
                 reference is within a function, i.e. 'from' and 'ea' belong to the
                 same function.
    @param ea: (C++: ea_t) linear address

Help on function get_name_ea in module ida_name:

get_name_ea(*args) -> 'ea_t'
    get_name_ea(_from, name) -> ea_t
    Get the address of a name. This function resolves a name into an address. It can
    handle regular global and local names, as well as debugger names.
    
    @param from: (C++: ea_t) linear address where the name is used. If specified, the local
                 labels of the function at the specified address will will be
                 checked. BADADDR means that local names won't be consulted.
    @param name: (C++: const char *) any name in the program or nullptr
    @return: address of the name or BADADDR

Help on function get_name_expr in module ida_name:

get_name_expr(*args) -> 'qstring *'
    get_name_expr(_from, n, ea, off, flags=0x0001) -> str
    Convert address to name expression (name with a displacement). This function
    takes into account fixup information and returns a colored name expression (in
    the form <name> +/- <offset>). It also knows about structure members and arrays.
    If the specified address doesn't have a name, a dummy name is generated.
    
    @param from: (C++: ea_t) linear address of instruction operand or data referring to the
                 name. This address will be used to get fixup information, so it
                 should point to exact position of the operand in the instruction.
    @param n: (C++: int) number of referencing operand. for data items specify 0
    @param ea: (C++: ea_t) address to convert to name expression
    @param off: (C++: uval_t) the value of name expression. this parameter is used only to check
                that the name expression will have the wanted value. 'off' may be
                equal to BADADDR but this is discouraged because it prohibits
                checks.
    @param flags: (C++: int) Name expression flags
    @return: < 0 if address is not valid, no segment or other failure. otherwise the
             length of the name expression in characters.

Help on function get_name_value in module ida_name:

get_name_value(*args) -> 'uval_t *'
    get_name_value(_from, name) -> int
    Get value of the name. This function knows about: regular names, enums, special
    segments, etc.
    
    @param from: (C++: ea_t) linear address where the name is used if not applicable, then
                 should be BADADDR
    @param name: (C++: const char *) any name in the program or nullptr
    @return: Name value result codes

Help on function get_nice_colored_name in module ida_name:

get_nice_colored_name(*args) -> 'qstring *'
    get_nice_colored_name(ea, flags=0) -> str
    Get a nice colored name at the specified address. Ex:
    * segment:sub+offset
    * segment:sub:local_label
    * segment:label
    * segment:address
    * segment:address+offset
    
    @param ea: (C++: ea_t) linear address
    @param flags: (C++: int) Nice colored name flags
    @return: the length of the generated name in bytes.

Help on function get_nlist_ea in module ida_name:

get_nlist_ea(*args) -> 'ea_t'
    get_nlist_ea(idx) -> ea_t
    Get address from the list at 'idx'.
    
    @param idx: (C++: size_t)

Help on function get_nlist_idx in module ida_name:

get_nlist_idx(*args) -> 'size_t'
    get_nlist_idx(ea) -> size_t
    Get index of the name in the list
    @warning: returns the closest match. may return idx >= size.
    
    @param ea: (C++: ea_t)

Help on function get_nlist_name in module ida_name:

get_nlist_name(*args) -> 'char const *'
    get_nlist_name(idx) -> char const *
    Get name using idx.
    
    @param idx: (C++: size_t)

Help on function get_nlist_size in module ida_name:

get_nlist_size(*args) -> 'size_t'
    get_nlist_size() -> size_t
    Get number of names in the list.

Help on function get_short_name in module ida_name:

get_short_name(*args) -> 'qstring'
    get_short_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

Help on function get_visible_name in module ida_name:

get_visible_name(*args) -> 'qstring'
    get_visible_name(ea, gtn_flags=0) -> qstring
    
    @param ea: ea_t
    @param gtn_flags: int

Help on function hide_name in module ida_name:

hide_name(*args) -> 'void'
    hide_name(ea)
    Remove name from the list of names
    
    @param ea: (C++: ea_t) address of the name

Help on function is_ident in module ida_name:

is_ident(*args) -> 'bool'
    is_ident(name) -> bool
    Is a valid name? (including ::MangleChars)
    
    @param name: (C++: const char *) char const *

Help on function is_ident_cp in module ida_name:

is_ident_cp(*args) -> 'bool'
    is_ident_cp(cp) -> bool
    Can a character appear in a name? (present in ::NameChars or ::MangleChars)
    
    @param cp: (C++: wchar32_t)

Help on function is_in_nlist in module ida_name:

is_in_nlist(*args) -> 'bool'
    is_in_nlist(ea) -> bool
    Is the name included into the name list?
    
    @param ea: (C++: ea_t)

Help on function is_name_defined_locally in module ida_name:

is_name_defined_locally(*args) -> 'bool'
    is_name_defined_locally(pfn, name, ignore_name_def, ea1=BADADDR, ea2=BADADDR) -> bool
    Is the name defined locally in the specified function?
    
    @param pfn: (C++: func_t *) pointer to function
    @param name: (C++: const char *) name to check
    @param ignore_name_def: (C++: ignore_name_def_t) which names to ignore when checking
    @param ea1: (C++: ea_t) the starting address of the range inside the function (optional)
    @param ea2: (C++: ea_t) the ending address of the range inside the function (optional)
    @return: true if the name has been defined

Help on function is_public_name in module ida_name:

is_public_name(*args) -> 'bool'
    is_public_name(ea) -> bool
    
    @param ea: ea_t

Help on function is_strlit_cp in module ida_name:

is_strlit_cp(*args) -> 'bool'
    is_strlit_cp(cp, specific_ranges=None) -> bool
    Can a character appear in a string literal (present in ::StrlitChars) If
    'specific_ranges' are specified, those will be used instead of the ones
    corresponding to the current culture (only if ::StrlitChars is configured to use
    the current culture)
    
    @param cp: (C++: wchar32_t)
    @param specific_ranges: (C++: const rangeset_crefvec_t *) rangeset_crefvec_t const *

Help on function is_uname in module ida_name:

is_uname(*args) -> 'bool'
    is_uname(name) -> bool
    Is valid user-specified name? (valid name & !dummy prefix).
    
    @param name: (C++: const char *) name to test. may be nullptr.
    @retval 1: yes
    @retval 0: no

Help on function is_valid_cp in module ida_name:

is_valid_cp(*args) -> 'bool'
    is_valid_cp(cp, kind, data=None) -> bool
    Is the given codepoint acceptable in the given context?
    
    @param cp: (C++: wchar32_t)
    @param kind: (C++: nametype_t) enum nametype_t
    @param data: (C++: void *)

Help on function is_valid_typename in module ida_name:

is_valid_typename(*args) -> 'bool'
    is_valid_typename(name) -> bool
    Is valid type name?
    
    @param name: (C++: const char *) name to test. may be nullptr.
    @retval 1: yes
    @retval 0: no

Help on function is_visible_cp in module ida_name:

is_visible_cp(*args) -> 'bool'
    is_visible_cp(cp) -> bool
    Can a character be displayed in a name? (present in ::NameChars)
    
    @param cp: (C++: wchar32_t)

Help on function is_weak_name in module ida_name:

is_weak_name(*args) -> 'bool'
    is_weak_name(ea) -> bool
    
    @param ea: ea_t

Help on function make_name_auto in module ida_name:

make_name_auto(*args) -> 'bool'
    make_name_auto(ea) -> bool
    
    @param ea: ea_t

Help on function make_name_non_public in module ida_name:

make_name_non_public(*args) -> 'void'
    make_name_non_public(ea)
    
    @param ea: ea_t

Help on function make_name_non_weak in module ida_name:

make_name_non_weak(*args) -> 'void'
    make_name_non_weak(ea)
    
    @param ea: ea_t

Help on function make_name_public in module ida_name:

make_name_public(*args) -> 'void'
    make_name_public(ea)
    
    @param ea: ea_t

Help on function make_name_user in module ida_name:

make_name_user(*args) -> 'bool'
    make_name_user(ea) -> bool
    
    @param ea: ea_t

Help on function make_name_weak in module ida_name:

make_name_weak(*args) -> 'void'
    make_name_weak(ea)
    
    @param ea: ea_t

Help on function rebuild_nlist in module ida_name:

rebuild_nlist(*args) -> 'void'
    rebuild_nlist()
    Rebuild the name list.

Help on function reorder_dummy_names in module ida_name:

reorder_dummy_names(*args) -> 'void'
    reorder_dummy_names()
    Renumber dummy names.

Help on function set_cp_validity in module ida_name:

set_cp_validity(*args) -> 'void'
    set_cp_validity(kind, cp, endcp=wchar32_t(-1), valid=True)
    Mark the given codepoint (or range) as acceptable or unacceptable in the given
    context If 'endcp' is not BADCP, it is considered to be the end of the range:
    [cp, endcp), and is not included in the range
    
    @param kind: (C++: ucdr_kind_t) enum ucdr_kind_t
    @param cp: (C++: wchar32_t)
    @param endcp: (C++: wchar32_t)

Help on function set_debug_name in module ida_name:

set_debug_name(*args) -> 'bool'
    set_debug_name(ea, name) -> bool
    
    @param ea: ea_t
    @param name: char const *

Help on function set_dummy_name in module ida_name:

set_dummy_name(*args) -> 'bool'
    set_dummy_name(_from, ea) -> bool
    Give an autogenerated (dummy) name. Autogenerated names have special prefixes
    (loc_...).
    
    @param from: (C++: ea_t) linear address of the operand which references to the address
    @param ea: (C++: ea_t) linear address
    @retval 1: ok, dummy name is generated or the byte already had a name
    @retval 0: failure, invalid address or tail byte

Help on function set_name in module ida_name:

set_name(*args) -> 'bool'
    set_name(ea, name, flags=0) -> bool
    Set or delete name of an item at the specified address. An item can be anything:
    instruction, function, data byte, word, string, structure, etc... Include name
    into the list of names.
    
    @param ea: (C++: ea_t) linear address. do nothing if ea is not valid (return 0). tail bytes
               can't have names.
    @param name: (C++: const char *) new name.
    * nullptr: do nothing (return 0).
    * "" : delete name.
    * otherwise this is a new name.
    @param flags: (C++: int) Set name flags. If a bit is not specified, then the corresponding
                  action is not performed and the name will retain the same bits as
                  before calling this function. For new names, default is: non-
                  public, non-weak, non-auto.
    @retval 1: ok, name is changed
    @retval 0: failure, a warning is displayed

Help on function show_name in module ida_name:

show_name(*args) -> 'void'
    show_name(ea)
    Insert name to the list of names.
    
    @param ea: (C++: ea_t)

Help on function validate_name in module ida_name:

validate_name(*args) -> 'PyObject *'
    validate_name(name, type, flags=0) -> PyObject *
    Validate a name. This function replaces all invalid characters in the name with
    SUBSTCHAR. However, it will return false if name is valid but not allowed to be
    an identifier (is a register name).
    
    @param name: (C++: qstring *) ptr to name. the name will be modified
    @param type: (C++: nametype_t) the type of name we want to validate
    @param flags: (C++: int) see SN_* . Only SN_IDBENC is currently considered
    @return: success

Module "ida_netnode"s docstring:
"""
Functions that provide the lowest level public interface to the database.

(Namely, Btree). To learn more about Balanced Trees:
\link{http://www.bluerwhite.org/btree/}

We don't use Btree directly. Instead, we have another layer built on the top of
Btree. Here is a brief explanation of this layer.

An object called "netnode" is modeled on the top of Btree. Each netnode has a
unique id: a 32-bit value (64-bit for ida64). Usually there is a trivial mapping
of the linear addresses used in the program to netnodes. If we have additional
information about an address (a comment is attached to it, for example), this
information is stored in the corresponding netnode. See nalt.hpp to see how the
kernel uses netnodes. Also, some netnodes have no corresponding linear address
(however, they still have an id). They are used to store information not related
to a particular address.

Each netnode _may_ have the following attributes:

* a name: an arbitrary non-empty string, up to 255KB-1 bytes
* a value: arbitrary sized object, max size is MAXSPECSIZE
* altvals: a sparse array of 32-bit values. indexes in this array may be 8-bit
or 32-bit values
* supvals: an array of arbitrary sized objects. (size of each object is limited
by MAXSPECSIZE) indexes in this array may be 8-bit or 32-bit values
* charvals: a sparse array of 8-bit values. indexes in this array may be 8-bit
or 32-bit values
* hashvals: a hash (an associative array). indexes in this array are strings
values are arbitrary sized (max size is MAXSPECSIZE)

Initially a new netnode contains no information at all so no disk space is used
for it. As you add new information, the netnode grows.

All arrays that are attached to the netnode behave in the same manner.
Initially:
* all members of altvals/charvals array are zeroes
* all members of supvals/hashvals array are undefined

If you need to store objects bigger that MAXSPECSIZE, please note that there are
high-level functions to store arbitrary sized objects in supvals. See
setblog/getblob and other blob-related functions.

You may use netnodes to store additional information about the program.
Limitations on the use of netnodes are the following:

* use netnodes only if you could not find a kernel service to store your type of
information
* do not create netnodes with valid identifier names. Use the "$ " prefix (or
any other prefix with characters not allowed in the identifiers for the names of
your netnodes. Although you will probably not destroy anything by accident,
using already defined names for the names of your netnodes is still discouraged.
* you may create as many netnodes as you want (creation of an unnamed netnode
does not increase the size of the database). however, since each netnode has a
number, creating too many netnodes could lead to the exhaustion of the netnode
numbers (the numbering starts at 0xFF000000)
* remember that netnodes are automatically saved to the disk by the kernel.

Advanced info:

In fact a netnode may contain up to 256 arrays of arbitrary sized objects (not
only the 4 listed above). Each array has an 8-bit tag. Usually tags are
represented by character constants. For example, altvals and supvals are simply
2 of 256 arrays, with the tags 'A' and 'S' respectively."""

Help on function exist in module ida_netnode:

exist(*args) -> 'bool'
    exist(n) -> bool
    
    @param n: netnode const &

Help on class netnode in module ida_netnode:

class netnode(builtins.object)
 |  Proxy of C++ netnode class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, n) -> bool
 |      
 |      @param n: netnode &
 |      
 |      __eq__(self, x) -> bool
 |      
 |      @param x: nodeidx_t
 |  
 |  __init__(self, *args)
 |      __init__(self, num=nodeidx_t(-1)) -> netnode
 |      
 |      @param num: nodeidx_t
 |      
 |      __init__(self, _name, namlen=0, do_create=False) -> netnode
 |      
 |      @param _name: char const *
 |      @param namlen: size_t
 |      @param do_create: bool
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, n) -> bool
 |      
 |      @param n: netnode &
 |      
 |      __ne__(self, x) -> bool
 |      
 |      @param x: nodeidx_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_netnode(...)
 |      delete_netnode(self)
 |  
 |  altdel(self, *args) -> 'bool'
 |      altdel(self, alt, tag=atag) -> bool
 |      Delete all elements of altval array. This function may be applied to 32-bit and
 |      8-bit altval arrays. This function deletes the whole altval array.
 |      
 |      @param alt: nodeidx_t
 |      @param tag: uchar
 |      
 |      @return: success
 |      altdel(self) -> bool
 |  
 |  altdel_all(self, *args) -> 'bool'
 |      altdel_all(self, tag=atag) -> bool
 |      Delete all elements of the specified altval array. This function may be applied
 |      to 32-bit and 8-bit altval arrays. This function deletes the whole altval array.
 |      
 |      @param tag: (C++: uchar) tag of array
 |      @return: success
 |  
 |  altdel_ea(self, *args) -> 'bool'
 |      altdel_ea(self, ea, tag=atag) -> bool
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  altdel_idx8(self, *args) -> 'bool'
 |      altdel_idx8(self, alt, tag) -> bool
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  altfirst(self, *args) -> 'nodeidx_t'
 |      altfirst(self, tag=atag) -> nodeidx_t
 |      Get first existing element of altval array.
 |      
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of first existing element of altval array, BADNODE if altval
 |               array is empty
 |  
 |  altfirst_idx8(self, *args) -> 'nodeidx_t'
 |      altfirst_idx8(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  altlast(self, *args) -> 'nodeidx_t'
 |      altlast(self, tag=atag) -> nodeidx_t
 |      Get last element of altval array.
 |      
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of last existing element of altval array, BADNODE if altval array
 |               is empty
 |  
 |  altlast_idx8(self, *args) -> 'nodeidx_t'
 |      altlast_idx8(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  altnext(self, *args) -> 'nodeidx_t'
 |      altnext(self, cur, tag=atag) -> nodeidx_t
 |      Get next existing element of altval array.
 |      
 |      @param cur: (C++: nodeidx_t) current index
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of the next existing element of altval array, BADNODE if no more
 |               altval array elements exist
 |  
 |  altnext_idx8(self, *args) -> 'nodeidx_t'
 |      altnext_idx8(self, cur, tag) -> nodeidx_t
 |      
 |      @param cur: uchar
 |      @param tag: uchar
 |  
 |  altprev(self, *args) -> 'nodeidx_t'
 |      altprev(self, cur, tag=atag) -> nodeidx_t
 |      Get previous existing element of altval array.
 |      
 |      @param cur: (C++: nodeidx_t) current index
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of the previous existing element of altval array, BADNODE if no
 |               more altval array elements exist
 |  
 |  altprev_idx8(self, *args) -> 'nodeidx_t'
 |      altprev_idx8(self, cur, tag) -> nodeidx_t
 |      
 |      @param cur: uchar
 |      @param tag: uchar
 |  
 |  altset(self, *args) -> 'bool'
 |      altset(self, alt, value, tag=atag) -> bool
 |      Set value of altval array.
 |      
 |      @param alt: (C++: nodeidx_t) index into array of altvals
 |      @param value: (C++: nodeidx_t) new value of altval element
 |      @param tag: (C++: uchar) tag of array
 |      @retval 1: ok
 |      @retval 0: failed, normally should not occur
 |  
 |  altset_ea(self, *args) -> 'bool'
 |      altset_ea(self, ea, value, tag=atag) -> bool
 |      
 |      @param ea: ea_t
 |      @param value: nodeidx_t
 |      @param tag: uchar
 |  
 |  altset_idx8(self, *args) -> 'bool'
 |      altset_idx8(self, alt, val, tag) -> bool
 |      
 |      @param alt: uchar
 |      @param val: nodeidx_t
 |      @param tag: uchar
 |  
 |  altshift(self, *args) -> 'size_t'
 |      altshift(self, _from, to, size, tag=atag) -> size_t
 |      Shift the altval array elements. Moves the array elements at (from..from+size)
 |      to (to..to+size)
 |      
 |      @param from: (C++: nodeidx_t)
 |      @param to: (C++: nodeidx_t)
 |      @param size: (C++: nodeidx_t)
 |      @param tag: (C++: uchar)
 |      @return: number of shifted elements
 |  
 |  altval(self, *args) -> 'nodeidx_t'
 |      altval(self, alt, tag=atag) -> nodeidx_t
 |      Get altval element of the specified array.
 |      
 |      @param alt: (C++: nodeidx_t) index into array of altvals
 |      @param tag: (C++: uchar) tag of array. may be omitted
 |      @return: value of altval element. nonexistent altval members are returned as
 |               zeroes
 |  
 |  altval_ea(self, *args) -> 'nodeidx_t'
 |      altval_ea(self, ea, tag=atag) -> nodeidx_t
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  altval_idx8(self, *args) -> 'nodeidx_t'
 |      altval_idx8(self, alt, tag) -> nodeidx_t
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  blobsize(self, *args) -> 'size_t'
 |      blobsize(self, _start, tag) -> size_t
 |      Get size of blob.
 |      
 |      @param _start: (C++: nodeidx_t) index of the first supval element used to store blob
 |      @param tag: (C++: uchar) tag of supval array
 |      @return: number of bytes required to store a blob
 |  
 |  blobsize_ea(self, *args) -> 'size_t'
 |      blobsize_ea(self, ea, tag) -> size_t
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  chardel(self, *args) -> 'bool'
 |      chardel(self, alt, tag) -> bool
 |      
 |      @param alt: nodeidx_t
 |      @param tag: uchar
 |  
 |  chardel_ea(self, *args) -> 'bool'
 |      chardel_ea(self, ea, tag) -> bool
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  chardel_idx8(self, *args) -> 'bool'
 |      chardel_idx8(self, alt, tag) -> bool
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  charfirst(self, *args) -> 'nodeidx_t'
 |      charfirst(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  charfirst_idx8(self, *args) -> 'nodeidx_t'
 |      charfirst_idx8(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  charlast(self, *args) -> 'nodeidx_t'
 |      charlast(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  charlast_idx8(self, *args) -> 'nodeidx_t'
 |      charlast_idx8(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  charnext(self, *args) -> 'nodeidx_t'
 |      charnext(self, cur, tag) -> nodeidx_t
 |      
 |      @param cur: nodeidx_t
 |      @param tag: uchar
 |  
 |  charnext_idx8(self, *args) -> 'nodeidx_t'
 |      charnext_idx8(self, cur, tag) -> nodeidx_t
 |      
 |      @param cur: uchar
 |      @param tag: uchar
 |  
 |  charprev(self, *args) -> 'nodeidx_t'
 |      charprev(self, cur, tag) -> nodeidx_t
 |      
 |      @param cur: nodeidx_t
 |      @param tag: uchar
 |  
 |  charprev_idx8(self, *args) -> 'nodeidx_t'
 |      charprev_idx8(self, cur, tag) -> nodeidx_t
 |      
 |      @param cur: uchar
 |      @param tag: uchar
 |  
 |  charset(self, *args) -> 'bool'
 |      charset(self, alt, val, tag) -> bool
 |      
 |      @param alt: nodeidx_t
 |      @param val: uchar
 |      @param tag: uchar
 |  
 |  charset_ea(self, *args) -> 'bool'
 |      charset_ea(self, ea, val, tag) -> bool
 |      
 |      @param ea: ea_t
 |      @param val: uchar
 |      @param tag: uchar
 |  
 |  charset_idx8(self, *args) -> 'bool'
 |      charset_idx8(self, alt, val, tag) -> bool
 |      
 |      @param alt: uchar
 |      @param val: uchar
 |      @param tag: uchar
 |  
 |  charshift(self, *args) -> 'size_t'
 |      charshift(self, _from, to, size, tag) -> size_t
 |      
 |      @param from: nodeidx_t
 |      @param to: nodeidx_t
 |      @param size: nodeidx_t
 |      @param tag: uchar
 |  
 |  charval(self, *args) -> 'uchar'
 |      charval(self, alt, tag) -> uchar
 |      
 |      @param alt: nodeidx_t
 |      @param tag: uchar
 |  
 |  charval_ea(self, *args) -> 'uchar'
 |      charval_ea(self, ea, tag) -> uchar
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  charval_idx8(self, *args) -> 'uchar'
 |      charval_idx8(self, alt, tag) -> uchar
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  copyto(self, *args) -> 'size_t'
 |      copyto(self, destnode, count=1) -> size_t
 |      
 |      @param destnode: netnode
 |      @param count: nodeidx_t
 |  
 |  create(self, *args) -> 'bool'
 |      create(self, _name, namlen=0) -> bool
 |      Create unnamed netnode.
 |      @retval 1: ok
 |      @retval 0: should not happen, indicates internal error
 |      
 |      @param _name: char const *
 |      @param namlen: size_t
 |      
 |      create(self) -> bool
 |  
 |  delblob(self, *args) -> 'int'
 |      delblob(self, _start, tag) -> int
 |      Delete a blob.
 |      
 |      @param _start: (C++: nodeidx_t) index of the first supval element used to store blob
 |      @param tag: (C++: uchar) tag of supval array
 |      @return: number of deleted supvals
 |  
 |  delblob_ea(self, *args) -> 'int'
 |      delblob_ea(self, ea, tag) -> int
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  delvalue(self, *args) -> 'bool'
 |      delvalue(self) -> bool
 |      Delete value of netnode.
 |      @retval 1: ok
 |      @retval 0: failed, netnode is bad or other error
 |  
 |  eadel(self, *args) -> 'bool'
 |      eadel(self, ea, tag) -> bool
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  eadel_idx8(self, *args) -> 'bool'
 |      eadel_idx8(self, idx, tag) -> bool
 |      
 |      @param idx: uchar
 |      @param tag: uchar
 |  
 |  eaget(self, *args) -> 'ea_t'
 |      eaget(self, ea, tag) -> ea_t
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  eaget_idx(self, *args) -> 'ea_t'
 |      eaget_idx(self, idx, tag) -> ea_t
 |      
 |      @param idx: nodeidx_t
 |      @param tag: uchar
 |  
 |  eaget_idx8(self, *args) -> 'ea_t'
 |      eaget_idx8(self, idx, tag) -> ea_t
 |      
 |      @param idx: uchar
 |      @param tag: uchar
 |  
 |  easet(self, *args) -> 'bool'
 |      easet(self, ea, addr, tag) -> bool
 |      Store/retrieve/delete an address value in the netnode that corresponds to an
 |      address.
 |      
 |      @param ea: (C++: ea_t)
 |      @param addr: (C++: ea_t)
 |      @param tag: (C++: uchar)
 |  
 |  easet_idx(self, *args) -> 'bool'
 |      easet_idx(self, idx, addr, tag) -> bool
 |      
 |      @param idx: nodeidx_t
 |      @param addr: ea_t
 |      @param tag: uchar
 |  
 |  easet_idx8(self, *args) -> 'bool'
 |      easet_idx8(self, idx, addr, tag) -> bool
 |      
 |      @param idx: uchar
 |      @param addr: ea_t
 |      @param tag: uchar
 |  
 |  end(self, *args) -> 'bool'
 |      end(self) -> bool
 |      Get last netnode in the graph. Sets netnodenumber to the highest existing
 |      number.
 |      @retval true: ok
 |      @retval false: graph is empty
 |  
 |  get_name(self, *args) -> 'ssize_t'
 |      get_name(self) -> ssize_t
 |      Get the netnode name.
 |      
 |      @return: -1 if netnode is unnamed (buf is untouched in this case), otherwise the
 |               name length
 |  
 |  getblob(self, *args) -> 'PyObject *'
 |      getblob(self, start, tag) -> bytes or None
 |      Get blob from a netnode into a qstring* and make sure the string is null-
 |      terminated.
 |      
 |      @param start: nodeidx_t
 |      @param tag: (C++: uchar) tag of supval array
 |      @return: -1 if blob doesn't exist size of string (including terminating null)
 |               otherwise
 |  
 |  getblob_ea(self, *args) -> 'PyObject *'
 |      getblob_ea(self, ea, tag) -> PyObject *
 |      
 |      @param ea: ea_t
 |      @param tag: char
 |  
 |  getclob(self, *args) -> 'PyObject *'
 |      getclob(self, start, tag) -> str
 |      
 |      @param start: nodeidx_t
 |      @param tag: char
 |  
 |  hashdel(self, *args) -> 'bool'
 |      hashdel(self, idx, tag=htag) -> bool
 |      Delete hash element.
 |      
 |      @param idx: (C++: const char *) index into hash
 |      @param tag: (C++: uchar) tag of hash. Default: htag
 |      @retval true: deleted
 |      @retval false: element does not exist
 |  
 |  hashdel_all(self, *args) -> 'bool'
 |      hashdel_all(self, tag=htag) -> bool
 |      Delete all elements of hash. This function deletes the whole hash.
 |      
 |      @param tag: (C++: uchar) tag of hash. Default: htag
 |      @return: success
 |  
 |  hashfirst(self, *args) -> 'ssize_t'
 |      hashfirst(self, tag=htag) -> ssize_t
 |      @see: hashfirst(qstring *buf, uchar tag=htag) const
 |      
 |      @param tag: (C++: uchar)
 |  
 |  hashlast(self, *args) -> 'ssize_t'
 |      hashlast(self, tag=htag) -> ssize_t
 |      @see: hashlast(qstring *buf, uchar tag=htag) const
 |      
 |      @param tag: (C++: uchar)
 |  
 |  hashnext(self, *args) -> 'ssize_t'
 |      hashnext(self, idx, tag=htag) -> ssize_t
 |      @see: hashnext(qstring *buf, const char *idx, uchar tag=htag) const
 |      
 |      @param idx: (C++: const char *) char const *
 |      @param tag: (C++: uchar)
 |  
 |  hashprev(self, *args) -> 'ssize_t'
 |      hashprev(self, idx, tag=htag) -> ssize_t
 |      @see: hashprev(qstring *buf, const char *idx, uchar tag=htag) const
 |      
 |      @param idx: (C++: const char *) char const *
 |      @param tag: (C++: uchar)
 |  
 |  hashset(self, *args) -> 'bool'
 |      hashset(self, idx, value, tag=htag) -> bool
 |      Set value of hash element to long value.
 |      
 |      @param idx: (C++: const char *) index into hash
 |      @param value: (C++: nodeidx_t) new value of hash element
 |      @param tag: (C++: uchar) tag of hash. Default: htag
 |      @retval 1: ok
 |      @retval 0: should not occur - indicates internal error
 |  
 |  hashset_buf(self, *args) -> 'bool'
 |      hashset_buf(self, idx, py_str, tag=htag) -> bool
 |      
 |      @param idx: char const *
 |      @param py_str: PyObject *
 |      @param tag: char
 |  
 |  hashset_idx(self, *args) -> 'bool'
 |      hashset_idx(self, idx, value, tag=htag) -> bool
 |      
 |      @param idx: char const *
 |      @param value: nodeidx_t
 |      @param tag: uchar
 |  
 |  hashstr(self, *args) -> 'ssize_t'
 |      hashstr(self, idx, tag=htag) -> ssize_t
 |      @see: hashstr(qstring *buf, const char *idx, uchar tag=htag) const
 |      
 |      @param idx: (C++: const char *) char const *
 |      @param tag: (C++: uchar)
 |  
 |  hashstr_buf(self, *args) -> 'PyObject *'
 |      hashstr_buf(self, idx, tag=htag) -> PyObject *
 |      
 |      @param idx: char const *
 |      @param tag: char
 |  
 |  hashval(self, *args) -> 'ssize_t'
 |      hashval(self, idx, tag=htag) -> ssize_t
 |      Get value of the specified hash element.
 |      
 |      @param idx: (C++: const char *) index into hash
 |      @param tag: (C++: uchar) tag of hash. Default: htag
 |      @return: -1 if element doesn't exist or idx is nullptr. otherwise returns the
 |               value size in bytes
 |  
 |  hashval_long(self, *args) -> 'nodeidx_t'
 |      hashval_long(self, idx, tag=htag) -> nodeidx_t
 |      Get value of the specified hash element.
 |      
 |      @param idx: (C++: const char *) index into hash
 |      @param tag: (C++: uchar) tag of hash. Default: htag
 |      @return: value of hash element (it should be set using hashset(nodeidx_t)), 0 if
 |               the element does not exist
 |  
 |  index(self, *args) -> 'nodeidx_t'
 |      index(self) -> nodeidx_t
 |  
 |  kill(self, *args) -> 'void'
 |      kill(self)
 |      Delete a netnode with all information attached to it.
 |  
 |  long_value(self, *args) -> 'nodeidx_t'
 |      long_value(self) -> nodeidx_t
 |  
 |  lower_bound(self, *args) -> 'nodeidx_t'
 |      lower_bound(self, cur, tag=stag) -> nodeidx_t
 |      Get lower bound of existing elements of supval array.
 |      
 |      @param cur: (C++: nodeidx_t) current index
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of first existing element of supval array >= cur BADNODE if
 |               supval array is empty
 |  
 |  lower_bound_ea(self, *args) -> 'nodeidx_t'
 |      lower_bound_ea(self, ea, tag=stag) -> nodeidx_t
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  lower_bound_idx8(self, *args) -> 'nodeidx_t'
 |      lower_bound_idx8(self, alt, tag) -> nodeidx_t
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  moveto(self, *args) -> 'size_t'
 |      moveto(self, destnode, count=1) -> size_t
 |      
 |      @param destnode: netnode
 |      @param count: nodeidx_t
 |  
 |  next(self, *args) -> 'bool'
 |      next(self) -> bool
 |      Get next netnode in the graph. Sets netnodenumber to the next existing number
 |      @retval true: ok
 |      @retval false: no more netnodes
 |  
 |  prev(self, *args) -> 'bool'
 |      prev(self) -> bool
 |      Get prev netnode in the graph. Sets netnodenumber to the previous existing
 |      number
 |      @retval true: ok
 |      @retval false: no more netnodes
 |  
 |  rename(self, *args) -> 'bool'
 |      rename(self, newname, namlen=0) -> bool
 |      Rename a netnode.
 |      
 |      @param newname: (C++: const char *) new name of netnode. nullptr or "" means to delete name. names
 |                      of user-defined netnodes must have the "$ " prefix in order to
 |                      avoid clashes with program byte names.
 |      @param namlen: (C++: size_t) length of new name. if not specified, it will be calculated using
 |                     strlen()
 |      @retval 1: ok
 |      @retval 0: failed, newname is already used
 |  
 |  set(self, *args) -> 'bool'
 |      set(self, value) -> bool
 |      Set value of netnode.
 |      
 |      @param value: (C++: const void *) pointer to value
 |      @return: 1 - ok
 |  
 |  set_long(self, *args) -> 'bool'
 |      set_long(self, x) -> bool
 |      Value of netnode as a long number:
 |      
 |      @param x: (C++: nodeidx_t)
 |  
 |  setblob(self, *args) -> 'bool'
 |      setblob(self, buf, _start, tag) -> bool
 |      Store a blob in a netnode.
 |      
 |      @param buf: (C++: const void *) pointer to blob to save
 |      @param _start: (C++: nodeidx_t)
 |      @param tag: (C++: uchar) tag of supval array
 |      @return: success
 |  
 |  setblob_ea(self, *args) -> 'bool'
 |      setblob_ea(self, buf, ea, tag) -> bool
 |      
 |      @param buf: void const *
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  start(self, *args) -> 'bool'
 |      start(self) -> bool
 |      Get first netnode in the graph. Sets netnodenumber to the lowest existing
 |      number.
 |      @retval true: ok
 |      @retval false: graph is empty
 |  
 |  supdel(self, *args) -> 'bool'
 |      supdel(self, alt, tag=stag) -> bool
 |      Delete all elements of supval array. This function may be applied to 32-bit and
 |      8-bit supval arrays. This function deletes the whole supval array.
 |      
 |      @param alt: nodeidx_t
 |      @param tag: uchar
 |      
 |      @return: success
 |      supdel(self) -> bool
 |  
 |  supdel_all(self, *args) -> 'bool'
 |      supdel_all(self, tag) -> bool
 |      Delete all elements of the specified supval array. This function may be applied
 |      to 32-bit and 8-bit supval arrays. This function deletes the whole supval array.
 |      
 |      @param tag: (C++: uchar)
 |      @return: success
 |  
 |  supdel_ea(self, *args) -> 'bool'
 |      supdel_ea(self, ea, tag=stag) -> bool
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  supdel_idx8(self, *args) -> 'bool'
 |      supdel_idx8(self, alt, tag) -> bool
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  supdel_range(self, *args) -> 'int'
 |      supdel_range(self, idx1, idx2, tag) -> int
 |      Delete range of elements in the specified supval array. Elements in range [idx1,
 |      idx2) will be deleted.
 |      @note: This function can also be used to delete a range of altval elements
 |      
 |      @param idx1: (C++: nodeidx_t) first element to delete
 |      @param idx2: (C++: nodeidx_t) last element to delete + 1
 |      @param tag: (C++: uchar) tag of array
 |      @return: number of deleted elements
 |  
 |  supdel_range_idx8(self, *args) -> 'int'
 |      supdel_range_idx8(self, idx1, idx2, tag) -> int
 |      Same as above, but accepts 8-bit indexes.
 |      
 |      @param idx1: (C++: uchar)
 |      @param idx2: (C++: uchar)
 |      @param tag: (C++: uchar)
 |  
 |  supfirst(self, *args) -> 'nodeidx_t'
 |      supfirst(self, tag=stag) -> nodeidx_t
 |      Get first existing element of supval array.
 |      
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of first existing element of supval array, BADNODE if supval
 |               array is empty
 |  
 |  supfirst_idx8(self, *args) -> 'nodeidx_t'
 |      supfirst_idx8(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  suplast(self, *args) -> 'nodeidx_t'
 |      suplast(self, tag=stag) -> nodeidx_t
 |      Get last existing element of supval array.
 |      
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of last existing element of supval array, BADNODE if supval array
 |               is empty
 |  
 |  suplast_idx8(self, *args) -> 'nodeidx_t'
 |      suplast_idx8(self, tag) -> nodeidx_t
 |      
 |      @param tag: uchar
 |  
 |  supnext(self, *args) -> 'nodeidx_t'
 |      supnext(self, cur, tag=stag) -> nodeidx_t
 |      Get next existing element of supval array.
 |      
 |      @param cur: (C++: nodeidx_t) current index
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of the next existing element of supval array, BADNODE if no more
 |               supval array elements exist
 |  
 |  supnext_idx8(self, *args) -> 'nodeidx_t'
 |      supnext_idx8(self, alt, tag) -> nodeidx_t
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  supprev(self, *args) -> 'nodeidx_t'
 |      supprev(self, cur, tag=stag) -> nodeidx_t
 |      Get previous existing element of supval array.
 |      
 |      @param cur: (C++: nodeidx_t) current index
 |      @param tag: (C++: uchar) tag of array
 |      @return: index of the previous existing element of supval array BADNODE if no
 |               more supval array elements exist
 |  
 |  supprev_idx8(self, *args) -> 'nodeidx_t'
 |      supprev_idx8(self, alt, tag) -> nodeidx_t
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  supset(self, *args) -> 'bool'
 |      supset(self, alt, value, tag=stag) -> bool
 |      Set value of supval array element.
 |      
 |      @param alt: (C++: nodeidx_t) index into array of supvals
 |      @param value: (C++: const void *) pointer to supval value
 |      @param tag: (C++: uchar) tag of array
 |      @retval 1: ok
 |      @retval 0: should not occur - indicates internal error
 |  
 |  supset_ea(self, *args) -> 'bool'
 |      supset_ea(self, ea, value, tag=stag) -> bool
 |      
 |      @param ea: ea_t
 |      @param value: void const *
 |      @param tag: uchar
 |  
 |  supset_idx8(self, *args) -> 'bool'
 |      supset_idx8(self, alt, value, tag) -> bool
 |      
 |      @param alt: uchar
 |      @param value: void const *
 |      @param tag: uchar
 |  
 |  supshift(self, *args) -> 'size_t'
 |      supshift(self, _from, to, size, tag=stag) -> size_t
 |      Shift the supval array elements. Moves the array elements at (from..from+size)
 |      to (to..to+size)
 |      
 |      @param from: (C++: nodeidx_t)
 |      @param to: (C++: nodeidx_t)
 |      @param size: (C++: nodeidx_t)
 |      @param tag: (C++: uchar)
 |      @return: number of shifted elements
 |  
 |  supstr(self, *args) -> 'ssize_t'
 |      supstr(self, alt, tag=stag) -> ssize_t
 |      @see: supstr(qstring *buf, nodeidx_t alt, uchar tag=stag) const
 |      
 |      @param alt: (C++: nodeidx_t)
 |      @param tag: (C++: uchar)
 |  
 |  supstr_ea(self, *args) -> 'ssize_t'
 |      supstr_ea(self, ea, tag=stag) -> ssize_t
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  supstr_idx8(self, *args) -> 'ssize_t'
 |      supstr_idx8(self, alt, tag) -> ssize_t
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  supval(self, *args) -> 'ssize_t'
 |      supval(self, alt, tag=stag) -> ssize_t
 |      Get value of the specified supval array element. NB: do not use this function to
 |      retrieve strings, see supstr()!
 |      
 |      @param alt: (C++: nodeidx_t) index into array of supvals
 |      @param tag: (C++: uchar) tag of array. Default: stag
 |      @return: size of value, -1 if element doesn't exist
 |  
 |  supval_ea(self, *args) -> 'ssize_t'
 |      supval_ea(self, ea, tag=stag) -> ssize_t
 |      
 |      @param ea: ea_t
 |      @param tag: uchar
 |  
 |  supval_idx8(self, *args) -> 'ssize_t'
 |      supval_idx8(self, alt, tag) -> ssize_t
 |      
 |      @param alt: uchar
 |      @param tag: uchar
 |  
 |  valobj(self, *args) -> 'ssize_t'
 |      valobj(self) -> ssize_t
 |      Get value of netnode. Netnode values are arbitrary sized objects with max size
 |      is MAXSPECSIZE. NB: do not use this function for strings - see valstr().
 |      
 |      @return: length of value, -1 if no value present
 |  
 |  valstr(self, *args) -> 'ssize_t'
 |      valstr(self) -> ssize_t
 |      @see: valstr(qstring *buf) const
 |  
 |  value_exists(self, *args) -> 'bool'
 |      value_exists(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  exist(*args) -> 'bool'
 |      exist(_name) -> bool
 |      Does the netnode with the specified name exist?
 |      
 |      @param _name: (C++: const char *) char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function netnode_exist in module ida_netnode:

netnode_exist(*args) -> 'bool'
    netnode_exist(_name) -> bool
    
    @param _name: char const *

Module "ida_offset"s docstring:
"""
Functions that deal with offsets.

"Being an offset" is a characteristic of an operand. This means that operand or
its part represent offset from some address in the program. This linear address
is called "offset base". Some operands may have 2 offsets simultaneously.
Generally, IDA doesn't handle this except for Motorola outer offsets. Thus there
may be two offset values in an operand: simple offset and outer offset.

Outer offsets are handled by specifying special operand number: it should be
ORed with OPND_OUTER value.

See bytes.hpp for further explanation of operand numbers."""

Help on function add_refinfo_dref in module ida_offset:

add_refinfo_dref(*args) -> 'ea_t'
    add_refinfo_dref(insn, _from, ri, opval, type, opoff) -> ea_t
    Add xrefs for a reference from the given instruction ( insn_t::ea). This
    function creates a cross references to the target and the base.
    insn_t::add_off_drefs() calls this function to create xrefs for 'offset'
    operand.
    
    @param insn: (C++: const insn_t &) the referencing instruction
    @param from: (C++: ea_t) the referencing instruction/data address
    @param ri: (C++: const refinfo_t &) reference info block from the database
    @param opval: (C++: adiff_t) operand value (usually op_t::value or op_t::addr)
    @param type: (C++: dref_t) type of xref
    @param opoff: (C++: int) offset of the operand from the start of instruction
    @return: the target address of the reference

Help on function calc_basevalue in module ida_offset:

calc_basevalue(*args) -> 'ea_t'
    calc_basevalue(target, base) -> ea_t
    Calculate the value of the reference base.
    
    @param target: (C++: ea_t)
    @param base: (C++: ea_t)

Help on function calc_offset_base in module ida_offset:

calc_offset_base(*args) -> 'ea_t'
    calc_offset_base(ea, n) -> ea_t
    Try to calculate the offset base This function takes into account the fixup
    information, current ds and cs values.
    
    @param ea: (C++: ea_t) the referencing instruction/data address
    @param n: (C++: int) operand number
    * 0: first operand
    * 1: other operand
    @return: output base address or BADADDR

Help on function calc_probable_base_by_value in module ida_offset:

calc_probable_base_by_value(*args) -> 'ea_t'
    calc_probable_base_by_value(ea, off) -> ea_t
    Try to calculate the offset base. 2 bases are checked: current ds and cs. If
    fails, return BADADDR
    
    @param ea: (C++: ea_t)
    @param off: (C++: uval_t)

Help on function calc_reference_data in module ida_offset:

calc_reference_data(*args) -> 'bool'
    calc_reference_data(target, base, _from, ri, opval) -> bool
    Calculate the target and base addresses of an offset expression. The calculated
    target and base addresses are returned in the locations pointed by 'base' and
    'target'. In case 'ri.base' is BADADDR, the function calculates the offset base
    address from the referencing instruction/data address. The target address is
    copied from ri.target. If ri.target is BADADDR then the target is calculated
    using the base address and 'opval'. This function also checks if 'opval' matches
    the full value of the reference and takes in account the memory-mapping.
    
    @param target: (C++: ea_t *) output target address
    @param base: (C++: ea_t *) output base address
    @param from: (C++: ea_t) the referencing instruction/data address
    @param ri: (C++: const refinfo_t &) reference info block from the database
    @param opval: (C++: adiff_t) operand value (usually op_t::value or op_t::addr)
    @return: success

Help on function calc_target in module ida_offset:

calc_target(*args) -> 'ea_t'
    calc_target(_from, opval, ri) -> ea_t
    Retrieves refinfo_t structure and calculates the target.
    
    @param from: (C++: ea_t)
    @param opval: (C++: adiff_t)
    @param ri: refinfo_t const &
    
    calc_target(_from, ea, n, opval) -> ea_t
    
    @param from: ea_t
    @param ea: ea_t
    @param n: int
    @param opval: adiff_t

Help on function can_be_off32 in module ida_offset:

can_be_off32(*args) -> 'ea_t'
    can_be_off32(ea) -> ea_t
    Does the specified address contain a valid OFF32 value?. For symbols in special
    segments the displacement is not taken into account. If yes, then the target
    address of OFF32 will be returned. If not, then BADADDR is returned.
    
    @param ea: (C++: ea_t)

Help on function get_default_reftype in module ida_offset:

get_default_reftype(*args) -> 'reftype_t'
    get_default_reftype(ea) -> reftype_t
    Get default reference type depending on the segment.
    
    @param ea: (C++: ea_t)
    @return: one of REF_OFF8,REF_OFF16,REF_OFF32

Help on function get_offbase in module ida_offset:

get_offbase(*args) -> 'ea_t'
    get_offbase(ea, n) -> ea_t
    Get offset base value
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand
    @return: offset base or BADADDR

Help on function get_offset_expr in module ida_offset:

get_offset_expr(*args) -> 'qstring *'
    get_offset_expr(ea, n, ri, _from, offset, getn_flags=0) -> str
    See get_offset_expression()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param ri: (C++: const refinfo_t &) refinfo_t const &
    @param from: (C++: ea_t)
    @param offset: (C++: adiff_t)
    @param getn_flags: (C++: int)

Help on function get_offset_expression in module ida_offset:

get_offset_expression(*args) -> 'qstring *'
    get_offset_expression(ea, n, _from, offset, getn_flags=0) -> str
    Get offset expression (in the form "offset name+displ"). This function uses
    offset translation function ( processor_t::translate) if your IDP module has
    such a function. Translation function is used to map linear addresses in the
    program (only for offsets).
    
    Example: suppose we have instruction at linear address 0x00011000:
    mov     ax, [bx+7422h]  and at ds:7422h:
    array   dw      ...  We want to represent the second operand with an offset
    expression, so then we call:
    get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf);
                         |         |  |         |       |
                         |         |  |         |       +output buffer
                         |         |  |         +value of offset expression
                         |         |  +address offset value in the instruction
                         |         +the second operand
                         +address of instruction and the function will return a
    colored string:
    offset array
    
    @param ea: (C++: ea_t) start of instruction or data with the offset expression
    @param n: (C++: int) number of operand (may be ORed with OPND_OUTER)
    * 0: first operand
    * 1: second operand
    @param from: (C++: ea_t) linear address of instruction operand or data referring to the
                 name. This address will be used to get fixup information, so it
                 should point to exact position of operand in the instruction.
    @param offset: (C++: adiff_t) value of operand or its part. The function will return text
                   representation of this value as offset expression.
    @param getn_flags: (C++: int) combination of:
    * GETN_APPZERO: meaningful only if the name refers to a structure. appends the
    struct field name if the field offset is zero
    * GETN_NODUMMY: do not generate dummy names for the expression but pretend they
    already exist (useful to verify that the offset expression can be represented)
    @retval 0: can't convert to offset expression
    @retval 1: ok, a simple offset expression
    @retval 2: ok, a complex offset expression

Help on function op_offset in module ida_offset:

op_offset(*args) -> 'bool'
    op_offset(ea, n, type_and_flags, target=BADADDR, base=0, tdelta=0) -> bool
    See op_offset_ex()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param type_and_flags: (C++: uint32)
    @param target: (C++: ea_t)
    @param base: (C++: ea_t)
    @param tdelta: (C++: adiff_t)

Help on function op_offset_ex in module ida_offset:

op_offset_ex(*args) -> 'bool'
    op_offset_ex(ea, n, ri) -> bool
    Convert operand to a reference. To delete an offset, use clr_op_type() function.
    
    @param ea: (C++: ea_t) linear address. if 'ea' has unexplored bytes, try to convert them to
    * no segment: fail
    * 16bit segment: to 16bit word data
    * 32bit segment: to dword
    @param n: (C++: int) number of operand (may be ORed with OPND_OUTER)
    * 0: first
    * 1: second
    * 2: third
    * OPND_MASK: all operands
    @param ri: (C++: const refinfo_t *) reference information
    @return: success

Help on function op_plain_offset in module ida_offset:

op_plain_offset(*args) -> 'bool'
    op_plain_offset(ea, n, base) -> bool
    Convert operand to a reference with the default reference type.
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param base: (C++: ea_t)

Module "ida_pro"s docstring:
"""
This is the first header included in the IDA project.

It defines the most common types, functions and data. Also, it tries to make
system dependent definitions.

The following preprocessor macros are used in the project (the list may be
incomplete)

Platform must be specified as one of:

__NT__ - MS Windows (all platforms)
__LINUX__ - Linux
__MAC__ - MAC OS X

__EA64__ - 64-bit address size (sizeof(ea_t)==8)
__X86__ - 32-bit debug servers (sizeof(void*)==4)
__X64__ - x64 processor (sizeof(void*)==8) default
__PPC__ - PowerPC
__ARM__ - ARM"""

Help on class __qmutex_t in module ida_pro:

class __qmutex_t(builtins.object)
 |  Proxy of C++ __qmutex_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qmutex_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qmutex_t(...)
 |      delete___qmutex_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __qsemaphore_t in module ida_pro:

class __qsemaphore_t(builtins.object)
 |  Proxy of C++ __qsemaphore_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qsemaphore_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qsemaphore_t(...)
 |      delete___qsemaphore_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class __qthread_t in module ida_pro:

class __qthread_t(builtins.object)
 |  Proxy of C++ __qthread_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> __qthread_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete___qthread_t(...)
 |      delete___qthread_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class _qstrvec_t in module ida_pro:

class _qstrvec_t(ida_idaapi.py_clinked_object_t)
 |  WARNING: It is very unlikely an IDAPython user should ever, ever
 |  have to use this type. It should only be used for IDAPython internals.
 |  
 |  For example, in py_askusingform.py, we ctypes-expose to the IDA
 |  kernel & UI a qstrvec instance, in case a DropdownListControl is
 |  constructed.
 |  That's because that's what ask_form expects, and we have no
 |  choice but to make a DropdownListControl hold a qstrvec_t.
 |  This is, afaict, the only situation where a Python
 |  _qstrvec_t is required.
 |  
 |  Method resolution order:
 |      _qstrvec_t
 |      ida_idaapi.py_clinked_object_t
 |      ida_idaapi.pyidc_opaque_object_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, idx)
 |      Gets the string at the given index
 |  
 |  __init__(self, items=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __setitem__(self, idx, s)
 |      Sets string at the given index
 |  
 |  _create_clink(self)
 |      Overwrite me.
 |      Creates a new clink
 |      @return: PyCapsule representing the C link
 |  
 |  _del_clink(self, lnk)
 |      Overwrite me.
 |      This method deletes the link
 |  
 |  _get_clink_ptr(self)
 |      Overwrite me.
 |      Returns the C link pointer as a 64bit number
 |  
 |  _qstrvec_t__get_size = __get_size(self)
 |  
 |  add(self, s)
 |      Add a string to the vector
 |  
 |  addressof(self, idx)
 |      Returns the address (as number) of the qstring at the given index
 |  
 |  assign(self, other)
 |      Copies the contents of 'other' to 'self'
 |  
 |  clear(self, qclear=False)
 |      Clears all strings from the vector.
 |      @param qclear: Just reset the size but do not actually free the memory
 |  
 |  from_list(self, lst)
 |      Populates the vector from a Python string list
 |  
 |  insert(self, idx, s)
 |      Insert a string into the vector
 |  
 |  remove(self, idx)
 |      Removes a string from the vector
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  size
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  __del__(self)
 |      Delete the link upon object destruction (only if not static)
 |  
 |  _free(self)
 |      Explicitly delete the link (only if not static)
 |  
 |  copy(self)
 |      Returns a new copy of this class
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.py_clinked_object_t:
 |  
 |  clink
 |  
 |  clink_ptr
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_idaapi.pyidc_opaque_object_t:
 |  
 |  __idc_cvt_id__ = 2

Help on class boolvec_t in module ida_pro:

class boolvec_t(builtins.object)
 |  Proxy of C++ qvector< bool > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< bool > const &
 |  
 |  __getitem__(self, *args) -> 'bool const &'
 |      __getitem__(self, i) -> bool const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> boolvec_t
 |      __init__(self, x) -> boolvec_t
 |      
 |      @param x: qvector< bool > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< bool > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: bool const &
 |  
 |  __swig_destroy__ = delete_boolvec_t(...)
 |      delete_boolvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: bool const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: bool const &
 |  
 |  append = push_back(self, *args) -> 'bool &'
 |  
 |  at = __getitem__(self, *args) -> 'bool const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< bool >::const_iterator'
 |      begin(self) -> qvector< bool >::iterator
 |      begin(self) -> qvector< bool >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< bool >::const_iterator'
 |      end(self) -> qvector< bool >::iterator
 |      end(self) -> qvector< bool >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< bool >::iterator'
 |      erase(self, it) -> qvector< bool >::iterator
 |      
 |      @param it: qvector< bool >::iterator
 |      
 |      erase(self, first, last) -> qvector< bool >::iterator
 |      
 |      @param first: qvector< bool >::iterator
 |      @param last: qvector< bool >::iterator
 |  
 |  extract(self, *args) -> 'bool *'
 |      extract(self) -> bool *
 |  
 |  find(self, *args) -> 'qvector< bool >::const_iterator'
 |      find(self, x) -> qvector< bool >::iterator
 |      
 |      @param x: bool const &
 |      
 |      find(self, x) -> qvector< bool >::const_iterator
 |      
 |      @param x: bool const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=bool())
 |      
 |      @param x: bool const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: bool const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: bool *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< bool >::iterator'
 |      insert(self, it, x) -> qvector< bool >::iterator
 |      
 |      @param it: qvector< bool >::iterator
 |      @param x: bool const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'bool &'
 |      push_back(self, x)
 |      
 |      @param x: bool const &
 |      
 |      push_back(self) -> bool &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: bool const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< bool > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class channel_redir_t in module ida_pro:

class channel_redir_t(builtins.object)
 |  Proxy of C++ channel_redir_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> channel_redir_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_channel_redir_t(...)
 |      delete_channel_redir_t(self)
 |  
 |  is_append(self, *args) -> 'bool'
 |      is_append(self) -> bool
 |  
 |  is_input(self, *args) -> 'bool'
 |      is_input(self) -> bool
 |  
 |  is_output(self, *args) -> 'bool'
 |      is_output(self) -> bool
 |  
 |  is_quoted(self, *args) -> 'bool'
 |      is_quoted(self) -> bool
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fd
 |      fd
 |  
 |  file
 |      file
 |  
 |  flags
 |      flags
 |  
 |  length
 |      length
 |  
 |  start
 |      start
 |  
 |  thisown
 |      The membership flag

Help on function check_process_exit in module ida_pro:

check_process_exit(*args) -> 'int'
    check_process_exit(handle, exit_code, msecs=-1) -> int
    Check whether process has terminated or not.
    
    @param handle: (C++: void *) process handle to wait for
    @param exit_code: (C++: int *) pointer to the buffer for the exit code
    @param msecs: how long to wait. special values:
    * 0: do not wait
    * 1 or -1: wait infinitely
    * other values: timeout in milliseconds
    @retval 0: process has exited, and the exit code is available. if *exit_code <
               0: the process was killed with a signal -*exit_code
    @retval 1: process has not exited yet
    @retval -1: error happened, see error code for winerr() in *exit_code

Help on class ea_array in module ida_pro:

class ea_array(builtins.object)
 |  Proxy of C++ ea_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'ea_t'
 |      __getitem__(self, index) -> ea_t
 |      
 |      @param index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> ea_array
 |      
 |      @param nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |      
 |      @param index: size_t
 |      @param value: ea_t
 |  
 |  __swig_destroy__ = delete_ea_array(...)
 |      delete_ea_array(self)
 |  
 |  cast(self, *args) -> 'ea_t *'
 |      cast(self) -> ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'ea_array *'
 |      frompointer(t) -> ea_array
 |      
 |      @param t: ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function ea_array_frompointer in module ida_pro:

ea_array_frompointer(*args) -> 'ea_array *'
    ea_array_frompointer(t) -> ea_array
    
    @param t: ea_t *

Help on class ea_pointer in module ida_pro:

class ea_pointer(builtins.object)
 |  Proxy of C++ ea_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> ea_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ea_pointer(...)
 |      delete_ea_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |      
 |      @param value: ea_t
 |  
 |  cast(self, *args) -> 'ea_t *'
 |      cast(self) -> ea_t *
 |  
 |  value(self, *args) -> 'ea_t'
 |      value(self) -> ea_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'ea_pointer *'
 |      frompointer(t) -> ea_pointer
 |      
 |      @param t: ea_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function ea_pointer_frompointer in module ida_pro:

ea_pointer_frompointer(*args) -> 'ea_pointer *'
    ea_pointer_frompointer(t) -> ea_pointer
    
    @param t: ea_t *

Help on function extend_sign in module ida_pro:

extend_sign(*args) -> 'uint64'
    extend_sign(v, nbytes, sign_extend) -> uint64
    Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v' is
    considered to be of size 'nbytes'.
    
    @param v: (C++: uint64)
    @param nbytes: (C++: int)
    @param sign_extend: (C++: bool)

Help on class instant_dbgopts_t in module ida_pro:

class instant_dbgopts_t(builtins.object)
 |  Proxy of C++ instant_dbgopts_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> instant_dbgopts_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_instant_dbgopts_t(...)
 |      delete_instant_dbgopts_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  _pass
 |      _pass
 |  
 |  attach
 |      attach
 |  
 |  debmod
 |      debmod
 |  
 |  env
 |      env
 |  
 |  event_id
 |      event_id
 |  
 |  host
 |      host
 |  
 |  pid
 |      pid
 |  
 |  port
 |      port
 |  
 |  thisown
 |      The membership flag

Help on class int64vec_t in module ida_pro:

class int64vec_t(builtins.object)
 |  Proxy of C++ qvector< long long > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< long long > const &
 |  
 |  __getitem__(self, *args) -> 'long long const &'
 |      __getitem__(self, i) -> long long const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> int64vec_t
 |      __init__(self, x) -> int64vec_t
 |      
 |      @param x: qvector< long long > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< long long > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: long long const &
 |  
 |  __swig_destroy__ = delete_int64vec_t(...)
 |      delete_int64vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: long long const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: long long const &
 |  
 |  append = push_back(self, *args) -> 'long long &'
 |  
 |  at = __getitem__(self, *args) -> 'long long const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< long long >::const_iterator'
 |      begin(self) -> qvector< long long >::iterator
 |      begin(self) -> qvector< long long >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< long long >::const_iterator'
 |      end(self) -> qvector< long long >::iterator
 |      end(self) -> qvector< long long >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< long long >::iterator'
 |      erase(self, it) -> qvector< long long >::iterator
 |      
 |      @param it: qvector< long long >::iterator
 |      
 |      erase(self, first, last) -> qvector< long long >::iterator
 |      
 |      @param first: qvector< long long >::iterator
 |      @param last: qvector< long long >::iterator
 |  
 |  extract(self, *args) -> 'long long *'
 |      extract(self) -> long long *
 |  
 |  find(self, *args) -> 'qvector< long long >::const_iterator'
 |      find(self, x) -> qvector< long long >::iterator
 |      
 |      @param x: long long const &
 |      
 |      find(self, x) -> qvector< long long >::const_iterator
 |      
 |      @param x: long long const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: long long const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: long long *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< long long >::iterator'
 |      insert(self, it, x) -> qvector< long long >::iterator
 |      
 |      @param it: qvector< long long >::iterator
 |      @param x: long long const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'long long &'
 |      push_back(self, x)
 |      
 |      @param x: long long const &
 |      
 |      push_back(self) -> long long &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: long long const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< long long > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class int_pointer in module ida_pro:

class int_pointer(builtins.object)
 |  Proxy of C++ int_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> int_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_int_pointer(...)
 |      delete_int_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |      
 |      @param value: int
 |  
 |  cast(self, *args) -> 'int *'
 |      cast(self) -> int *
 |  
 |  value(self, *args) -> 'int'
 |      value(self) -> int
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'int_pointer *'
 |      frompointer(t) -> int_pointer
 |      
 |      @param t: int *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function int_pointer_frompointer in module ida_pro:

int_pointer_frompointer(*args) -> 'int_pointer *'
    int_pointer_frompointer(t) -> int_pointer
    
    @param t: int *

Help on class intvec_t in module ida_pro:

class intvec_t(builtins.object)
 |  Proxy of C++ qvector< int > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< int > const &
 |  
 |  __getitem__(self, *args) -> 'int const &'
 |      __getitem__(self, i) -> int const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> intvec_t
 |      __init__(self, x) -> intvec_t
 |      
 |      @param x: qvector< int > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< int > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: int const &
 |  
 |  __swig_destroy__ = delete_intvec_t(...)
 |      delete_intvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: int const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: int const &
 |  
 |  append = push_back(self, *args) -> 'int &'
 |  
 |  at = __getitem__(self, *args) -> 'int const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< int >::const_iterator'
 |      begin(self) -> qvector< int >::iterator
 |      begin(self) -> qvector< int >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< int >::const_iterator'
 |      end(self) -> qvector< int >::iterator
 |      end(self) -> qvector< int >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< int >::iterator'
 |      erase(self, it) -> qvector< int >::iterator
 |      
 |      @param it: qvector< int >::iterator
 |      
 |      erase(self, first, last) -> qvector< int >::iterator
 |      
 |      @param first: qvector< int >::iterator
 |      @param last: qvector< int >::iterator
 |  
 |  extract(self, *args) -> 'int *'
 |      extract(self) -> int *
 |  
 |  find(self, *args) -> 'qvector< int >::const_iterator'
 |      find(self, x) -> qvector< int >::iterator
 |      
 |      @param x: int const &
 |      
 |      find(self, x) -> qvector< int >::const_iterator
 |      
 |      @param x: int const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: int const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: int *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< int >::iterator'
 |      insert(self, it, x) -> qvector< int >::iterator
 |      
 |      @param it: qvector< int >::iterator
 |      @param x: int const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'int &'
 |      push_back(self, x)
 |      
 |      @param x: int const &
 |      
 |      push_back(self) -> int &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: int const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< int > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function is_control_tty in module ida_pro:

is_control_tty(*args) -> 'enum tty_control_t'
    is_control_tty(fd) -> enum tty_control_t
    Check if the current process is the owner of the TTY specified by 'fd'
    (typically an opened descriptor to /dev/tty).
    
    @param fd: (C++: int)

Help on function is_main_thread in module ida_pro:

is_main_thread(*args) -> 'bool'
    is_main_thread() -> bool
    Are we running in the main thread?

Help on function log2ceil in module ida_pro:

log2ceil(*args) -> 'int'
    log2ceil(d64) -> int
    calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 == 0
    
    @param d64: (C++: uint64)

Help on function log2floor in module ida_pro:

log2floor(*args) -> 'int'
    log2floor(d64) -> int
    
    @param d64: uint64

Help on function parse_dbgopts in module ida_pro:

parse_dbgopts(*args) -> 'bool'
    parse_dbgopts(ido, r_switch) -> bool
    Parse the -r command line switch (for instant debugging). r_switch points to the
    value of the -r switch. Example: win32@localhost+
    
    @param ido: (C++: struct instant_dbgopts_t *) instant_dbgopts_t *
    @param r_switch: (C++: const char *) char const *
    @return: true-ok, false-parse error

Help on function qatoll in module ida_pro:

qatoll(*args) -> 'int64'
    qatoll(nptr) -> int64
    
    @param nptr: char const *

Help on function qcontrol_tty in module ida_pro:

qcontrol_tty(*args) -> 'void'
    qcontrol_tty()
    Make the current terminal the controlling terminal of the calling process.
    @note: The current terminal is supposed to be /dev/tty

Help on function qdetach_tty in module ida_pro:

qdetach_tty(*args) -> 'void'
    qdetach_tty()
    If the current terminal is the controlling terminal of the calling process, give
    up this controlling terminal.
    @note: The current terminal is supposed to be /dev/tty

Help on function qexit in module ida_pro:

qexit(*args) -> 'void'
    qexit(code)
    Call qatexit functions, shut down UI and kernel, and exit.
    
    @param code: (C++: int) exit code

Help on class qmutex_locker_t in module ida_pro:

class qmutex_locker_t(builtins.object)
 |  Proxy of C++ qmutex_locker_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _lock) -> qmutex_locker_t
 |      
 |      @param _lock: qmutex_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qmutex_locker_t(...)
 |      delete_qmutex_locker_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class qrefcnt_obj_t in module ida_pro:

class qrefcnt_obj_t(builtins.object)
 |  Proxy of C++ qrefcnt_obj_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_qrefcnt_obj_t(...)
 |      delete_qrefcnt_obj_t(self)
 |  
 |  release(self, *args) -> 'void'
 |      release(self)
 |      Call destructor. We use release() instead of operator delete() to maintain
 |      binary compatibility with all compilers (vc and gcc use different vtable layouts
 |      for operator delete)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  refcnt
 |      refcnt
 |  
 |  thisown
 |      The membership flag

Help on function qstrvec_t_add in module ida_pro:

qstrvec_t_add(*args) -> 'bool'
    qstrvec_t_add(_self, s) -> bool
    
    @param self: PyObject *
    @param s: char const *

Help on function qstrvec_t_addressof in module ida_pro:

qstrvec_t_addressof(*args) -> 'PyObject *'
    qstrvec_t_addressof(_self, idx) -> PyObject *
    
    @param self: PyObject *
    @param idx: size_t

Help on function qstrvec_t_assign in module ida_pro:

qstrvec_t_assign(*args) -> 'bool'
    qstrvec_t_assign(_self, other) -> bool
    
    @param self: PyObject *
    @param other: PyObject *

Help on function qstrvec_t_clear in module ida_pro:

qstrvec_t_clear(*args) -> 'bool'
    qstrvec_t_clear(_self, qclear) -> bool
    
    @param self: PyObject *
    @param qclear: bool

Help on function qstrvec_t_create in module ida_pro:

qstrvec_t_create(*args) -> 'PyObject *'
    qstrvec_t_create() -> PyObject *

Help on function qstrvec_t_destroy in module ida_pro:

qstrvec_t_destroy(*args) -> 'bool'
    qstrvec_t_destroy(py_obj) -> bool
    
    @param py_obj: PyObject *

Help on function qstrvec_t_from_list in module ida_pro:

qstrvec_t_from_list(*args) -> 'bool'
    qstrvec_t_from_list(_self, py_list) -> bool
    
    @param self: PyObject *
    @param py_list: PyObject *

Help on function qstrvec_t_get in module ida_pro:

qstrvec_t_get(*args) -> 'PyObject *'
    qstrvec_t_get(_self, idx) -> PyObject *
    
    @param self: PyObject *
    @param idx: size_t

Help on function qstrvec_t_get_clink in module ida_pro:

qstrvec_t_get_clink(*args) -> 'qstrvec_t *'
    qstrvec_t_get_clink(_self) -> qstrvec_t *
    
    @param self: PyObject *

Help on function qstrvec_t_get_clink_ptr in module ida_pro:

qstrvec_t_get_clink_ptr(*args) -> 'PyObject *'
    qstrvec_t_get_clink_ptr(_self) -> PyObject *
    
    @param self: PyObject *

Help on function qstrvec_t_insert in module ida_pro:

qstrvec_t_insert(*args) -> 'bool'
    qstrvec_t_insert(_self, idx, s) -> bool
    
    @param self: PyObject *
    @param idx: size_t
    @param s: char const *

Help on function qstrvec_t_remove in module ida_pro:

qstrvec_t_remove(*args) -> 'bool'
    qstrvec_t_remove(_self, idx) -> bool
    
    @param self: PyObject *
    @param idx: size_t

Help on function qstrvec_t_set in module ida_pro:

qstrvec_t_set(*args) -> 'bool'
    qstrvec_t_set(_self, idx, s) -> bool
    
    @param self: PyObject *
    @param idx: size_t
    @param s: char const *

Help on function qstrvec_t_size in module ida_pro:

qstrvec_t_size(*args) -> 'size_t'
    qstrvec_t_size(_self) -> size_t
    
    @param self: PyObject *

Help on function qthread_equal in module ida_pro:

qthread_equal(*args) -> 'bool'
    qthread_equal(q1, q2) -> bool
    Are two threads equal?
    
    @param q1: (C++: qthread_t)
    @param q2: (C++: qthread_t)

Help on function quote_cmdline_arg in module ida_pro:

quote_cmdline_arg(*args) -> 'bool'
    quote_cmdline_arg(arg) -> bool
    Quote a command line argument if it contains escape characters. For example, *.c
    will be converted into "*.c" because * may be inadvertently expanded by the
    shell
    
    @param arg: (C++: qstring *)
    @return: true: modified 'arg'

Help on function qvector_reserve in module ida_pro:

qvector_reserve(*args) -> 'void *'
    qvector_reserve(vec, old, cnt, elsize) -> void *
    Change capacity of given qvector.
    
    @param vec: (C++: void *) a pointer to a qvector
    @param old: (C++: void *) a pointer to the qvector's array
    @param cnt: (C++: size_t) number of elements to reserve
    @param elsize: (C++: size_t) size of each element
    @return: a pointer to the newly allocated array

Help on function readbytes in module ida_pro:

readbytes(*args) -> 'int'
    readbytes(h, res, size, mf) -> int
    Read at most 4 bytes from file.
    
    @param h: (C++: int) file handle
    @param res: (C++: uint32 *) value read from file
    @param size: (C++: int) size of value in bytes (1,2,4)
    @param mf: (C++: bool) is MSB first?
    @return: 0 on success, nonzero otherwise

Help on function reloc_value in module ida_pro:

reloc_value(*args) -> 'void'
    reloc_value(value, size, delta, mf)
    
    @param value: void *
    @param size: int
    @param delta: adiff_t
    @param mf: bool

Help on function relocate_relobj in module ida_pro:

relocate_relobj(*args) -> 'bool'
    relocate_relobj(_relobj, ea, mf) -> bool
    
    @param _relobj: relobj_t *
    @param ea: ea_t
    @param mf: bool

Help on class sel_array in module ida_pro:

class sel_array(builtins.object)
 |  Proxy of C++ sel_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'sel_t'
 |      __getitem__(self, index) -> sel_t
 |      
 |      @param index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> sel_array
 |      
 |      @param nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |      
 |      @param index: size_t
 |      @param value: sel_t
 |  
 |  __swig_destroy__ = delete_sel_array(...)
 |      delete_sel_array(self)
 |  
 |  cast(self, *args) -> 'sel_t *'
 |      cast(self) -> sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'sel_array *'
 |      frompointer(t) -> sel_array
 |      
 |      @param t: sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function sel_array_frompointer in module ida_pro:

sel_array_frompointer(*args) -> 'sel_array *'
    sel_array_frompointer(t) -> sel_array
    
    @param t: sel_t *

Help on class sel_pointer in module ida_pro:

class sel_pointer(builtins.object)
 |  Proxy of C++ sel_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sel_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sel_pointer(...)
 |      delete_sel_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |      
 |      @param value: sel_t
 |  
 |  cast(self, *args) -> 'sel_t *'
 |      cast(self) -> sel_t *
 |  
 |  value(self, *args) -> 'sel_t'
 |      value(self) -> sel_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'sel_pointer *'
 |      frompointer(t) -> sel_pointer
 |      
 |      @param t: sel_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function sel_pointer_frompointer in module ida_pro:

sel_pointer_frompointer(*args) -> 'sel_pointer *'
    sel_pointer_frompointer(t) -> sel_pointer
    
    @param t: sel_t *

Help on class sizevec_t in module ida_pro:

class sizevec_t(builtins.object)
 |  Proxy of C++ qvector< size_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< size_t > const &
 |  
 |  __getitem__(self, *args) -> 'size_t const &'
 |      __getitem__(self, i) -> size_t const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sizevec_t
 |      __init__(self, x) -> sizevec_t
 |      
 |      @param x: qvector< size_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< size_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: size_t const &
 |  
 |  __swig_destroy__ = delete_sizevec_t(...)
 |      delete_sizevec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: size_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: size_t const &
 |  
 |  at(self, *args) -> 'size_t const &'
 |      at(self, _idx) -> size_t const &
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< size_t >::const_iterator'
 |      begin(self) -> qvector< size_t >::iterator
 |      begin(self) -> qvector< size_t >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< size_t >::const_iterator'
 |      end(self) -> qvector< size_t >::iterator
 |      end(self) -> qvector< size_t >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< size_t >::iterator'
 |      erase(self, it) -> qvector< size_t >::iterator
 |      
 |      @param it: qvector< size_t >::iterator
 |      
 |      erase(self, first, last) -> qvector< size_t >::iterator
 |      
 |      @param first: qvector< size_t >::iterator
 |      @param last: qvector< size_t >::iterator
 |  
 |  extract(self, *args) -> 'size_t *'
 |      extract(self) -> size_t *
 |  
 |  find(self, *args) -> 'qvector< size_t >::const_iterator'
 |      find(self, x) -> qvector< size_t >::iterator
 |      
 |      @param x: size_t const &
 |      
 |      find(self, x) -> qvector< size_t >::const_iterator
 |      
 |      @param x: size_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=size_t())
 |      
 |      @param x: size_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: size_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: size_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< size_t >::iterator'
 |      insert(self, it, x) -> qvector< size_t >::iterator
 |      
 |      @param it: qvector< size_t >::iterator
 |      @param x: size_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'size_t &'
 |      push_back(self, x)
 |      
 |      @param x: size_t const &
 |      
 |      push_back(self) -> size_t &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: size_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< size_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function str2user in module ida_pro:

str2user(*args) -> 'PyObject *'
    str2user(str) -> str or None
    Insert C-style escape characters to string
    
    @param str: char const *
    @return: new string with escape characters inserted

Help on class strvec_t in module ida_pro:

class strvec_t(builtins.object)
 |  Proxy of C++ qvector< simpleline_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'simpleline_t const &'
 |      __getitem__(self, i) -> simpleline_t const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strvec_t
 |      __init__(self, x) -> strvec_t
 |      
 |      @param x: qvector< simpleline_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: simpleline_t const &
 |  
 |  __swig_destroy__ = delete_strvec_t(...)
 |      delete_strvec_t(self)
 |  
 |  append = push_back(self, *args) -> 'simpleline_t &'
 |  
 |  at = __getitem__(self, *args) -> 'simpleline_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< simpleline_t >::const_iterator'
 |      begin(self) -> qvector< simpleline_t >::iterator
 |      begin(self) -> qvector< simpleline_t >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< simpleline_t >::const_iterator'
 |      end(self) -> qvector< simpleline_t >::iterator
 |      end(self) -> qvector< simpleline_t >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< simpleline_t >::iterator'
 |      erase(self, it) -> qvector< simpleline_t >::iterator
 |      
 |      @param it: qvector< simpleline_t >::iterator
 |      
 |      erase(self, first, last) -> qvector< simpleline_t >::iterator
 |      
 |      @param first: qvector< simpleline_t >::iterator
 |      @param last: qvector< simpleline_t >::iterator
 |  
 |  extract(self, *args) -> 'simpleline_t *'
 |      extract(self) -> simpleline_t *
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=simpleline_t())
 |      
 |      @param x: simpleline_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: simpleline_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< simpleline_t >::iterator'
 |      insert(self, it, x) -> qvector< simpleline_t >::iterator
 |      
 |      @param it: qvector< simpleline_t >::iterator
 |      @param x: simpleline_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'simpleline_t &'
 |      push_back(self, x)
 |      
 |      @param x: simpleline_t const &
 |      
 |      push_back(self) -> simpleline_t &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: simpleline_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< simpleline_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class sval_pointer in module ida_pro:

class sval_pointer(builtins.object)
 |  Proxy of C++ sval_pointer class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sval_pointer
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sval_pointer(...)
 |      delete_sval_pointer(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, value)
 |      
 |      @param value: sval_t
 |  
 |  cast(self, *args) -> 'sval_t *'
 |      cast(self) -> sval_t *
 |  
 |  value(self, *args) -> 'sval_t'
 |      value(self) -> sval_t
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'sval_pointer *'
 |      frompointer(t) -> sval_pointer
 |      
 |      @param t: sval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function sval_pointer_frompointer in module ida_pro:

sval_pointer_frompointer(*args) -> 'sval_pointer *'
    sval_pointer_frompointer(t) -> sval_pointer
    
    @param t: sval_t *

Help on class tid_array in module ida_pro:

class tid_array(builtins.object)
 |  Proxy of C++ tid_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'tid_t'
 |      __getitem__(self, index) -> tid_t
 |      
 |      @param index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> tid_array
 |      
 |      @param nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |      
 |      @param index: size_t
 |      @param value: tid_t
 |  
 |  __swig_destroy__ = delete_tid_array(...)
 |      delete_tid_array(self)
 |  
 |  cast(self, *args) -> 'tid_t *'
 |      cast(self) -> tid_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'tid_array *'
 |      frompointer(t) -> tid_array
 |      
 |      @param t: tid_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function tid_array_frompointer in module ida_pro:

tid_array_frompointer(*args) -> 'tid_array *'
    tid_array_frompointer(t) -> tid_array
    
    @param t: tid_t *

Help on class uchar_array in module ida_pro:

class uchar_array(builtins.object)
 |  Proxy of C++ uchar_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'uchar'
 |      __getitem__(self, index) -> uchar
 |      
 |      @param index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> uchar_array
 |      
 |      @param nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |      
 |      @param index: size_t
 |      @param value: uchar
 |  
 |  __swig_destroy__ = delete_uchar_array(...)
 |      delete_uchar_array(self)
 |  
 |  cast(self, *args) -> 'uchar *'
 |      cast(self) -> uchar *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'uchar_array *'
 |      frompointer(t) -> uchar_array
 |      
 |      @param t: uchar *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function uchar_array_frompointer in module ida_pro:

uchar_array_frompointer(*args) -> 'uchar_array *'
    uchar_array_frompointer(t) -> uchar_array
    
    @param t: uchar *

Help on class uint64vec_t in module ida_pro:

class uint64vec_t(builtins.object)
 |  Proxy of C++ qvector< unsigned long long > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< unsigned long long > const &
 |  
 |  __getitem__(self, *args) -> 'unsigned long long const &'
 |      __getitem__(self, i) -> unsigned long long const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uint64vec_t
 |      __init__(self, x) -> uint64vec_t
 |      
 |      @param x: qvector< unsigned long long > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< unsigned long long > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned long long const &
 |  
 |  __swig_destroy__ = delete_uint64vec_t(...)
 |      delete_uint64vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: unsigned long long const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: unsigned long long const &
 |  
 |  append = push_back(self, *args) -> 'unsigned long long &'
 |  
 |  at = __getitem__(self, *args) -> 'unsigned long long const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< unsigned long long >::const_iterator'
 |      begin(self) -> qvector< unsigned long long >::iterator
 |      begin(self) -> qvector< unsigned long long >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< unsigned long long >::const_iterator'
 |      end(self) -> qvector< unsigned long long >::iterator
 |      end(self) -> qvector< unsigned long long >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< unsigned long long >::iterator'
 |      erase(self, it) -> qvector< unsigned long long >::iterator
 |      
 |      @param it: qvector< unsigned long long >::iterator
 |      
 |      erase(self, first, last) -> qvector< unsigned long long >::iterator
 |      
 |      @param first: qvector< unsigned long long >::iterator
 |      @param last: qvector< unsigned long long >::iterator
 |  
 |  extract(self, *args) -> 'unsigned long long *'
 |      extract(self) -> unsigned long long *
 |  
 |  find(self, *args) -> 'qvector< unsigned long long >::const_iterator'
 |      find(self, x) -> qvector< unsigned long long >::iterator
 |      
 |      @param x: unsigned long long const &
 |      
 |      find(self, x) -> qvector< unsigned long long >::const_iterator
 |      
 |      @param x: unsigned long long const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: unsigned long long const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: unsigned long long *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< unsigned long long >::iterator'
 |      insert(self, it, x) -> qvector< unsigned long long >::iterator
 |      
 |      @param it: qvector< unsigned long long >::iterator
 |      @param x: unsigned long long const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'unsigned long long &'
 |      push_back(self, x)
 |      
 |      @param x: unsigned long long const &
 |      
 |      push_back(self) -> unsigned long long &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: unsigned long long const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< unsigned long long > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class uintvec_t in module ida_pro:

class uintvec_t(builtins.object)
 |  Proxy of C++ qvector< unsigned int > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< unsigned int > const &
 |  
 |  __getitem__(self, *args) -> 'unsigned int const &'
 |      __getitem__(self, i) -> unsigned int const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> uintvec_t
 |      __init__(self, x) -> uintvec_t
 |      
 |      @param x: qvector< unsigned int > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< unsigned int > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned int const &
 |  
 |  __swig_destroy__ = delete_uintvec_t(...)
 |      delete_uintvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: unsigned int const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: unsigned int const &
 |  
 |  append = push_back(self, *args) -> 'unsigned int &'
 |  
 |  at = __getitem__(self, *args) -> 'unsigned int const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< unsigned int >::const_iterator'
 |      begin(self) -> qvector< unsigned int >::iterator
 |      begin(self) -> qvector< unsigned int >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< unsigned int >::const_iterator'
 |      end(self) -> qvector< unsigned int >::iterator
 |      end(self) -> qvector< unsigned int >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< unsigned int >::iterator'
 |      erase(self, it) -> qvector< unsigned int >::iterator
 |      
 |      @param it: qvector< unsigned int >::iterator
 |      
 |      erase(self, first, last) -> qvector< unsigned int >::iterator
 |      
 |      @param first: qvector< unsigned int >::iterator
 |      @param last: qvector< unsigned int >::iterator
 |  
 |  extract(self, *args) -> 'unsigned int *'
 |      extract(self) -> unsigned int *
 |  
 |  find(self, *args) -> 'qvector< unsigned int >::const_iterator'
 |      find(self, x) -> qvector< unsigned int >::iterator
 |      
 |      @param x: unsigned int const &
 |      
 |      find(self, x) -> qvector< unsigned int >::const_iterator
 |      
 |      @param x: unsigned int const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: unsigned int const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: unsigned int *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< unsigned int >::iterator'
 |      insert(self, it, x) -> qvector< unsigned int >::iterator
 |      
 |      @param it: qvector< unsigned int >::iterator
 |      @param x: unsigned int const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'unsigned int &'
 |      push_back(self, x)
 |      
 |      @param x: unsigned int const &
 |      
 |      push_back(self) -> unsigned int &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: unsigned int const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< unsigned int > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class uval_array in module ida_pro:

class uval_array(builtins.object)
 |  Proxy of C++ uval_array class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'uval_t'
 |      __getitem__(self, index) -> uval_t
 |      
 |      @param index: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, nelements) -> uval_array
 |      
 |      @param nelements: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, index, value)
 |      
 |      @param index: size_t
 |      @param value: uval_t
 |  
 |  __swig_destroy__ = delete_uval_array(...)
 |      delete_uval_array(self)
 |  
 |  cast(self, *args) -> 'uval_t *'
 |      cast(self) -> uval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  frompointer(*args) -> 'uval_array *'
 |      frompointer(t) -> uval_array
 |      
 |      @param t: uval_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function uval_array_frompointer in module ida_pro:

uval_array_frompointer(*args) -> 'uval_array *'
    uval_array_frompointer(t) -> uval_array
    
    @param t: uval_t *

Help on function writebytes in module ida_pro:

writebytes(*args) -> 'int'
    writebytes(h, l, size, mf) -> int
    Write at most 4 bytes to file.
    
    @param h: (C++: int) file handle
    @param l: (C++: uint32) value to write
    @param size: (C++: int) size of value in bytes (1,2,4)
    @param mf: (C++: bool) is MSB first?
    @return: 0 on success, nonzero otherwise

Module "ida_problems"s docstring:
"""
Functions that deal with the list of problems.

There are several problem lists. An address may be inserted to any list. The
kernel simply maintains these lists, no additional processing is done.

The problem lists are accessible for the user from the View->Subviews->Problems
menu item.

Addresses in the lists are kept sorted. In general IDA just maintains these
lists without using them during analysis (except PR_ROLLED)."""

Help on function forget_problem in module ida_problems:

forget_problem(*args) -> 'bool'
    forget_problem(type, ea) -> bool
    Remove an address from a problem list
    
    @param type: (C++: problist_id_t) problem list type
    @param ea: (C++: ea_t) linear address
    @return: success

Help on function get_problem in module ida_problems:

get_problem(*args) -> 'ea_t'
    get_problem(type, lowea) -> ea_t
    Get an address from the specified problem list. The address is not removed from
    the list.
    
    @param type: (C++: problist_id_t) problem list type
    @param lowea: (C++: ea_t) the returned address will be higher or equal than the specified
                  address
    @return: linear address or BADADDR

Help on function get_problem_desc in module ida_problems:

get_problem_desc(*args) -> 'qstring *'
    get_problem_desc(t, ea) -> str
    Get the human-friendly description of the problem, if one was provided to
    remember_problem.
    
    @param t: (C++: problist_id_t) problem list type.
    @param ea: (C++: ea_t) linear address.
    @return: the message length or -1 if none

Help on function get_problem_name in module ida_problems:

get_problem_name(*args) -> 'char const *'
    get_problem_name(type, longname=True) -> char const *
    Get problem list description.
    
    @param type: (C++: problist_id_t)
    @param longname: (C++: bool)

Help on function is_problem_present in module ida_problems:

is_problem_present(*args) -> 'bool'
    is_problem_present(t, ea) -> bool
    Check if the specified address is present in the problem list.
    
    @param t: (C++: problist_id_t)
    @param ea: (C++: ea_t)

Help on function remember_problem in module ida_problems:

remember_problem(*args) -> 'void'
    remember_problem(type, ea, msg=None)
    Insert an address to a list of problems. Display a message saying about the
    problem (except of PR_ATTN,PR_FINAL) PR_JUMP is temporarily ignored.
    
    @param type: (C++: problist_id_t) problem list type
    @param ea: (C++: ea_t) linear address
    @param msg: (C++: const char *) a user-friendly message to be displayed instead of the default more
                generic one associated with the type of problem. Defaults to
                nullptr.

Help on function was_ida_decision in module ida_problems:

was_ida_decision(*args) -> 'bool'
    was_ida_decision(ea) -> bool
    
    @param ea: ea_t

Module "ida_range"s docstring:
"""
Contains the definition of range_t.

A range is a non-empty continuous range of addresses (specified by its start and
end addresses, the end address is excluded from the range).

Ranges are stored in the Btree part of the IDA database. To learn more about
Btrees (Balanced Trees): \link{http://www.bluerwhite.org/btree/}"""

Help on class array_of_rangesets in module ida_range:

class array_of_rangesets(builtins.object)
 |  Proxy of C++ qvector< rangeset_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< rangeset_t > const &
 |  
 |  __getitem__(self, *args) -> 'rangeset_t const &'
 |      __getitem__(self, i) -> rangeset_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> array_of_rangesets
 |      __init__(self, x) -> array_of_rangesets
 |      
 |      @param x: qvector< rangeset_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< rangeset_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: rangeset_t const &
 |  
 |  __swig_destroy__ = delete_array_of_rangesets(...)
 |      delete_array_of_rangesets(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: rangeset_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: rangeset_t const &
 |  
 |  at(self, *args) -> 'rangeset_t const &'
 |      at(self, _idx) -> rangeset_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< rangeset_t >::const_iterator'
 |      begin(self) -> rangeset_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< rangeset_t >::const_iterator'
 |      end(self) -> rangeset_t
 |  
 |  erase(self, *args) -> 'qvector< rangeset_t >::iterator'
 |      erase(self, it) -> rangeset_t
 |      
 |      @param it: qvector< rangeset_t >::iterator
 |      
 |      erase(self, first, last) -> rangeset_t
 |      
 |      @param first: qvector< rangeset_t >::iterator
 |      @param last: qvector< rangeset_t >::iterator
 |  
 |  extract(self, *args) -> 'rangeset_t *'
 |      extract(self) -> rangeset_t
 |  
 |  find(self, *args) -> 'qvector< rangeset_t >::const_iterator'
 |      find(self, x) -> rangeset_t
 |      
 |      @param x: rangeset_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=rangeset_t())
 |      
 |      @param x: rangeset_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: rangeset_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: rangeset_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< rangeset_t >::iterator'
 |      insert(self, it, x) -> rangeset_t
 |      
 |      @param it: qvector< rangeset_t >::iterator
 |      @param x: rangeset_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'rangeset_t &'
 |      push_back(self, x)
 |      
 |      @param x: rangeset_t const &
 |      
 |      push_back(self) -> rangeset_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: rangeset_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< rangeset_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class range_t in module ida_range:

class range_t(builtins.object)
 |  Proxy of C++ range_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> range_t
 |      __init__(self, ea1, ea2) -> range_t
 |      
 |      @param ea1: ea_t
 |      @param ea2: ea_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_range_t(...)
 |      delete_range_t(self)
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function range_t_print in module ida_range:

range_t_print(*args) -> 'size_t'
    range_t_print(cb) -> str
    Helper function. Should not be called directly!
    
    @param cb: range_t const *

Help on class rangeset_t in module ida_range:

class rangeset_t(builtins.object)
 |  Proxy of C++ rangeset_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, aset) -> bool
 |      
 |      @param aset: rangeset_t const &
 |  
 |  __getitem__(self, idx)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangeset_t
 |      __init__(self, range) -> rangeset_t
 |      
 |      @param range: range_t const &
 |      
 |      __init__(self, ivs) -> rangeset_t
 |      
 |      @param ivs: rangeset_t const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = nranges(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, aset) -> bool
 |      
 |      @param aset: rangeset_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rangeset_t(...)
 |      delete_rangeset_t(self)
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  add(self, *args) -> 'bool'
 |      add(self, range) -> bool
 |      Add each element of 'aset' to the set.
 |      
 |      @param range: range_t const &
 |      
 |      @return: false if no elements were added (the set was unchanged)
 |      add(self, start, _end) -> bool
 |      
 |      @param start: ea_t
 |      @param _end: ea_t
 |      
 |      add(self, aset) -> bool
 |      
 |      @param aset: rangeset_t const &
 |  
 |  begin(self, *args) -> 'rangeset_t::iterator'
 |      begin(self) -> range_t
 |      Get an iterator that points to the first element in the set.
 |  
 |  cached_range(self, *args) -> 'range_t const *'
 |      cached_range(self) -> range_t
 |      When searching the rangeset, we keep a cached element to help speed up searches.
 |      
 |      @return: a pointer to the cached element
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Delete all elements from the set. See qvector::clear()
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every element in 'aset' contained in an element of this rangeset?. See
 |      range_t::contains(range_t)
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, aset) -> bool
 |      
 |      @param aset: rangeset_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Does the set have zero elements.
 |  
 |  end(self, *args) -> 'rangeset_t::iterator'
 |      end(self) -> range_t
 |      Get an iterator that points to the end of the set. (This is NOT the last
 |      element)
 |  
 |  find_range(self, *args) -> 'range_t const *'
 |      find_range(self, ea) -> range_t
 |      Get the element from the set that contains 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |      @return: nullptr if there is no such element
 |  
 |  getrange(self, *args) -> 'range_t const &'
 |      getrange(self, idx) -> range_t
 |      Get the range_t at index 'idx'.
 |      
 |      @param idx: (C++: int)
 |  
 |  has_common(self, *args) -> 'bool'
 |      has_common(self, range) -> bool
 |      Does any element of 'aset' overlap with an element in this rangeset?. See
 |      range_t::overlaps()
 |      
 |      @param range: range_t const &
 |      
 |      has_common(self, aset) -> bool
 |      
 |      @param aset: rangeset_t const &
 |  
 |  includes(self, *args) -> 'bool'
 |      includes(self, range) -> bool
 |      Is every ea in 'range' contained in the rangeset?
 |      
 |      @param range: (C++: const range_t &) range_t const &
 |  
 |  intersect(self, *args) -> 'bool'
 |      intersect(self, aset) -> bool
 |      Set the rangeset to its intersection with 'aset'.
 |      
 |      @param aset: (C++: const rangeset_t &) rangeset_t const &
 |      @return: false if the set was unchanged
 |  
 |  is_equal(self, *args) -> 'bool'
 |      is_equal(self, aset) -> bool
 |      Do this rangeset and 'aset' have identical elements?
 |      
 |      @param aset: (C++: const rangeset_t &) rangeset_t const &
 |  
 |  is_subset_of(self, *args) -> 'bool'
 |      is_subset_of(self, aset) -> bool
 |      Is every element in the rangeset contained in an element of 'aset'?
 |      
 |      @param aset: (C++: const rangeset_t &) rangeset_t const &
 |  
 |  lastrange(self, *args) -> 'range_t const &'
 |      lastrange(self) -> range_t
 |      Get the last range_t in the set.
 |  
 |  next_addr(self, *args) -> 'ea_t'
 |      next_addr(self, ea) -> ea_t
 |      Get the smallest ea_t value greater than 'ea' contained in the rangeset.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  next_range(self, *args) -> 'ea_t'
 |      next_range(self, ea) -> ea_t
 |      Get the smallest ea_t value greater than 'ea' that is not in the same range as
 |      'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  nranges(self, *args) -> 'size_t'
 |      nranges(self) -> size_t
 |      Get the number of range_t elements in the set.
 |  
 |  prev_addr(self, *args) -> 'ea_t'
 |      prev_addr(self, ea) -> ea_t
 |      Get the largest ea_t value less than 'ea' contained in the rangeset.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  prev_range(self, *args) -> 'ea_t'
 |      prev_range(self, ea) -> ea_t
 |      Get the largest ea_t value less than 'ea' that is not in the same range as 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  sub(self, *args) -> 'bool'
 |      sub(self, range) -> bool
 |      Subtract each range in 'aset' from the set
 |      
 |      @param range: range_t const &
 |      
 |      @return: false if nothing was subtracted (the set was unchanged)
 |      sub(self, ea) -> bool
 |      
 |      @param ea: ea_t
 |      
 |      sub(self, aset) -> bool
 |      
 |      @param aset: rangeset_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Set this = 'r' and 'r' = this. See qvector::swap()
 |      
 |      @param r: (C++: rangeset_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class rangevec_base_t in module ida_range:

class rangevec_base_t(builtins.object)
 |  Proxy of C++ qvector< range_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangevec_base_t
 |      __init__(self, x) -> rangevec_base_t
 |      
 |      @param x: qvector< range_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  __swig_destroy__ = delete_rangevec_base_t(...)
 |      delete_rangevec_base_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: range_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      
 |      erase(self, first, last) -> range_t
 |      
 |      @param first: qvector< range_t >::iterator
 |      @param last: qvector< range_t >::iterator
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      
 |      @param x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |      
 |      @param x: range_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: range_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      @param x: range_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      
 |      @param x: range_t const &
 |      
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: range_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< range_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class rangevec_t in module ida_range:

class rangevec_t(rangevec_base_t)
 |  Proxy of C++ rangevec_t class.
 |  
 |  Method resolution order:
 |      rangevec_t
 |      rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rangevec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rangevec_t(...)
 |      delete_rangevec_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: range_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      
 |      erase(self, first, last) -> range_t
 |      
 |      @param first: qvector< range_t >::iterator
 |      @param last: qvector< range_t >::iterator
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      
 |      @param x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |      
 |      @param x: range_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: range_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      @param x: range_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      
 |      @param x: range_t const &
 |      
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: range_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< range_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from rangevec_base_t:
 |  
 |  __hash__ = None

Module "ida_registry"s docstring:
"""
Registry related functions.

IDA uses the registry to store global configuration options that must persist
after IDA has been closed.

On Windows, IDA uses the Windows registry directly. On Unix systems, the
registry is stored in a file (typically ~/.idapro/ida.reg).

The root key for accessing IDA settings in the registry is defined by
ROOT_KEY_NAME."""

Help on function reg_data_type in module ida_registry:

reg_data_type(*args) -> 'regval_type_t'
    reg_data_type(name, subkey=None) -> regval_type_t
    Get data type of a given value.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) key name
    @return: false if the [key+]value doesn't exist

Help on function reg_delete in module ida_registry:

reg_delete(*args) -> 'bool'
    reg_delete(name, subkey=None) -> bool
    Delete a value from the registry.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) parent key
    @return: success

Help on function reg_delete_subkey in module ida_registry:

reg_delete_subkey(*args) -> 'bool'
    reg_delete_subkey(name) -> bool
    Delete a key from the registry.
    
    @param name: (C++: const char *) char const *

Help on function reg_delete_tree in module ida_registry:

reg_delete_tree(*args) -> 'bool'
    reg_delete_tree(name) -> bool
    Delete a subtree from the registry.
    
    @param name: (C++: const char *) char const *

Help on function reg_exists in module ida_registry:

reg_exists(*args) -> 'bool'
    reg_exists(name, subkey=None) -> bool
    Is there already a value with the given name?
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) parent key

Help on function reg_flush in module ida_registry:

reg_flush(*args) -> 'void'
    reg_flush()

Help on function reg_load in module ida_registry:

reg_load(*args) -> 'void'
    reg_load()

Help on function reg_read_binary in module ida_registry:

reg_read_binary(*args) -> 'PyObject *'
    reg_read_binary(name, subkey=None) -> bytes or None
    Read binary data from the registry.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) key name
    @return: success

Help on function reg_read_bool in module ida_registry:

reg_read_bool(*args) -> 'bool'
    reg_read_bool(name, defval, subkey=None) -> bool
    Read boolean value from the registry.
    
    @param name: (C++: const char *) value name
    @param defval: (C++: bool) default value
    @param subkey: (C++: const char *) key name
    @return: boolean read from registry, or 'defval' if the read failed

Help on function reg_read_int in module ida_registry:

reg_read_int(*args) -> 'int'
    reg_read_int(name, defval, subkey=None) -> int
    Read integer value from the registry.
    
    @param name: (C++: const char *) value name
    @param defval: (C++: int) default value
    @param subkey: (C++: const char *) key name
    @return: the value read from the registry, or 'defval' if the read failed

Help on function reg_read_string in module ida_registry:

reg_read_string(*args) -> 'PyObject *'
    reg_read_string(name, subkey=None, _def=None) -> str
    Read a string from the registry.
    
    @param name: (C++: const char *) value name
    @param subkey: (C++: const char *) key name
    @param def: char const *
    @return: success

Help on function reg_read_strlist in module ida_registry:

reg_read_strlist(*args) -> 'qstrvec_t *'
    reg_read_strlist(subkey)
    Retrieve all string values associated with the given key. Also see
    reg_update_strlist().
    
    @param subkey: (C++: const char *) char const *

Help on function reg_subkey_exists in module ida_registry:

reg_subkey_exists(*args) -> 'bool'
    reg_subkey_exists(name) -> bool
    Is there already a key with the given name?
    
    @param name: (C++: const char *) char const *

Help on function reg_subkey_subkeys in module ida_registry:

reg_subkey_subkeys(*args) -> 'PyObject *'
    reg_subkey_subkeys(name) -> [str, ...]
    Get all subkey names of given key.
    
    @param name: (C++: const char *) char const *

Help on function reg_subkey_values in module ida_registry:

reg_subkey_values(*args) -> 'PyObject *'
    reg_subkey_values(name) -> [str, ...]
    Get all value names under given key.
    
    @param name: (C++: const char *) char const *

Help on function reg_update_filestrlist in module ida_registry:

reg_update_filestrlist(*args) -> 'void'
    reg_update_filestrlist(subkey, add, maxrecs, rem=None)
    Update registry with a file list. Case sensitivity will vary depending on the
    target OS.
    @note: 'add' and 'rem' must be UTF-8, just like for regular string operations.
    
    @param subkey: (C++: const char *) char const *
    @param add: (C++: const char *) char const *
    @param maxrecs: (C++: size_t)
    @param rem: (C++: const char *) char const *

Help on function reg_update_strlist in module ida_registry:

reg_update_strlist(*args) -> 'void'
    reg_update_strlist(subkey, add, maxrecs, rem=None, ignorecase=False)
    Update list of strings associated with given key.
    
    @param subkey: (C++: const char *) key name
    @param add: (C++: const char *) string to be added to list, can be nullptr
    @param maxrecs: (C++: size_t) limit list to this size
    @param rem: (C++: const char *) string to be removed from list, can be nullptr
    @param ignorecase: (C++: bool) ignore case for 'add' and 'rem'

Help on function reg_write_binary in module ida_registry:

reg_write_binary(*args) -> 'PyObject *'
    reg_write_binary(name, py_bytes, subkey=None) -> PyObject *
    Write binary data to the registry.
    
    @param name: (C++: const char *) value name
    @param py_bytes: PyObject *
    @param subkey: (C++: const char *) key name

Help on function reg_write_bool in module ida_registry:

reg_write_bool(*args) -> 'void'
    reg_write_bool(name, value, subkey=None)
    Write boolean value to the registry.
    
    @param name: (C++: const char *) value name
    @param value: (C++: int) boolean to write (nonzero = true)
    @param subkey: (C++: const char *) key name

Help on function reg_write_int in module ida_registry:

reg_write_int(*args) -> 'void'
    reg_write_int(name, value, subkey=None)
    Write integer value to the registry.
    
    @param name: (C++: const char *) value name
    @param value: (C++: int) value to write
    @param subkey: (C++: const char *) key name

Help on function reg_write_string in module ida_registry:

reg_write_string(*args) -> 'void'
    reg_write_string(name, utf8, subkey=None)
    Write a string to the registry.
    
    @param name: (C++: const char *) value name
    @param utf8: (C++: const char *) utf8-encoded string
    @param subkey: (C++: const char *) key name

Help on function set_registry_root in module ida_registry:

set_registry_root(*args) -> 'bool'
    set_registry_root(name) -> bool
    
    @param name: char const *

Module "ida_search"s docstring:
"""
Middle-level search functions.

They all are controlled by Search flags"""

Help on function find_binary in module ida_search:

find_binary(*args) -> 'ea_t'
    find_binary(arg1, arg2, arg3, arg4, arg5) -> ea_t
    Deprecated. Please use ida_bytes.bin_search() instead.
    
    @param arg1: ea_t
    @param arg2: ea_t
    @param arg3: char const *
    @param arg4: int
    @param arg5: int

Help on function find_code in module ida_search:

find_code(*args) -> 'ea_t'
    find_code(ea, sflag) -> ea_t
    Find next code address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_data in module ida_search:

find_data(*args) -> 'ea_t'
    find_data(ea, sflag) -> ea_t
    Find next data address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_defined in module ida_search:

find_defined(*args) -> 'ea_t'
    find_defined(ea, sflag) -> ea_t
    Find next ea that is the start of an instruction or data.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_error in module ida_search:

find_error(*args) -> 'int *'
    find_error(ea, sflag) -> ea_t
    Find next error or problem.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_imm in module ida_search:

find_imm(*args) -> 'int *'
    find_imm(ea, sflag, search_value) -> ea_t
    Find next immediate operand with the given value.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)
    @param search_value: (C++: uval_t)

Help on function find_not_func in module ida_search:

find_not_func(*args) -> 'ea_t'
    find_not_func(ea, sflag) -> ea_t
    Find next code address that does not belong to a function.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_notype in module ida_search:

find_notype(*args) -> 'int *'
    find_notype(ea, sflag) -> ea_t
    Find next operand without any type info.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_reg_access in module ida_search:

find_reg_access(*args) -> 'ea_t'
    find_reg_access(out, start_ea, end_ea, regname, sflag) -> ea_t
    Find access to a register.
    
    @param out: (C++: struct reg_access_t *) pointer to the output buffer. must be non-null. upon success
                contains info about the found register. upon failed search for a
                read access out->range contains the info about the non-redefined
                parts of the register.
    @param start_ea: (C++: ea_t) starting address
    @param end_ea: (C++: ea_t) ending address. BADADDR means that the end limit is missing.
                   otherwise, if the search direction is SEARCH_UP, END_EA must be
                   lower than START_EA.
    @param regname: (C++: const char *) the register to search for.
    @param sflag: (C++: int) combination of Search flags bits.
    @note: This function does not care about the control flow and probes all
           instructions in the specified range, starting from START_EA. Only direct
           references to registers are detected. Function calls and system traps are
           ignored.
    @return: the found address. BADADDR if not found or error.

Help on function find_suspop in module ida_search:

find_suspop(*args) -> 'int *'
    find_suspop(ea, sflag) -> ea_t
    Find next suspicious operand.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_text in module ida_search:

find_text(*args) -> 'ea_t'
    find_text(start_ea, y, x, ustr, sflag) -> ea_t
    See search()
    
    @param start_ea: (C++: ea_t)
    @param y: (C++: int)
    @param x: (C++: int)
    @param ustr: (C++: const char *) char const *
    @param sflag: (C++: int)

Help on function find_unknown in module ida_search:

find_unknown(*args) -> 'ea_t'
    find_unknown(ea, sflag) -> ea_t
    Find next unexplored address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function search_down in module ida_search:

search_down(*args) -> 'bool'
    search_down(sflag) -> bool
    Is the SEARCH_DOWN bit set?
    
    @param sflag: (C++: int)

Module "ida_segment"s docstring:
"""
Functions that deal with segments.

IDA requires that all program addresses belong to segments (each address must
belong to exactly one segment). The situation when an address doesn't belong to
any segment is allowed as a temporary situation only when the user changes
program segmentation. Bytes outside a segment can't be converted to
instructions, have names, comments, etc. Each segment has its start address,
ending address and represents a contiguous range of addresses. There might be
unused holes between segments.

Each segment has its unique segment selector. This selector is used to
distinguish the segment from other segments. For 16-bit programs the selector is
equal to the segment base paragraph. For 32-bit programs there is special array
to translate the selectors to the segment base paragraphs. A selector is a 32/64
bit value.

The segment base paragraph determines the offsets in the segment. If the start
address of the segment == (base << 4) then the first offset in the segment will
be 0. The start address should be higher or equal to (base << 4). We will call
the offsets in the segment 'virtual addresses'. So, the virtual address of the
first byte of the segment is

(start address of segment - segment base linear address)

For IBM PC, the virtual address corresponds to the offset part of the address.
For other processors (Z80, for example), virtual addresses correspond to Z80
addresses and linear addresses are used only internally. For MS Windows programs
the segment base paragraph is 0 and therefore the segment virtual addresses are
equal to linear addresses."""

Help on function add_segm in module ida_segment:

add_segm(*args) -> 'bool'
    add_segm(para, start, end, name, sclass, flags=0) -> bool
    Add a new segment, second form. Segment alignment is set to saRelByte. Segment
    combination is "public" or "stack" (if segment class is "STACK"). Addressing
    mode of segment is taken as default (16bit or 32bit). Default segment registers
    are set to BADSEL. If a segment already exists at the specified range of
    addresses, this segment will be truncated. Instructions and data in the old
    segment will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    @param para: (C++: ea_t) segment base paragraph. if paragraph can't fit in 16bit, then a new
                 selector is allocated and mapped to the paragraph.
    @param start: (C++: ea_t) start address of the segment. if start==BADADDR then start <-
                  to_ea(para,0).
    @param end: (C++: ea_t) end address of the segment. end address should be higher than start
                address. For emulate empty segments, use SEG_NULL segment type. If
                the end address is lower than start address, then fail. If
                end==BADADDR, then a segment up to the next segment will be created
                (if the next segment doesn't exist, then 1 byte segment will be
                created). If 'end' is too high and the new segment would overlap the
                next segment, 'end' is adjusted properly.
    @param name: (C++: const char *) name of new segment. may be nullptr
    @param sclass: (C++: const char *) class of the segment. may be nullptr. type of the new segment is
                   modified if class is one of predefined names:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "CONST" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * "XTRN" -> SEG_XTRN
    * "COMM" -> SEG_COMM
    * "ABS" -> SEG_ABSSYM
    @param flags: (C++: int) Add segment flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

Help on function add_segm_ex in module ida_segment:

add_segm_ex(*args) -> 'bool'
    add_segm_ex(NONNULL_s, name, sclass, flags) -> bool
    Add a new segment. If a segment already exists at the specified range of
    addresses, this segment will be truncated. Instructions and data in the old
    segment will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    @param NONNULL_s: (C++: segment_t *)
    @param name: (C++: const char *) name of new segment. may be nullptr. if specified, the segment is
                 immediately renamed
    @param sclass: (C++: const char *) class of the segment. may be nullptr. if specified, the segment
                   class is immediately changed
    @param flags: (C++: int) Add segment flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

Help on function add_segment_translation in module ida_segment:

add_segment_translation(*args) -> 'bool'
    add_segment_translation(segstart, mappedseg) -> bool
    Add segment translation.
    
    @param segstart: (C++: ea_t) start address of the segment to add translation to
    @param mappedseg: (C++: ea_t) start address of the overlayed segment
    @retval 1: ok
    @retval 0: too many translations or bad segstart

Help on function allocate_selector in module ida_segment:

allocate_selector(*args) -> 'sel_t'
    allocate_selector(segbase) -> sel_t
    Allocate a selector for a segment unconditionally. You must call this function
    before calling add_segm_ex(). add_segm() calls this function itself, so you
    don't need to allocate a selector. This function will allocate a new free
    selector and setup its mapping using find_free_selector() and set_selector()
    functions.
    
    @param segbase: (C++: ea_t) a new segment base paragraph
    @return: the allocated selector number

Help on function change_segment_status in module ida_segment:

change_segment_status(*args) -> 'int'
    change_segment_status(s, is_deb_segm) -> int
    Convert a debugger segment to a regular segment and vice versa. When converting
    debug->regular, the memory contents will be copied to the database.
    
    @param s: (C++: segment_t *) segment to modify
    @param is_deb_segm: (C++: bool) new status of the segment
    @return: Change segment status result codes

Help on function del_segm in module ida_segment:

del_segm(*args) -> 'bool'
    del_segm(ea, flags) -> bool
    Delete a segment.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, no segment at 'ea'.

Help on function del_segment_translations in module ida_segment:

del_segment_translations(*args) -> 'void'
    del_segment_translations(segstart)
    Delete the translation list
    
    @param segstart: (C++: ea_t) start address of the segment to delete translation list

Help on function del_selector in module ida_segment:

del_selector(*args) -> 'void'
    del_selector(selector)
    Delete mapping of a selector. Be wary of deleting selectors that are being used
    in the program, this can make a mess in the segments.
    
    @param selector: (C++: sel_t) number of selector to remove from the translation table

Help on function find_free_selector in module ida_segment:

find_free_selector(*args) -> 'sel_t'
    find_free_selector() -> sel_t
    Find first unused selector.
    
    @return: a number >= 1

Help on function find_selector in module ida_segment:

find_selector(*args) -> 'sel_t'
    find_selector(base) -> sel_t
    Find a selector that has mapping to the specified paragraph.
    
    @param base: (C++: ea_t) paragraph to search in the translation table
    @return: selector value or base

Help on function get_defsr in module ida_segment:

get_defsr(*args) -> 'sel_t'
    get_defsr(s, reg) -> sel_t
    Deprecated, use instead:
        value = s.defsr[reg]
    
    @param s: segment_t *
    @param reg: int

Help on function get_first_seg in module ida_segment:

get_first_seg(*args) -> 'segment_t *'
    get_first_seg() -> segment_t
    Get pointer to the first segment.

Help on function get_group_selector in module ida_segment:

get_group_selector(*args) -> 'sel_t'
    get_group_selector(grpsel) -> sel_t
    Get common selector for a group of segments.
    
    @param grpsel: (C++: sel_t) selector of group segment
    @return: common selector of the group or 'grpsel' if no such group is found

Help on function get_last_seg in module ida_segment:

get_last_seg(*args) -> 'segment_t *'
    get_last_seg() -> segment_t
    Get pointer to the last segment.

Help on function get_next_seg in module ida_segment:

get_next_seg(*args) -> 'segment_t *'
    get_next_seg(ea) -> segment_t
    Get pointer to the next segment.
    
    @param ea: (C++: ea_t)

Help on function get_prev_seg in module ida_segment:

get_prev_seg(*args) -> 'segment_t *'
    get_prev_seg(ea) -> segment_t
    Get pointer to the previous segment.
    
    @param ea: (C++: ea_t)

Help on function get_segm_base in module ida_segment:

get_segm_base(*args) -> 'ea_t'
    get_segm_base(s) -> ea_t
    Get segment base linear address. Segment base linear address is used to
    calculate virtual addresses. The virtual address of the first byte of the
    segment will be (start address of segment - segment base linear address)
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: 0 if s == nullptr, otherwise segment base linear address

Help on function get_segm_by_name in module ida_segment:

get_segm_by_name(*args) -> 'segment_t *'
    get_segm_by_name(name) -> segment_t
    Get pointer to segment by its name. If there are several segments with the same
    name, returns the first of them.
    
    @param name: (C++: const char *) segment name. may be nullptr.
    @return: nullptr or pointer to segment structure

Help on function get_segm_by_sel in module ida_segment:

get_segm_by_sel(*args) -> 'segment_t *'
    get_segm_by_sel(selector) -> segment_t
    Get pointer to segment structure. This function finds a segment by its selector.
    If there are several segments with the same selectors, the last one will be
    returned.
    
    @param selector: (C++: sel_t) a segment with the specified selector will be returned
    @return: pointer to segment or nullptr

Help on function get_segm_class in module ida_segment:

get_segm_class(*args) -> 'qstring *'
    get_segm_class(s) -> str
    Get segment class. Segment class is arbitrary text (max 8 characters).
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: size of segment class (-1 if s==nullptr or bufsize<=0)

Help on function get_segm_name in module ida_segment:

get_segm_name(*args) -> 'qstring *'
    get_segm_name(s, flags=0) -> str
    Get true segment name by pointer to segment.
    
    @param s: (C++: const segment_t *) pointer to segment
    @param flags: (C++: int) 0-return name as is; 1-substitute bad symbols with _ 1 corresponds
                  to GN_VISIBLE
    @return: size of segment name (-1 if s==nullptr)

Help on function get_segm_num in module ida_segment:

get_segm_num(*args) -> 'int'
    get_segm_num(ea) -> int
    Get number of segment by address.
    
    @param ea: (C++: ea_t) linear address belonging to the segment
    @return: -1 if no segment occupies the specified address. otherwise returns
             number of the specified segment (0..get_segm_qty()-1)

Help on function get_segm_para in module ida_segment:

get_segm_para(*args) -> 'ea_t'
    get_segm_para(s) -> ea_t
    Get segment base paragraph. Segment base paragraph may be converted to segment
    base linear address using to_ea() function. In fact, to_ea(get_segm_para(s), 0)
    == get_segm_base(s).
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: 0 if s == nullptr, the segment base paragraph

Help on function get_segm_qty in module ida_segment:

get_segm_qty(*args) -> 'int'
    get_segm_qty() -> int
    Get number of segments.

Help on function get_segment_alignment in module ida_segment:

get_segment_alignment(*args) -> 'char const *'
    get_segment_alignment(align) -> char const *
    Get text representation of segment alignment code.
    
    @param align: (C++: uchar)
    @return: text digestable by IBM PC assembler.

Help on function get_segment_cmt in module ida_segment:

get_segment_cmt(*args) -> 'qstring *'
    get_segment_cmt(s, repeatable) -> str
    Get segment comment.
    
    @param s: (C++: const segment_t *) pointer to segment structure
    @param repeatable: (C++: bool) 0: get regular comment. 1: get repeatable comment.
    @return: size of comment or -1

Help on function get_segment_combination in module ida_segment:

get_segment_combination(*args) -> 'char const *'
    get_segment_combination(comb) -> char const *
    Get text representation of segment combination code.
    
    @param comb: (C++: uchar)
    @return: text digestable by IBM PC assembler.

Help on function get_segment_translations in module ida_segment:

get_segment_translations(*args) -> 'ssize_t'
    get_segment_translations(transmap, segstart) -> ssize_t
    Get segment translation list.
    
    @param transmap: (C++: eavec_t *) vector of segment start addresses for the translation list
    @param segstart: (C++: ea_t) start address of the segment to get information about
    @return: -1 if no translation list or bad segstart. otherwise returns size of
             translation list.

Help on function get_selector_qty in module ida_segment:

get_selector_qty(*args) -> 'size_t'
    get_selector_qty() -> size_t
    Get number of defined selectors.

Help on function get_visible_segm_name in module ida_segment:

get_visible_segm_name(*args) -> 'qstring *'
    get_visible_segm_name(s) -> str
    Get segment name by pointer to segment.
    
    @param s: (C++: const segment_t *) pointer to segment
    @return: size of segment name (-1 if s==nullptr)

Help on function getn_selector in module ida_segment:

getn_selector(*args) -> 'sel_t *, ea_t *'
    getn_selector(n) -> bool
    Get description of selector (0..get_selector_qty()-1)
    
    @param n: (C++: int)

Help on function getnseg in module ida_segment:

getnseg(*args) -> 'segment_t *'
    getnseg(n) -> segment_t
    Get pointer to segment by its number.
    @warning: Obsoleted because it can slow down the debugger (it has to refresh the
              whole memory segmentation to calculate the correct answer)
    
    @param n: (C++: int) segment number in the range (0..get_segm_qty()-1)
    @return: nullptr or pointer to segment structure

Help on function getseg in module ida_segment:

getseg(*args) -> 'segment_t *'
    getseg(ea) -> segment_t
    Get pointer to segment by linear address.
    
    @param ea: (C++: ea_t) linear address belonging to the segment
    @return: nullptr or pointer to segment structure

Help on function is_finally_visible_segm in module ida_segment:

is_finally_visible_segm(*args) -> 'bool'
    is_finally_visible_segm(s) -> bool
    See SFL_HIDDEN, SCF_SHHID_SEGM.
    
    @param s: (C++: segment_t *)

Help on function is_miniidb in module ida_segment:

is_miniidb(*args) -> 'bool'
    is_miniidb() -> bool
    Is the database a miniidb created by the debugger?.
    
    @return: true if the database contains no segments or only debugger segments

Help on function is_segm_locked in module ida_segment:

is_segm_locked(*args) -> 'bool'
    is_segm_locked(segm) -> bool
    Is a segment pointer locked?
    
    @param segm: (C++: const segment_t *) segment_t const *

Help on function is_spec_ea in module ida_segment:

is_spec_ea(*args) -> 'bool'
    is_spec_ea(ea) -> bool
    Does the address belong to a segment with a special type?. (SEG_XTRN, SEG_GRP,
    SEG_ABSSYM, SEG_COMM)
    
    @param ea: (C++: ea_t) linear address

Help on function is_spec_segm in module ida_segment:

is_spec_segm(*args) -> 'bool'
    is_spec_segm(seg_type) -> bool
    Has segment a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM)
    
    @param seg_type: (C++: uchar)

Help on function is_visible_segm in module ida_segment:

is_visible_segm(*args) -> 'bool'
    is_visible_segm(s) -> bool
    See SFL_HIDDEN.
    
    @param s: (C++: segment_t *)

Help on function lock_segm in module ida_segment:

lock_segm(*args) -> 'void'
    lock_segm(segm, lock)
    Lock segment pointer Locked pointers are guaranteed to remain valid until they
    are unlocked. Ranges with locked pointers cannot be deleted or moved.
    
    @param segm: (C++: const segment_t *) segment_t const *
    @param lock: (C++: bool)

Help on class lock_segment in module ida_segment:

class lock_segment(builtins.object)
 |  Proxy of C++ lock_segment class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _segm) -> lock_segment
 |      
 |      @param _segm: segment_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lock_segment(...)
 |      delete_lock_segment(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function move_segm in module ida_segment:

move_segm(*args) -> 'int'
    move_segm(s, to, flags=0) -> int
    Move a segment to a new address. This function moves all information to the new
    address. It fixes up address sensitive information in the kernel. The total
    effect is equal to reloading the segment to the target address. For the file
    format dependent address sensitive information, loader_t::move_segm is called.
    Also IDB notification event idb_event::segm_moved is called.
    
    @param s: (C++: segment_t *) segment to move
    @param to: (C++: ea_t) new segment start address
    @param flags: (C++: int) Move segment flags
    @return: Move segment result codes

Help on function move_segm_start in module ida_segment:

move_segm_start(*args) -> 'bool'
    move_segm_start(ea, newstart, mode) -> bool
    Move segment start. The main difference between this function and
    set_segm_start() is that this function may expand the previous segment while
    set_segm_start() never does it. So, this function allows to change bounds of two
    segments simultaneously. If the previous segment and the specified segment have
    the same addressing mode and segment base, then instructions and data are not
    destroyed - they simply move from one segment to another. Otherwise all
    instructions/data which migrate from one segment to another are destroyed.
    @note: this function never disables addresses.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param newstart: (C++: ea_t) new start address of the segment note that segment start
                     address should be higher than segment base linear address.
    @param mode: (C++: int) policy for destroying defined items
    * 0: if it is necessary to destroy defined items, display a dialog box and ask
    confirmation
    * 1: if it is necessary to destroy defined items, just destroy them without
    asking the user
    * -1: if it is necessary to destroy defined items, don't destroy them (i.e.
    function will fail)
    * -2: don't destroy defined items (function will succeed)
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

Help on function rebase_program in module ida_segment:

rebase_program(*args) -> 'int'
    rebase_program(delta, flags) -> int
    Rebase the whole program by 'delta' bytes.
    
    @param delta: (C++: adiff_t) number of bytes to move the program
    @param flags: (C++: int) Move segment flags it is recommended to use MSF_FIXONCE so that
                  the loader takes care of global variables it stored in the
                  database
    @return: Move segment result codes

Help on function segm_adjust_diff in module ida_segment:

segm_adjust_diff(*args) -> 'adiff_t'
    segm_adjust_diff(s, delta) -> adiff_t
    Truncate and sign extend a delta depending on the segment.
    
    @param s: (C++: const segment_t *) segment_t const *
    @param delta: (C++: adiff_t)

Help on function segm_adjust_ea in module ida_segment:

segm_adjust_ea(*args) -> 'ea_t'
    segm_adjust_ea(s, ea) -> ea_t
    Truncate an address depending on the segment.
    
    @param s: (C++: const segment_t *) segment_t const *
    @param ea: (C++: ea_t)

Help on class segment_defsr_array in module ida_segment:

class segment_defsr_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< sel_t,SREG_NUM > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'unsigned-ea-like-numeric-type const &'
 |      __getitem__(self, i) -> unsigned-ea-like-numeric-type const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> segment_defsr_array
 |      
 |      @param data: unsigned-ea-like-numeric-type (&)[SREG_NUM]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: unsigned-ea-like-numeric-type const &
 |  
 |  __swig_destroy__ = delete_segment_defsr_array(...)
 |      delete_segment_defsr_array(self)
 |  
 |  _get_bytes(self, *args) -> 'bytevec_t'
 |      _get_bytes(self) -> bytevec_t
 |  
 |  _set_bytes(self, *args) -> 'void'
 |      _set_bytes(self, bts)
 |      
 |      Parameters
 |      ----------
 |      bts: bytevec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      _get_bytes(self) -> bytevec_t
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class segment_t in module ida_segment:

class segment_t(ida_range.range_t)
 |  Proxy of C++ segment_t class.
 |  
 |  Method resolution order:
 |      segment_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> segment_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_segment_t(...)
 |      delete_segment_t(self)
 |  
 |  _segment_t__getDefsr = __getDefsr(self, *args) -> 'wrapped_array_t< sel_t,SREG_NUM >'
 |      __getDefsr(self) -> segment_defsr_array
 |  
 |  abits(self, *args) -> 'int'
 |      abits(self) -> int
 |      Get number of address bits.
 |  
 |  abytes(self, *args) -> 'int'
 |      abytes(self) -> int
 |      Get number of address bytes.
 |  
 |  clr_comorg(self, *args) -> 'void'
 |      clr_comorg(self)
 |  
 |  clr_ob_ok(self, *args) -> 'void'
 |      clr_ob_ok(self)
 |  
 |  comorg(self, *args) -> 'bool'
 |      comorg(self) -> bool
 |  
 |  is_16bit(self, *args) -> 'bool'
 |      is_16bit(self) -> bool
 |      Is a 16-bit segment?
 |  
 |  is_32bit(self, *args) -> 'bool'
 |      is_32bit(self) -> bool
 |      Is a 32-bit segment?
 |  
 |  is_64bit(self, *args) -> 'bool'
 |      is_64bit(self) -> bool
 |      Is a 64-bit segment?
 |  
 |  is_header_segm(self, *args) -> 'bool'
 |      is_header_segm(self) -> bool
 |  
 |  is_hidden_segtype(self, *args) -> 'bool'
 |      is_hidden_segtype(self) -> bool
 |  
 |  is_loader_segm(self, *args) -> 'bool'
 |      is_loader_segm(self) -> bool
 |  
 |  is_visible_segm(self, *args) -> 'bool'
 |      is_visible_segm(self) -> bool
 |  
 |  ob_ok(self, *args) -> 'bool'
 |      ob_ok(self) -> bool
 |  
 |  set_comorg(self, *args) -> 'void'
 |      set_comorg(self)
 |  
 |  set_debugger_segm(self, *args) -> 'void'
 |      set_debugger_segm(self, debseg)
 |      
 |      @param debseg: bool
 |  
 |  set_header_segm(self, *args) -> 'void'
 |      set_header_segm(self, on)
 |      
 |      @param on: bool
 |  
 |  set_hidden_segtype(self, *args) -> 'void'
 |      set_hidden_segtype(self, hide)
 |      
 |      @param hide: bool
 |  
 |  set_loader_segm(self, *args) -> 'void'
 |      set_loader_segm(self, ldrseg)
 |      
 |      @param ldrseg: bool
 |  
 |  set_ob_ok(self, *args) -> 'void'
 |      set_ob_ok(self)
 |  
 |  set_visible_segm(self, *args) -> 'void'
 |      set_visible_segm(self, visible)
 |      
 |      @param visible: bool
 |  
 |  update(self, *args) -> 'bool'
 |      update(self) -> bool
 |      Update segment information. You must call this function after modification of
 |      segment characteristics. Note that not all fields of segment structure may be
 |      modified directly, there are special functions to modify some fields.
 |      
 |      @return: success
 |  
 |  use64 = is_64bit(self, *args) -> 'bool'
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  align
 |      align
 |  
 |  bitness
 |      bitness
 |  
 |  color
 |      color
 |  
 |  comb
 |      comb
 |  
 |  defsr
 |      __getDefsr(self) -> segment_defsr_array
 |  
 |  end_ea
 |      end_ea
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  orgbase
 |      orgbase
 |  
 |  perm
 |      perm
 |  
 |  sclass
 |      sclass
 |  
 |  sel
 |      sel
 |  
 |  start_ea
 |      start_ea
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Help on function segtype in module ida_segment:

segtype(*args) -> 'uchar'
    segtype(ea) -> uchar
    Get segment type.
    
    @param ea: (C++: ea_t) any linear address within the segment
    @return: Segment types, SEG_UNDF if no segment found at 'ea'

Help on function sel2ea in module ida_segment:

sel2ea(*args) -> 'ea_t'
    sel2ea(selector) -> ea_t
    Get mapping of a selector as a linear address.
    
    @param selector: (C++: sel_t) number of selector to translate to linear address
    @return: linear address the specified selector is mapped to. if there is no
             mapping, returns to_ea(selector,0);

Help on function sel2para in module ida_segment:

sel2para(*args) -> 'ea_t'
    sel2para(selector) -> ea_t
    Get mapping of a selector.
    
    @param selector: (C++: sel_t) number of selector to translate
    @return: paragraph the specified selector is mapped to. if there is no mapping,
             returns 'selector'.

Help on function set_defsr in module ida_segment:

set_defsr(*args) -> 'void'
    set_defsr(s, reg, value)
    Deprecated, use instead:
        s.defsr[reg] = value
    
    @param s: segment_t *
    @param reg: int
    @param value: sel_t

Help on function set_group_selector in module ida_segment:

set_group_selector(*args) -> 'int'
    set_group_selector(grp, sel) -> int
    Create a new group of segments (used OMF files).
    
    @param grp: (C++: sel_t) selector of group segment (segment type is SEG_GRP) You should
                create an 'empty' (1 byte) group segment It won't contain anything
                and will be used to redirect references to the group of segments to
                the common selector.
    @param sel: (C++: sel_t) common selector of all segments belonging to the segment You should
                create all segments within the group with the same selector value.
    @return: 1 ok
    0 too many groups (see MAX_GROUPS)

Help on function set_segm_addressing in module ida_segment:

set_segm_addressing(*args) -> 'bool'
    set_segm_addressing(s, bitness) -> bool
    Change segment addressing mode (16, 32, 64 bits). You must use this function to
    change segment addressing, never change the 'bitness' field directly. This
    function will delete all instructions, comments and names in the segment
    
    @param s: (C++: segment_t *) pointer to segment
    @param bitness: (C++: size_t) new addressing mode of segment
    * 2: 64bit segment
    * 1: 32bit segment
    * 0: 16bit segment
    @return: success

Help on function set_segm_base in module ida_segment:

set_segm_base(*args) -> 'bool'
    set_segm_base(s, newbase) -> bool
    Internal function.
    
    @param s: (C++: segment_t *)
    @param newbase: (C++: ea_t)

Help on function set_segm_class in module ida_segment:

set_segm_class(*args) -> 'int'
    set_segm_class(s, sclass, flags=0) -> int
    Set segment class.
    
    @param s: (C++: segment_t *) pointer to segment (may be nullptr)
    @param sclass: (C++: const char *) segment class (may be nullptr). If segment type is SEG_NORM and
                   segment class is one of predefined names, then segment type is
                   changed to:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * if "UNK" then segment type is reset to SEG_NORM.
    @param flags: (C++: int) Add segment flags
    @retval 1: ok, name is good and segment is renamed
    @retval 0: failure, name is nullptr or bad or segment is nullptr

Help on function set_segm_end in module ida_segment:

set_segm_end(*args) -> 'bool'
    set_segm_end(ea, newend, flags) -> bool
    Set segment end address. The next segment is shrinked to allow expansion of the
    specified segment. The kernel might even delete the next segment if necessary.
    The kernel will ask the user for a permission to destroy instructions or data
    going out of segment scope if such instructions exist.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param newend: (C++: ea_t) new end address of the segment
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

Help on function set_segm_name in module ida_segment:

set_segm_name(*args) -> 'int'
    set_segm_name(s, name, flags=0) -> int
    Rename segment. The new name is validated (see validate_name). A segment always
    has a name. If you hadn't specified a name, the kernel will assign it "seg###"
    name where ### is segment number.
    
    @param s: (C++: segment_t *) pointer to segment (may be nullptr)
    @param name: (C++: const char *) new segment name
    @param flags: (C++: int) ADDSEG_IDBENC or 0
    @retval 1: ok, name is good and segment is renamed
    @retval 0: failure, name is bad or segment is nullptr

Help on function set_segm_start in module ida_segment:

set_segm_start(*args) -> 'bool'
    set_segm_start(ea, newstart, flags) -> bool
    Set segment start address. The previous segment is trimmed to allow expansion of
    the specified segment. The kernel might even delete the previous segment if
    necessary. The kernel will ask the user for a permission to destroy instructions
    or data going out of segment scope if such instructions exist.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param newstart: (C++: ea_t) new start address of the segment note that segment start
                     address should be higher than segment base linear address.
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, a warning message is displayed

Help on function set_segment_cmt in module ida_segment:

set_segment_cmt(*args) -> 'void'
    set_segment_cmt(s, cmt, repeatable)
    Set segment comment.
    
    @param s: (C++: const segment_t *) pointer to segment structure
    @param cmt: (C++: const char *) comment string, may be multiline (with '
    '). maximal size is 4096 bytes. Use empty str ("") to delete comment
    @param repeatable: (C++: bool) 0: set regular comment. 1: set repeatable comment.

Help on function set_segment_translations in module ida_segment:

set_segment_translations(*args) -> 'bool'
    set_segment_translations(segstart, transmap) -> bool
    Set new translation list.
    
    @param segstart: (C++: ea_t) start address of the segment to add translation to
    @param transmap: (C++: const eavec_t &) vector of segment start addresses for the translation list. If
                     transmap is empty, the translation list is deleted.
    @retval 1: ok
    @retval 0: too many translations or bad segstart

Help on function set_selector in module ida_segment:

set_selector(*args) -> 'int'
    set_selector(selector, paragraph) -> int
    Set mapping of selector to a paragraph. You should call this function _before_
    creating a segment which uses the selector, otherwise the creation of the
    segment will fail.
    
    @param selector: (C++: sel_t) number of selector to map
    * if selector == BADSEL, then return 0 (fail)
    * if the selector has had a mapping, old mapping is destroyed
    * if the selector number is equal to paragraph value, then the mapping is
    destroyed because we don't need to keep trivial mappings.
    @param paragraph: (C++: ea_t) paragraph to map selector
    @retval 1: ok
    @retval 0: failure (bad selector or too many mappings)

Help on function set_visible_segm in module ida_segment:

set_visible_segm(*args) -> 'void'
    set_visible_segm(s, visible)
    See SFL_HIDDEN.
    
    @param s: (C++: segment_t *)
    @param visible: (C++: bool)

Help on function setup_selector in module ida_segment:

setup_selector(*args) -> 'sel_t'
    setup_selector(segbase) -> sel_t
    Allocate a selector for a segment if necessary. You must call this function
    before calling add_segm_ex(). add_segm() calls this function itself, so you
    don't need to allocate a selector. This function will allocate a selector if
    'segbase' requires more than 16 bits and the current processor is IBM PC.
    Otherwise it will return the segbase value.
    
    @param segbase: (C++: ea_t) a new segment base paragraph
    @return: the allocated selector number

Help on function std_out_segm_footer in module ida_segment:

std_out_segm_footer(*args) -> 'void'
    std_out_segm_footer(ctx, seg)
    Generate segment footer line as a comment line. This function may be used in IDP
    modules to generate segment footer if the target assembler doesn't have 'ends'
    directive.
    
    @param ctx: (C++: struct outctx_t &) outctx_t &
    @param seg: (C++: segment_t *)

Help on function take_memory_snapshot in module ida_segment:

take_memory_snapshot(*args) -> 'bool'
    take_memory_snapshot(only_loader_segs) -> bool
    Take a memory snapshot of the running process.
    
    @param only_loader_segs: (C++: bool) only is_loader_segm() segments will be affected
    @return: success

Help on function update_segm in module ida_segment:

update_segm(*args) -> 'bool'
    update_segm(s) -> bool
    
    @param s: segment_t *

Module "ida_segregs"s docstring:
"""
Functions that deal with the segment registers.

If your processor doesn't use segment registers, then these functions are of no
use for you. However, you should define two virtual segment registers - CS and
DS (for code segment and data segment) and specify their internal numbers in the
LPH structure (processor_t::reg_code_sreg and processor_t::reg_data_sreg)."""

Help on function copy_sreg_ranges in module ida_segregs:

copy_sreg_ranges(*args) -> 'void'
    copy_sreg_ranges(dst_rg, src_rg, map_selector=False)
    Duplicate segment register ranges.
    
    @param dst_rg: (C++: int) number of destination segment register
    @param src_rg: (C++: int) copy ranges from
    @param map_selector: (C++: bool) map selectors to linear addresses using sel2ea()

Help on function del_sreg_range in module ida_segregs:

del_sreg_range(*args) -> 'bool'
    del_sreg_range(ea, rg) -> bool
    Delete segment register range started at ea. When a segment register range is
    deleted, the previous range is extended to cover the empty space. The segment
    register range at the beginning of a segment cannot be deleted.
    
    @param ea: (C++: ea_t) start_ea of the deleted range
    @param rg: (C++: int) the segment register number
    @return: success

Help on function get_prev_sreg_range in module ida_segregs:

get_prev_sreg_range(*args) -> 'bool'
    get_prev_sreg_range(out, ea, rg) -> bool
    Get segment register range previous to one with address.
    @note: more efficient then get_sreg_range(reg, ea-1)
    
    @param out: (C++: sreg_range_t *) segment register range
    @param ea: (C++: ea_t) any linear address in the program
    @param rg: (C++: int) the segment register number
    @return: success

Help on function get_sreg in module ida_segregs:

get_sreg(*args) -> 'sel_t'
    get_sreg(ea, rg) -> sel_t
    Get value of a segment register. This function uses segment register range and
    default segment register values stored in the segment structure.
    
    @param ea: (C++: ea_t) linear address in the program
    @param rg: (C++: int) number of the segment register
    @return: value of the segment register, BADSEL if value is unknown.

Help on function get_sreg_range in module ida_segregs:

get_sreg_range(*args) -> 'bool'
    get_sreg_range(out, ea, rg) -> bool
    Get segment register range by linear address.
    
    @param out: (C++: sreg_range_t *) segment register range
    @param ea: (C++: ea_t) any linear address in the program
    @param rg: (C++: int) the segment register number
    @return: success

Help on function get_sreg_range_num in module ida_segregs:

get_sreg_range_num(*args) -> 'int'
    get_sreg_range_num(ea, rg) -> int
    Get number of segment register range by address.
    
    @param ea: (C++: ea_t) any address in the range
    @param rg: (C++: int) the segment register number
    @return: -1 if no range occupies the specified address. otherwise returns number
             of the specified range (0..get_srranges_qty()-1)

Help on function get_sreg_ranges_qty in module ida_segregs:

get_sreg_ranges_qty(*args) -> 'size_t'
    get_sreg_ranges_qty(rg) -> size_t
    Get number of segment register ranges.
    
    @param rg: (C++: int) the segment register number

Help on function getn_sreg_range in module ida_segregs:

getn_sreg_range(*args) -> 'bool'
    getn_sreg_range(out, rg, n) -> bool
    Get segment register range by its number.
    
    @param out: (C++: sreg_range_t *) segment register range
    @param rg: (C++: int) the segment register number
    @param n: (C++: int) number of range (0..qty()-1)
    @return: success

Help on function set_default_dataseg in module ida_segregs:

set_default_dataseg(*args) -> 'void'
    set_default_dataseg(ds_sel)
    Set default value of DS register for all segments.
    
    @param ds_sel: (C++: sel_t)

Help on function set_default_sreg_value in module ida_segregs:

set_default_sreg_value(*args) -> 'bool'
    set_default_sreg_value(sg, rg, value) -> bool
    Set default value of a segment register for a segment.
    
    @param sg: (C++: segment_t *) pointer to segment structure if nullptr, then set the register for
               all segments
    @param rg: (C++: int) number of segment register
    @param value: (C++: sel_t) its default value. this value will be used by get_sreg() if value
                  of the register is unknown at the specified address.
    @return: success

Help on function set_sreg_at_next_code in module ida_segregs:

set_sreg_at_next_code(*args) -> 'void'
    set_sreg_at_next_code(ea1, ea2, rg, value)
    Set the segment register value at the next instruction. This function is
    designed to be called from idb_event::sgr_changed handler in order to contain
    the effect of changing a segment register value only until the next instruction.
    
    It is useful, for example, in the ARM module: the modification of the T register
    does not affect existing instructions later in the code.
    
    @param ea1: (C++: ea_t) address to start to search for an instruction
    @param ea2: (C++: ea_t) the maximal address
    @param rg: (C++: int) the segment register number
    @param value: (C++: sel_t) the segment register value

Help on function split_sreg_range in module ida_segregs:

split_sreg_range(*args) -> 'bool'
    split_sreg_range(ea, rg, v, tag, silent=False) -> bool
    Create a new segment register range. This function is used when the IDP emulator
    detects that a segment register changes its value.
    
    @param ea: (C++: ea_t) linear address where the segment register will have a new value. if
               ea==BADADDR, nothing to do.
    @param rg: (C++: int) the number of the segment register
    @param v: (C++: sel_t) the new value of the segment register. If the value is unknown, you
              should specify BADSEL.
    @param tag: (C++: uchar) the register info tag. see Segment register range tags
    @param silent: (C++: bool) if false, display a warning() in the case of failure
    @return: success

Help on class sreg_range_t in module ida_segregs:

class sreg_range_t(ida_range.range_t)
 |  Proxy of C++ sreg_range_t class.
 |  
 |  Method resolution order:
 |      sreg_range_t
 |      ida_range.range_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> sreg_range_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_sreg_range_t(...)
 |      delete_sreg_range_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  tag
 |      tag
 |  
 |  thisown
 |      The membership flag
 |  
 |  val
 |      val
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.range_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  _print(self, *args) -> 'size_t'
 |      _print(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Set start_ea, end_ea to 0.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      Compare two range_t instances, based on the start_ea.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  contains(self, *args) -> 'bool'
 |      contains(self, ea) -> bool
 |      Is every ea in 'r' also in this range_t?
 |      
 |      @param ea: ea_t
 |      
 |      contains(self, r) -> bool
 |      
 |      @param r: range_t const &
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Is the size of the range_t <= 0?
 |  
 |  extend(self, *args) -> 'void'
 |      extend(self, ea)
 |      Ensure that the range_t includes 'ea'.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  intersect(self, *args) -> 'void'
 |      intersect(self, r)
 |      Assign the range_t to the intersection between the range_t and 'r'.
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  overlaps(self, *args) -> 'bool'
 |      overlaps(self, r) -> bool
 |      Is there an ea in 'r' that is also in this range_t?
 |      
 |      @param r: (C++: const range_t &) range_t const &
 |  
 |  size(self, *args) -> 'asize_t'
 |      size(self) -> asize_t
 |      Get end_ea - start_ea.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.range_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  end_ea
 |      end_ea
 |  
 |  start_ea
 |      start_ea
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.range_t:
 |  
 |  __hash__ = None

Module "ida_srclang"s docstring:
"""
Third-party compiler support."""

Help on function parse_decls_for_srclang in module ida_srclang:

parse_decls_for_srclang(*args) -> 'int'
    parse_decls_for_srclang(lang, til, input, is_path) -> int
    Parse type declarations in the specified language
    
    @param lang: (C++: srclang_t) the source language(s) expected in the input
    @param til: (C++: til_t *) type library to store the types
    @param input: (C++: const char *) input source. can be a file path or decl string
    @param is_path: (C++: bool) true if input parameter is a path to a source file, false if the
                    input is an in-memory source snippet
    @retval -1: no parser was found that supports the given source language(s)
    @retval else: the number of errors encountered in the input source

Help on function parse_decls_with_parser in module ida_srclang:

parse_decls_with_parser(*args) -> 'int'
    parse_decls_with_parser(parser_name, til, input, is_path) -> int
    Parse type declarations using the parser with the specified name
    
    @param parser_name: (C++: const char *) name of the target parser
    @param til: (C++: til_t *) type library to store the types
    @param input: (C++: const char *) input source. can be a file path or decl string
    @param is_path: (C++: bool) true if input parameter is a path to a source file, false if the
                    input is an in-memory source snippet
    @retval -1: no parser was found with the given name
    @retval else: the number of errors encountered in the input source

Help on function select_parser_by_name in module ida_srclang:

select_parser_by_name(*args) -> 'bool'
    select_parser_by_name(name) -> bool
    Set the parser with the given name as the current parser. Pass nullptr or an
    empty string to select the default parser.
    
    @param name: (C++: const char *) char const *
    @return: false if no parser was found with the given name

Help on function select_parser_by_srclang in module ida_srclang:

select_parser_by_srclang(*args) -> 'bool'
    select_parser_by_srclang(lang) -> bool
    Set the parser that supports the given language(s) as the current parser. The
    selected parser must support all languages specified by the given srclang_t.
    
    @param lang: (C++: srclang_t)
    @return: false if no such parser was found

Help on function set_parser_argv in module ida_srclang:

set_parser_argv(*args) -> 'int'
    set_parser_argv(parser_name, argv) -> int
    Set the command-line args to use for invocations of the parser with the given
    name
    
    @param parser_name: (C++: const char *) name of the target parser
    @param argv: (C++: const char *) argument list
    @retval -1: no parser was found with the given name
    @retval -2: the operation is not supported by the given parser
    @retval 0: success

Module "ida_strlist"s docstring:
"""
Functions that deal with the string list.

While the kernel keeps the string list, it does not update it. The string list
is not used by the kernel because keeping it up-to-date would slow down IDA
without any benefit. If the string list is not cleared using clear_strlist(),
the list will be saved to the database and restored on the next startup.

The users of this list should call build_strlist() if they need an up-to-date
version."""

Help on function build_strlist in module ida_strlist:

build_strlist(*args) -> 'void'
    build_strlist()
    Rebuild the string list.

Help on function clear_strlist in module ida_strlist:

clear_strlist(*args) -> 'void'
    clear_strlist()
    Clear the string list.

Help on function get_strlist_item in module ida_strlist:

get_strlist_item(*args) -> 'bool'
    get_strlist_item(si, n) -> bool
    Get nth element of the string list (n=0..get_strlist_qty()-1)
    
    @param si: (C++: string_info_t *)
    @param n: (C++: size_t)

Help on function get_strlist_options in module ida_strlist:

get_strlist_options(*args) -> 'strwinsetup_t const *'
    get_strlist_options() -> strwinsetup_t
    Get the static string list options.

Help on function get_strlist_qty in module ida_strlist:

get_strlist_qty(*args) -> 'size_t'
    get_strlist_qty() -> size_t
    Get number of elements in the string list. The list will be loaded from the
    database (if saved) or built from scratch.

Help on class string_info_t in module ida_strlist:

class string_info_t(builtins.object)
 |  Proxy of C++ string_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _ea=BADADDR) -> string_info_t
 |      
 |      @param _ea: ea_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: string_info_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_string_info_t(...)
 |      delete_string_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ea
 |      ea
 |  
 |  length
 |      length
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type

Help on class strwinsetup_t in module ida_strlist:

class strwinsetup_t(builtins.object)
 |  Proxy of C++ strwinsetup_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> strwinsetup_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_strwinsetup_t(...)
 |      delete_strwinsetup_t(self)
 |  
 |  _get_strtypes(self, *args) -> 'PyObject *'
 |      _get_strtypes(self) -> PyObject *
 |  
 |  _set_strtypes(self, *args) -> 'PyObject *'
 |      _set_strtypes(self, py_t) -> PyObject *
 |      
 |      Parameters
 |      ----------
 |      py_t: PyObject *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  display_only_existing_strings
 |      display_only_existing_strings
 |  
 |  ignore_heads
 |      ignore_heads
 |  
 |  minlen
 |      minlen
 |  
 |  only_7bit
 |      only_7bit
 |  
 |  strtypes
 |      _get_strtypes(self) -> PyObject *
 |  
 |  thisown
 |      The membership flag

Module "ida_struct"s docstring:
"""
Structure type management (assembly level types)"""

Help on function add_struc in module ida_struct:

add_struc(*args) -> 'tid_t'
    add_struc(idx, name, is_union=False) -> tid_t
    Create a structure type. if idx==BADADDR then add as the last idx. if
    name==nullptr then a name will be generated "struct_%d".
    
    @param idx: (C++: uval_t)
    @param name: (C++: const char *) char const *
    @param is_union: (C++: bool)

Help on function add_struc_member in module ida_struct:

add_struc_member(*args) -> 'struc_error_t'
    add_struc_member(sptr, fieldname, offset, flag, mt, nbytes) -> struc_error_t
    Add member to existing structure.
    
    @param sptr: (C++: struc_t *) structure to modify
    @param fieldname: (C++: const char *) if nullptr, then "anonymous_#" name will be generated
    @param offset: (C++: ea_t) BADADDR means add to the end of structure
    @param flag: (C++: flags_t) type + representation bits
    @param mt: (C++: const opinfo_t *) additional info about member type. must be present for structs,
               offsets, enums, strings, struct offsets.
    @param nbytes: (C++: asize_t) if == 0 then the structure will be a varstruct. in this case the
                   member should be the last member in the structure

Help on function del_member_tinfo in module ida_struct:

del_member_tinfo(*args) -> 'bool'
    del_member_tinfo(sptr, mptr) -> bool
    Delete tinfo for given member.
    
    @param sptr: (C++: struc_t *)
    @param mptr: (C++: member_t *)

Help on function del_struc in module ida_struct:

del_struc(*args) -> 'bool'
    del_struc(sptr) -> bool
    Delete a structure type.
    
    @param sptr: (C++: struc_t *)

Help on function del_struc_member in module ida_struct:

del_struc_member(*args) -> 'bool'
    del_struc_member(sptr, offset) -> bool
    Delete member at given offset.
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)

Help on function del_struc_members in module ida_struct:

del_struc_members(*args) -> 'int'
    del_struc_members(sptr, off1, off2) -> int
    Delete members which occupy range of offsets (off1..off2).
    
    @param sptr: (C++: struc_t *)
    @param off1: (C++: ea_t)
    @param off2: (C++: ea_t)
    @return: number of deleted members or -1 on error

Help on class dyn_member_ref_array in module ida_struct:

class dyn_member_ref_array(builtins.object)
 |  Proxy of C++ dynamic_wrapped_array_t< member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'member_t const &'
 |      __getitem__(self, i) -> member_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, _data, _count) -> dyn_member_ref_array
 |      
 |      @param _data: member_t *
 |      @param _count: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: member_t const &
 |  
 |  __swig_destroy__ = delete_dyn_member_ref_array(...)
 |      delete_dyn_member_ref_array(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  count
 |      count
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on function expand_struc in module ida_struct:

expand_struc(*args) -> 'bool'
    expand_struc(sptr, offset, delta, recalc=True) -> bool
    Expand/Shrink structure type.
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)
    @param delta: (C++: adiff_t)
    @param recalc: (C++: bool)

Help on function get_best_fit_member in module ida_struct:

get_best_fit_member(*args) -> 'member_t *'
    get_best_fit_member(sptr, offset) -> member_t
    Get member that is most likely referenced by the specified offset. Useful for
    offsets > sizeof(struct).
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: asize_t)

Help on function get_first_struc_idx in module ida_struct:

get_first_struc_idx(*args) -> 'uval_t'
    get_first_struc_idx() -> uval_t
    Get index of first structure.
    
    @return: BADADDR if no known structures, 0 otherwise

Help on function get_innermost_member in module ida_struct:

get_innermost_member(*args) -> 'PyObject *'
    get_innermost_member(sptr, offset) -> (member_t, struc_t, int)
    Get the innermost member at the given offset
    
    @param sptr: the starting structure
    @param offset: offset into the starting structure
    @return:     - None on failure
        - tuple(member_t, struct_t, offset)
          where member_t: a member in SPTR (it is not a structure),
                struct_t: the innermost structure,
                offset:   remaining offset into the returned member

Help on function get_last_struc_idx in module ida_struct:

get_last_struc_idx(*args) -> 'uval_t'
    get_last_struc_idx() -> uval_t
    Get index of last structure.
    
    @return: BADADDR if no known structures, get_struc_qty()-1 otherwise

Help on function get_max_offset in module ida_struct:

get_max_offset(*args) -> 'ea_t'
    get_max_offset(sptr) -> ea_t
    For unions: returns number of members, for structs: returns size of structure.
    
    @param sptr: (C++: struc_t *)

Help on function get_member in module ida_struct:

get_member(*args) -> 'member_t *'
    get_member(sptr, offset) -> member_t
    Get member at given offset.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: asize_t)

Help on function get_member_by_fullname in module ida_struct:

get_member_by_fullname(*args) -> 'struc_t **'
    get_member_by_fullname(fullname) -> member_t
    Get a member by its fully qualified name, "struct.field".
    
    @param fullname: (C++: const char *) char const *

Help on function get_member_by_id in module ida_struct:

get_member_by_id(*args) -> 'qstring *, struc_t **'
    get_member_by_id(mid) -> member_t
    Check if the specified member id points to a struct member. convenience
    function.
    
    @param mid: (C++: tid_t)

Help on function get_member_by_name in module ida_struct:

get_member_by_name(*args) -> 'member_t *'
    get_member_by_name(sptr, membername) -> member_t
    Get a member by its name, like "field44".
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param membername: (C++: const char *) char const *

Help on function get_member_cmt in module ida_struct:

get_member_cmt(*args) -> 'qstring *'
    get_member_cmt(mid, repeatable) -> str
    Get comment of structure member.
    
    @param mid: (C++: tid_t)
    @param repeatable: (C++: bool)

Help on function get_member_fullname in module ida_struct:

get_member_fullname(*args) -> 'qstring *'
    get_member_fullname(mid) -> str
    Get a member's fully qualified name, "struct.field".
    
    @param mid: (C++: tid_t)

Help on function get_member_id in module ida_struct:

get_member_id(*args) -> 'tid_t'
    get_member_id(sptr, offset) -> tid_t
    Get member id at given offset.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: asize_t)

Help on function get_member_name in module ida_struct:

get_member_name(*args) -> 'qstring *'
    get_member_name(mid) -> str
    
    @param mid: tid_t

Help on function get_member_size in module ida_struct:

get_member_size(*args) -> 'asize_t'
    get_member_size(NONNULL_mptr) -> asize_t
    Get size of structure member. May return 0 for the last member of varstruct. For
    union members, returns member_t::eoff.
    
    @param NONNULL_mptr: (C++: const member_t *) member_t const *

Help on function get_member_struc in module ida_struct:

get_member_struc(*args) -> 'struc_t *'
    get_member_struc(fullname) -> struc_t
    Get containing structure of member by its full name "struct.field".
    
    @param fullname: (C++: const char *) char const *

Help on function get_member_tinfo in module ida_struct:

get_member_tinfo(*args) -> 'bool'
    get_member_tinfo(tif, mptr) -> bool
    Get tinfo for given member.
    
    @param tif: (C++: tinfo_t *)
    @param mptr: (C++: const member_t *) member_t const *

Help on function get_next_member_idx in module ida_struct:

get_next_member_idx(*args) -> 'ssize_t'
    get_next_member_idx(sptr, off) -> ssize_t
    Get the next member idx, if it does not exist, return -1.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param off: (C++: asize_t)

Help on function get_next_struc_idx in module ida_struct:

get_next_struc_idx(*args) -> 'uval_t'
    get_next_struc_idx(idx) -> uval_t
    Get next struct index.
    
    @param idx: (C++: uval_t)
    @return: BADADDR if resulting index is out of bounds, otherwise idx++

Help on function get_or_guess_member_tinfo in module ida_struct:

get_or_guess_member_tinfo(*args) -> 'bool'
    get_or_guess_member_tinfo(tif, mptr) -> bool
    Try to get tinfo for given member - if failed, generate a tinfo using
    information about the member id from the disassembly
    
    @param tif: (C++: tinfo_t *)
    @param mptr: (C++: const member_t *) member_t const *

Help on function get_prev_member_idx in module ida_struct:

get_prev_member_idx(*args) -> 'ssize_t'
    get_prev_member_idx(sptr, off) -> ssize_t
    Get the prev member idx, if it does not exist, return -1.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param off: (C++: asize_t)

Help on function get_prev_struc_idx in module ida_struct:

get_prev_struc_idx(*args) -> 'uval_t'
    get_prev_struc_idx(idx) -> uval_t
    Get previous struct index.
    
    @param idx: (C++: uval_t)
    @return: BADADDR if resulting index is negative, otherwise idx - 1

Help on function get_sptr in module ida_struct:

get_sptr(*args) -> 'struc_t *'
    get_sptr(mptr) -> struc_t
    Get child struct if member is a struct.
    
    @param mptr: (C++: const member_t *) member_t const *

Help on function get_struc in module ida_struct:

get_struc(*args) -> 'struc_t *'
    get_struc(id) -> struc_t
    Get pointer to struct type info.
    
    @param id: (C++: tid_t)

Help on function get_struc_by_idx in module ida_struct:

get_struc_by_idx(*args) -> 'tid_t'
    get_struc_by_idx(idx) -> tid_t
    Get struct id by struct number.
    
    @param idx: (C++: uval_t)

Help on function get_struc_cmt in module ida_struct:

get_struc_cmt(*args) -> 'qstring *'
    get_struc_cmt(id, repeatable) -> str
    Get struct comment.
    
    @param id: (C++: tid_t)
    @param repeatable: (C++: bool)

Help on function get_struc_first_offset in module ida_struct:

get_struc_first_offset(*args) -> 'ea_t'
    get_struc_first_offset(sptr) -> ea_t
    Get offset of first member.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @return: BADADDR if memqty == 0

Help on function get_struc_id in module ida_struct:

get_struc_id(*args) -> 'tid_t'
    get_struc_id(name) -> tid_t
    Get struct id by name.
    
    @param name: (C++: const char *) char const *

Help on function get_struc_idx in module ida_struct:

get_struc_idx(*args) -> 'uval_t'
    get_struc_idx(id) -> uval_t
    Get internal number of the structure.
    
    @param id: (C++: tid_t)

Help on function get_struc_last_offset in module ida_struct:

get_struc_last_offset(*args) -> 'ea_t'
    get_struc_last_offset(sptr) -> ea_t
    Get offset of last member.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @return: BADADDR if memqty == 0

Help on function get_struc_name in module ida_struct:

get_struc_name(*args) -> 'qstring *'
    get_struc_name(id, flags=0) -> str
    
    @param id: tid_t
    @param flags: int

Help on function get_struc_next_offset in module ida_struct:

get_struc_next_offset(*args) -> 'ea_t'
    get_struc_next_offset(sptr, offset) -> ea_t
    Get offset of member with smallest offset larger than 'offset'.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: ea_t)
    @return: BADADDR if no next offset

Help on function get_struc_prev_offset in module ida_struct:

get_struc_prev_offset(*args) -> 'ea_t'
    get_struc_prev_offset(sptr, offset) -> ea_t
    Get offset of member with largest offset less than 'offset'.
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param offset: (C++: ea_t)
    @return: BADADDR if no prev offset

Help on function get_struc_qty in module ida_struct:

get_struc_qty(*args) -> 'size_t'
    get_struc_qty() -> size_t
    Get number of known structures.

Help on function get_struc_size in module ida_struct:

get_struc_size(*args) -> 'asize_t'
    get_struc_size(sptr) -> asize_t
    Get struct size (also see get_struc_size(const struc_t *))
    
    @param sptr: struc_t const *
    
    get_struc_size(id) -> asize_t
    
    @param id: tid_t

Help on function is_anonymous_member_name in module ida_struct:

is_anonymous_member_name(*args) -> 'bool'
    is_anonymous_member_name(name) -> bool
    Is member name prefixed with "anonymous"?
    
    @param name: (C++: const char *) char const *

Help on function is_dummy_member_name in module ida_struct:

is_dummy_member_name(*args) -> 'bool'
    is_dummy_member_name(name) -> bool
    Is member name an auto-generated name?
    
    @param name: (C++: const char *) char const *

Help on function is_member_id in module ida_struct:

is_member_id(*args) -> 'bool'
    is_member_id(mid) -> bool
    Is a member id?
    
    @param mid: (C++: tid_t)

Help on function is_special_member in module ida_struct:

is_special_member(*args) -> 'bool'
    is_special_member(id) -> bool
    Is a special member with the name beginning with ' '?
    
    @param id: (C++: tid_t)

Help on function is_union in module ida_struct:

is_union(*args) -> 'bool'
    is_union(id) -> bool
    Is a union?
    
    @param id: (C++: tid_t)

Help on function is_varmember in module ida_struct:

is_varmember(*args) -> 'bool'
    is_varmember(mptr) -> bool
    Is variable size member?
    
    @param mptr: (C++: const member_t *) member_t const *

Help on function is_varstr in module ida_struct:

is_varstr(*args) -> 'bool'
    is_varstr(id) -> bool
    Is variable size structure?
    
    @param id: (C++: tid_t)

Help on class member_t in module ida_struct:

class member_t(builtins.object)
 |  Proxy of C++ member_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> member_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_member_t(...)
 |      delete_member_t(self)
 |  
 |  by_til(self, *args) -> 'bool'
 |      by_til(self) -> bool
 |      Was the member created due to the type system?
 |  
 |  get_size(self, *args) -> 'asize_t'
 |      get_size(self) -> asize_t
 |      Get member size.
 |  
 |  get_soff(self, *args) -> 'ea_t'
 |      get_soff(self) -> ea_t
 |      Get start offset (for unions - returns 0)
 |  
 |  has_ti(self, *args) -> 'bool'
 |      has_ti(self) -> bool
 |      Has type information?
 |  
 |  has_union(self, *args) -> 'bool'
 |      has_union(self) -> bool
 |      Has members of type "union"?
 |  
 |  is_baseclass(self, *args) -> 'bool'
 |      is_baseclass(self) -> bool
 |      Is a base class member?
 |  
 |  is_destructor(self, *args) -> 'bool'
 |      is_destructor(self) -> bool
 |      Is a virtual destructor?
 |  
 |  is_dupname(self, *args) -> 'bool'
 |      is_dupname(self) -> bool
 |      Duplicate name was resolved during import?
 |  
 |  unimem(self, *args) -> 'bool'
 |      unimem(self) -> bool
 |      Is a member of a union?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  eoff
 |      eoff
 |  
 |  flag
 |      flag
 |  
 |  id
 |      id
 |  
 |  props
 |      props
 |  
 |  soff
 |      soff
 |  
 |  thisown
 |      The membership flag

Help on function retrieve_member_info in module ida_struct:

retrieve_member_info(*args) -> 'opinfo_t *'
    retrieve_member_info(buf, mptr) -> opinfo_t
    Get operand type info for member.
    
    @param buf: (C++: opinfo_t *)
    @param mptr: (C++: const member_t *) member_t const *

Help on function save_struc in module ida_struct:

save_struc(*args) -> 'void'
    save_struc(sptr, may_update_ltypes=True)
    Update struct information in the database (internal function)
    
    @param sptr: (C++: struc_t *)
    @param may_update_ltypes: (C++: bool)

Help on function set_member_cmt in module ida_struct:

set_member_cmt(*args) -> 'bool'
    set_member_cmt(mptr, cmt, repeatable) -> bool
    Set member comment.
    
    @param mptr: (C++: member_t *)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_member_name in module ida_struct:

set_member_name(*args) -> 'bool'
    set_member_name(sptr, offset, name) -> bool
    Set name of member at given offset.
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)
    @param name: (C++: const char *) char const *

Help on function set_member_tinfo in module ida_struct:

set_member_tinfo(*args) -> 'smt_code_t'
    set_member_tinfo(sptr, mptr, memoff, tif, flags) -> smt_code_t
    Set tinfo for given member.
    
    @param sptr: (C++: struc_t *) containing struct
    @param mptr: (C++: member_t *) target member
    @param memoff: (C++: uval_t) offset within member
    @param tif: (C++: const tinfo_t &) type info
    @param flags: (C++: int) Set member tinfo flags

Help on function set_member_type in module ida_struct:

set_member_type(*args) -> 'bool'
    set_member_type(sptr, offset, flag, mt, nbytes) -> bool
    Set type of member at given offset (also see add_struc_member())
    
    @param sptr: (C++: struc_t *)
    @param offset: (C++: ea_t)
    @param flag: (C++: flags_t)
    @param mt: (C++: const opinfo_t *) opinfo_t const *
    @param nbytes: (C++: asize_t)

Help on function set_struc_align in module ida_struct:

set_struc_align(*args) -> 'bool'
    set_struc_align(sptr, shift) -> bool
    Set structure alignment (SF_ALIGN)
    
    @param sptr: (C++: struc_t *)
    @param shift: (C++: int)

Help on function set_struc_cmt in module ida_struct:

set_struc_cmt(*args) -> 'bool'
    set_struc_cmt(id, cmt, repeatable) -> bool
    Set structure comment.
    
    @param id: (C++: tid_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_struc_hidden in module ida_struct:

set_struc_hidden(*args) -> 'void'
    set_struc_hidden(sptr, is_hidden)
    Hide/unhide a struct type.
    
    @param sptr: (C++: struc_t *)
    @param is_hidden: (C++: bool)

Help on function set_struc_idx in module ida_struct:

set_struc_idx(*args) -> 'bool'
    set_struc_idx(sptr, idx) -> bool
    Set internal number of struct. Also see get_struc_idx(), get_struc_by_idx().
    
    @param sptr: (C++: const struc_t *) struc_t const *
    @param idx: (C++: uval_t)

Help on function set_struc_listed in module ida_struct:

set_struc_listed(*args) -> 'void'
    set_struc_listed(sptr, is_listed)
    Add/remove a struct type from the struct list.
    
    @param sptr: (C++: struc_t *)
    @param is_listed: (C++: bool)

Help on function set_struc_name in module ida_struct:

set_struc_name(*args) -> 'bool'
    set_struc_name(id, name) -> bool
    Set structure name.
    
    @param id: (C++: tid_t)
    @param name: (C++: const char *) char const *

Help on function stroff_as_size in module ida_struct:

stroff_as_size(*args) -> 'bool'
    stroff_as_size(plen, sptr, value) -> bool
    Should display a structure offset expression as the structure size?
    
    @param plen: (C++: int)
    @param sptr: (C++: const struc_t *) struc_t const *
    @param value: (C++: asize_t)

Help on class struc_t in module ida_struct:

class struc_t(builtins.object)
 |  Proxy of C++ struc_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_members__(self, *args) -> 'dynamic_wrapped_array_t< member_t >'
 |      __get_members__(self) -> dyn_member_ref_array
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_struc_t(...)
 |      delete_struc_t(self)
 |  
 |  from_til(self, *args) -> 'bool'
 |      from_til(self) -> bool
 |      Does structure come from a type library?
 |  
 |  get_alignment(self, *args) -> 'int'
 |      get_alignment(self) -> int
 |      See SF_ALIGN.
 |  
 |  get_last_member(self, *args) -> 'member_t const *'
 |      get_last_member(self) -> member_t
 |  
 |  get_member(self, index)
 |  
 |  has_union(self, *args) -> 'bool'
 |      has_union(self) -> bool
 |      Has members of type "union"?
 |  
 |  is_choosable(self, *args) -> 'bool'
 |      is_choosable(self) -> bool
 |      Is included in chooser list? Use set_struc_listed to change the listed status
 |  
 |  is_copyof(self, *args) -> 'bool'
 |      is_copyof(self) -> bool
 |      Is copied from a local type?
 |  
 |  is_frame(self, *args) -> 'bool'
 |      is_frame(self) -> bool
 |      Is this structure a function frame?
 |  
 |  is_ghost(self, *args) -> 'bool'
 |      is_ghost(self) -> bool
 |      Is a ghost copy of a local type?
 |  
 |  is_hidden(self, *args) -> 'bool'
 |      is_hidden(self) -> bool
 |      Is the structure collapsed? Use set_struc_hidden to change the hidden status
 |  
 |  is_mappedto(self, *args) -> 'bool'
 |      is_mappedto(self) -> bool
 |      Is mapped to a local type?
 |  
 |  is_synced(self, *args) -> 'bool'
 |      is_synced(self) -> bool
 |      Is synced with a local type?
 |  
 |  is_union(self, *args) -> 'bool'
 |      is_union(self) -> bool
 |      Is a union?
 |  
 |  is_varstr(self, *args) -> 'bool'
 |      is_varstr(self) -> bool
 |      Is variable size structure?
 |  
 |  like_union(self, *args) -> 'bool'
 |      like_union(self) -> bool
 |      Is a union or contains members of type "union"?
 |  
 |  set_alignment(self, *args) -> 'void'
 |      set_alignment(self, shift)
 |      Do not use; use set_struc_align()
 |      
 |      @param shift: (C++: int)
 |  
 |  set_ghost(self, *args) -> 'void'
 |      set_ghost(self, _is_ghost)
 |      
 |      @param _is_ghost: bool
 |  
 |  unsync(self, *args) -> 'void'
 |      unsync(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  age
 |      age
 |  
 |  id
 |      id
 |  
 |  members
 |      __get_members__(self) -> dyn_member_ref_array
 |  
 |  memqty
 |      memqty
 |  
 |  ordinal
 |      ordinal
 |  
 |  props
 |      props
 |  
 |  thisown
 |      The membership flag

Help on class struct_field_visitor_t in module ida_struct:

class struct_field_visitor_t(builtins.object)
 |  Proxy of C++ struct_field_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> struct_field_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_struct_field_visitor_t(...)
 |      delete_struct_field_visitor_t(self)
 |  
 |  visit_field(self, *args) -> 'int'
 |      visit_field(self, sptr, mptr) -> int
 |      
 |      @param sptr: struc_t *
 |      @param mptr: member_t *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function visit_stroff_fields in module ida_struct:

visit_stroff_fields(*args) -> 'adiff_t *'
    visit_stroff_fields(sfv, path, disp, appzero) -> flags_t
    Visit structure fields in a stroff expression or in a reference to a struct data
    variable. This function can be used to enumerate all components of an expression
    like 'a.b.c'.
    
    @param sfv: (C++: struct_field_visitor_t &) visitor object
    @param path: (C++: const tid_t *) struct path (path[0] contains the initial struct id)
    @param disp: (C++: adiff_t *) offset into structure
    @param appzero: (C++: bool) should visit field at offset zero?

Module "ida_tryblks"s docstring:
"""
Architecture independent exception handling info.

Try blocks have the following general properties:
* A try block specifies a possibly fragmented guarded code region.
* Each try block has always at least one catch/except block description
* Each catch block contains its boundaries and a filter.
* Additionally a catch block can hold sp adjustment and the offset to the
exception object offset (C++).
* Try blocks can be nested. Nesting is automatically calculated at the retrieval
time.
* There may be (nested) multiple try blocks starting at the same address.

See examples in tests/input/src/eh_tests."""

Help on function add_tryblk in module ida_tryblks:

add_tryblk(*args) -> 'int'
    add_tryblk(tb) -> int
    Add one try block information.
    
    @param tb: (C++: const tryblk_t &) try block to add.
    @return: error code; 0 means good

Help on class catch_t in module ida_tryblks:

class catch_t(try_handler_t)
 |  Proxy of C++ catch_t class.
 |  
 |  Method resolution order:
 |      catch_t
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> catch_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_catch_t(...)
 |      delete_catch_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  obj
 |      obj
 |  
 |  thisown
 |      The membership flag
 |  
 |  type_id
 |      type_id
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from try_handler_t:
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from try_handler_t:
 |  
 |  disp
 |      disp
 |  
 |  fpreg
 |      fpreg
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: range_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      
 |      erase(self, first, last) -> range_t
 |      
 |      @param first: qvector< range_t >::iterator
 |      @param last: qvector< range_t >::iterator
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      
 |      @param x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |      
 |      @param x: range_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: range_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      @param x: range_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      
 |      @param x: range_t const &
 |      
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: range_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< range_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class catchvec_t in module ida_tryblks:

class catchvec_t(builtins.object)
 |  Proxy of C++ qvector< catch_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< catch_t > const &
 |  
 |  __getitem__(self, *args) -> 'catch_t const &'
 |      __getitem__(self, i) -> catch_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> catchvec_t
 |      __init__(self, x) -> catchvec_t
 |      
 |      @param x: qvector< catch_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< catch_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: catch_t const &
 |  
 |  __swig_destroy__ = delete_catchvec_t(...)
 |      delete_catchvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: catch_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: catch_t const &
 |  
 |  at(self, *args) -> 'catch_t const &'
 |      at(self, _idx) -> catch_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< catch_t >::const_iterator'
 |      begin(self) -> catch_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< catch_t >::const_iterator'
 |      end(self) -> catch_t
 |  
 |  erase(self, *args) -> 'qvector< catch_t >::iterator'
 |      erase(self, it) -> catch_t
 |      
 |      @param it: qvector< catch_t >::iterator
 |      
 |      erase(self, first, last) -> catch_t
 |      
 |      @param first: qvector< catch_t >::iterator
 |      @param last: qvector< catch_t >::iterator
 |  
 |  extract(self, *args) -> 'catch_t *'
 |      extract(self) -> catch_t
 |  
 |  find(self, *args) -> 'qvector< catch_t >::const_iterator'
 |      find(self, x) -> catch_t
 |      
 |      @param x: catch_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=catch_t())
 |      
 |      @param x: catch_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: catch_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: catch_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< catch_t >::iterator'
 |      insert(self, it, x) -> catch_t
 |      
 |      @param it: qvector< catch_t >::iterator
 |      @param x: catch_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'catch_t &'
 |      push_back(self, x)
 |      
 |      @param x: catch_t const &
 |      
 |      push_back(self) -> catch_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: catch_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< catch_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function del_tryblks in module ida_tryblks:

del_tryblks(*args) -> 'void'
    del_tryblks(range)
    Delete try block information in the specified range.
    
    @param range: (C++: const range_t &) the range to be cleared

Help on function find_syseh in module ida_tryblks:

find_syseh(*args) -> 'ea_t'
    find_syseh(ea) -> ea_t
    Find the start address of the system eh region including the argument.
    
    @param ea: (C++: ea_t) search address
    @return: start address of surrounding tryblk, otherwise BADADDR

Help on function get_tryblks in module ida_tryblks:

get_tryblks(*args) -> 'size_t'
    get_tryblks(tbv, range) -> size_t
    Retrieve try block information from the specified address range. Try blocks are
    sorted by starting address and their nest levels calculated.
    
    @param tbv: (C++: tryblks_t *) output buffer; may be nullptr
    @param range: (C++: const range_t &) address range to change
    @return: number of found try blocks

Help on function is_ea_tryblks in module ida_tryblks:

is_ea_tryblks(*args) -> 'bool'
    is_ea_tryblks(ea, flags) -> bool
    Check if the given address ea is part of tryblks description.
    
    @param ea: (C++: ea_t) address to check
    @param flags: (C++: uint32) combination of flags for is_ea_tryblks()

Help on class seh_t in module ida_tryblks:

class seh_t(try_handler_t)
 |  Proxy of C++ seh_t class.
 |  
 |  Method resolution order:
 |      seh_t
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> seh_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_seh_t(...)
 |      delete_seh_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  filter
 |      filter
 |  
 |  seh_code
 |      seh_code
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from try_handler_t:
 |  
 |  disp
 |      disp
 |  
 |  fpreg
 |      fpreg
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: range_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      
 |      erase(self, first, last) -> range_t
 |      
 |      @param first: qvector< range_t >::iterator
 |      @param last: qvector< range_t >::iterator
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      
 |      @param x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |      
 |      @param x: range_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: range_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      @param x: range_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      
 |      @param x: range_t const &
 |      
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: range_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< range_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class try_handler_t in module ida_tryblks:

class try_handler_t(ida_range.rangevec_t)
 |  Proxy of C++ try_handler_t class.
 |  
 |  Method resolution order:
 |      try_handler_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> try_handler_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_try_handler_t(...)
 |      delete_try_handler_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  disp
 |      disp
 |  
 |  fpreg
 |      fpreg
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: range_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      
 |      erase(self, first, last) -> range_t
 |      
 |      @param first: qvector< range_t >::iterator
 |      @param last: qvector< range_t >::iterator
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      
 |      @param x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |      
 |      @param x: range_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: range_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      @param x: range_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      
 |      @param x: range_t const &
 |      
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: range_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< range_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class tryblk_t in module ida_tryblks:

class tryblk_t(ida_range.rangevec_t)
 |  Proxy of C++ tryblk_t class.
 |  
 |  Method resolution order:
 |      tryblk_t
 |      ida_range.rangevec_t
 |      ida_range.rangevec_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tryblk_t
 |      __init__(self, r) -> tryblk_t
 |      
 |      @param r: tryblk_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tryblk_t(...)
 |      delete_tryblk_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  cpp(self, *args) -> 'catchvec_t &'
 |      cpp(self) -> catchvec_t
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  get_kind(self, *args) -> 'uchar'
 |      get_kind(self) -> uchar
 |  
 |  is_cpp(self, *args) -> 'bool'
 |      is_cpp(self) -> bool
 |  
 |  is_seh(self, *args) -> 'bool'
 |      is_seh(self) -> bool
 |  
 |  seh(self, *args) -> 'seh_t &'
 |      seh(self) -> seh_t
 |  
 |  set_cpp(self, *args) -> 'catchvec_t &'
 |      set_cpp(self) -> catchvec_t
 |  
 |  set_seh(self, *args) -> 'seh_t &'
 |      set_seh(self) -> seh_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  level
 |      level
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from ida_range.rangevec_base_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __getitem__(self, *args) -> 'range_t const &'
 |      __getitem__(self, i) -> range_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< range_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: range_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: range_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  at(self, *args) -> 'range_t const &'
 |      at(self, _idx) -> range_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< range_t >::const_iterator'
 |      begin(self) -> range_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  end(self, *args) -> 'qvector< range_t >::const_iterator'
 |      end(self) -> range_t
 |  
 |  erase(self, *args) -> 'qvector< range_t >::iterator'
 |      erase(self, it) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      
 |      erase(self, first, last) -> range_t
 |      
 |      @param first: qvector< range_t >::iterator
 |      @param last: qvector< range_t >::iterator
 |  
 |  extract(self, *args) -> 'range_t *'
 |      extract(self) -> range_t
 |  
 |  find(self, *args) -> 'qvector< range_t >::const_iterator'
 |      find(self, x) -> range_t
 |      
 |      @param x: range_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=range_t())
 |      
 |      @param x: range_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: range_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: range_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< range_t >::iterator'
 |      insert(self, it, x) -> range_t
 |      
 |      @param it: qvector< range_t >::iterator
 |      @param x: range_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'range_t &'
 |      push_back(self, x)
 |      
 |      @param x: range_t const &
 |      
 |      push_back(self) -> range_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: range_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< range_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from ida_range.rangevec_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from ida_range.rangevec_base_t:
 |  
 |  __hash__ = None

Help on class tryblks_t in module ida_tryblks:

class tryblks_t(builtins.object)
 |  Proxy of C++ qvector< tryblk_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< tryblk_t > const &
 |  
 |  __getitem__(self, *args) -> 'tryblk_t const &'
 |      __getitem__(self, i) -> tryblk_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tryblks_t
 |      __init__(self, x) -> tryblks_t
 |      
 |      @param x: qvector< tryblk_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< tryblk_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: tryblk_t const &
 |  
 |  __swig_destroy__ = delete_tryblks_t(...)
 |      delete_tryblks_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: tryblk_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: tryblk_t const &
 |  
 |  at(self, *args) -> 'tryblk_t const &'
 |      at(self, _idx) -> tryblk_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< tryblk_t >::const_iterator'
 |      begin(self) -> tryblk_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< tryblk_t >::const_iterator'
 |      end(self) -> tryblk_t
 |  
 |  erase(self, *args) -> 'qvector< tryblk_t >::iterator'
 |      erase(self, it) -> tryblk_t
 |      
 |      @param it: qvector< tryblk_t >::iterator
 |      
 |      erase(self, first, last) -> tryblk_t
 |      
 |      @param first: qvector< tryblk_t >::iterator
 |      @param last: qvector< tryblk_t >::iterator
 |  
 |  extract(self, *args) -> 'tryblk_t *'
 |      extract(self) -> tryblk_t
 |  
 |  find(self, *args) -> 'qvector< tryblk_t >::const_iterator'
 |      find(self, x) -> tryblk_t
 |      
 |      @param x: tryblk_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=tryblk_t())
 |      
 |      @param x: tryblk_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: tryblk_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: tryblk_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< tryblk_t >::iterator'
 |      insert(self, it, x) -> tryblk_t
 |      
 |      @param it: qvector< tryblk_t >::iterator
 |      @param x: tryblk_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'tryblk_t &'
 |      push_back(self, x)
 |      
 |      @param x: tryblk_t const &
 |      
 |      push_back(self) -> tryblk_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: tryblk_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< tryblk_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Module "ida_typeinf"s docstring:
"""
Describes the type information records in IDA.

The recommended way of using type info is to use the tinfo_t class. The type
information is internally kept as an array of bytes terminated by 0.

Items in brackets [] are optional and sometimes are omitted. type_t... means a
sequence of type_t bytes which defines a type.

@note: to work with the types of instructions or data in the database, use
       get_tinfo()/set_tinfo() and similar functions."""

Help on function f in module ida_idaapi:

f()

Help on swigvarlink object:

<class 'swigvarlink'>
Help on class _wrap_cvar in module ida_typeinf:

class _wrap_cvar(builtins.object)
 |  Methods defined here:
 |  
 |  __getattr__(self, attr)
 |  
 |  __setattr__(self, attr, value)
 |      Implement setattr(self, name, value).
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function add_til in module ida_typeinf:

add_til(*args) -> 'int'
    add_til(name, flags) -> int
    Load a til file and add it the database type libraries list. IDA will also apply
    function prototypes for matching function names.
    
    @param name: (C++: const char *) til name
    @param flags: (C++: int) combination of Load TIL flags
    @return: one of Load TIL result codes

Help on function alloc_type_ordinal in module ida_typeinf:

alloc_type_ordinal(*args) -> 'uint32'
    alloc_type_ordinal(ti) -> uint32
    alloc_type_ordinals(ti, 1)
    
    @param ti: (C++: til_t *)

Help on function alloc_type_ordinals in module ida_typeinf:

alloc_type_ordinals(*args) -> 'uint32'
    alloc_type_ordinals(ti, qty) -> uint32
    Allocate a range of ordinal numbers for new types.
    
    @param ti: (C++: til_t *) type library
    @param qty: (C++: int) number of ordinals to allocate
    @return: the first ordinal. 0 means failure.

Help on class aloc_visitor_t in module ida_typeinf:

class aloc_visitor_t(builtins.object)
 |  Proxy of C++ aloc_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> aloc_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_aloc_visitor_t(...)
 |      delete_aloc_visitor_t(self)
 |  
 |  visit_location(self, *args) -> 'int'
 |      visit_location(self, v, off, size) -> int
 |      
 |      @param v: argloc_t &
 |      @param off: int
 |      @param size: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function append_abi_opts in module ida_typeinf:

append_abi_opts(*args) -> 'bool'
    append_abi_opts(abi_opts, user_level=False) -> bool
    Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-...
    or -opt1-opt2-...
    
    @param abi_opts: (C++: const char *) - ABI options to add/remove in form opt1-opt2-...
    @param user_level: (C++: bool) - initiated by user if TRUE (==SETCOMP_BY_USER)
    @return: success

Help on function append_argloc in module ida_typeinf:

append_argloc(*args) -> 'bool'
    append_argloc(out, vloc) -> bool
    Serialize argument location
    
    @param out: (C++: qtype *)
    @param vloc: (C++: const argloc_t &) argloc_t const &

Help on function append_tinfo_covered in module ida_typeinf:

append_tinfo_covered(*args) -> 'bool'
    append_tinfo_covered(out, typid, offset) -> bool
    
    @param out: rangeset_t *
    @param typid: uint32
    @param offset: uint64

Help on function apply_callee_tinfo in module ida_typeinf:

apply_callee_tinfo(*args) -> 'bool'
    apply_callee_tinfo(caller, tif) -> bool
    Apply the type of the called function to the calling instruction. This function
    will append parameter comments and rename the local variables of the calling
    function. It also stores information about the instructions that initialize call
    arguments in the database. Use get_arg_addrs() to retrieve it if necessary.
    Alternatively it is possible to hook to processor_t::arg_addrs_ready event.
    
    @param caller: (C++: ea_t) linear address of the calling instruction. must belong to a
                   function.
    @param tif: (C++: const tinfo_t &) type info
    @return: success

Help on function apply_cdecl in module ida_typeinf:

apply_cdecl(*args) -> 'bool'
    apply_cdecl(til, ea, decl, flags=0) -> bool
    Apply the specified type to the address. This function parses the declaration
    and calls apply_tinfo()
    
    @param til: (C++: til_t *) type library
    @param ea: (C++: ea_t) linear address
    @param decl: (C++: const char *) type declaration in C form
    @param flags: (C++: int) flags to pass to apply_tinfo (TINFO_DEFINITE is always passed)
    @return: success

Help on function apply_named_type in module ida_typeinf:

apply_named_type(*args) -> 'bool'
    apply_named_type(ea, name) -> bool
    Apply the specified named type to the address.
    
    @param ea: (C++: ea_t) linear address
    @param name: (C++: const char *) the type name, e.g. "FILE"
    @return: success

Help on function apply_once_tinfo_and_name in module ida_typeinf:

apply_once_tinfo_and_name(*args) -> 'bool'
    apply_once_tinfo_and_name(dea, tif, name) -> bool
    Apply the specified type and name to the address. This function checks if the
    address already has a type. If the old type
    does not exist or the new type is 'better' than the old type, then the
    new type will be applied. A type is considered better if it has more
    information (e.g. BTMT_STRUCT is better than BT_INT).
    The same logic is with the name: if the address already have a meaningful
    name, it will be preserved. Only if the old name does not exist or it
    is a dummy name like byte_123, it will be replaced by the new name.
    
    @param dea: (C++: ea_t) linear address
    @param tif: (C++: const tinfo_t &) type string in the internal format
    @param name: (C++: const char *) new name for the address
    @return: success

Help on function apply_tinfo in module ida_typeinf:

apply_tinfo(*args) -> 'bool'
    apply_tinfo(ea, tif, flags) -> bool
    Apply the specified type to the specified address. This function sets the type
    and tries to convert the item at the specified address to conform the type.
    
    @param ea: (C++: ea_t) linear address
    @param tif: (C++: const tinfo_t &) type string in internal format
    @param flags: (C++: uint32) combination of Apply tinfo flags
    @return: success

Help on function apply_tinfo_to_stkarg in module ida_typeinf:

apply_tinfo_to_stkarg(*args) -> 'bool'
    apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool
    Helper function for the processor modules. to be called from
    processor_t::use_stkarg_type
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: (C++: const op_t &) op_t const &
    @param v: (C++: uval_t)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param name: (C++: const char *) char const *

Help on function apply_type in module ida_typeinf:

apply_type(*args) -> 'bool'
    apply_type(ti, type, fields, ea, flags) -> bool
    Apply the specified type to the address
    
    @param ti: Type info library. 'None' can be used.
    @param type: type_t const *
    @param fields: p_list const *
    @param ea: the address of the object
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

Help on class argloc_t in module ida_typeinf:

class argloc_t(builtins.object)
 |  Proxy of C++ argloc_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argloc_t
 |      __init__(self, r) -> argloc_t
 |      
 |      @param r: argloc_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_argloc_t(...)
 |      delete_argloc_t(self)
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: rrel_t *
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: scattered_aloc_t *
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      data: argloc_t::biggest_t
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      pdata: void *
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |      
 |      Parameters
 |      ----------
 |      _ea: ea_t
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, reg, off=0)
 |      
 |      Parameters
 |      ----------
 |      reg: int
 |      off: int
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |      
 |      Parameters
 |      ----------
 |      _reg1: int
 |      _reg2: int
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |      
 |      Parameters
 |      ----------
 |      off: sval_t
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |      Move the location to point 'delta' bytes further.
 |      
 |      @param delta: (C++: int)
 |  
 |  align_reg_high(self, *args) -> 'void'
 |      align_reg_high(self, size, _slotsize)
 |      Set register offset to align it to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  align_stkoff_high(self, *args) -> 'void'
 |      align_stkoff_high(self, size, _slotsize)
 |      Set stack offset to align to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |      Get type (Argument location types)
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: argloc_t const &
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |      Set register-relative location - can't be nullptr.
 |      
 |      @param p: (C++: rrel_t *)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |      Set distributed argument location.
 |      
 |      @param p: (C++: scattered_aloc_t *) scattered_aloc_t const &
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |      Get custom argloc info. Use if atype() == ALOC_CUSTOM
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |      Get the global address. Use when atype() == ALOC_STATIC
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |      Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      Get register-relative info. Use when atype() == ALOC_RREL
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |      TRUE if argloc has a stack part.
 |  
 |  in_stack(self, *args) -> 'bool'
 |      in_stack(self) -> bool
 |      TRUE if argloc is in stack entirely.
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |      See ALOC_NONE.
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |      See ALOC_CUSTOM.
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |      See ALOC_STATIC.
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |      is_scattered() || is_reg2()
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg1() || is_reg2()
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |      See ALOC_REG1.
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |      See ALOC_REG2.
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |      See ALOC_RREL.
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      See ALOC_DIST.
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |      See ALOC_STACK.
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |      Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |      Get info for the second register. Use when atype() == ALOC_REG2
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |      Get offset from the beginning of the register in bytes. Use when atype() ==
 |      ALOC_REG1
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      Get scattered argument info. Use when atype() == ALOC_DIST
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |      Set static ea location.
 |      
 |      @param _ea: (C++: ea_t)
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, reg, off=0)
 |      Set register location.
 |      
 |      @param reg: (C++: int)
 |      @param off: (C++: int)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |      Set secondary register location.
 |      
 |      @param _reg1: (C++: int)
 |      @param _reg2: (C++: int)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |      Set stack offset location.
 |      
 |      @param off: (C++: sval_t)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |      Get the stack offset. Use if atype() == ALOC_STACK
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Assign this == r and r == this.
 |      
 |      @param r: (C++: argloc_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class argpart_t in module ida_typeinf:

class argpart_t(argloc_t)
 |  Proxy of C++ argpart_t class.
 |  
 |  Method resolution order:
 |      argpart_t
 |      argloc_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, a) -> argpart_t
 |      
 |      @param a: argloc_t const &
 |      
 |      __init__(self) -> argpart_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: argpart_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_argpart_t(...)
 |      delete_argpart_t(self)
 |  
 |  bad_offset(self, *args) -> 'bool'
 |      bad_offset(self) -> bool
 |      Does this argpart have a valid offset?
 |  
 |  bad_size(self, *args) -> 'bool'
 |      bad_size(self) -> bool
 |      Does this argpart have a valid size?
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Assign this = r and r = this.
 |      
 |      @param r: (C++: argpart_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  off
 |      off
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from argloc_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: argloc_t const &
 |  
 |  _consume_rrel(self, *args) -> 'bool'
 |      _consume_rrel(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: rrel_t *
 |  
 |  _consume_scattered(self, *args) -> 'bool'
 |      _consume_scattered(self, p) -> bool
 |      
 |      Parameters
 |      ----------
 |      p: scattered_aloc_t *
 |  
 |  _set_badloc(self, *args) -> 'void'
 |      _set_badloc(self)
 |  
 |  _set_biggest(self, *args) -> 'void'
 |      _set_biggest(self, ct, data)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      data: argloc_t::biggest_t
 |  
 |  _set_custom(self, *args) -> 'void'
 |      _set_custom(self, ct, pdata)
 |      
 |      Parameters
 |      ----------
 |      ct: argloc_type_t
 |      pdata: void *
 |  
 |  _set_ea(self, *args) -> 'void'
 |      _set_ea(self, _ea)
 |      
 |      Parameters
 |      ----------
 |      _ea: ea_t
 |  
 |  _set_reg1(self, *args) -> 'void'
 |      _set_reg1(self, reg, off=0)
 |      
 |      Parameters
 |      ----------
 |      reg: int
 |      off: int
 |  
 |  _set_reg2(self, *args) -> 'void'
 |      _set_reg2(self, _reg1, _reg2)
 |      
 |      Parameters
 |      ----------
 |      _reg1: int
 |      _reg2: int
 |  
 |  _set_stkoff(self, *args) -> 'void'
 |      _set_stkoff(self, off)
 |      
 |      Parameters
 |      ----------
 |      off: sval_t
 |  
 |  advance(self, *args) -> 'bool'
 |      advance(self, delta) -> bool
 |      Move the location to point 'delta' bytes further.
 |      
 |      @param delta: (C++: int)
 |  
 |  align_reg_high(self, *args) -> 'void'
 |      align_reg_high(self, size, _slotsize)
 |      Set register offset to align it to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  align_stkoff_high(self, *args) -> 'void'
 |      align_stkoff_high(self, size, _slotsize)
 |      Set stack offset to align to the upper part of _SLOTSIZE.
 |      
 |      @param size: (C++: size_t)
 |      @param _slotsize: (C++: size_t)
 |  
 |  atype(self, *args) -> 'argloc_type_t'
 |      atype(self) -> argloc_type_t
 |      Get type (Argument location types)
 |  
 |  calc_offset(self, *args) -> 'sval_t'
 |      calc_offset(self) -> sval_t
 |      Calculate offset that can be used to compare 2 similar arglocs.
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: argloc_t const &
 |  
 |  consume_rrel(self, *args) -> 'void'
 |      consume_rrel(self, p)
 |      Set register-relative location - can't be nullptr.
 |      
 |      @param p: (C++: rrel_t *)
 |  
 |  consume_scattered(self, *args) -> 'void'
 |      consume_scattered(self, p)
 |      Set distributed argument location.
 |      
 |      @param p: (C++: scattered_aloc_t *) scattered_aloc_t const &
 |  
 |  get_biggest(self, *args) -> 'argloc_t::biggest_t'
 |      get_biggest(self) -> argloc_t::biggest_t
 |      Get largest element in internal union.
 |  
 |  get_custom(self, *args) -> 'void *'
 |      get_custom(self) -> void *
 |      Get custom argloc info. Use if atype() == ALOC_CUSTOM
 |  
 |  get_ea(self, *args) -> 'ea_t'
 |      get_ea(self) -> ea_t
 |      Get the global address. Use when atype() == ALOC_STATIC
 |  
 |  get_reginfo(self, *args) -> 'uint32'
 |      get_reginfo(self) -> uint32
 |      Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2
 |  
 |  get_rrel(self, *args) -> 'rrel_t const &'
 |      get_rrel(self) -> rrel_t
 |      Get register-relative info. Use when atype() == ALOC_RREL
 |  
 |  has_reg(self, *args) -> 'bool'
 |      has_reg(self) -> bool
 |      TRUE if argloc has a register part.
 |  
 |  has_stkoff(self, *args) -> 'bool'
 |      has_stkoff(self) -> bool
 |      TRUE if argloc has a stack part.
 |  
 |  in_stack(self, *args) -> 'bool'
 |      in_stack(self) -> bool
 |      TRUE if argloc is in stack entirely.
 |  
 |  is_badloc(self, *args) -> 'bool'
 |      is_badloc(self) -> bool
 |      See ALOC_NONE.
 |  
 |  is_custom(self, *args) -> 'bool'
 |      is_custom(self) -> bool
 |      See ALOC_CUSTOM.
 |  
 |  is_ea(self, *args) -> 'bool'
 |      is_ea(self) -> bool
 |      See ALOC_STATIC.
 |  
 |  is_fragmented(self, *args) -> 'bool'
 |      is_fragmented(self) -> bool
 |      is_scattered() || is_reg2()
 |  
 |  is_mixed_scattered(self, *args) -> 'bool'
 |      is_mixed_scattered(self) -> bool
 |      mixed scattered: consists of register and stack parts
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self) -> bool
 |      is_reg1() || is_reg2()
 |  
 |  is_reg1(self, *args) -> 'bool'
 |      is_reg1(self) -> bool
 |      See ALOC_REG1.
 |  
 |  is_reg2(self, *args) -> 'bool'
 |      is_reg2(self) -> bool
 |      See ALOC_REG2.
 |  
 |  is_rrel(self, *args) -> 'bool'
 |      is_rrel(self) -> bool
 |      See ALOC_RREL.
 |  
 |  is_scattered(self, *args) -> 'bool'
 |      is_scattered(self) -> bool
 |      See ALOC_DIST.
 |  
 |  is_stkoff(self, *args) -> 'bool'
 |      is_stkoff(self) -> bool
 |      See ALOC_STACK.
 |  
 |  reg1(self, *args) -> 'int'
 |      reg1(self) -> int
 |      Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2
 |  
 |  reg2(self, *args) -> 'int'
 |      reg2(self) -> int
 |      Get info for the second register. Use when atype() == ALOC_REG2
 |  
 |  regoff(self, *args) -> 'int'
 |      regoff(self) -> int
 |      Get offset from the beginning of the register in bytes. Use when atype() ==
 |      ALOC_REG1
 |  
 |  scattered(self, *args) -> 'scattered_aloc_t const &'
 |      scattered(self) -> scattered_aloc_t
 |      Get scattered argument info. Use when atype() == ALOC_DIST
 |  
 |  set_badloc(self, *args) -> 'void'
 |      set_badloc(self)
 |      Set to invalid location.
 |  
 |  set_ea(self, *args) -> 'void'
 |      set_ea(self, _ea)
 |      Set static ea location.
 |      
 |      @param _ea: (C++: ea_t)
 |  
 |  set_reg1(self, *args) -> 'void'
 |      set_reg1(self, reg, off=0)
 |      Set register location.
 |      
 |      @param reg: (C++: int)
 |      @param off: (C++: int)
 |  
 |  set_reg2(self, *args) -> 'void'
 |      set_reg2(self, _reg1, _reg2)
 |      Set secondary register location.
 |      
 |      @param _reg1: (C++: int)
 |      @param _reg2: (C++: int)
 |  
 |  set_stkoff(self, *args) -> 'void'
 |      set_stkoff(self, off)
 |      Set stack offset location.
 |      
 |      @param off: (C++: sval_t)
 |  
 |  stkoff(self, *args) -> 'sval_t'
 |      stkoff(self) -> sval_t
 |      Get the stack offset. Use if atype() == ALOC_STACK
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from argloc_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from argloc_t:
 |  
 |  __hash__ = None

Help on class argpartvec_t in module ida_typeinf:

class argpartvec_t(builtins.object)
 |  Proxy of C++ qvector< argpart_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< argpart_t > const &
 |  
 |  __getitem__(self, *args) -> 'argpart_t const &'
 |      __getitem__(self, i) -> argpart_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argpartvec_t
 |      __init__(self, x) -> argpartvec_t
 |      
 |      @param x: qvector< argpart_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< argpart_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: argpart_t const &
 |  
 |  __swig_destroy__ = delete_argpartvec_t(...)
 |      delete_argpartvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: argpart_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: argpart_t const &
 |  
 |  at(self, *args) -> 'argpart_t const &'
 |      at(self, _idx) -> argpart_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      begin(self) -> argpart_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      end(self) -> argpart_t
 |  
 |  erase(self, *args) -> 'qvector< argpart_t >::iterator'
 |      erase(self, it) -> argpart_t
 |      
 |      @param it: qvector< argpart_t >::iterator
 |      
 |      erase(self, first, last) -> argpart_t
 |      
 |      @param first: qvector< argpart_t >::iterator
 |      @param last: qvector< argpart_t >::iterator
 |  
 |  extract(self, *args) -> 'argpart_t *'
 |      extract(self) -> argpart_t
 |  
 |  find(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      find(self, x) -> argpart_t
 |      
 |      @param x: argpart_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=argpart_t())
 |      
 |      @param x: argpart_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: argpart_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: argpart_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< argpart_t >::iterator'
 |      insert(self, it, x) -> argpart_t
 |      
 |      @param it: qvector< argpart_t >::iterator
 |      @param x: argpart_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'argpart_t &'
 |      push_back(self, x)
 |      
 |      @param x: argpart_t const &
 |      
 |      push_back(self) -> argpart_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: argpart_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< argpart_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class argtinfo_helper_t in module ida_typeinf:

class argtinfo_helper_t(builtins.object)
 |  Proxy of C++ argtinfo_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> argtinfo_helper_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_argtinfo_helper_t(...)
 |      delete_argtinfo_helper_t(self)
 |  
 |  has_delay_slot(self, *args) -> 'bool'
 |      has_delay_slot(self, arg0) -> bool
 |      The call instruction with a delay slot?.
 |      
 |      @param arg0: ea_t
 |  
 |  is_stkarg_load(self, *args) -> 'bool'
 |      is_stkarg_load(self, insn, src, dst) -> bool
 |      Is the current insn a stkarg load?. if yes:
 |      * src: index of the source operand in insn_t::ops
 |      * dst: index of the destination operand in insn_t::ops insn_t::ops[dst].addr is
 |      expected to have the stack offset
 |      
 |      @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
 |      @param src: (C++: int *)
 |      @param dst: (C++: int *)
 |  
 |  set_op_tinfo(self, *args) -> 'bool'
 |      set_op_tinfo(self, insn, x, tif, name) -> bool
 |      Set the operand type as specified.
 |      
 |      @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
 |      @param x: (C++: const op_t &) op_t const &
 |      @param tif: (C++: const tinfo_t &) tinfo_t const &
 |      @param name: (C++: const char *) char const *
 |  
 |  use_arg_tinfos(self, *args) -> 'void'
 |      use_arg_tinfos(self, caller, fti, rargs)
 |      This function is to be called by the processor module in response to
 |      ev_use_arg_types.
 |      
 |      @param caller: (C++: ea_t)
 |      @param fti: (C++: func_type_data_t *)
 |      @param rargs: (C++: funcargvec_t *)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reserved
 |      reserved
 |  
 |  thisown
 |      The membership flag

Help on class array_type_data_t in module ida_typeinf:

class array_type_data_t(builtins.object)
 |  Proxy of C++ array_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, b=0, n=0) -> array_type_data_t
 |      
 |      @param b: size_t
 |      @param n: size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_array_type_data_t(...)
 |      delete_array_type_data_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      set this = r and r = this
 |      
 |      @param r: (C++: array_type_data_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  base
 |      base
 |  
 |  elem_type
 |      elem_type
 |  
 |  nelems
 |      nelems
 |  
 |  thisown
 |      The membership flag

Help on function begin_type_updating in module ida_typeinf:

begin_type_updating(*args) -> 'void'
    begin_type_updating(utp)
    Mark the beginning of a large update operation on the types. Can be used with
    add_enum_member(), add_struc_member, etc... Also see end_type_updating()
    
    @param utp: (C++: update_type_t) enum update_type_t

Help on class bitfield_type_data_t in module ida_typeinf:

class bitfield_type_data_t(builtins.object)
 |  Proxy of C++ bitfield_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, _nbytes=0, _width=0, _is_unsigned=False) -> bitfield_type_data_t
 |      
 |      @param _nbytes: uchar
 |      @param _width: uchar
 |      @param _is_unsigned: bool
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_bitfield_type_data_t(...)
 |      delete_bitfield_type_data_t(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: bitfield_type_data_t const &
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: bitfield_type_data_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  is_unsigned
 |      is_unsigned
 |  
 |  nbytes
 |      nbytes
 |  
 |  thisown
 |      The membership flag
 |  
 |  width
 |      width
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function calc_c_cpp_name in module ida_typeinf:

calc_c_cpp_name(*args) -> 'qstring *'
    calc_c_cpp_name(name, type, ccn_flags) -> str
    Get C or C++ form of the name.
    
    @param name: (C++: const char *) original (mangled or decorated) name
    @param type: (C++: const tinfo_t *) name type if known, otherwise nullptr
    @param ccn_flags: (C++: int) one of C/C++ naming flags

Help on function calc_number_of_children in module ida_typeinf:

calc_number_of_children(*args) -> 'int'
    calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int
    Calculate max number of lines of a formatted c data, when expanded (PTV_EXPAND).
    
    @param loc: (C++: const argloc_t &) location of the data (ALOC_STATIC or ALOC_CUSTOM)
    @param tif: (C++: const tinfo_t &) type info
    @param dont_deref_ptr: (C++: bool) consider 'ea' as the ptr value
    @retval 0: data is not expandable
    @retval -1: error, see qerrno
    @retval else: the max number of lines

Help on function calc_tinfo_gaps in module ida_typeinf:

calc_tinfo_gaps(*args) -> 'bool'
    calc_tinfo_gaps(out, typid) -> bool
    
    @param out: rangeset_t *
    @param typid: uint32

Help on function calc_type_size in module ida_typeinf:

calc_type_size(*args) -> 'PyObject *'
    calc_type_size(ti, tp) -> PyObject *
    Returns the size of a type
    
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @return:     - None on failure
        - The size of the type

Help on class callregs_t in module ida_typeinf:

class callregs_t(builtins.object)
 |  Proxy of C++ callregs_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> callregs_t
 |      __init__(self, cc) -> callregs_t
 |      
 |      @param cc: cm_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_callregs_t(...)
 |      delete_callregs_t(self)
 |  
 |  by_slots(self, *args) -> 'bool'
 |      by_slots(self) -> bool
 |  
 |  init_regs(self, *args) -> 'void'
 |      init_regs(self, cc)
 |      Init policy & registers for given CC.
 |      
 |      @param cc: (C++: cm_t)
 |  
 |  reginds(self, *args) -> 'bool'
 |      reginds(self, gp_ind, fp_ind, r) -> bool
 |      Get register indexes within GP/FP arrays. (-1 -> is not present in the
 |      corresponding array)
 |      
 |      @param gp_ind: (C++: int *)
 |      @param fp_ind: (C++: int *)
 |      @param r: (C++: int)
 |  
 |  reset(self, *args) -> 'void'
 |      reset(self)
 |      Set policy and registers to invalid values.
 |  
 |  set(self, *args) -> 'void'
 |      set(self, _policy, gprs, fprs)
 |      Init policy & registers (arrays are -1-terminated)
 |      
 |      @param _policy: (C++: argreg_policy_t) enum argreg_policy_t
 |      @param gprs: (C++: const int *) int const *
 |      @param fprs: (C++: const int *) int const *
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  regcount(*args) -> 'int'
 |      regcount(cc) -> int
 |      Get max number of registers may be used in a function call.
 |      
 |      @param cc: (C++: cm_t)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  fpregs
 |      fpregs
 |  
 |  gpregs
 |      gpregs
 |  
 |  nregs
 |      nregs
 |  
 |  policy
 |      policy
 |  
 |  thisown
 |      The membership flag

Help on function callregs_t_regcount in module ida_typeinf:

callregs_t_regcount(*args) -> 'int'
    callregs_t_regcount(cc) -> int
    
    @param cc: cm_t

Help on function choose_local_tinfo in module ida_typeinf:

choose_local_tinfo(*args) -> 'uint32'
    choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32
    Choose a type from the local type library.
    
    @param ti: (C++: const til_t *) pointer to til
    @param title: (C++: const char *) title of listbox to display
    @param func: (C++: local_tinfo_predicate_t *) predicate to select types to display (maybe nullptr)
    @param def_ord: (C++: uint32) ordinal to position cursor before choose
    @param ud: (C++: void *) user data
    @return: == 0 means nothing is chosen, otherwise an ordinal number

Help on function choose_local_tinfo_and_delta in module ida_typeinf:

choose_local_tinfo_and_delta(*args) -> 'uint32'
    choose_local_tinfo_and_delta(delta, ti, title, func=None, def_ord=0, ud=None) -> uint32
    Choose a type from the local type library and specify the pointer shift value.
    
    @param delta: (C++: int32 *) pointer shift value
    @param ti: (C++: const til_t *) pointer to til
    @param title: (C++: const char *) title of listbox to display
    @param func: (C++: local_tinfo_predicate_t *) predicate to select types to display (maybe nullptr)
    @param def_ord: (C++: uint32) ordinal to position cursor before choose
    @param ud: (C++: void *) user data
    @return: == 0 means nothing is chosen, otherwise an ordinal number

Help on function choose_named_type in module ida_typeinf:

choose_named_type(*args) -> 'bool'
    choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool
    Choose a type from a type library.
    
    @param out_sym: (C++: til_symbol_t *) pointer to be filled with the chosen type
    @param root_til: (C++: const til_t *) pointer to starting til (the function will inspect the base
                     tils if allowed by flags)
    @param title: (C++: const char *) title of listbox to display
    @param ntf_flags: (C++: int) combination of Flags for named types
    @param predicate: (C++: predicate_t *) predicate to select types to display (maybe nullptr)
    @return: false if nothing is chosen, otherwise true

Help on function clear_tinfo_t in module ida_typeinf:

clear_tinfo_t(*args) -> 'void'
    clear_tinfo_t(_this)
    
    @param _this: tinfo_t *

Help on function compact_til in module ida_typeinf:

compact_til(*args) -> 'bool'
    compact_til(ti) -> bool
    Collect garbage in til. Must be called before storing the til.
    
    @param ti: (C++: til_t *)
    @return: true if any memory was freed

Help on function compare_tinfo in module ida_typeinf:

compare_tinfo(*args) -> 'bool'
    compare_tinfo(t1, t2, tcflags) -> bool
    
    @param t1: uint32
    @param t2: uint32
    @param tcflags: int

Help on class const_aloc_visitor_t in module ida_typeinf:

class const_aloc_visitor_t(builtins.object)
 |  Proxy of C++ const_aloc_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> const_aloc_visitor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_const_aloc_visitor_t(...)
 |      delete_const_aloc_visitor_t(self)
 |  
 |  visit_location(self, *args) -> 'int'
 |      visit_location(self, v, off, size) -> int
 |      
 |      @param v: argloc_t const &
 |      @param off: int
 |      @param size: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function convert_pt_flags_to_hti in module ida_typeinf:

convert_pt_flags_to_hti(*args) -> 'int'
    convert_pt_flags_to_hti(pt_flags) -> int
    Convert Type parsing flags to Type formatting flags. Type parsing flags lesser
    than 0x10 don't have stable meaning and will be ignored (more on these flags can
    be seen in idc.idc)
    
    @param pt_flags: (C++: int)

Help on function copy_named_type in module ida_typeinf:

copy_named_type(*args) -> 'uint32'
    copy_named_type(dsttil, srctil, name) -> uint32
    Copy a named type from one til to another. This function will copy the specified
    type and all dependent types from the source type library to the destination
    library.
    
    @param dsttil: (C++: til_t *) Destination til. It must have orginal types enabled
    @param srctil: (C++: const til_t *) Source til.
    @param name: (C++: const char *) name of the type to copy
    @return: ordinal number of the copied type. 0 means error

Help on function copy_tinfo_t in module ida_typeinf:

copy_tinfo_t(*args) -> 'void'
    copy_tinfo_t(_this, r)
    
    @param _this: tinfo_t *
    @param r: tinfo_t const &

Help on function create_numbered_type_name in module ida_typeinf:

create_numbered_type_name(*args) -> 'qstring *'
    create_numbered_type_name(ord) -> str
    Create anonymous name for numbered type. This name can be used to reference a
    numbered type by its ordinal Ordinal names have the following format: '#' +
    set_de(ord) Returns: -1 if error, otherwise the name length
    
    @param ord: (C++: int32)

Help on function create_tinfo in module ida_typeinf:

create_tinfo(*args) -> 'bool'
    create_tinfo(_this, bt, bt2, ptr) -> bool
    
    @param _this: tinfo_t *
    @param bt: type_t
    @param bt2: type_t
    @param ptr: void *

Help on function default_compiler in module ida_typeinf:

default_compiler(*args) -> 'comp_t'
    default_compiler() -> comp_t
    Get compiler specified by inf.cc.

Help on function del_named_type in module ida_typeinf:

del_named_type(*args) -> 'bool'
    del_named_type(ti, name, ntf_flags) -> bool
    Delete information about a symbol.
    
    @param ti: (C++: til_t *) type library
    @param name: (C++: const char *) name of symbol
    @param ntf_flags: (C++: int) combination of Flags for named types
    @return: success

Help on function del_numbered_type in module ida_typeinf:

del_numbered_type(*args) -> 'bool'
    del_numbered_type(ti, ordinal) -> bool
    Delete a numbered type.
    
    @param ti: (C++: til_t *)
    @param ordinal: (C++: uint32)

Help on function del_til in module ida_typeinf:

del_til(*args) -> 'bool'
    del_til(name) -> bool
    Unload a til file.
    
    @param name: (C++: const char *) char const *

Help on function del_tinfo_attr in module ida_typeinf:

del_tinfo_attr(*args) -> 'bool'
    del_tinfo_attr(tif, key, make_copy) -> bool
    
    @param tif: tinfo_t *
    @param key: qstring const &
    @param make_copy: bool

Help on function del_vftable_ea in module ida_typeinf:

del_vftable_ea(*args) -> 'bool'
    del_vftable_ea(ordinal) -> bool
    Delete the address of a vftable instance for a vftable type.
    
    @param ordinal: (C++: uint32) ordinal number of a vftable type.
    @return: success

Help on function deref_ptr in module ida_typeinf:

deref_ptr(*args) -> 'bool'
    deref_ptr(ptr_ea, tif, closure_obj=None) -> bool
    Dereference a pointer.
    
    @param ptr_ea: (C++: ea_t *) in/out parameter
    * in: address of the pointer
    * out: the pointed address
    @param tif: (C++: const tinfo_t &) type of the pointer
    @param closure_obj: (C++: ea_t *) closure object (not used yet)
    @return: success

Help on function deserialize_tinfo in module ida_typeinf:

deserialize_tinfo(*args) -> 'bool'
    deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -> bool
    
    @param tif: tinfo_t *
    @param til: til_t const *
    @param ptype: type_t const **
    @param pfields: p_list const **
    @param pfldcmts: p_list const **

Help on function dstr_tinfo in module ida_typeinf:

dstr_tinfo(*args) -> 'char const *'
    dstr_tinfo(tif) -> char const *
    
    @param tif: tinfo_t const *

Help on function dump_func_type_data in module ida_typeinf:

dump_func_type_data(*args) -> 'qstring *'
    dump_func_type_data(fti, praloc_bits) -> str
    Use func_type_data_t::dump()
    
    @param fti: (C++: const func_type_data_t &) func_type_data_t const &
    @param praloc_bits: (C++: int)

Help on function end_type_updating in module ida_typeinf:

end_type_updating(*args) -> 'void'
    end_type_updating(utp)
    Mark the end of a large update operation on the types (see
    begin_type_updating())
    
    @param utp: (C++: update_type_t) enum update_type_t

Help on class enum_member_t in module ida_typeinf:

class enum_member_t(builtins.object)
 |  Proxy of C++ enum_member_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: enum_member_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: enum_member_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_member_t(...)
 |      delete_enum_member_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: enum_member_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      cmt
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class enum_member_vec_t in module ida_typeinf:

class enum_member_vec_t(builtins.object)
 |  Proxy of C++ qvector< enum_member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< enum_member_t > const &
 |  
 |  __getitem__(self, *args) -> 'enum_member_t const &'
 |      __getitem__(self, i) -> enum_member_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> enum_member_vec_t
 |      __init__(self, x) -> enum_member_vec_t
 |      
 |      @param x: qvector< enum_member_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< enum_member_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: enum_member_t const &
 |  
 |  __swig_destroy__ = delete_enum_member_vec_t(...)
 |      delete_enum_member_vec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: enum_member_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: enum_member_t const &
 |  
 |  at(self, *args) -> 'enum_member_t const &'
 |      at(self, _idx) -> enum_member_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      begin(self) -> enum_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      end(self) -> enum_member_t
 |  
 |  erase(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      erase(self, it) -> enum_member_t
 |      
 |      @param it: qvector< enum_member_t >::iterator
 |      
 |      erase(self, first, last) -> enum_member_t
 |      
 |      @param first: qvector< enum_member_t >::iterator
 |      @param last: qvector< enum_member_t >::iterator
 |  
 |  extract(self, *args) -> 'enum_member_t *'
 |      extract(self) -> enum_member_t
 |  
 |  find(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      find(self, x) -> enum_member_t
 |      
 |      @param x: enum_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=enum_member_t())
 |      
 |      @param x: enum_member_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: enum_member_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: enum_member_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      insert(self, it, x) -> enum_member_t
 |      
 |      @param it: qvector< enum_member_t >::iterator
 |      @param x: enum_member_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'enum_member_t &'
 |      push_back(self, x)
 |      
 |      @param x: enum_member_t const &
 |      
 |      push_back(self) -> enum_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: enum_member_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< enum_member_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class enum_type_data_t in module ida_typeinf:

class enum_type_data_t(enum_member_vec_t)
 |  Proxy of C++ enum_type_data_t class.
 |  
 |  Method resolution order:
 |      enum_type_data_t
 |      enum_member_vec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _bte=BTE_ALWAYS|BTE_HEX) -> enum_type_data_t
 |      
 |      @param _bte: bte_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_enum_type_data_t(...)
 |      delete_enum_type_data_t(self)
 |  
 |  calc_mask(self, *args) -> 'uint64'
 |      calc_mask(self) -> uint64
 |  
 |  calc_nbytes(self, *args) -> 'int'
 |      calc_nbytes(self) -> int
 |  
 |  is_64bit(self, *args) -> 'bool'
 |      is_64bit(self) -> bool
 |  
 |  is_char(self, *args) -> 'bool'
 |      is_char(self) -> bool
 |  
 |  is_hex(self, *args) -> 'bool'
 |      is_hex(self) -> bool
 |  
 |  is_sdec(self, *args) -> 'bool'
 |      is_sdec(self) -> bool
 |  
 |  is_udec(self, *args) -> 'bool'
 |      is_udec(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      swap two instances
 |      
 |      @param r: (C++: enum_type_data_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  bte
 |      bte
 |  
 |  group_sizes
 |      group_sizes
 |  
 |  taenum_bits
 |      taenum_bits
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from enum_member_vec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< enum_member_t > const &
 |  
 |  __getitem__(self, *args) -> 'enum_member_t const &'
 |      __getitem__(self, i) -> enum_member_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< enum_member_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: enum_member_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: enum_member_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: enum_member_t const &
 |  
 |  at(self, *args) -> 'enum_member_t const &'
 |      at(self, _idx) -> enum_member_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      begin(self) -> enum_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      end(self) -> enum_member_t
 |  
 |  erase(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      erase(self, it) -> enum_member_t
 |      
 |      @param it: qvector< enum_member_t >::iterator
 |      
 |      erase(self, first, last) -> enum_member_t
 |      
 |      @param first: qvector< enum_member_t >::iterator
 |      @param last: qvector< enum_member_t >::iterator
 |  
 |  extract(self, *args) -> 'enum_member_t *'
 |      extract(self) -> enum_member_t
 |  
 |  find(self, *args) -> 'qvector< enum_member_t >::const_iterator'
 |      find(self, x) -> enum_member_t
 |      
 |      @param x: enum_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=enum_member_t())
 |      
 |      @param x: enum_member_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: enum_member_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: enum_member_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< enum_member_t >::iterator'
 |      insert(self, it, x) -> enum_member_t
 |      
 |      @param it: qvector< enum_member_t >::iterator
 |      @param x: enum_member_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'enum_member_t &'
 |      push_back(self, x)
 |      
 |      @param x: enum_member_t const &
 |      
 |      push_back(self) -> enum_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: enum_member_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from enum_member_vec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from enum_member_vec_t:
 |  
 |  __hash__ = None

Help on function extract_argloc in module ida_typeinf:

extract_argloc(*args) -> 'bool'
    extract_argloc(vloc, ptype, forbid_stkoff) -> bool
    Deserialize an argument location. Argument FORBID_STKOFF checks location type.
    It can be used, for example, to check the return location of a function that
    cannot return a value in the stack
    
    @param vloc: (C++: argloc_t *)
    @param ptype: (C++: const type_t **) type_t const **
    @param forbid_stkoff: (C++: bool)

Help on function find_tinfo_udt_member in module ida_typeinf:

find_tinfo_udt_member(*args) -> 'int'
    find_tinfo_udt_member(udm, typid, strmem_flags) -> int
    
    @param udm: udt_member_t *
    @param typid: uint32
    @param strmem_flags: int

Help on function first_named_type in module ida_typeinf:

first_named_type(*args) -> 'char const *'
    first_named_type(ti, ntf_flags) -> char const *
    Enumerate types.
    
    @param ti: (C++: const til_t *) type library. nullptr means the local type library for the current
               database.
    @param ntf_flags: (C++: int) combination of Flags for named types
    @return: Type or symbol names, depending of ntf_flags. Returns mangled names.
             Never returns anonymous types. To include them, enumerate types by
             ordinals.

Help on function for_all_arglocs in module ida_typeinf:

for_all_arglocs(*args) -> 'int'
    for_all_arglocs(vv, vloc, size, off=0) -> int
    Compress larger argloc types and initiate the aloc visitor.
    
    @param vv: (C++: aloc_visitor_t &)
    @param vloc: (C++: argloc_t &)
    @param size: (C++: int)
    @param off: (C++: int)

Help on function for_all_const_arglocs in module ida_typeinf:

for_all_const_arglocs(*args) -> 'int'
    for_all_const_arglocs(vv, vloc, size, off=0) -> int
    See for_all_arglocs()
    
    @param vv: (C++: const_aloc_visitor_t &)
    @param vloc: (C++: const argloc_t &) argloc_t const &
    @param size: (C++: int)
    @param off: (C++: int)

Help on function free_til in module ida_typeinf:

free_til(*args) -> 'void'
    free_til(ti)
    Free memory allocated by til.
    
    @param ti: (C++: til_t *)

Help on function func_has_stkframe_hole in module ida_typeinf:

func_has_stkframe_hole(*args) -> 'bool'
    func_has_stkframe_hole(ea, fti) -> bool
    Looks for a hole at the beginning of the stack arguments. Will make use of the
    IDB's func_t function at that place (if present) to help determine the presence
    of such a hole.
    
    @param ea: (C++: ea_t)
    @param fti: (C++: const func_type_data_t &) func_type_data_t const &

Help on class func_type_data_t in module ida_typeinf:

class func_type_data_t(funcargvec_t)
 |  Proxy of C++ func_type_data_t class.
 |  
 |  Method resolution order:
 |      func_type_data_t
 |      funcargvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> func_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_func_type_data_t(...)
 |      delete_func_type_data_t(self)
 |  
 |  dump(self, *args) -> 'bool'
 |      dump(self, praloc_bits=0x02) -> bool
 |      Dump information that is not always visible in the function prototype. (argument
 |      locations, return location, total stkarg size)
 |      
 |      @param praloc_bits: (C++: int)
 |  
 |  get_call_method(self, *args) -> 'int'
 |      get_call_method(self) -> int
 |  
 |  guess_cc(self, *args) -> 'cm_t'
 |      guess_cc(self, purged, cc_flags) -> cm_t
 |      Guess function calling convention use the following info: argument locations and
 |      'stkargs'
 |      
 |      @param purged: (C++: int)
 |      @param cc_flags: (C++: int)
 |  
 |  is_const(self, *args) -> 'bool'
 |      is_const(self) -> bool
 |  
 |  is_ctor(self, *args) -> 'bool'
 |      is_ctor(self) -> bool
 |  
 |  is_dtor(self, *args) -> 'bool'
 |      is_dtor(self) -> bool
 |  
 |  is_golang_cc(self, *args) -> 'bool'
 |      is_golang_cc(self) -> bool
 |  
 |  is_high(self, *args) -> 'bool'
 |      is_high(self) -> bool
 |  
 |  is_noret(self, *args) -> 'bool'
 |      is_noret(self) -> bool
 |  
 |  is_pure(self, *args) -> 'bool'
 |      is_pure(self) -> bool
 |  
 |  is_static(self, *args) -> 'bool'
 |      is_static(self) -> bool
 |  
 |  is_vararg_cc(self, *args) -> 'bool'
 |      is_vararg_cc(self) -> bool
 |  
 |  is_virtual(self, *args) -> 'bool'
 |      is_virtual(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: func_type_data_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  cc
 |      cc
 |  
 |  flags
 |      flags
 |  
 |  retloc
 |      retloc
 |  
 |  rettype
 |      rettype
 |  
 |  spoiled
 |      spoiled
 |  
 |  stkargs
 |      stkargs
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from funcargvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< funcarg_t > const &
 |  
 |  __getitem__(self, *args) -> 'funcarg_t const &'
 |      __getitem__(self, i) -> funcarg_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< funcarg_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: funcarg_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: funcarg_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: funcarg_t const &
 |  
 |  at(self, *args) -> 'funcarg_t const &'
 |      at(self, _idx) -> funcarg_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      begin(self) -> funcarg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      end(self) -> funcarg_t
 |  
 |  erase(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      erase(self, it) -> funcarg_t
 |      
 |      @param it: qvector< funcarg_t >::iterator
 |      
 |      erase(self, first, last) -> funcarg_t
 |      
 |      @param first: qvector< funcarg_t >::iterator
 |      @param last: qvector< funcarg_t >::iterator
 |  
 |  extract(self, *args) -> 'funcarg_t *'
 |      extract(self) -> funcarg_t
 |  
 |  find(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      find(self, x) -> funcarg_t
 |      
 |      @param x: funcarg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=funcarg_t())
 |      
 |      @param x: funcarg_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: funcarg_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: funcarg_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      insert(self, it, x) -> funcarg_t
 |      
 |      @param it: qvector< funcarg_t >::iterator
 |      @param x: funcarg_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'funcarg_t &'
 |      push_back(self, x)
 |      
 |      @param x: funcarg_t const &
 |      
 |      push_back(self) -> funcarg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: funcarg_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from funcargvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from funcargvec_t:
 |  
 |  __hash__ = None

Help on class funcarg_t in module ida_typeinf:

class funcarg_t(builtins.object)
 |  Proxy of C++ funcarg_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: funcarg_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> funcarg_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: funcarg_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_funcarg_t(...)
 |      delete_funcarg_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  argloc
 |      argloc
 |  
 |  cmt
 |      cmt
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class funcargvec_t in module ida_typeinf:

class funcargvec_t(builtins.object)
 |  Proxy of C++ qvector< funcarg_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< funcarg_t > const &
 |  
 |  __getitem__(self, *args) -> 'funcarg_t const &'
 |      __getitem__(self, i) -> funcarg_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> funcargvec_t
 |      __init__(self, x) -> funcargvec_t
 |      
 |      @param x: qvector< funcarg_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< funcarg_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: funcarg_t const &
 |  
 |  __swig_destroy__ = delete_funcargvec_t(...)
 |      delete_funcargvec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: funcarg_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: funcarg_t const &
 |  
 |  at(self, *args) -> 'funcarg_t const &'
 |      at(self, _idx) -> funcarg_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      begin(self) -> funcarg_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      end(self) -> funcarg_t
 |  
 |  erase(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      erase(self, it) -> funcarg_t
 |      
 |      @param it: qvector< funcarg_t >::iterator
 |      
 |      erase(self, first, last) -> funcarg_t
 |      
 |      @param first: qvector< funcarg_t >::iterator
 |      @param last: qvector< funcarg_t >::iterator
 |  
 |  extract(self, *args) -> 'funcarg_t *'
 |      extract(self) -> funcarg_t
 |  
 |  find(self, *args) -> 'qvector< funcarg_t >::const_iterator'
 |      find(self, x) -> funcarg_t
 |      
 |      @param x: funcarg_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=funcarg_t())
 |      
 |      @param x: funcarg_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: funcarg_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: funcarg_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< funcarg_t >::iterator'
 |      insert(self, it, x) -> funcarg_t
 |      
 |      @param it: qvector< funcarg_t >::iterator
 |      @param x: funcarg_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'funcarg_t &'
 |      push_back(self, x)
 |      
 |      @param x: funcarg_t const &
 |      
 |      push_back(self) -> funcarg_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: funcarg_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< funcarg_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function gcc_layout in module ida_typeinf:

gcc_layout(*args) -> 'bool'
    gcc_layout() -> bool
    Should use the struct/union layout as done by gcc?

Help on function gen_decorate_name in module ida_typeinf:

gen_decorate_name(*args) -> 'qstring *'
    gen_decorate_name(name, mangle, cc, type) -> str
    Generic function for decorate_name() (may be used in IDP modules)
    
    @param name: (C++: const char *) char const *
    @param mangle: (C++: bool)
    @param cc: (C++: cm_t)
    @param type: (C++: const tinfo_t *) tinfo_t const *

Help on function gen_use_arg_tinfos in module ida_typeinf:

gen_use_arg_tinfos(*args) -> 'void'
    gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)
    
    @param caller: ea_t
    @param fti: func_type_data_t *
    @param rargs: funcargvec_t *
    @param set_optype: set_op_tinfo_t *
    @param is_stkarg_load: is_stkarg_load_t *
    @param has_delay_slot: has_delay_slot_t *

Help on function gen_use_arg_tinfos2 in module ida_typeinf:

gen_use_arg_tinfos2(*args) -> 'void'
    gen_use_arg_tinfos2(_this, caller, fti, rargs)
    Do not call this function directly, use argtinfo_helper_t.
    
    @param _this: (C++: struct argtinfo_helper_t *) argtinfo_helper_t *
    @param caller: (C++: ea_t)
    @param fti: (C++: func_type_data_t *)
    @param rargs: (C++: funcargvec_t *)

Help on function get_abi_name in module ida_typeinf:

get_abi_name(*args) -> 'qstring *'
    get_abi_name() -> str
    Get ABI name.
    
    @return: length of the name (>=0)

Help on function get_alias_target in module ida_typeinf:

get_alias_target(*args) -> 'uint32'
    get_alias_target(ti, ordinal) -> uint32
    Find the final alias destination. If the ordinal has not been aliased, return
    the specified ordinal itself If failed, returns 0.
    
    @param ti: (C++: const til_t *) til_t const *
    @param ordinal: (C++: uint32)

Help on function get_arg_addrs in module ida_typeinf:

get_arg_addrs(*args) -> 'PyObject *'
    get_arg_addrs(caller) -> PyObject *
    Retrieve addresses of argument initialization instructions
    
    @param caller: the address of the call instruction
    @return: list of instruction addresses

Help on function get_base_type in module ida_typeinf:

get_base_type(*args) -> 'type_t'
    get_base_type(t) -> type_t
    Get get basic type bits (TYPE_BASE_MASK)
    
    @param t: (C++: type_t)

Help on function get_c_header_path in module ida_typeinf:

get_c_header_path(*args) -> 'qstring *'
    get_c_header_path() -> str
    Get the include directory path of the target compiler.

Help on function get_c_macros in module ida_typeinf:

get_c_macros(*args) -> 'qstring *'
    get_c_macros() -> str
    Get predefined macros for the target compiler.

Help on function get_comp in module ida_typeinf:

get_comp(*args) -> 'comp_t'
    get_comp(comp) -> comp_t
    Get compiler bits.
    
    @param comp: (C++: comp_t)

Help on function get_compiler_abbr in module ida_typeinf:

get_compiler_abbr(*args) -> 'char const *'
    get_compiler_abbr(id) -> char const *
    Get abbreviated compiler name.
    
    @param id: (C++: comp_t)

Help on function get_compiler_name in module ida_typeinf:

get_compiler_name(*args) -> 'char const *'
    get_compiler_name(id) -> char const *
    Get full compiler name.
    
    @param id: (C++: comp_t)

Help on function get_compilers in module ida_typeinf:

get_compilers(*args) -> 'void'
    get_compilers(ids, names, abbrs)
    Get names of all built-in compilers.
    
    @param ids: (C++: compvec_t *)
    @param names: (C++: qstrvec_t *)
    @param abbrs: (C++: qstrvec_t *)

Help on function get_enum_member_expr in module ida_typeinf:

get_enum_member_expr(*args) -> 'qstring *'
    get_enum_member_expr(tif, serial, value) -> str
    Return a C expression that can be used to represent an enum member. If the value
    does not correspond to any single enum member, this function tries to find a
    bitwise combination of enum members that correspond to it. If more than half of
    value bits do not match any enum members, it fails.
    
    @param tif: (C++: const tinfo_t &) enumeration type
    @param serial: (C++: int) which enumeration member to use (0 means the first with the given
                   value)
    @param value: (C++: uint64) value to search in the enumeration type. only 32-bit number can be
                  handled yet
    @return: success

Help on function get_full_type in module ida_typeinf:

get_full_type(*args) -> 'type_t'
    get_full_type(t) -> type_t
    Get basic type bits + type flags (TYPE_FULL_MASK)
    
    @param t: (C++: type_t)

Help on function get_idainfo_by_type in module ida_typeinf:

get_idainfo_by_type(*args) -> 'size_t *, flags_t *, opinfo_t *, size_t *'
    get_idainfo_by_type(tif) -> bool
    Extract information from a tinfo_t.
    
    @param tif: (C++: const tinfo_t &) the type to inspect

Help on function get_idati in module ida_typeinf:

get_idati(*args) -> 'til_t const *'
    get_idati() -> til_t
    Pointer to the local type library - this til is private for each IDB file
    Function that accepts til_t* uses local type library instead of nullptr.

Help on function get_named_type in module ida_typeinf:

get_named_type(*args) -> 'PyObject *'
    get_named_type(til, name, ntf_flags) -> (int, bytes, bytes, NoneType, NoneType, int, int)
    Get a type data by its name.
    
    @param til: the type library
    @param name: the type name
    @param ntf_flags: a combination of NTF_* constants
    @return:     None on failure
        tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success

Help on function get_named_type64 in module ida_typeinf:

get_named_type64(*args) -> 'PyObject *'
    get_named_type64(til, name, ntf_flags) -> (int, bytes, NoneType, NoneType, NoneType, int, int)
    See get_named_type() above.
    @note: If the value in the 'ti' library is 32-bit, it will be sign-extended
           before being stored in the 'value' pointer.
    
    @param til: til_t const *
    @param name: (C++: const char *) char const *
    @param ntf_flags: (C++: int)

Help on function get_numbered_type in module ida_typeinf:

get_numbered_type(*args) -> 'PyObject *'
    get_numbered_type(til, ordinal) -> (bytes, NoneType, NoneType, NoneType, int), (bytes, bytes, NoneType, NoneType, int)
    Retrieve a type by its ordinal number.
    
    @param til: til_t const *
    @param ordinal: (C++: uint32)

Help on function get_numbered_type_name in module ida_typeinf:

get_numbered_type_name(*args) -> 'char const *'
    get_numbered_type_name(ti, ordinal) -> char const *
    Get type name (if exists) by its ordinal. If the type is anonymous, returns "".
    If failed, returns nullptr
    
    @param ti: (C++: const til_t *) til_t const *
    @param ordinal: (C++: uint32)

Help on function get_ordinal_from_idb_type in module ida_typeinf:

get_ordinal_from_idb_type(*args) -> 'int'
    get_ordinal_from_idb_type(name, type) -> int
    Get ordinal number of an idb type (struct/enum). The 'type' parameter is used
    only to determine the kind of the type (struct or enum) Use this function to
    find out the correspondence between idb types and til types
    
    @param name: (C++: const char *) char const *
    @param type: (C++: const type_t *) type_t const *

Help on function get_ordinal_qty in module ida_typeinf:

get_ordinal_qty(*args) -> 'uint32'
    get_ordinal_qty(ti) -> uint32
    Get number of allocated ordinals.
    
    @param ti: (C++: const til_t *) til_t const *
    @return: uint32(-1) if failed

Help on function get_scalar_bt in module ida_typeinf:

get_scalar_bt(*args) -> 'type_t'
    get_scalar_bt(size) -> type_t
    
    @param size: int

Help on function get_stock_tinfo in module ida_typeinf:

get_stock_tinfo(*args) -> 'bool'
    get_stock_tinfo(tif, id) -> bool
    
    @param tif: tinfo_t *
    @param id: enum stock_type_id_t

Help on function get_tinfo_attr in module ida_typeinf:

get_tinfo_attr(*args) -> 'bool'
    get_tinfo_attr(typid, key, bv, all_attrs) -> bool
    
    @param typid: uint32
    @param key: qstring const &
    @param bv: bytevec_t *
    @param all_attrs: bool

Help on function get_tinfo_attrs in module ida_typeinf:

get_tinfo_attrs(*args) -> 'bool'
    get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool
    
    @param typid: uint32
    @param tav: type_attrs_t *
    @param include_ref_attrs: bool

Help on function get_tinfo_details in module ida_typeinf:

get_tinfo_details(*args) -> 'bool'
    get_tinfo_details(typid, bt2, buf) -> bool
    
    @param typid: uint32
    @param bt2: type_t
    @param buf: void *

Help on function get_tinfo_pdata in module ida_typeinf:

get_tinfo_pdata(*args) -> 'size_t'
    get_tinfo_pdata(outptr, typid, what) -> size_t
    
    @param outptr: void *
    @param typid: uint32
    @param what: int

Help on function get_tinfo_property in module ida_typeinf:

get_tinfo_property(*args) -> 'size_t'
    get_tinfo_property(typid, gta_prop) -> size_t
    
    @param typid: uint32
    @param gta_prop: int

Help on function get_tinfo_size in module ida_typeinf:

get_tinfo_size(*args) -> 'size_t'
    get_tinfo_size(p_effalign, typid, gts_code) -> size_t
    
    @param p_effalign: uint32 *
    @param typid: uint32
    @param gts_code: int

Help on function get_type_flags in module ida_typeinf:

get_type_flags(*args) -> 'type_t'
    get_type_flags(t) -> type_t
    Get type flags (TYPE_FLAGS_MASK)
    
    @param t: (C++: type_t)

Help on function get_type_ordinal in module ida_typeinf:

get_type_ordinal(*args) -> 'int32'
    get_type_ordinal(ti, name) -> int32
    Get type ordinal by its name.
    
    @param ti: (C++: const til_t *) til_t const *
    @param name: (C++: const char *) char const *

Help on function get_vftable_ea in module ida_typeinf:

get_vftable_ea(*args) -> 'ea_t'
    get_vftable_ea(ordinal) -> ea_t
    Get address of a virtual function table.
    
    @param ordinal: (C++: uint32) ordinal number of a vftable type.
    @return: address of the corresponding virtual function table in the current
             database.

Help on function get_vftable_ordinal in module ida_typeinf:

get_vftable_ordinal(*args) -> 'uint32'
    get_vftable_ordinal(vftable_ea) -> uint32
    Get ordinal number of the virtual function table.
    
    @param vftable_ea: (C++: ea_t) address of a virtual function table.
    @return: ordinal number of the corresponding vftable type. 0 - failure.

Help on function guess_func_cc in module ida_typeinf:

guess_func_cc(*args) -> 'cm_t'
    guess_func_cc(fti, npurged, cc_flags) -> cm_t
    Use func_type_data_t::guess_cc()
    
    @param fti: (C++: const func_type_data_t &) func_type_data_t const &
    @param npurged: (C++: int)
    @param cc_flags: (C++: int)

Help on function guess_tinfo in module ida_typeinf:

guess_tinfo(*args) -> 'int'
    guess_tinfo(tif, id) -> int
    Generate a type information about the id from the disassembly. id can be a
    structure/union/enum id or an address.
    
    @param tif: (C++: tinfo_t *)
    @param id: (C++: tid_t)
    @return: one of Guess tinfo codes

Help on class ida_lowertype_helper_t in module ida_typeinf:

class ida_lowertype_helper_t(lowertype_helper_t)
 |  Proxy of C++ ida_lowertype_helper_t class.
 |  
 |  Method resolution order:
 |      ida_lowertype_helper_t
 |      lowertype_helper_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _tif, _ea, _pb) -> ida_lowertype_helper_t
 |      
 |      @param _tif: tinfo_t const &
 |      @param _ea: ea_t
 |      @param _pb: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ida_lowertype_helper_t(...)
 |      delete_ida_lowertype_helper_t(self)
 |  
 |  func_has_stkframe_hole(self, *args) -> 'bool'
 |      func_has_stkframe_hole(self, candidate, candidate_data) -> bool
 |      
 |      @param candidate: tinfo_t const &
 |      @param candidate_data: func_type_data_t const &
 |  
 |  get_func_purged_bytes(self, *args) -> 'int'
 |      get_func_purged_bytes(self, candidate, arg3) -> int
 |      
 |      @param candidate: tinfo_t const &
 |      @param arg3: func_type_data_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from lowertype_helper_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function idc_get_local_type in module ida_typeinf:

idc_get_local_type(*args) -> 'size_t'
    idc_get_local_type(ordinal, flags) -> str
    
    @param ordinal: int
    @param flags: int

Help on function idc_get_local_type_name in module ida_typeinf:

idc_get_local_type_name(*args) -> 'size_t'
    idc_get_local_type_name(ordinal) -> str
    
    @param ordinal: int

Help on function idc_get_local_type_raw in module ida_typeinf:

idc_get_local_type_raw(*args) -> 'PyObject *'
    idc_get_local_type_raw(ordinal) -> (bytes, bytes)
    
    @param ordinal: int

Help on function idc_get_type in module ida_typeinf:

idc_get_type(*args) -> 'size_t'
    idc_get_type(ea) -> str
    
    @param ea: ea_t

Help on function idc_get_type_raw in module ida_typeinf:

idc_get_type_raw(*args) -> 'PyObject *'
    idc_get_type_raw(ea) -> PyObject *
    
    @param ea: ea_t

Help on function idc_guess_type in module ida_typeinf:

idc_guess_type(*args) -> 'size_t'
    idc_guess_type(ea) -> str
    
    @param ea: ea_t

Help on function idc_parse_decl in module ida_typeinf:

idc_parse_decl(*args) -> 'PyObject *'
    idc_parse_decl(ti, decl, flags) -> (str, bytes, bytes) or None
    
    @param ti: til_t *
    @param decl: char const *
    @param flags: int

Help on function idc_parse_types in module ida_typeinf:

idc_parse_types(*args) -> 'int'
    idc_parse_types(input, flags) -> int
    
    @param input: char const *
    @param flags: int

Help on function idc_print_type in module ida_typeinf:

idc_print_type(*args) -> 'PyObject *'
    idc_print_type(type, fields, name, flags) -> str
    
    @param type: type_t const *
    @param fields: p_list const *
    @param name: char const *
    @param flags: int

Help on function idc_set_local_type in module ida_typeinf:

idc_set_local_type(*args) -> 'int'
    idc_set_local_type(ordinal, dcl, flags) -> int
    
    @param ordinal: int
    @param dcl: char const *
    @param flags: int

Help on function import_type in module ida_typeinf:

import_type(*args) -> 'tid_t'
    import_type(til, idx, name, flags=0) -> tid_t
    Copy a named type from til to idb.
    
    @param til: (C++: const til_t *) type library
    @param idx: (C++: int) the position of the new type in the list of types (structures or
                enums). -1 means at the end of the list
    @param name: (C++: const char *) the type name
    @param flags: (C++: int) combination of Import type flags
    @return: BADNODE on error

Help on function inf_big_arg_align in module ida_typeinf:

inf_big_arg_align(*args) -> 'bool'
    inf_big_arg_align() -> bool
    inf_big_arg_align(cc) -> bool
    
    @param cc: cm_t

Help on function inf_pack_stkargs in module ida_typeinf:

inf_pack_stkargs(*args) -> 'bool'
    inf_pack_stkargs() -> bool
    inf_pack_stkargs(cc) -> bool
    
    @param cc: cm_t

Help on function is_autosync in module ida_typeinf:

is_autosync(*args) -> 'bool'
    is_autosync(name, type) -> bool
    Is the specified idb type automatically synchronized?
    
    @param name: (C++: const char *) char const *
    @param type: type_t const *
    
    is_autosync(name, tif) -> bool
    
    @param name: char const *
    @param tif: tinfo_t const &

Help on function is_code_far in module ida_typeinf:

is_code_far(*args) -> 'bool'
    is_code_far(cm) -> bool
    Does the given model specify far code?.
    
    @param cm: (C++: cm_t)

Help on function is_comp_unsure in module ida_typeinf:

is_comp_unsure(*args) -> 'comp_t'
    is_comp_unsure(comp) -> comp_t
    See COMP_UNSURE.
    
    @param comp: (C++: comp_t)

Help on function is_data_far in module ida_typeinf:

is_data_far(*args) -> 'bool'
    is_data_far(cm) -> bool
    Does the given model specify far data?.
    
    @param cm: (C++: cm_t)

Help on function is_gcc in module ida_typeinf:

is_gcc(*args) -> 'bool'
    is_gcc() -> bool
    Is the target compiler COMP_GNU?

Help on function is_gcc32 in module ida_typeinf:

is_gcc32(*args) -> 'bool'
    is_gcc32() -> bool
    Is the target compiler 32 bit gcc?

Help on function is_gcc64 in module ida_typeinf:

is_gcc64(*args) -> 'bool'
    is_gcc64() -> bool
    Is the target compiler 64 bit gcc?

Help on function is_golang_cc in module ida_typeinf:

is_golang_cc(*args) -> 'bool'
    is_golang_cc(cc) -> bool
    GO language calling convention (return value in stack)?
    
    @param cc: (C++: cm_t)

Help on function is_ordinal_name in module ida_typeinf:

is_ordinal_name(*args) -> 'bool'
    is_ordinal_name(name, ord=None) -> bool
    Check if the name is an ordinal name. Ordinal names have the following format:
    '#' + set_de(ord)
    
    @param name: (C++: const char *) char const *
    @param ord: (C++: uint32 *)

Help on function is_purging_cc in module ida_typeinf:

is_purging_cc(*args) -> 'bool'
    is_purging_cc(cm) -> bool
    Does the calling convention clean the stack arguments upon return?.
    @note: this function is valid only for x86 code
    
    @param cm: (C++: cm_t)

Help on function is_restype_enum in module ida_typeinf:

is_restype_enum(*args) -> 'bool'
    is_restype_enum(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

Help on function is_restype_struct in module ida_typeinf:

is_restype_struct(*args) -> 'bool'
    is_restype_struct(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

Help on function is_restype_struni in module ida_typeinf:

is_restype_struni(*args) -> 'bool'
    is_restype_struni(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

Help on function is_restype_void in module ida_typeinf:

is_restype_void(*args) -> 'bool'
    is_restype_void(til, type) -> bool
    
    @param til: til_t const *
    @param type: type_t const *

Help on function is_sdacl_byte in module ida_typeinf:

is_sdacl_byte(*args) -> 'bool'
    is_sdacl_byte(t) -> bool
    Identify an sdacl byte. The first sdacl byte has the following format: 11xx000x.
    The sdacl bytes are appended to udt fields. They indicate the start of type
    attributes (as the tah-bytes do). The sdacl bytes are used in the udt headers
    instead of the tah-byte. This is done for compatibility with old databases, they
    were already using sdacl bytes in udt headers and as udt field postfixes. (see
    "sdacl-typeattrs" in the type bit definitions)
    
    @param t: (C++: type_t)

Help on function is_tah_byte in module ida_typeinf:

is_tah_byte(*args) -> 'bool'
    is_tah_byte(t) -> bool
    The TAH byte (type attribute header byte) denotes the start of type attributes.
    (see "tah-typeattrs" in the type bit definitions)
    
    @param t: (C++: type_t)

Help on function is_type_arithmetic in module ida_typeinf:

is_type_arithmetic(*args) -> 'bool'
    is_type_arithmetic(t) -> bool
    Is the type an arithmetic type? (floating or integral)
    
    @param t: (C++: type_t)

Help on function is_type_array in module ida_typeinf:

is_type_array(*args) -> 'bool'
    is_type_array(t) -> bool
    See BT_ARRAY.
    
    @param t: (C++: type_t)

Help on function is_type_bitfld in module ida_typeinf:

is_type_bitfld(*args) -> 'bool'
    is_type_bitfld(t) -> bool
    See BT_BITFIELD.
    
    @param t: (C++: type_t)

Help on function is_type_bool in module ida_typeinf:

is_type_bool(*args) -> 'bool'
    is_type_bool(t) -> bool
    See BTF_BOOL.
    
    @param t: (C++: type_t)

Help on function is_type_char in module ida_typeinf:

is_type_char(*args) -> 'bool'
    is_type_char(t) -> bool
    Does the type specify a char value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

Help on function is_type_complex in module ida_typeinf:

is_type_complex(*args) -> 'bool'
    is_type_complex(t) -> bool
    See BT_COMPLEX.
    
    @param t: (C++: type_t)

Help on function is_type_const in module ida_typeinf:

is_type_const(*args) -> 'bool'
    is_type_const(t) -> bool
    See BTM_CONST.
    
    @param t: (C++: type_t)

Help on function is_type_double in module ida_typeinf:

is_type_double(*args) -> 'bool'
    is_type_double(t) -> bool
    See BTF_DOUBLE.
    
    @param t: (C++: type_t)

Help on function is_type_enum in module ida_typeinf:

is_type_enum(*args) -> 'bool'
    is_type_enum(t) -> bool
    See BTF_ENUM.
    
    @param t: (C++: type_t)

Help on function is_type_ext_arithmetic in module ida_typeinf:

is_type_ext_arithmetic(*args) -> 'bool'
    is_type_ext_arithmetic(t) -> bool
    Is the type an extended arithmetic type? (arithmetic or enum)
    
    @param t: (C++: type_t)

Help on function is_type_ext_integral in module ida_typeinf:

is_type_ext_integral(*args) -> 'bool'
    is_type_ext_integral(t) -> bool
    Is the type an extended integral type? (integral or enum)
    
    @param t: (C++: type_t)

Help on function is_type_float in module ida_typeinf:

is_type_float(*args) -> 'bool'
    is_type_float(t) -> bool
    See BTF_FLOAT.
    
    @param t: (C++: type_t)

Help on function is_type_floating in module ida_typeinf:

is_type_floating(*args) -> 'bool'
    is_type_floating(t) -> bool
    Is the type a floating point type?
    
    @param t: (C++: type_t)

Help on function is_type_func in module ida_typeinf:

is_type_func(*args) -> 'bool'
    is_type_func(t) -> bool
    See BT_FUNC.
    
    @param t: (C++: type_t)

Help on function is_type_int in module ida_typeinf:

is_type_int(*args) -> 'bool'
    is_type_int(bt) -> bool
    Does the type_t specify one of the basic types in Basic type: integer?
    
    @param bt: (C++: type_t)

Help on function is_type_int128 in module ida_typeinf:

is_type_int128(*args) -> 'bool'
    is_type_int128(t) -> bool
    Does the type specify a 128-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

Help on function is_type_int16 in module ida_typeinf:

is_type_int16(*args) -> 'bool'
    is_type_int16(t) -> bool
    Does the type specify a 16-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

Help on function is_type_int32 in module ida_typeinf:

is_type_int32(*args) -> 'bool'
    is_type_int32(t) -> bool
    Does the type specify a 32-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

Help on function is_type_int64 in module ida_typeinf:

is_type_int64(*args) -> 'bool'
    is_type_int64(t) -> bool
    Does the type specify a 64-bit value? (signed or unsigned, see Basic type:
    integer)
    
    @param t: (C++: type_t)

Help on function is_type_integral in module ida_typeinf:

is_type_integral(*args) -> 'bool'
    is_type_integral(t) -> bool
    Is the type an integral type (char/short/int/long/bool)?
    
    @param t: (C++: type_t)

Help on function is_type_ldouble in module ida_typeinf:

is_type_ldouble(*args) -> 'bool'
    is_type_ldouble(t) -> bool
    See BTF_LDOUBLE.
    
    @param t: (C++: type_t)

Help on function is_type_paf in module ida_typeinf:

is_type_paf(*args) -> 'bool'
    is_type_paf(t) -> bool
    Is the type a pointer, array, or function type?
    
    @param t: (C++: type_t)

Help on function is_type_partial in module ida_typeinf:

is_type_partial(*args) -> 'bool'
    is_type_partial(t) -> bool
    Identifies an unknown or void type with a known size (see Basic type: unknown &
    void)
    
    @param t: (C++: type_t)

Help on function is_type_ptr in module ida_typeinf:

is_type_ptr(*args) -> 'bool'
    is_type_ptr(t) -> bool
    See BT_PTR.
    
    @param t: (C++: type_t)

Help on function is_type_ptr_or_array in module ida_typeinf:

is_type_ptr_or_array(*args) -> 'bool'
    is_type_ptr_or_array(t) -> bool
    Is the type a pointer or array type?
    
    @param t: (C++: type_t)

Help on function is_type_struct in module ida_typeinf:

is_type_struct(*args) -> 'bool'
    is_type_struct(t) -> bool
    See BTF_STRUCT.
    
    @param t: (C++: type_t)

Help on function is_type_struni in module ida_typeinf:

is_type_struni(*args) -> 'bool'
    is_type_struni(t) -> bool
    Is the type a struct or union?
    
    @param t: (C++: type_t)

Help on function is_type_sue in module ida_typeinf:

is_type_sue(*args) -> 'bool'
    is_type_sue(t) -> bool
    Is the type a struct/union/enum?
    
    @param t: (C++: type_t)

Help on function is_type_tbyte in module ida_typeinf:

is_type_tbyte(*args) -> 'bool'
    is_type_tbyte(t) -> bool
    See BTF_FLOAT.
    
    @param t: (C++: type_t)

Help on function is_type_typedef in module ida_typeinf:

is_type_typedef(*args) -> 'bool'
    is_type_typedef(t) -> bool
    See BTF_TYPEDEF.
    
    @param t: (C++: type_t)

Help on function is_type_uchar in module ida_typeinf:

is_type_uchar(*args) -> 'bool'
    is_type_uchar(t) -> bool
    See BTF_UCHAR.
    
    @param t: (C++: type_t)

Help on function is_type_uint in module ida_typeinf:

is_type_uint(*args) -> 'bool'
    is_type_uint(t) -> bool
    See BTF_UINT.
    
    @param t: (C++: type_t)

Help on function is_type_uint128 in module ida_typeinf:

is_type_uint128(*args) -> 'bool'
    is_type_uint128(t) -> bool
    See BTF_UINT128.
    
    @param t: (C++: type_t)

Help on function is_type_uint16 in module ida_typeinf:

is_type_uint16(*args) -> 'bool'
    is_type_uint16(t) -> bool
    See BTF_UINT16.
    
    @param t: (C++: type_t)

Help on function is_type_uint32 in module ida_typeinf:

is_type_uint32(*args) -> 'bool'
    is_type_uint32(t) -> bool
    See BTF_UINT32.
    
    @param t: (C++: type_t)

Help on function is_type_uint64 in module ida_typeinf:

is_type_uint64(*args) -> 'bool'
    is_type_uint64(t) -> bool
    See BTF_UINT64.
    
    @param t: (C++: type_t)

Help on function is_type_union in module ida_typeinf:

is_type_union(*args) -> 'bool'
    is_type_union(t) -> bool
    See BTF_UNION.
    
    @param t: (C++: type_t)

Help on function is_type_unknown in module ida_typeinf:

is_type_unknown(*args) -> 'bool'
    is_type_unknown(t) -> bool
    See BT_UNKNOWN.
    
    @param t: (C++: type_t)

Help on function is_type_void in module ida_typeinf:

is_type_void(*args) -> 'bool'
    is_type_void(t) -> bool
    See BTF_VOID.
    
    @param t: (C++: type_t)

Help on function is_type_volatile in module ida_typeinf:

is_type_volatile(*args) -> 'bool'
    is_type_volatile(t) -> bool
    See BTM_VOLATILE.
    
    @param t: (C++: type_t)

Help on function is_typeid_last in module ida_typeinf:

is_typeid_last(*args) -> 'bool'
    is_typeid_last(t) -> bool
    Is the type_t the last byte of type declaration? (there are no additional bytes
    after a basic type, see _BT_LAST_BASIC)
    
    @param t: (C++: type_t)

Help on function is_user_cc in module ida_typeinf:

is_user_cc(*args) -> 'bool'
    is_user_cc(cm) -> bool
    Does the calling convention specify argument locations explicitly?
    
    @param cm: (C++: cm_t)

Help on function is_vararg_cc in module ida_typeinf:

is_vararg_cc(*args) -> 'bool'
    is_vararg_cc(cm) -> bool
    Does the calling convention use ellipsis?
    
    @param cm: (C++: cm_t)

Help on function lexcompare_tinfo in module ida_typeinf:

lexcompare_tinfo(*args) -> 'int'
    lexcompare_tinfo(t1, t2, arg3) -> int
    
    @param t1: uint32
    @param t2: uint32
    @param arg3: int

Help on function load_til in module ida_typeinf:

load_til(*args) -> 'qstring *'
    load_til(name, tildir=None) -> til_t
    Load til from a file without adding it to the database list (see also add_til).
    Failure to load base tils are reported into 'errbuf'. They do not prevent
    loading of the main til.
    
    @param name: (C++: const char *) filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    @param tildir: (C++: const char *) directory where to load the til from. nullptr means default til
                   subdirectories.
    @return: pointer to resulting til, nullptr if failed and error message is in
             errbuf

Help on function load_til_header in module ida_typeinf:

load_til_header(*args) -> 'qstring *'
    load_til_header(tildir, name) -> til_t
    Get human-readable til description.
    
    @param tildir: (C++: const char *) char const *
    @param name: (C++: const char *) char const *

Help on function lower_type in module ida_typeinf:

lower_type(*args) -> 'int'
    lower_type(til, tif, name=None, _helper=None) -> int
    Lower type. Inspect the type and lower all function subtypes using
    lower_func_type().
    We call the prototypes usually encountered in source files "high level"
    They may have implicit arguments, array arguments, big structure retvals, etc
    We introduce explicit arguments (i.e. 'this' pointer) and call the result
    "low level prototype". See FTI_HIGH.
    
    In order to improve heuristics for recognition of big structure retvals,
    it is recommended to pass a helper that will be used to make decisions.
    That helper will be used only for lowering 'tif', and not for the children
    types walked through by recursion.
    @retval 1: removed FTI_HIGH,
    @retval 2: made substantial changes
    @retval -1: failure
    
    @param til: (C++: til_t *)
    @param tif: (C++: tinfo_t *)
    @param name: (C++: const char *) char const *
    @param _helper: (C++: lowertype_helper_t *)

Help on class lowertype_helper_t in module ida_typeinf:

class lowertype_helper_t(builtins.object)
 |  Proxy of C++ lowertype_helper_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_lowertype_helper_t(...)
 |      delete_lowertype_helper_t(self)
 |  
 |  func_has_stkframe_hole(self, *args) -> 'bool'
 |      func_has_stkframe_hole(self, candidate, candidate_data) -> bool
 |      
 |      @param candidate: tinfo_t const &
 |      @param candidate_data: func_type_data_t const &
 |  
 |  get_func_purged_bytes(self, *args) -> 'int'
 |      get_func_purged_bytes(self, candidate, candidate_data) -> int
 |      
 |      @param candidate: tinfo_t const &
 |      @param candidate_data: func_type_data_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function new_til in module ida_typeinf:

new_til(*args) -> 'til_t *'
    new_til(name, desc) -> til_t
    Initialize a til.
    
    @param name: (C++: const char *) char const *
    @param desc: (C++: const char *) char const *

Help on function next_named_type in module ida_typeinf:

next_named_type(*args) -> 'char const *'
    next_named_type(ti, name, ntf_flags) -> char const *
    Enumerate types.
    
    @param ti: (C++: const til_t *) type library. nullptr means the local type library for the current
               database.
    @param name: (C++: const char *) the current name. the name that follows this one will be returned.
    @param ntf_flags: (C++: int) combination of Flags for named types
    @return: Type or symbol names, depending of ntf_flags. Returns mangled names.
             Never returns anonymous types. To include them, enumerate types by
             ordinals.

Help on function optimize_argloc in module ida_typeinf:

optimize_argloc(*args) -> 'bool'
    optimize_argloc(vloc, size, gaps) -> bool
    Verify and optimize scattered argloc into simple form. All new arglocs must be
    processed by this function.
    @retval true: success
    @retval false: the input argloc was illegal
    
    @param vloc: (C++: argloc_t *)
    @param size: (C++: int)
    @param gaps: (C++: const rangeset_t *) rangeset_t const *

Help on function pack_idcobj_to_bv in module ida_typeinf:

pack_idcobj_to_bv(*args) -> 'error_t'
    pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t
    Write a typed idc object to the byte vector. Byte vector may be non-empty, this
    function will append data to it
    
    @param obj: (C++: const idc_value_t *) idc_value_t const *
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param bytes: (C++: relobj_t *)
    @param objoff: (C++: void *)
    @param pio_flags: (C++: int)

Help on function pack_idcobj_to_idb in module ida_typeinf:

pack_idcobj_to_idb(*args) -> 'error_t'
    pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t
    Write a typed idc object to the database.
    
    @param obj: (C++: const idc_value_t *) idc_value_t const *
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param ea: (C++: ea_t)
    @param pio_flags: (C++: int)

Help on function pack_object_to_bv in module ida_typeinf:

pack_object_to_bv(*args) -> 'PyObject *'
    pack_object_to_bv(py_obj, ti, type, fields, base_ea, pio_flags=0) -> PyObject *
    Packs a typed object to a string
    
    @param py_obj: PyObject *
    @param ti: Type info. 'None' can be passed.
    @param type: type_t const *
    @param fields: fields string (may be empty or None)
    @param base_ea: base ea used to relocate the pointers in the packed object
    @param pio_flags: flags used while unpacking
    @return:     tuple(0, err_code) on failure
        tuple(1, packed_buf) on success

Help on function pack_object_to_idb in module ida_typeinf:

pack_object_to_idb(*args) -> 'PyObject *'
    pack_object_to_idb(py_obj, ti, type, fields, ea, pio_flags=0) -> PyObject *
    Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    @param py_obj: PyObject *
    @param ti: Type info. 'None' can be passed.
    @param type: type_t const *
    @param fields: fields string (may be empty or None)
    @param ea: ea to be used while packing
    @param pio_flags: flags used while unpacking

Help on function parse_decl in module ida_typeinf:

parse_decl(*args) -> 'qstring *'
    parse_decl(tif, til, decl, flags) -> str
    Parse ONE declaration. If the input string contains more than one declaration,
    the first complete type declaration (PT_TYP) or the last variable declaration
    (PT_VAR) will be used.
    @note: name & tif may be empty after the call!
    
    @param tif: (C++: tinfo_t *) type info
    @param til: (C++: til_t *) type library to use. may be nullptr
    @param decl: (C++: const char *) C declaration to parse
    @param flags: (C++: int) combination of Type parsing flags bits
    @retval true: ok
    @retval false: declaration is bad, the error message is displayed if !PT_SIL

Help on function parse_decls in module ida_typeinf:

parse_decls(*args) -> 'int'
    parse_decls(til, input, printer, hti_flags) -> int
    Parse many declarations and store them in a til. If there are any errors, they
    will be printed using 'printer'. This function uses default include path and
    predefined macros from the database settings. It always uses the HTI_DCL bit.
    
    @param til: (C++: til_t *) type library to store the result
    @param input: (C++: const char *) input string or file name (see hti_flags)
    @param printer: (C++: printer_t *) function to output error messages (use msg or nullptr or your
                    own callback)
    @param hti_flags: (C++: int) combination of Type formatting flags
    @return: number of errors, 0 means ok.

Help on class predicate_t in module ida_typeinf:

class predicate_t(builtins.object)
 |  Proxy of C++ predicate_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> predicate_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_predicate_t(...)
 |      delete_predicate_t(self)
 |  
 |  should_display(self, *args) -> 'bool'
 |      should_display(self, til, name, type, fields) -> bool
 |      
 |      @param til: til_t const *
 |      @param name: char const *
 |      @param type: type_t const *
 |      @param fields: p_list const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function print_argloc in module ida_typeinf:

print_argloc(*args) -> 'size_t'
    print_argloc(vloc, size=0, vflags=0) -> str
    Convert an argloc to human readable form.
    
    @param vloc: (C++: const argloc_t &) argloc_t const &
    @param size: (C++: int)
    @param vflags: (C++: int)

Help on function print_decls in module ida_typeinf:

print_decls(*args) -> 'PyObject *'
    print_decls(printer, til, py_ordinals, flags) -> int
    Print types (and possibly their dependencies) in a format suitable for using in
    a header file. This is the reverse parse_decls().
    
    @param printer: (C++: text_sink_t &) a handler for printing text
    @param til: (C++: til_t *) the type library holding the ordinals
    @param py_ordinals: ordinals of types to export. nullptr means: all ordinals in til
    @param pdf_flags: (C++: uint32) flags for the algorithm. A combination of PDF_ constants
    @retval >0: the number of types exported
    @retval 0: an error occurred
    @retval <0: the negated number of types exported. There were minor errors and
                the resulting output might not be compilable.

Help on function print_tinfo in module ida_typeinf:

print_tinfo(*args) -> 'qstring *'
    print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> str
    
    @param prefix: char const *
    @param indent: int
    @param cmtindent: int
    @param flags: int
    @param tif: tinfo_t const *
    @param name: char const *
    @param cmt: char const *

Help on function print_type in module ida_typeinf:

print_type(*args) -> 'qstring *'
    print_type(ea, prtype_flags) -> str
    Get type declaration for the specified address.
    
    @param ea: (C++: ea_t) address
    @param prtype_flags: (C++: int) combination of Type printing flags
    @return: success

Help on class ptr_type_data_t in module ida_typeinf:

class ptr_type_data_t(builtins.object)
 |  Proxy of C++ ptr_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: ptr_type_data_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -> ptr_type_data_t
 |      
 |      @param c: tinfo_t
 |      @param bps: uchar
 |      @param p: tinfo_t
 |      @param d: int32
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: ptr_type_data_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_ptr_type_data_t(...)
 |      delete_ptr_type_data_t(self)
 |  
 |  is_code_ptr(self, *args) -> 'bool'
 |      is_code_ptr(self) -> bool
 |      Are we pointing to code?
 |  
 |  is_shifted(self, *args) -> 'bool'
 |      is_shifted(self) -> bool
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Set this = r and r = this.
 |      
 |      @param r: (C++: ptr_type_data_t &)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  based_ptr_size
 |      based_ptr_size
 |  
 |  closure
 |      closure
 |  
 |  delta
 |      delta
 |  
 |  obj_type
 |      obj_type
 |  
 |  parent
 |      parent
 |  
 |  taptr_bits
 |      taptr_bits
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function read_tinfo_bitfield_value in module ida_typeinf:

read_tinfo_bitfield_value(*args) -> 'uint64'
    read_tinfo_bitfield_value(typid, v, bitoff) -> uint64
    
    @param typid: uint32
    @param v: uint64
    @param bitoff: int

Help on class reginfovec_t in module ida_typeinf:

class reginfovec_t(builtins.object)
 |  Proxy of C++ qvector< reg_info_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< reg_info_t > const &
 |  
 |  __getitem__(self, *args) -> 'reg_info_t const &'
 |      __getitem__(self, i) -> reg_info_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> reginfovec_t
 |      __init__(self, x) -> reginfovec_t
 |      
 |      @param x: qvector< reg_info_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< reg_info_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: reg_info_t const &
 |  
 |  __swig_destroy__ = delete_reginfovec_t(...)
 |      delete_reginfovec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: reg_info_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: reg_info_t const &
 |  
 |  append = push_back(self, *args) -> 'reg_info_t &'
 |  
 |  at = __getitem__(self, *args) -> 'reg_info_t const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< reg_info_t >::const_iterator'
 |      begin(self) -> reg_info_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< reg_info_t >::const_iterator'
 |      end(self) -> reg_info_t
 |  
 |  erase(self, *args) -> 'qvector< reg_info_t >::iterator'
 |      erase(self, it) -> reg_info_t
 |      
 |      @param it: qvector< reg_info_t >::iterator
 |      
 |      erase(self, first, last) -> reg_info_t
 |      
 |      @param first: qvector< reg_info_t >::iterator
 |      @param last: qvector< reg_info_t >::iterator
 |  
 |  extract(self, *args) -> 'reg_info_t *'
 |      extract(self) -> reg_info_t
 |  
 |  find(self, *args) -> 'qvector< reg_info_t >::const_iterator'
 |      find(self, x) -> reg_info_t
 |      
 |      @param x: reg_info_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=reg_info_t())
 |      
 |      @param x: reg_info_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: reg_info_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: reg_info_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< reg_info_t >::iterator'
 |      insert(self, it, x) -> reg_info_t
 |      
 |      @param it: qvector< reg_info_t >::iterator
 |      @param x: reg_info_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'reg_info_t &'
 |      push_back(self, x)
 |      
 |      @param x: reg_info_t const &
 |      
 |      push_back(self) -> reg_info_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: reg_info_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< reg_info_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class regobj_t in module ida_typeinf:

class regobj_t(builtins.object)
 |  Proxy of C++ regobj_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobj_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regobj_t(...)
 |      delete_regobj_t(self)
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  regidx
 |      regidx
 |  
 |  relocate
 |      relocate
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value

Help on class regobjs_t in module ida_typeinf:

class regobjs_t(regobjvec_t)
 |  Proxy of C++ regobjs_t class.
 |  
 |  Method resolution order:
 |      regobjs_t
 |      regobjvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobjs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_regobjs_t(...)
 |      delete_regobjs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from regobjvec_t:
 |  
 |  __getitem__(self, *args) -> 'regobj_t const &'
 |      __getitem__(self, i) -> regobj_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: regobj_t const &
 |  
 |  at(self, *args) -> 'regobj_t const &'
 |      at(self, _idx) -> regobj_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      begin(self) -> regobj_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      end(self) -> regobj_t
 |  
 |  erase(self, *args) -> 'qvector< regobj_t >::iterator'
 |      erase(self, it) -> regobj_t
 |      
 |      @param it: qvector< regobj_t >::iterator
 |      
 |      erase(self, first, last) -> regobj_t
 |      
 |      @param first: qvector< regobj_t >::iterator
 |      @param last: qvector< regobj_t >::iterator
 |  
 |  extract(self, *args) -> 'regobj_t *'
 |      extract(self) -> regobj_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=regobj_t())
 |      
 |      @param x: regobj_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: regobj_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< regobj_t >::iterator'
 |      insert(self, it, x) -> regobj_t
 |      
 |      @param it: qvector< regobj_t >::iterator
 |      @param x: regobj_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'regobj_t &'
 |      push_back(self, x)
 |      
 |      @param x: regobj_t const &
 |      
 |      push_back(self) -> regobj_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: regobj_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< regobj_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from regobjvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class regobjvec_t in module ida_typeinf:

class regobjvec_t(builtins.object)
 |  Proxy of C++ qvector< regobj_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'regobj_t const &'
 |      __getitem__(self, i) -> regobj_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> regobjvec_t
 |      __init__(self, x) -> regobjvec_t
 |      
 |      @param x: qvector< regobj_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: regobj_t const &
 |  
 |  __swig_destroy__ = delete_regobjvec_t(...)
 |      delete_regobjvec_t(self)
 |  
 |  at(self, *args) -> 'regobj_t const &'
 |      at(self, _idx) -> regobj_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      begin(self) -> regobj_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< regobj_t >::const_iterator'
 |      end(self) -> regobj_t
 |  
 |  erase(self, *args) -> 'qvector< regobj_t >::iterator'
 |      erase(self, it) -> regobj_t
 |      
 |      @param it: qvector< regobj_t >::iterator
 |      
 |      erase(self, first, last) -> regobj_t
 |      
 |      @param first: qvector< regobj_t >::iterator
 |      @param last: qvector< regobj_t >::iterator
 |  
 |  extract(self, *args) -> 'regobj_t *'
 |      extract(self) -> regobj_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=regobj_t())
 |      
 |      @param x: regobj_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: regobj_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< regobj_t >::iterator'
 |      insert(self, it, x) -> regobj_t
 |      
 |      @param it: qvector< regobj_t >::iterator
 |      @param x: regobj_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'regobj_t &'
 |      push_back(self, x)
 |      
 |      @param x: regobj_t const &
 |      
 |      push_back(self) -> regobj_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: regobj_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< regobj_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function remove_abi_opts in module ida_typeinf:

remove_abi_opts(*args) -> 'bool'
    remove_abi_opts(abi_opts, user_level=False) -> bool
    
    @param abi_opts: char const *
    @param user_level: bool

Help on function remove_pointer in module ida_typeinf:

remove_pointer(*args) -> 'tinfo_t'
    remove_pointer(tif) -> tinfo_t
    
    @param BT_PTR: If the current type is a pointer, return the pointed object. If the
    current type is not a pointer, return the current type. See also
    get_ptrarr_object() and get_pointed_object()

Help on function remove_tinfo_pointer in module ida_typeinf:

remove_tinfo_pointer(*args) -> 'PyObject *'
    remove_tinfo_pointer(tif, name, til) -> (bool, NoneType), (bool, str)
    Remove pointer of a type. (i.e. convert "char *" into "char"). Optionally remove
    the "lp" (or similar) prefix of the input name. If the input type is not a
    pointer, then fail.
    
    @param tif: (C++: tinfo_t *)
    @param name: char const *
    @param til: (C++: const til_t *) til_t const *

Help on function replace_ordinal_typerefs in module ida_typeinf:

replace_ordinal_typerefs(*args) -> 'int'
    replace_ordinal_typerefs(til, tif) -> int
    Replace references to ordinal types by name references. This function 'unties'
    the type from the current local type library and makes it easier to export it.
    
    @param til: (C++: til_t *) type library to use. may be nullptr.
    @param tif: (C++: tinfo_t *) type to modify (in/out)
    @retval number: of replaced subtypes, -1 on failure

Help on function resolve_typedef in module ida_typeinf:

resolve_typedef(*args) -> 'type_t const *'
    resolve_typedef(til, type) -> type_t const *
    
    @param til: til_t const *
    @param type: type_t const *

Help on class rrel_t in module ida_typeinf:

class rrel_t(builtins.object)
 |  Proxy of C++ rrel_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> rrel_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_rrel_t(...)
 |      delete_rrel_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  off
 |      off
 |  
 |  reg
 |      reg
 |  
 |  thisown
 |      The membership flag

Help on function save_tinfo in module ida_typeinf:

save_tinfo(*args) -> 'tinfo_code_t'
    save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t
    
    @param tif: tinfo_t *
    @param til: til_t *
    @param ord: size_t
    @param name: char const *
    @param ntf_flags: int

Help on class scattered_aloc_t in module ida_typeinf:

class scattered_aloc_t(argpartvec_t)
 |  Proxy of C++ scattered_aloc_t class.
 |  
 |  Method resolution order:
 |      scattered_aloc_t
 |      argpartvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> scattered_aloc_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_scattered_aloc_t(...)
 |      delete_scattered_aloc_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from argpartvec_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< argpart_t > const &
 |  
 |  __getitem__(self, *args) -> 'argpart_t const &'
 |      __getitem__(self, i) -> argpart_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< argpart_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: argpart_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: argpart_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: argpart_t const &
 |  
 |  at(self, *args) -> 'argpart_t const &'
 |      at(self, _idx) -> argpart_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      begin(self) -> argpart_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      end(self) -> argpart_t
 |  
 |  erase(self, *args) -> 'qvector< argpart_t >::iterator'
 |      erase(self, it) -> argpart_t
 |      
 |      @param it: qvector< argpart_t >::iterator
 |      
 |      erase(self, first, last) -> argpart_t
 |      
 |      @param first: qvector< argpart_t >::iterator
 |      @param last: qvector< argpart_t >::iterator
 |  
 |  extract(self, *args) -> 'argpart_t *'
 |      extract(self) -> argpart_t
 |  
 |  find(self, *args) -> 'qvector< argpart_t >::const_iterator'
 |      find(self, x) -> argpart_t
 |      
 |      @param x: argpart_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=argpart_t())
 |      
 |      @param x: argpart_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: argpart_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: argpart_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< argpart_t >::iterator'
 |      insert(self, it, x) -> argpart_t
 |      
 |      @param it: qvector< argpart_t >::iterator
 |      @param x: argpart_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'argpart_t &'
 |      push_back(self, x)
 |      
 |      @param x: argpart_t const &
 |      
 |      push_back(self) -> argpart_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: argpart_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< argpart_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from argpartvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from argpartvec_t:
 |  
 |  __hash__ = None

Help on function score_tinfo in module ida_typeinf:

score_tinfo(*args) -> 'uint32'
    score_tinfo(tif) -> uint32
    
    @param tif: tinfo_t const *

Help on function serialize_tinfo in module ida_typeinf:

serialize_tinfo(*args) -> 'bool'
    serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool
    
    @param type: qtype *
    @param fields: qtype *
    @param fldcmts: qtype *
    @param tif: tinfo_t const *
    @param sudt_flags: int

Help on function set_abi_name in module ida_typeinf:

set_abi_name(*args) -> 'bool'
    set_abi_name(abiname, user_level=False) -> bool
    Set abi name (see Compiler IDs)
    
    @param abiname: (C++: const char *) char const *
    @param user_level: (C++: bool)

Help on function set_c_header_path in module ida_typeinf:

set_c_header_path(*args) -> 'void'
    set_c_header_path(incdir)
    Set include directory path the target compiler.
    
    @param incdir: (C++: const char *) char const *

Help on function set_c_macros in module ida_typeinf:

set_c_macros(*args) -> 'void'
    set_c_macros(macros)
    Set predefined macros for the target compiler.
    
    @param macros: (C++: const char *) char const *

Help on function set_compiler in module ida_typeinf:

set_compiler(*args) -> 'bool'
    set_compiler(cc, flags, abiname=None) -> bool
    Change current compiler.
    
    @param cc: (C++: const compiler_info_t &) compiler to switch to
    @param flags: (C++: int) Set compiler flags
    @param abiname: (C++: const char *) ABI name
    @return: success

Help on function set_compiler_id in module ida_typeinf:

set_compiler_id(*args) -> 'bool'
    set_compiler_id(id, abiname=None) -> bool
    Set the compiler id (see Compiler IDs)
    
    @param id: (C++: comp_t)
    @param abiname: (C++: const char *) char const *

Help on function set_compiler_string in module ida_typeinf:

set_compiler_string(*args) -> 'bool'
    set_compiler_string(compstr, user_level) -> bool
    
    @param compstr: (C++: const char *) - compiler description in form <abbr>:<abiname>
    @param user_level: (C++: bool) - initiated by user if TRUE
    @return: success

Help on function set_numbered_type in module ida_typeinf:

set_numbered_type(*args) -> 'tinfo_code_t'
    set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t
    Store a type in the til. 'name' may be nullptr for anonymous types. The
    specified ordinal must be free (no other type is using it). For ntf_flags, only
    NTF_REPLACE is consulted.
    
    @param ti: (C++: til_t *)
    @param ordinal: (C++: uint32)
    @param ntf_flags: (C++: int)
    @param name: (C++: const char *) char const *
    @param type: (C++: const type_t *) type_t const *
    @param fields: (C++: const p_list *) p_list const *
    @param cmt: (C++: const char *) char const *
    @param fldcmts: (C++: const p_list *) p_list const *
    @param sclass: (C++: const sclass_t *) sclass_t const *

Help on function set_tinfo_attr in module ida_typeinf:

set_tinfo_attr(*args) -> 'bool'
    set_tinfo_attr(tif, ta, may_overwrite) -> bool
    
    @param tif: tinfo_t *
    @param ta: type_attr_t const &
    @param may_overwrite: bool

Help on function set_tinfo_attrs in module ida_typeinf:

set_tinfo_attrs(*args) -> 'bool'
    set_tinfo_attrs(tif, ta) -> bool
    
    @param tif: tinfo_t *
    @param ta: type_attrs_t *

Help on function set_tinfo_property in module ida_typeinf:

set_tinfo_property(*args) -> 'size_t'
    set_tinfo_property(tif, sta_prop, x) -> size_t
    
    @param tif: tinfo_t *
    @param sta_prop: int
    @param x: size_t

Help on function set_type_alias in module ida_typeinf:

set_type_alias(*args) -> 'bool'
    set_type_alias(ti, src_ordinal, dst_ordinal) -> bool
    Create a type alias. Redirects all references to source type to the destination
    type. This is equivalent to instantaneous replacement all reference to srctype
    by dsttype.
    
    @param ti: (C++: til_t *)
    @param src_ordinal: (C++: uint32)
    @param dst_ordinal: (C++: uint32)

Help on function set_vftable_ea in module ida_typeinf:

set_vftable_ea(*args) -> 'bool'
    set_vftable_ea(ordinal, vftable_ea) -> bool
    Set the address of a vftable instance for a vftable type.
    
    @param ordinal: (C++: uint32) ordinal number of the corresponding vftable type.
    @param vftable_ea: (C++: ea_t) address of a virtual function table.
    @return: success

Help on class simd_info_t in module ida_typeinf:

class simd_info_t(builtins.object)
 |  Proxy of C++ simd_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, nm=None, sz=0, memt=BTF_UNK) -> simd_info_t
 |      
 |      @param nm: char const *
 |      @param sz: uint16
 |      @param memt: type_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_simd_info_t(...)
 |      delete_simd_info_t(self)
 |  
 |  match_pattern(self, *args) -> 'bool'
 |      match_pattern(self, pattern) -> bool
 |      
 |      @param pattern: simd_info_t const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  memtype
 |      memtype
 |  
 |  name
 |      name
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag
 |  
 |  tif
 |      tif

Help on class stkarg_area_info_t in module ida_typeinf:

class stkarg_area_info_t(builtins.object)
 |  Proxy of C++ stkarg_area_info_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> stkarg_area_info_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_stkarg_area_info_t(...)
 |      delete_stkarg_area_info_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cb
 |      cb
 |  
 |  linkage_area
 |      linkage_area
 |  
 |  shadow_size
 |      shadow_size
 |  
 |  stkarg_offset
 |      stkarg_offset
 |  
 |  thisown
 |      The membership flag

Help on function store_til in module ida_typeinf:

store_til(*args) -> 'bool'
    store_til(ti, tildir, name) -> bool
    Store til to a file. If the til contains garbage, it will be collected before
    storing the til. Your plugin should call compact_til() before calling
    store_til().
    
    @param ti: (C++: til_t *) type library to store
    @param tildir: (C++: const char *) directory where to store the til. nullptr means current
                   directory.
    @param name: (C++: const char *) filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    @return: success

Help on function switch_to_golang in module ida_typeinf:

switch_to_golang(*args) -> 'void'
    switch_to_golang()
    switch to GOLANG calling convention (to be used as default CC)

Help on class text_sink_t in module ida_typeinf:

class text_sink_t(builtins.object)
 |  Proxy of C++ text_sink_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> text_sink_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_text_sink_t(...)
 |      delete_text_sink_t(self)
 |  
 |  _print(self, *args) -> 'int'
 |      _print(self, str) -> int
 |      
 |      Parameters
 |      ----------
 |      str: char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class til_symbol_t in module ida_typeinf:

class til_symbol_t(builtins.object)
 |  Proxy of C++ til_symbol_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, n=None, t=None) -> til_symbol_t
 |      
 |      @param n: char const *
 |      @param t: til_t const *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_til_symbol_t(...)
 |      delete_til_symbol_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  til
 |      til

Help on class til_t in module ida_typeinf:

class til_t(builtins.object)
 |  Proxy of C++ til_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> til_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_til_t(...)
 |      delete_til_t(self)
 |  
 |  base(self, *args) -> 'til_t *'
 |      base(self, n) -> til_t
 |      tils that our til is based on
 |      
 |      @param n: int
 |  
 |  is_dirty(self, *args) -> 'bool'
 |      is_dirty(self) -> bool
 |      Has the til been modified? (TIL_MOD)
 |  
 |  set_dirty(self, *args) -> 'void'
 |      set_dirty(self)
 |      Mark the til as modified (TIL_MOD)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cc
 |      cc
 |  
 |  desc
 |      desc
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  nbases
 |      nbases
 |  
 |  nrefs
 |      nrefs
 |  
 |  nstreams
 |      nstreams
 |  
 |  streams
 |      streams
 |  
 |  thisown
 |      The membership flag

Help on class tinfo_t in module ida_typeinf:

class tinfo_t(builtins.object)
 |  Proxy of C++ tinfo_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  __gt__(self, *args) -> 'bool'
 |      __gt__(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> tinfo_t
 |      __init__(self, decl_type) -> tinfo_t
 |      
 |      @param decl_type: type_t
 |      
 |      __init__(self, r) -> tinfo_t
 |      
 |      @param r: tinfo_t const &
 |  
 |  __le__(self, *args) -> 'bool'
 |      __le__(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __str__(self, *args) -> 'qstring'
 |      __str__(self) -> qstring
 |  
 |  __swig_destroy__ = delete_tinfo_t(...)
 |      delete_tinfo_t(self)
 |  
 |  _print(self, *args) -> 'bool'
 |      _print(self, name=None, prtype_flags=0, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
 |      
 |      Parameters
 |      ----------
 |      name: char const *
 |      prtype_flags: int
 |      indent: int
 |      cmtindent: int
 |      prefix: char const *
 |      cmt: char const *
 |  
 |  append_covered(self, *args) -> 'bool'
 |      append_covered(self, out, offset=0) -> bool
 |      Calculate set of covered bytes for the type
 |      
 |      @param out: (C++: rangeset_t *) pointer to the output buffer. covered bytes will be appended to it.
 |      @param offset: (C++: uint64) delta in bytes to add to all calculations. used internally during
 |                     recurion.
 |  
 |  calc_gaps(self, *args) -> 'bool'
 |      calc_gaps(self, out) -> bool
 |      Calculate set of padding bytes for the type
 |      
 |      @param out: (C++: rangeset_t *) pointer to the output buffer; old buffer contents will be lost.
 |  
 |  calc_purged_bytes(self, *args) -> 'int'
 |      calc_purged_bytes(self) -> int
 |  
 |  calc_score(self, *args) -> 'uint32'
 |      calc_score(self) -> uint32
 |      Calculate the type score (the higher - the nicer is the type)
 |  
 |  calc_udt_aligns(self, *args) -> 'bool'
 |      calc_udt_aligns(self, sudt_flags=0x0004) -> bool
 |      Calculate the udt alignments using the field offsets/sizes and the total udt
 |      size This function does not work on typerefs
 |      
 |      @param sudt_flags: (C++: int)
 |  
 |  change_sign(self, *args) -> 'bool'
 |      change_sign(self, sign) -> bool
 |      Change the type sign. Works only for the types that may have sign.
 |      
 |      @param sign: (C++: type_sign_t)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |      Clear contents of this tinfo, and remove from the type system.
 |  
 |  clr_const(self, *args) -> 'void'
 |      clr_const(self)
 |  
 |  clr_const_volatile(self, *args) -> 'void'
 |      clr_const_volatile(self)
 |  
 |  clr_volatile(self, *args) -> 'void'
 |      clr_volatile(self)
 |  
 |  compare(self, *args) -> 'int'
 |      compare(self, r) -> int
 |      
 |      @param r: tinfo_t const &
 |  
 |  compare_with(self, *args) -> 'bool'
 |      compare_with(self, r, tcflags=0) -> bool
 |      Compare two types, based on given flags (see tinfo_t comparison flags)
 |      
 |      @param r: (C++: const tinfo_t &) tinfo_t const &
 |      @param tcflags: (C++: int)
 |  
 |  convert_array_to_ptr(self, *args) -> 'bool'
 |      convert_array_to_ptr(self) -> bool
 |      Convert an array into a pointer. type[] => type *
 |  
 |  copy(self, *args) -> 'tinfo_t'
 |      copy(self) -> tinfo_t
 |  
 |  create_array(self, *args) -> 'bool'
 |      create_array(self, p, decl_type=BT_ARRAY) -> bool
 |      
 |      @param p: array_type_data_t const &
 |      @param decl_type: type_t
 |      
 |      create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
 |      
 |      @param tif: tinfo_t const &
 |      @param nelems: uint32
 |      @param base: uint32
 |      @param decl_type: type_t
 |  
 |  create_bitfield(self, *args) -> 'bool'
 |      create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
 |      
 |      @param p: bitfield_type_data_t const &
 |      @param decl_type: type_t
 |      
 |      create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
 |      
 |      @param nbytes: uchar
 |      @param width: uchar
 |      @param is_unsigned: bool
 |      @param decl_type: type_t
 |  
 |  create_enum(self, *args) -> 'bool'
 |      create_enum(self, p, decl_type=BTF_ENUM) -> bool
 |      
 |      @param p: enum_type_data_t &
 |      @param decl_type: type_t
 |  
 |  create_forward_decl(self, *args) -> 'tinfo_code_t'
 |      create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
 |      Create a forward declaration. decl_type: BTF_STRUCT, BTF_UNION, or BTF_ENUM
 |      
 |      @param til: (C++: til_t *)
 |      @param decl_type: (C++: type_t)
 |      @param name: (C++: const char *) char const *
 |      @param ntf_flags: (C++: int)
 |  
 |  create_func(self, *args) -> 'bool'
 |      create_func(self, p, decl_type=BT_FUNC) -> bool
 |      
 |      @param p: func_type_data_t &
 |      @param decl_type: type_t
 |  
 |  create_ptr(self, *args) -> 'bool'
 |      create_ptr(self, p, decl_type=BT_PTR) -> bool
 |      
 |      @param p: ptr_type_data_t const &
 |      @param decl_type: type_t
 |      
 |      create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
 |      
 |      @param tif: tinfo_t const &
 |      @param bps: uchar
 |      @param decl_type: type_t
 |  
 |  create_simple_type(self, *args) -> 'bool'
 |      create_simple_type(self, decl_type) -> bool
 |      
 |      @param decl_type: type_t
 |  
 |  create_typedef(self, *args) -> 'void'
 |      create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
 |      
 |      @param p: typedef_type_data_t const &
 |      @param decl_type: type_t
 |      @param try_ordinal: bool
 |      
 |      create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
 |      
 |      @param til: til_t const *
 |      @param name: char const *
 |      @param decl_type: type_t
 |      @param try_ordinal: bool
 |      
 |      create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
 |      
 |      @param til: til_t const *
 |      @param ord: uint
 |      @param decl_type: type_t
 |  
 |  create_udt(self, *args) -> 'bool'
 |      create_udt(self, p, decl_type) -> bool
 |      
 |      @param p: udt_type_data_t &
 |      @param decl_type: type_t
 |  
 |  del_attr(self, *args) -> 'bool'
 |      del_attr(self, key, make_copy=True) -> bool
 |      Del a type attribute. typerefs cannot be modified by this function.
 |      
 |      @param key: (C++: const qstring &) qstring const &
 |      @param make_copy: (C++: bool)
 |  
 |  del_attrs(self, *args) -> 'void'
 |      del_attrs(self)
 |      Del all type attributes. typerefs cannot be modified by this function.
 |  
 |  deserialize(self, *args) -> 'bool'
 |      deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
 |      Deserialize a type string into a tinfo_t object.
 |      
 |      @param til: (C++: const til_t *) til_t const *
 |      @param ptype: (C++: const qtype *) type_t const **
 |      @param pfields: (C++: const qtype *) p_list const **
 |      @param pfldcmts: (C++: const qtype *) p_list const **
 |      
 |      deserialize(self, til, type, fields, cmts=None) -> bool
 |      
 |      @param til: til_t const *
 |      @param type: type_t const *
 |      @param fields: p_list const *
 |      @param cmts: p_list const *
 |  
 |  dstr(self, *args) -> 'char const *'
 |      dstr(self) -> char const *
 |      Function to facilitate debugging.
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |      Was tinfo_t initialized with some type info or not?
 |  
 |  equals_to(self, *args) -> 'bool'
 |      equals_to(self, r) -> bool
 |      
 |      @param r: tinfo_t const &
 |  
 |  find_udt_member(self, *args) -> 'int'
 |      find_udt_member(self, udm, strmem_flags) -> int
 |      BTF_STRUCT,BTF_UNION: Find a udt member.
 |      * at the specified offset (STRMEM_OFFSET)
 |      * with the specified index (STRMEM_INDEX)
 |      * with the specified type (STRMEM_TYPE)
 |      * with the specified name (STRMEM_NAME)
 |      
 |      @param udm: (C++: struct udt_member_t *) udt_member_t *
 |      @param strmem_flags: (C++: int)
 |      @return: the index of the found member or -1
 |  
 |  get_array_details(self, *args) -> 'bool'
 |      get_array_details(self, ai) -> bool
 |      Get the array specific info.
 |      
 |      @param ai: (C++: array_type_data_t *)
 |  
 |  get_array_element(self, *args) -> 'tinfo_t'
 |      get_array_element(self) -> tinfo_t
 |  
 |  get_array_nelems(self, *args) -> 'int'
 |      get_array_nelems(self) -> int
 |  
 |  get_attr(self, *args) -> 'PyObject *'
 |      get_attr(self, key, all_attrs=True) -> str or None
 |      Get a type attribute.
 |      
 |      @param key: (C++: const qstring &) qstring const &
 |      @param all_attrs: (C++: bool)
 |  
 |  get_attrs(self, *args) -> 'bool'
 |      get_attrs(self, tav, all_attrs=False) -> bool
 |      Get type attributes (all_attrs: include attributes of referenced types, if any)
 |      
 |      @param tav: (C++: type_attrs_t *)
 |      @param all_attrs: (C++: bool)
 |  
 |  get_bitfield_details(self, *args) -> 'bool'
 |      get_bitfield_details(self, bi) -> bool
 |      Get the bitfield specific info.
 |      
 |      @param bi: (C++: bitfield_type_data_t *)
 |  
 |  get_declalign(self, *args) -> 'uchar'
 |      get_declalign(self) -> uchar
 |      Get declared alignment of the type.
 |  
 |  get_decltype(self, *args) -> 'type_t'
 |      get_decltype(self) -> type_t
 |      Get declared type (without resolving type references; they are returned as is).
 |      Obviously this is a very fast function and should be used instead of
 |      get_realtype() if possible.
 |  
 |  get_enum_base_type(self, *args) -> 'type_t'
 |      get_enum_base_type(self) -> type_t
 |      Get enum base type (convert enum to integer type) Returns BT_UNK if failed to
 |      convert
 |  
 |  get_enum_details(self, *args) -> 'bool'
 |      get_enum_details(self, ei) -> bool
 |      Get the enum specific info.
 |      
 |      @param ei: (C++: enum_type_data_t *)
 |  
 |  get_final_ordinal(self, *args) -> 'uint32'
 |      get_final_ordinal(self) -> uint32
 |      Get final type ordinal (0 is none)
 |  
 |  get_final_type_name(self, *args) -> 'bool'
 |      get_final_type_name(self) -> bool
 |      Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
 |      
 |      @return: the name of the last type in the chain (TYPEn). if there is no chain,
 |               returns TYPE1
 |  
 |  get_func_details(self, *args) -> 'bool'
 |      get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
 |      Get only the function specific info for this tinfo_t.
 |      
 |      @param fi: (C++: func_type_data_t *)
 |      @param gtd: (C++: gtd_func_t) enum gtd_func_t
 |  
 |  get_methods(self, *args) -> 'bool'
 |      get_methods(self, methods) -> bool
 |      
 |      @param BT_COMPLEX: get a list of member functions declared in this udt.
 |      @return: false if no member functions exist
 |  
 |  get_modifiers(self, *args) -> 'type_t'
 |      get_modifiers(self) -> type_t
 |  
 |  get_named_type(self, *args) -> 'bool'
 |      get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
 |      Create a tinfo_t object for an existing named type.
 |      
 |      @param til: (C++: const til_t *) type library to use
 |      @param name: (C++: const char *) name of the type to link to
 |      @param decl_type: (C++: type_t) if the reference was explicitly specified with the type tag
 |      (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may specify it.
 |      the kernel will accept only the specified tag after resolving
 |      the type. If the resolved type does not correspond to the
 |      explicitly specified tag, the type will be considered as undefined
 |      @param resolve: (C++: bool) true: immediately resolve the type and return success code.
 |      @param try_ordinal: (C++: bool) true: try to replace name reference by an ordinal reference
 |  
 |  get_nargs(self, *args) -> 'int'
 |      get_nargs(self) -> int
 |      BT_FUNC or BT_PTR BT_FUNC: Calculate number of arguments (-1 - error)
 |  
 |  get_next_type_name(self, *args) -> 'bool'
 |      get_next_type_name(self) -> bool
 |      Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
 |      
 |      @return: the name of the next type in the chain (TYPE2). if there is no chain,
 |               returns failure
 |  
 |  get_nth_arg(self, *args) -> 'tinfo_t'
 |      get_nth_arg(self, n) -> tinfo_t
 |      BT_FUNC or BT_PTR BT_FUNC: Get type of n-th arg (-1 means return type, see
 |      get_rettype())
 |      
 |      @param n: (C++: int)
 |  
 |  get_numbered_type(self, *args) -> 'bool'
 |      get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
 |      Create a tinfo_t object for an existing ordinal type.
 |      
 |      @param til: (C++: const til_t *) type library to use
 |      @param ordinal: (C++: uint32) number of the type to link to
 |      @param decl_type: (C++: type_t) if the reference was explicitly specified with the type tag
 |                        (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may specify it. the kernel
 |                        will accept only the specified tag after resolving the type.
 |                        If the resolved type does not correspond to the explicitly
 |                        specified tag, the type will be considered as undefined
 |      @param resolve: (C++: bool) true: immediately resolve the type and return success code
 |  
 |  get_onemember_type(self, *args) -> 'tinfo_t'
 |      get_onemember_type(self) -> tinfo_t
 |      For objects consisting of one member entirely: return type of the member.
 |  
 |  get_ordinal(self, *args) -> 'uint32'
 |      get_ordinal(self) -> uint32
 |      Get type ordinal (only if the type was created as a numbered type, 0 if none)
 |  
 |  get_pointed_object(self, *args) -> 'tinfo_t'
 |      get_pointed_object(self) -> tinfo_t
 |  
 |  get_ptr_details(self, *args) -> 'bool'
 |      get_ptr_details(self, pi) -> bool
 |      Get the pointer info.
 |      
 |      @param pi: (C++: ptr_type_data_t *)
 |  
 |  get_ptrarr_object(self, *args) -> 'tinfo_t'
 |      get_ptrarr_object(self) -> tinfo_t
 |      BT_PTR & BT_ARRAY: get the pointed object or array element. If the current type
 |      is not a pointer or array, return empty type info.
 |  
 |  get_ptrarr_objsize(self, *args) -> 'int'
 |      get_ptrarr_objsize(self) -> int
 |      BT_PTR & BT_ARRAY: get size of pointed object or array element. On error returns
 |      -1
 |  
 |  get_realtype(self, *args) -> 'type_t'
 |      get_realtype(self, full=False) -> type_t
 |      Get the resolved base type. Deserialization options:
 |      * if full=true, the referenced type will be deserialized fully, this may not
 |      always be desirable (slows down things)
 |      * if full=false, we just return the base type, the referenced type will be
 |      resolved again later if necessary (this may lead to multiple resolvings of the
 |      same type) imho full=false is a better approach because it does not perform
 |      unnecessary actions just in case. however, in some cases the caller knows that
 |      it is very likely that full type info will be required. in those cases full=true
 |      makes sense
 |      
 |      @param full: (C++: bool)
 |  
 |  get_rettype(self, *args) -> 'tinfo_t'
 |      get_rettype(self) -> tinfo_t
 |      BT_FUNC or BT_PTR BT_FUNC: Get the function's return type
 |  
 |  get_sign(self, *args) -> 'type_sign_t'
 |      get_sign(self) -> type_sign_t
 |      Get type sign.
 |  
 |  get_size(self, *args) -> 'size_t'
 |      get_size(self, p_effalign=None, gts_code=0) -> size_t
 |      Get the type size in bytes.
 |      
 |      @param p_effalign: (C++: uint32 *) buffer for the alignment value
 |      @param gts_code: (C++: int) combination of GTS_... constants
 |      @return: BADSIZE in case of problems
 |  
 |  get_til(self, *args) -> 'til_t const *'
 |      get_til(self) -> til_t
 |      Get the type library for tinfo_t.
 |  
 |  get_type_name(self, *args) -> 'bool'
 |      get_type_name(self) -> bool
 |      Does a type refer to a name?. If yes, fill the provided buffer with the type
 |      name and return true. Names are returned for numbered types too: either a user-
 |      defined nice name or, if a user-provided name does not exist, an ordinal name
 |      (like #xx, see create_numbered_type_name()).
 |  
 |  get_udt_details(self, *args) -> 'bool'
 |      get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
 |      Get the udt specific info.
 |      
 |      @param udt: (C++: udt_type_data_t *)
 |      @param gtd: (C++: gtd_udt_t) enum gtd_udt_t
 |  
 |  get_udt_nmembers(self, *args) -> 'int'
 |      get_udt_nmembers(self) -> int
 |      Get number of udt members. -1-error.
 |  
 |  get_unpadded_size(self, *args) -> 'size_t'
 |      get_unpadded_size(self) -> size_t
 |      Get the type size in bytes without the final padding, in bytes. For some UDTs
 |      get_unpadded_size() != get_size()
 |  
 |  has_details(self, *args) -> 'bool'
 |      has_details(self) -> bool
 |      Does this type refer to a nontrivial type?
 |  
 |  has_vftable(self, *args) -> 'bool'
 |      has_vftable(self) -> bool
 |      Has a vftable?
 |  
 |  is_anonymous_udt(self, *args) -> 'bool'
 |      is_anonymous_udt(self) -> bool
 |      Is an anonymous struct/union? We assume that types with names are anonymous if
 |      the name starts with $
 |  
 |  is_arithmetic(self, *args) -> 'bool'
 |      is_arithmetic(self) -> bool
 |      is_type_arithmetic(get_realtype())
 |  
 |  is_array(self, *args) -> 'bool'
 |      is_array(self) -> bool
 |      is_type_array(get_realtype())
 |  
 |  is_bitfield(self, *args) -> 'bool'
 |      is_bitfield(self) -> bool
 |      is_type_bitfld(get_realtype())
 |  
 |  is_bool(self, *args) -> 'bool'
 |      is_bool(self) -> bool
 |      is_type_bool(get_realtype())
 |  
 |  is_castable_to(self, *args) -> 'bool'
 |      is_castable_to(self, target) -> bool
 |      
 |      @param target: tinfo_t const &
 |  
 |  is_char(self, *args) -> 'bool'
 |      is_char(self) -> bool
 |      is_type_char(get_realtype())
 |  
 |  is_complex(self, *args) -> 'bool'
 |      is_complex(self) -> bool
 |      is_type_complex(get_realtype())
 |  
 |  is_const(self, *args) -> 'bool'
 |      is_const(self) -> bool
 |      is_type_const(get_realtype())
 |  
 |  is_correct(self, *args) -> 'bool'
 |      is_correct(self) -> bool
 |      Is the type object correct?. It is possible to create incorrect types. For
 |      example, we can define a function that returns a enum and then delete the enum
 |      type. If this function returns false, the type should not be used in
 |      disassembly. Please note that this function does not verify all involved types:
 |      for example, pointers to undefined types are permitted.
 |  
 |  is_decl_array(self, *args) -> 'bool'
 |      is_decl_array(self) -> bool
 |      is_type_array(get_decltype())
 |  
 |  is_decl_bitfield(self, *args) -> 'bool'
 |      is_decl_bitfield(self) -> bool
 |      is_type_bitfld(get_decltype())
 |  
 |  is_decl_bool(self, *args) -> 'bool'
 |      is_decl_bool(self) -> bool
 |      is_type_bool(get_decltype())
 |  
 |  is_decl_char(self, *args) -> 'bool'
 |      is_decl_char(self) -> bool
 |      is_type_char(get_decltype())
 |  
 |  is_decl_complex(self, *args) -> 'bool'
 |      is_decl_complex(self) -> bool
 |      is_type_complex(get_decltype())
 |  
 |  is_decl_const(self, *args) -> 'bool'
 |      is_decl_const(self) -> bool
 |      is_type_const(get_decltype())
 |  
 |  is_decl_double(self, *args) -> 'bool'
 |      is_decl_double(self) -> bool
 |      is_type_double(get_decltype())
 |  
 |  is_decl_enum(self, *args) -> 'bool'
 |      is_decl_enum(self) -> bool
 |      is_type_enum(get_decltype())
 |  
 |  is_decl_float(self, *args) -> 'bool'
 |      is_decl_float(self) -> bool
 |      is_type_float(get_decltype())
 |  
 |  is_decl_floating(self, *args) -> 'bool'
 |      is_decl_floating(self) -> bool
 |      is_type_floating(get_decltype())
 |  
 |  is_decl_func(self, *args) -> 'bool'
 |      is_decl_func(self) -> bool
 |      is_type_func(get_decltype())
 |  
 |  is_decl_int(self, *args) -> 'bool'
 |      is_decl_int(self) -> bool
 |      is_type_int(get_decltype())
 |  
 |  is_decl_int128(self, *args) -> 'bool'
 |      is_decl_int128(self) -> bool
 |      is_type_int128(get_decltype())
 |  
 |  is_decl_int16(self, *args) -> 'bool'
 |      is_decl_int16(self) -> bool
 |      is_type_int16(get_decltype())
 |  
 |  is_decl_int32(self, *args) -> 'bool'
 |      is_decl_int32(self) -> bool
 |      is_type_int32(get_decltype())
 |  
 |  is_decl_int64(self, *args) -> 'bool'
 |      is_decl_int64(self) -> bool
 |      is_type_int64(get_decltype())
 |  
 |  is_decl_last(self, *args) -> 'bool'
 |      is_decl_last(self) -> bool
 |      is_typeid_last(get_decltype())
 |  
 |  is_decl_ldouble(self, *args) -> 'bool'
 |      is_decl_ldouble(self) -> bool
 |      is_type_ldouble(get_decltype())
 |  
 |  is_decl_paf(self, *args) -> 'bool'
 |      is_decl_paf(self) -> bool
 |      is_type_paf(get_decltype())
 |  
 |  is_decl_partial(self, *args) -> 'bool'
 |      is_decl_partial(self) -> bool
 |      is_type_partial(get_decltype())
 |  
 |  is_decl_ptr(self, *args) -> 'bool'
 |      is_decl_ptr(self) -> bool
 |      is_type_ptr(get_decltype())
 |  
 |  is_decl_struct(self, *args) -> 'bool'
 |      is_decl_struct(self) -> bool
 |      is_type_struct(get_decltype())
 |  
 |  is_decl_sue(self, *args) -> 'bool'
 |      is_decl_sue(self) -> bool
 |      is_type_sue(get_decltype())
 |  
 |  is_decl_tbyte(self, *args) -> 'bool'
 |      is_decl_tbyte(self) -> bool
 |      is_type_tbyte(get_decltype())
 |  
 |  is_decl_typedef(self, *args) -> 'bool'
 |      is_decl_typedef(self) -> bool
 |      is_type_typedef(get_decltype())
 |  
 |  is_decl_uchar(self, *args) -> 'bool'
 |      is_decl_uchar(self) -> bool
 |      is_type_uchar(get_decltype())
 |  
 |  is_decl_udt(self, *args) -> 'bool'
 |      is_decl_udt(self) -> bool
 |      is_type_struni(get_decltype())
 |  
 |  is_decl_uint(self, *args) -> 'bool'
 |      is_decl_uint(self) -> bool
 |      is_type_uint(get_decltype())
 |  
 |  is_decl_uint128(self, *args) -> 'bool'
 |      is_decl_uint128(self) -> bool
 |      is_type_uint128(get_decltype())
 |  
 |  is_decl_uint16(self, *args) -> 'bool'
 |      is_decl_uint16(self) -> bool
 |      is_type_uint16(get_decltype())
 |  
 |  is_decl_uint32(self, *args) -> 'bool'
 |      is_decl_uint32(self) -> bool
 |      is_type_uint32(get_decltype())
 |  
 |  is_decl_uint64(self, *args) -> 'bool'
 |      is_decl_uint64(self) -> bool
 |      is_type_uint64(get_decltype())
 |  
 |  is_decl_union(self, *args) -> 'bool'
 |      is_decl_union(self) -> bool
 |      is_type_union(get_decltype())
 |  
 |  is_decl_unknown(self, *args) -> 'bool'
 |      is_decl_unknown(self) -> bool
 |      is_type_unknown(get_decltype())
 |  
 |  is_decl_void(self, *args) -> 'bool'
 |      is_decl_void(self) -> bool
 |      is_type_void(get_decltype())
 |  
 |  is_decl_volatile(self, *args) -> 'bool'
 |      is_decl_volatile(self) -> bool
 |      is_type_volatile(get_decltype())
 |  
 |  is_double(self, *args) -> 'bool'
 |      is_double(self) -> bool
 |      is_type_double(get_realtype())
 |  
 |  is_empty_udt(self, *args) -> 'bool'
 |      is_empty_udt(self) -> bool
 |      Is an empty struct/union? (has no fields)
 |  
 |  is_enum(self, *args) -> 'bool'
 |      is_enum(self) -> bool
 |      is_type_enum(get_realtype())
 |  
 |  is_ext_arithmetic(self, *args) -> 'bool'
 |      is_ext_arithmetic(self) -> bool
 |      is_type_ext_arithmetic(get_realtype())
 |  
 |  is_ext_integral(self, *args) -> 'bool'
 |      is_ext_integral(self) -> bool
 |      is_type_ext_integral(get_realtype())
 |  
 |  is_float(self, *args) -> 'bool'
 |      is_float(self) -> bool
 |      is_type_float(get_realtype())
 |  
 |  is_floating(self, *args) -> 'bool'
 |      is_floating(self) -> bool
 |      is_type_floating(get_realtype())
 |  
 |  is_forward_decl(self, *args) -> 'bool'
 |      is_forward_decl(self) -> bool
 |      Is this a forward declaration?. Forward declarations are placeholders: the type
 |      definition does not exist
 |  
 |  is_from_subtil(self, *args) -> 'bool'
 |      is_from_subtil(self) -> bool
 |      Was the named type found in some base type library (not the top level type
 |      library)?. If yes, it usually means that the type comes from some loaded type
 |      library, not the local type library for the database
 |  
 |  is_func(self, *args) -> 'bool'
 |      is_func(self) -> bool
 |      is_type_func(get_realtype())
 |  
 |  is_funcptr(self, *args) -> 'bool'
 |      is_funcptr(self) -> bool
 |      Is this pointer to a function?
 |  
 |  is_high_func(self, *args) -> 'bool'
 |      is_high_func(self) -> bool
 |  
 |  is_int(self, *args) -> 'bool'
 |      is_int(self) -> bool
 |      is_type_int(get_realtype())
 |  
 |  is_int128(self, *args) -> 'bool'
 |      is_int128(self) -> bool
 |      is_type_int128(get_realtype())
 |  
 |  is_int16(self, *args) -> 'bool'
 |      is_int16(self) -> bool
 |      is_type_int16(get_realtype())
 |  
 |  is_int32(self, *args) -> 'bool'
 |      is_int32(self) -> bool
 |      is_type_int32(get_realtype())
 |  
 |  is_int64(self, *args) -> 'bool'
 |      is_int64(self) -> bool
 |      is_type_int64(get_realtype())
 |  
 |  is_integral(self, *args) -> 'bool'
 |      is_integral(self) -> bool
 |      is_type_integral(get_realtype())
 |  
 |  is_ldouble(self, *args) -> 'bool'
 |      is_ldouble(self) -> bool
 |      is_type_ldouble(get_realtype())
 |  
 |  is_manually_castable_to(self, *args) -> 'bool'
 |      is_manually_castable_to(self, target) -> bool
 |      
 |      @param target: tinfo_t const &
 |  
 |  is_one_fpval(self, *args) -> 'bool'
 |      is_one_fpval(self) -> bool
 |      Floating value or an object consisting of one floating member entirely.
 |  
 |  is_paf(self, *args) -> 'bool'
 |      is_paf(self) -> bool
 |      is_type_paf(get_realtype())
 |  
 |  is_partial(self, *args) -> 'bool'
 |      is_partial(self) -> bool
 |      is_type_partial(get_realtype())
 |  
 |  is_ptr(self, *args) -> 'bool'
 |      is_ptr(self) -> bool
 |      is_type_ptr(get_realtype())
 |  
 |  is_ptr_or_array(self, *args) -> 'bool'
 |      is_ptr_or_array(self) -> bool
 |      is_type_ptr_or_array(get_realtype())
 |  
 |  is_purging_cc(self, *args) -> 'bool'
 |      is_purging_cc(self) -> bool
 |      is_purging_cc(get_cc())
 |  
 |  is_pvoid(self, *args) -> 'bool'
 |      is_pvoid(self) -> bool
 |      Is "void *"?. This function does not check the pointer attributes and type
 |      modifiers.
 |  
 |  is_scalar(self, *args) -> 'bool'
 |      is_scalar(self) -> bool
 |      Does the type represent a single number?
 |  
 |  is_shifted_ptr(self, *args) -> 'bool'
 |      is_shifted_ptr(self) -> bool
 |      Is a shifted pointer?
 |  
 |  is_signed(self, *args) -> 'bool'
 |      is_signed(self) -> bool
 |      Is this a signed type?
 |  
 |  is_small_udt(self, *args) -> 'bool'
 |      is_small_udt(self) -> bool
 |      Is a small udt? (can fit a register or a pair of registers)
 |  
 |  is_sse_type(self, *args) -> 'bool'
 |      is_sse_type(self) -> bool
 |      Is a SSE vector type?
 |  
 |  is_struct(self, *args) -> 'bool'
 |      is_struct(self) -> bool
 |      is_type_struct(get_realtype())
 |  
 |  is_sue(self, *args) -> 'bool'
 |      is_sue(self) -> bool
 |      is_type_sue(get_realtype())
 |  
 |  is_tbyte(self, *args) -> 'bool'
 |      is_tbyte(self) -> bool
 |      is_type_tbyte(get_realtype())
 |  
 |  is_typeref(self, *args) -> 'bool'
 |      is_typeref(self) -> bool
 |      Is this type a type reference?. Type references cannot be modified. Once
 |      created, they do not change. Because of this, the set_... functions applied to
 |      typerefs create a new type id. Other types are modified directly.
 |  
 |  is_uchar(self, *args) -> 'bool'
 |      is_uchar(self) -> bool
 |      is_type_uchar(get_realtype())
 |  
 |  is_udt(self, *args) -> 'bool'
 |      is_udt(self) -> bool
 |      is_type_struni(get_realtype())
 |  
 |  is_uint(self, *args) -> 'bool'
 |      is_uint(self) -> bool
 |      is_type_uint(get_realtype())
 |  
 |  is_uint128(self, *args) -> 'bool'
 |      is_uint128(self) -> bool
 |      is_type_uint128(get_realtype())
 |  
 |  is_uint16(self, *args) -> 'bool'
 |      is_uint16(self) -> bool
 |      is_type_uint16(get_realtype())
 |  
 |  is_uint32(self, *args) -> 'bool'
 |      is_uint32(self) -> bool
 |      is_type_uint32(get_realtype())
 |  
 |  is_uint64(self, *args) -> 'bool'
 |      is_uint64(self) -> bool
 |      is_type_uint64(get_realtype())
 |  
 |  is_union(self, *args) -> 'bool'
 |      is_union(self) -> bool
 |      is_type_union(get_realtype())
 |  
 |  is_unknown(self, *args) -> 'bool'
 |      is_unknown(self) -> bool
 |      is_type_unknown(get_realtype())
 |  
 |  is_unsigned(self, *args) -> 'bool'
 |      is_unsigned(self) -> bool
 |      Is this an unsigned type?
 |  
 |  is_user_cc(self, *args) -> 'bool'
 |      is_user_cc(self) -> bool
 |      is_user_cc(get_cc())
 |  
 |  is_vararg_cc(self, *args) -> 'bool'
 |      is_vararg_cc(self) -> bool
 |      is_vararg_cc(get_cc())
 |  
 |  is_varstruct(self, *args) -> 'bool'
 |      is_varstruct(self) -> bool
 |      Is a variable-size structure?
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |      Is a vftable type?
 |  
 |  is_void(self, *args) -> 'bool'
 |      is_void(self) -> bool
 |      is_type_void(get_realtype())
 |  
 |  is_volatile(self, *args) -> 'bool'
 |      is_volatile(self) -> bool
 |      is_type_volatile(get_realtype())
 |  
 |  is_well_defined(self, *args) -> 'bool'
 |      is_well_defined(self) -> bool
 |      !(empty()) && !(is_decl_partial())
 |  
 |  present(self, *args) -> 'bool'
 |      present(self) -> bool
 |      Is the type really present? (not a reference to a missing type, for example)
 |  
 |  read_bitfield_value(self, *args) -> 'uint64'
 |      read_bitfield_value(self, v, bitoff) -> uint64
 |      
 |      @param v: uint64
 |      @param bitoff: int
 |  
 |  remove_ptr_or_array(self, *args) -> 'bool'
 |      remove_ptr_or_array(self) -> bool
 |      Replace the current type with the ptr obj or array element. This function
 |      performs one of the following conversions:
 |      * type[] => type
 |      * type* => type If the conversion is performed successfully, return true
 |  
 |  requires_qualifier(self, *args) -> 'bool'
 |      requires_qualifier(self, name, offset) -> bool
 |      Requires full qualifier? (name is not unique)
 |      
 |      @param name: (C++: const char *) field name
 |      @param offset: (C++: uint64) field offset in bits
 |      @return: if the name is not unique, returns true
 |  
 |  serialize(self, *args) -> 'PyObject *'
 |      serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> (bytes, NoneType, NoneType), (bytes, bytes, NoneType)
 |      Serialize tinfo_t object into a type string.
 |      
 |      @param sudt_flags: (C++: int)
 |  
 |  set_attr(self, *args) -> 'bool'
 |      set_attr(self, ta, may_overwrite=True) -> bool
 |      Set a type attribute. If necessary, a new typid will be created.
 |      
 |      @param ta: (C++: const type_attr_t &) type_attr_t const &
 |      @param may_overwrite: (C++: bool)
 |  
 |  set_attrs(self, *args) -> 'bool'
 |      set_attrs(self, tav) -> bool
 |      Set type attributes. If necessary, a new typid will be created. this function
 |      modifies tav! (returns old attributes, if any)
 |      
 |      @param tav: (C++: type_attrs_t *)
 |      @return: false: bad attributes
 |  
 |  set_const(self, *args) -> 'void'
 |      set_const(self)
 |  
 |  set_declalign(self, *args) -> 'bool'
 |      set_declalign(self, declalign) -> bool
 |      Set declared alignment of the type.
 |      
 |      @param declalign: (C++: uchar)
 |  
 |  set_methods(self, *args) -> 'bool'
 |      set_methods(self, methods) -> bool
 |      
 |      @param BT_COMPLEX: set the list of member functions. This function consumes 'methods'
 |      (makes it empty).
 |      @return: false if this type is not a udt, or if the given list is empty
 |  
 |  set_modifiers(self, *args) -> 'void'
 |      set_modifiers(self, mod)
 |      
 |      @param mod: type_t
 |  
 |  set_named_type(self, *args) -> 'tinfo_code_t'
 |      set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
 |      
 |      @param til: til_t *
 |      @param name: char const *
 |      @param ntf_flags: int
 |  
 |  set_numbered_type(self, *args) -> 'tinfo_code_t'
 |      set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
 |      
 |      @param til: til_t *
 |      @param ord: uint32
 |      @param ntf_flags: int
 |      @param name: char const *
 |  
 |  set_symbol_type(self, *args) -> 'tinfo_code_t'
 |      set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
 |      
 |      @param til: til_t *
 |      @param name: char const *
 |      @param ntf_flags: int
 |  
 |  set_volatile(self, *args) -> 'void'
 |      set_volatile(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      Assign this = r and r = this.
 |      
 |      @param r: (C++: tinfo_t &)
 |  
 |  write_bitfield_value(self, *args) -> 'uint64'
 |      write_bitfield_value(self, dst, v, bitoff) -> uint64
 |      
 |      @param dst: uint64
 |      @param v: uint64
 |      @param bitoff: int
 |  
 |  ----------------------------------------------------------------------
 |  Static methods defined here:
 |  
 |  get_stock(*args) -> 'tinfo_t'
 |      get_stock(id) -> tinfo_t
 |      Get stock type information. This function can be used to get tinfo_t for some
 |      common types. The same tinfo_t will be returned for the same id, thus saving
 |      memory and increasing the speed Please note that retrieving the STI_SIZE_T or
 |      STI_SSIZE_T stock type, will also have the side-effect of adding that type to
 |      the 'idati' TIL, under the well-known name 'size_t' or 'ssize_t' (respectively).
 |      The same is valid for STI_COMPLEX64 and STI_COMPLEX64 stock types with names
 |      'complex64_t' and 'complex128_t' (respectively).
 |      
 |      @param id: (C++: stock_type_id_t) enum stock_type_id_t
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function tinfo_t_get_stock in module ida_typeinf:

tinfo_t_get_stock(*args) -> 'tinfo_t'
    tinfo_t_get_stock(id) -> tinfo_t
    
    @param id: enum stock_type_id_t

Help on class tinfo_visitor_t in module ida_typeinf:

class tinfo_visitor_t(builtins.object)
 |  Proxy of C++ tinfo_visitor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self, s=0) -> tinfo_visitor_t
 |      
 |      @param s: int
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_tinfo_visitor_t(...)
 |      delete_tinfo_visitor_t(self)
 |  
 |  apply_to(self, *args) -> 'int'
 |      apply_to(self, tif, out=None, name=None, cmt=None) -> int
 |      Call this function to initiate the traversal.
 |      
 |      @param tif: (C++: const tinfo_t &) tinfo_t const &
 |      @param out: (C++: type_mods_t *)
 |      @param name: (C++: const char *) char const *
 |      @param cmt: (C++: const char *) char const *
 |  
 |  prune_now(self, *args) -> 'void'
 |      prune_now(self)
 |      To refuse to visit children of the current type, use this:
 |  
 |  visit_type(self, *args) -> 'int'
 |      visit_type(self, out, tif, name, cmt) -> int
 |      Visit a subtype. this function must be implemented in the derived class. it may
 |      optionally fill out with the new type info. this can be used to modify types (in
 |      this case the 'out' argument of apply_to() may not be nullptr) return 0 to
 |      continue the traversal. return !=0 to stop the traversal.
 |      
 |      @param out: (C++: type_mods_t *)
 |      @param tif: (C++: const tinfo_t &) tinfo_t const &
 |      @param name: (C++: const char *) char const *
 |      @param cmt: (C++: const char *) char const *
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  state
 |      state
 |  
 |  thisown
 |      The membership flag

Help on class type_attr_t in module ida_typeinf:

class type_attr_t(builtins.object)
 |  Proxy of C++ type_attr_t class.
 |  
 |  Methods defined here:
 |  
 |  __ge__(self, *args) -> 'bool'
 |      __ge__(self, r) -> bool
 |      
 |      @param r: type_attr_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_attr_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: type_attr_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_type_attr_t(...)
 |      delete_type_attr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  key
 |      key
 |  
 |  thisown
 |      The membership flag
 |  
 |  value
 |      value

Help on class type_attrs_t in module ida_typeinf:

class type_attrs_t(builtins.object)
 |  Proxy of C++ qvector< type_attr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'type_attr_t const &'
 |      __getitem__(self, i) -> type_attr_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_attrs_t
 |      __init__(self, x) -> type_attrs_t
 |      
 |      @param x: qvector< type_attr_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: type_attr_t const &
 |  
 |  __swig_destroy__ = delete_type_attrs_t(...)
 |      delete_type_attrs_t(self)
 |  
 |  at(self, *args) -> 'type_attr_t const &'
 |      at(self, _idx) -> type_attr_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< type_attr_t >::const_iterator'
 |      begin(self) -> type_attr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< type_attr_t >::const_iterator'
 |      end(self) -> type_attr_t
 |  
 |  erase(self, *args) -> 'qvector< type_attr_t >::iterator'
 |      erase(self, it) -> type_attr_t
 |      
 |      @param it: qvector< type_attr_t >::iterator
 |      
 |      erase(self, first, last) -> type_attr_t
 |      
 |      @param first: qvector< type_attr_t >::iterator
 |      @param last: qvector< type_attr_t >::iterator
 |  
 |  extract(self, *args) -> 'type_attr_t *'
 |      extract(self) -> type_attr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=type_attr_t())
 |      
 |      @param x: type_attr_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: type_attr_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< type_attr_t >::iterator'
 |      insert(self, it, x) -> type_attr_t
 |      
 |      @param it: qvector< type_attr_t >::iterator
 |      @param x: type_attr_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'type_attr_t &'
 |      push_back(self, x)
 |      
 |      @param x: type_attr_t const &
 |      
 |      push_back(self) -> type_attr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: type_attr_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< type_attr_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on class type_mods_t in module ida_typeinf:

class type_mods_t(builtins.object)
 |  Proxy of C++ type_mods_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> type_mods_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_type_mods_t(...)
 |      delete_type_mods_t(self)
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  has_cmt(self, *args) -> 'bool'
 |      has_cmt(self) -> bool
 |  
 |  has_info(self, *args) -> 'bool'
 |      has_info(self) -> bool
 |  
 |  has_name(self, *args) -> 'bool'
 |      has_name(self) -> bool
 |  
 |  has_type(self, *args) -> 'bool'
 |      has_type(self) -> bool
 |  
 |  set_new_cmt(self, *args) -> 'void'
 |      set_new_cmt(self, c)
 |      
 |      @param c: qstring const &
 |  
 |  set_new_name(self, *args) -> 'void'
 |      set_new_name(self, n)
 |      
 |      @param n: qstring const &
 |  
 |  set_new_type(self, *args) -> 'void'
 |      set_new_type(self, t)
 |      The visit_type() function may optionally save the modified type info. Use the
 |      following functions for that. The new name and comment will be applied only if
 |      the current tinfo element has storage for them.
 |      
 |      @param t: (C++: const tinfo_t &) tinfo_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      cmt
 |  
 |  flags
 |      flags
 |  
 |  name
 |      name
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type

Help on class typedef_type_data_t in module ida_typeinf:

class typedef_type_data_t(builtins.object)
 |  Proxy of C++ typedef_type_data_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self, _til, _name, _resolve=False) -> typedef_type_data_t
 |      
 |      @param _til: til_t const *
 |      @param _name: char const *
 |      @param _resolve: bool
 |      
 |      __init__(self, _til, ord, _resolve=False) -> typedef_type_data_t
 |      
 |      @param _til: til_t const *
 |      @param ord: uint32
 |      @param _resolve: bool
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_typedef_type_data_t(...)
 |      delete_typedef_type_data_t(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: typedef_type_data_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  is_ordref
 |      is_ordref
 |  
 |  name
 |      name
 |  
 |  ordinal
 |      ordinal
 |  
 |  resolve
 |      resolve
 |  
 |  thisown
 |      The membership flag
 |  
 |  til
 |      til

Help on class udt_member_t in module ida_typeinf:

class udt_member_t(builtins.object)
 |  Proxy of C++ udt_member_t class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: udt_member_t const &
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udt_member_t
 |  
 |  __lt__(self, *args) -> 'bool'
 |      __lt__(self, r) -> bool
 |      
 |      @param r: udt_member_t const &
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: udt_member_t const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udt_member_t(...)
 |      delete_udt_member_t(self)
 |  
 |  begin(self, *args) -> 'uint64'
 |      begin(self) -> uint64
 |  
 |  clr_baseclass(self, *args) -> 'void'
 |      clr_baseclass(self)
 |  
 |  clr_method(self, *args) -> 'void'
 |      clr_method(self)
 |  
 |  clr_unaligned(self, *args) -> 'void'
 |      clr_unaligned(self)
 |  
 |  clr_vftable(self, *args) -> 'void'
 |      clr_vftable(self)
 |  
 |  clr_virtbase(self, *args) -> 'void'
 |      clr_virtbase(self)
 |  
 |  end(self, *args) -> 'uint64'
 |      end(self) -> uint64
 |  
 |  is_anonymous_udm(self, *args) -> 'bool'
 |      is_anonymous_udm(self) -> bool
 |  
 |  is_baseclass(self, *args) -> 'bool'
 |      is_baseclass(self) -> bool
 |  
 |  is_bitfield(self, *args) -> 'bool'
 |      is_bitfield(self) -> bool
 |  
 |  is_method(self, *args) -> 'bool'
 |      is_method(self) -> bool
 |  
 |  is_unaligned(self, *args) -> 'bool'
 |      is_unaligned(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  is_virtbase(self, *args) -> 'bool'
 |      is_virtbase(self) -> bool
 |  
 |  is_zero_bitfield(self, *args) -> 'bool'
 |      is_zero_bitfield(self) -> bool
 |  
 |  set_baseclass(self, *args) -> 'void'
 |      set_baseclass(self)
 |  
 |  set_method(self, *args) -> 'void'
 |      set_method(self)
 |  
 |  set_unaligned(self, *args) -> 'void'
 |      set_unaligned(self)
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  set_virtbase(self, *args) -> 'void'
 |      set_virtbase(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: udt_member_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cmt
 |      cmt
 |  
 |  effalign
 |      effalign
 |  
 |  fda
 |      fda
 |  
 |  name
 |      name
 |  
 |  offset
 |      offset
 |  
 |  size
 |      size
 |  
 |  tafld_bits
 |      tafld_bits
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on class udt_type_data_t in module ida_typeinf:

class udt_type_data_t(udtmembervec_t)
 |  Proxy of C++ udt_type_data_t class.
 |  
 |  Method resolution order:
 |      udt_type_data_t
 |      udtmembervec_t
 |      udtmembervec_template_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udt_type_data_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udt_type_data_t(...)
 |      delete_udt_type_data_t(self)
 |  
 |  is_cppobj(self, *args) -> 'bool'
 |      is_cppobj(self) -> bool
 |  
 |  is_last_baseclass(self, *args) -> 'bool'
 |      is_last_baseclass(self, idx) -> bool
 |      
 |      @param idx: size_t
 |  
 |  is_msstruct(self, *args) -> 'bool'
 |      is_msstruct(self) -> bool
 |  
 |  is_unaligned(self, *args) -> 'bool'
 |      is_unaligned(self) -> bool
 |  
 |  is_vftable(self, *args) -> 'bool'
 |      is_vftable(self) -> bool
 |  
 |  set_vftable(self, *args) -> 'void'
 |      set_vftable(self)
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: udt_type_data_t &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  effalign
 |      effalign
 |  
 |  is_union
 |      is_union
 |  
 |  pack
 |      pack
 |  
 |  sda
 |      sda
 |  
 |  taudt_bits
 |      taudt_bits
 |  
 |  thisown
 |      The membership flag
 |  
 |  total_size
 |      total_size
 |  
 |  unpadded_size
 |      unpadded_size
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from udtmembervec_template_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< udt_member_t > const &
 |  
 |  __getitem__(self, *args) -> 'udt_member_t const &'
 |      __getitem__(self, i) -> udt_member_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< udt_member_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: udt_member_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: udt_member_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: udt_member_t const &
 |  
 |  at(self, *args) -> 'udt_member_t const &'
 |      at(self, _idx) -> udt_member_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      erase(self, it) -> udt_member_t
 |      
 |      @param it: qvector< udt_member_t >::iterator
 |      
 |      erase(self, first, last) -> udt_member_t
 |      
 |      @param first: qvector< udt_member_t >::iterator
 |      @param last: qvector< udt_member_t >::iterator
 |  
 |  extract(self, *args) -> 'udt_member_t *'
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      find(self, x) -> udt_member_t
 |      
 |      @param x: udt_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=udt_member_t())
 |      
 |      @param x: udt_member_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: udt_member_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: udt_member_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      insert(self, it, x) -> udt_member_t
 |      
 |      @param it: qvector< udt_member_t >::iterator
 |      @param x: udt_member_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'udt_member_t &'
 |      push_back(self, x)
 |      
 |      @param x: udt_member_t const &
 |      
 |      push_back(self) -> udt_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: udt_member_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from udtmembervec_template_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from udtmembervec_template_t:
 |  
 |  __hash__ = None

Help on class udtmembervec_t in module ida_typeinf:

class udtmembervec_t(udtmembervec_template_t)
 |  Proxy of C++ udtmembervec_t class.
 |  
 |  Method resolution order:
 |      udtmembervec_t
 |      udtmembervec_template_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udtmembervec_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_udtmembervec_t(...)
 |      delete_udtmembervec_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from udtmembervec_template_t:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< udt_member_t > const &
 |  
 |  __getitem__(self, *args) -> 'udt_member_t const &'
 |      __getitem__(self, i) -> udt_member_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< udt_member_t > const &
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: udt_member_t const &
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: udt_member_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: udt_member_t const &
 |  
 |  at(self, *args) -> 'udt_member_t const &'
 |      at(self, _idx) -> udt_member_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      erase(self, it) -> udt_member_t
 |      
 |      @param it: qvector< udt_member_t >::iterator
 |      
 |      erase(self, first, last) -> udt_member_t
 |      
 |      @param first: qvector< udt_member_t >::iterator
 |      @param last: qvector< udt_member_t >::iterator
 |  
 |  extract(self, *args) -> 'udt_member_t *'
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      find(self, x) -> udt_member_t
 |      
 |      @param x: udt_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=udt_member_t())
 |      
 |      @param x: udt_member_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: udt_member_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: udt_member_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      insert(self, it, x) -> udt_member_t
 |      
 |      @param it: qvector< udt_member_t >::iterator
 |      @param x: udt_member_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'udt_member_t &'
 |      push_back(self, x)
 |      
 |      @param x: udt_member_t const &
 |      
 |      push_back(self) -> udt_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: udt_member_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< udt_member_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from udtmembervec_template_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from udtmembervec_template_t:
 |  
 |  __hash__ = None

Help on class udtmembervec_template_t in module ida_typeinf:

class udtmembervec_template_t(builtins.object)
 |  Proxy of C++ qvector< udt_member_t > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< udt_member_t > const &
 |  
 |  __getitem__(self, *args) -> 'udt_member_t const &'
 |      __getitem__(self, i) -> udt_member_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> udtmembervec_template_t
 |      __init__(self, x) -> udtmembervec_template_t
 |      
 |      @param x: qvector< udt_member_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< udt_member_t > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: udt_member_t const &
 |  
 |  __swig_destroy__ = delete_udtmembervec_template_t(...)
 |      delete_udtmembervec_template_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: udt_member_t const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: udt_member_t const &
 |  
 |  at(self, *args) -> 'udt_member_t const &'
 |      at(self, _idx) -> udt_member_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      begin(self) -> udt_member_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      end(self) -> udt_member_t
 |  
 |  erase(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      erase(self, it) -> udt_member_t
 |      
 |      @param it: qvector< udt_member_t >::iterator
 |      
 |      erase(self, first, last) -> udt_member_t
 |      
 |      @param first: qvector< udt_member_t >::iterator
 |      @param last: qvector< udt_member_t >::iterator
 |  
 |  extract(self, *args) -> 'udt_member_t *'
 |      extract(self) -> udt_member_t
 |  
 |  find(self, *args) -> 'qvector< udt_member_t >::const_iterator'
 |      find(self, x) -> udt_member_t
 |      
 |      @param x: udt_member_t const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=udt_member_t())
 |      
 |      @param x: udt_member_t const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: udt_member_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: udt_member_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< udt_member_t >::iterator'
 |      insert(self, it, x) -> udt_member_t
 |      
 |      @param it: qvector< udt_member_t >::iterator
 |      @param x: udt_member_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'udt_member_t &'
 |      push_back(self, x)
 |      
 |      @param x: udt_member_t const &
 |      
 |      push_back(self) -> udt_member_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: udt_member_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< udt_member_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function unpack_idcobj_from_bv in module ida_typeinf:

unpack_idcobj_from_bv(*args) -> 'error_t'
    unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t
    Read a typed idc object from the byte vector.
    
    @param obj: (C++: idc_value_t *)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param bytes: (C++: const bytevec_t &) bytevec_t const &
    @param pio_flags: (C++: int)

Help on function unpack_idcobj_from_idb in module ida_typeinf:

unpack_idcobj_from_idb(*args) -> 'error_t'
    unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t
    Collection of register objects.
    
    Read a typed idc object from the database
    
    @param obj: (C++: idc_value_t *)
    @param tif: (C++: const tinfo_t &) tinfo_t const &
    @param ea: (C++: ea_t)
    @param off0: (C++: const bytevec_t *) bytevec_t const *
    @param pio_flags: (C++: int)

Help on function unpack_object_from_bv in module ida_typeinf:

unpack_object_from_bv(*args) -> 'PyObject *'
    unpack_object_from_bv(ti, type, fields, bytes, pio_flags=0) -> PyObject *
    Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    @param ti: Type info. 'None' can be passed.
    @param type: type_t const *
    @param fields: fields string (may be empty or None)
    @param bytes: the bytes to unpack
    @param pio_flags: flags used while unpacking
    @return:     - tuple(0, err) on failure
        - tuple(1, obj) on success

Help on function unpack_object_from_idb in module ida_typeinf:

unpack_object_from_idb(*args) -> 'PyObject *'
    unpack_object_from_idb(ti, type, fields, ea, pio_flags=0) -> PyObject *
    
    @param ti: til_t *
    @param type: type_t const *
    @param fields: p_list const *
    @param ea: ea_t
    @param pio_flags: int

Help on function use_golang_cc in module ida_typeinf:

use_golang_cc(*args) -> 'bool'
    use_golang_cc() -> bool
    is GOLANG calling convention used by default?

Help on class valstr_t in module ida_typeinf:

class valstr_t(builtins.object)
 |  Proxy of C++ valstr_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstr_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_valstr_t(...)
 |      delete_valstr_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  info
 |      info
 |  
 |  length
 |      length
 |  
 |  members
 |      members
 |  
 |  oneline
 |      oneline
 |  
 |  props
 |      props
 |  
 |  thisown
 |      The membership flag

Help on class valstrs_t in module ida_typeinf:

class valstrs_t(valstrvec_t)
 |  Proxy of C++ valstrs_t class.
 |  
 |  Method resolution order:
 |      valstrs_t
 |      valstrvec_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstrs_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_valstrs_t(...)
 |      delete_valstrs_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from valstrvec_t:
 |  
 |  __getitem__(self, *args) -> 'valstr_t const &'
 |      __getitem__(self, i) -> valstr_t
 |      
 |      @param i: size_t
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: valstr_t const &
 |  
 |  at(self, *args) -> 'valstr_t const &'
 |      at(self, _idx) -> valstr_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      begin(self) -> valstr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      end(self) -> valstr_t
 |  
 |  erase(self, *args) -> 'qvector< valstr_t >::iterator'
 |      erase(self, it) -> valstr_t
 |      
 |      @param it: qvector< valstr_t >::iterator
 |      
 |      erase(self, first, last) -> valstr_t
 |      
 |      @param first: qvector< valstr_t >::iterator
 |      @param last: qvector< valstr_t >::iterator
 |  
 |  extract(self, *args) -> 'valstr_t *'
 |      extract(self) -> valstr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=valstr_t())
 |      
 |      @param x: valstr_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: valstr_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< valstr_t >::iterator'
 |      insert(self, it, x) -> valstr_t
 |      
 |      @param it: qvector< valstr_t >::iterator
 |      @param x: valstr_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'valstr_t &'
 |      push_back(self, x)
 |      
 |      @param x: valstr_t const &
 |      
 |      push_back(self) -> valstr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: valstr_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< valstr_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from valstrvec_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on class valstrvec_t in module ida_typeinf:

class valstrvec_t(builtins.object)
 |  Proxy of C++ qvector< valstr_t > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'valstr_t const &'
 |      __getitem__(self, i) -> valstr_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> valstrvec_t
 |      __init__(self, x) -> valstrvec_t
 |      
 |      @param x: qvector< valstr_t > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: valstr_t const &
 |  
 |  __swig_destroy__ = delete_valstrvec_t(...)
 |      delete_valstrvec_t(self)
 |  
 |  at(self, *args) -> 'valstr_t const &'
 |      at(self, _idx) -> valstr_t
 |      
 |      @param _idx: size_t
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      begin(self) -> valstr_t
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< valstr_t >::const_iterator'
 |      end(self) -> valstr_t
 |  
 |  erase(self, *args) -> 'qvector< valstr_t >::iterator'
 |      erase(self, it) -> valstr_t
 |      
 |      @param it: qvector< valstr_t >::iterator
 |      
 |      erase(self, first, last) -> valstr_t
 |      
 |      @param first: qvector< valstr_t >::iterator
 |      @param last: qvector< valstr_t >::iterator
 |  
 |  extract(self, *args) -> 'valstr_t *'
 |      extract(self) -> valstr_t
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=valstr_t())
 |      
 |      @param x: valstr_t const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: valstr_t *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< valstr_t >::iterator'
 |      insert(self, it, x) -> valstr_t
 |      
 |      @param it: qvector< valstr_t >::iterator
 |      @param x: valstr_t const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'valstr_t &'
 |      push_back(self, x)
 |      
 |      @param x: valstr_t const &
 |      
 |      push_back(self) -> valstr_t
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: valstr_t const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< valstr_t > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag

Help on function verify_argloc in module ida_typeinf:

verify_argloc(*args) -> 'int'
    verify_argloc(vloc, size, gaps) -> int
    Verify argloc_t.
    
    @param vloc: (C++: const argloc_t &) argloc to verify
    @param size: (C++: int) total size of the variable
    @param gaps: (C++: const rangeset_t *) if not nullptr, specifies gaps in structure definition. these gaps
                 should not map to any argloc, but everything else must be covered
    @return: 0 if ok, otherwise an interr code.

Help on function verify_tinfo in module ida_typeinf:

verify_tinfo(*args) -> 'int'
    verify_tinfo(typid) -> int
    
    @param typid: uint32

Help on function visit_subtypes in module ida_typeinf:

visit_subtypes(*args) -> 'int'
    visit_subtypes(visitor, out, tif, name, cmt) -> int
    
    @param visitor: tinfo_visitor_t *
    @param out: type_mods_t *
    @param tif: tinfo_t const &
    @param name: char const *
    @param cmt: char const *

Help on function write_tinfo_bitfield_value in module ida_typeinf:

write_tinfo_bitfield_value(*args) -> 'uint64'
    write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64
    
    @param typid: uint32
    @param dst: uint64
    @param v: uint64
    @param bitoff: int

Module "ida_ua"s docstring:
"""
Functions that deal with the disassembling of program instructions.

There are 2 kinds of functions:
* functions that are called from the kernel to disassemble an instruction. These
functions call IDP module for it.
* functions that are called from IDP module to disassemble an instruction. We
will call them 'helper functions'.

Disassembly of an instruction is made in three steps:
1. analysis: ana.cpp
2. emulation: emu.cpp
3. conversion to text: out.cpp

The kernel calls the IDP module to perform these steps. At first, the kernel
always calls the analysis. The analyzer must decode the instruction and fill the
insn_t instance that it receives through its callback. It must not change
anything in the database.

The second step, the emulation, is called for each instruction. This step must
make necessary changes to the database, plan analysis of subsequent
instructions, track register values, memory contents, etc. Please keep in mind
that the kernel may call the emulation step for any address in the program -
there is no ordering of addresses. Usually, the emulation is called for
consecutive addresses but this is not guaranteed.

The last step, conversion to text, is called each time an instruction is
displayed on the screen. The kernel will always call the analysis step before
calling the text conversion step. The emulation and the text conversion steps
should use the information stored in the insn_t instance they receive. They
should not access the bytes of the instruction and decode it again - this should
only be done in the analysis step."""

Help on function calc_dataseg in module ida_ua:

calc_dataseg(*args) -> 'ea_t'
    calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t
    Get data segment for the instruction operand. 'opnum' and 'rgnum' are meaningful
    only if the processor has segment registers.
    
    @param insn: (C++: const insn_t &) an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param n: (C++: int)
    @param rgnum: (C++: int)

Help on function can_decode in module ida_ua:

can_decode(*args) -> 'bool'
    can_decode(ea) -> bool
    Can the bytes at address 'ea' be decoded as instruction?
    
    @param ea: (C++: ea_t) linear address
    @return: whether or not the contents at that address could be a valid
             instruction

Help on function construct_macro in module ida_ua:

construct_macro(*args) -> 'bool'
    construct_macro(insn, enable, build_macro) -> bool
    See ua.hpp's construct_macro().
    
    @param insn: insn_t &
    @param enable: bool
    @param build_macro: PyObject *

Help on function construct_macro2 in module ida_ua:

construct_macro2(*args) -> 'bool'
    construct_macro2(_this, insn, enable) -> bool
    
    @param _this: macro_constructor_t *
    @param insn: insn_t *
    @param enable: bool

Help on function create_insn in module ida_ua:

create_insn(*args) -> 'int'
    create_insn(ea, out=None) -> int
    Create an instruction at the specified address. This function checks if an
    instruction is present at the specified address and will try to create one if
    there is none. It will fail if there is a data item or other items hindering the
    creation of the new instruction. This function will also fill the 'out'
    structure.
    
    @param ea: (C++: ea_t) linear address
    @param out: (C++: insn_t *) the resulting instruction
    @return: the length of the instruction or 0

Help on function create_outctx in module ida_ua:

create_outctx(*args) -> 'outctx_base_t *'
    create_outctx(ea, F=0, suspop=0) -> outctx_base_t
    Create a new output context. To delete it, just use "delete pctx"
    
    @param ea: (C++: ea_t)
    @param F: (C++: flags_t)
    @param suspop: (C++: int)

Help on function decode_insn in module ida_ua:

decode_insn(*args) -> 'int'
    decode_insn(out, ea) -> int
    Analyze the specified address and fill 'out'. This function does not modify the
    database. It just tries to interpret the specified address as an instruction and
    fills the 'out' structure.
    
    @param out: (C++: insn_t *) the resulting instruction
    @param ea: (C++: ea_t) linear address
    @return: the length of the (possible) instruction or 0

Help on function decode_preceding_insn in module ida_ua:

decode_preceding_insn(*args) -> 'PyObject *'
    decode_preceding_insn(out, ea) -> (int, int)
    Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
    
    @param out: instruction storage
    @param ea: current ea
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)

Help on function decode_prev_insn in module ida_ua:

decode_prev_insn(*args) -> 'ea_t'
    decode_prev_insn(out, ea) -> ea_t
    Decode previous instruction if it exists, fill 'out'.
    
    @param out: (C++: insn_t *) the resulting instruction
    @param ea: (C++: ea_t) the address to decode the previous instruction from
    @return: the previous instruction address (BADADDR-no such insn)

Help on function get_dtype_by_size in module ida_ua:

get_dtype_by_size(*args) -> 'int'
    get_dtype_by_size(size) -> int
    Get op_t::dtype from size.
    
    @param size: (C++: asize_t)

Help on function get_dtype_flag in module ida_ua:

get_dtype_flag(*args) -> 'flags_t'
    get_dtype_flag(dtype) -> flags_t
    Get flags for op_t::dtype field.
    
    @param dtype: (C++: op_dtype_t)

Help on function get_dtype_size in module ida_ua:

get_dtype_size(*args) -> 'size_t'
    get_dtype_size(dtype) -> size_t
    Get size of opt_::dtype field.
    
    @param dtype: (C++: op_dtype_t)

Help on function get_immvals in module ida_ua:

get_immvals(*args) -> 'PyObject *'
    get_immvals(ea, n, F=0) -> [int, ...]
    Get immediate values at the specified address. This function decodes instruction
    at the specified address or inspects the data item. It finds immediate values
    and copies them to 'out'. This function will store the original value of the
    operands in 'out', unless the last bits of 'F' are "...0 11111111", in which
    case the transformed values (as needed for printing) will be stored instead.
    
    @param ea: (C++: ea_t) address to analyze
    @param n: (C++: int) number of operand (0..UA_MAXOP-1), -1 means all operands
    @param F: (C++: flags_t) flags for the specified address
    @return: number of immediate values (0..2*UA_MAXOP)

Help on function get_lookback in module ida_ua:

get_lookback(*args) -> 'int'
    get_lookback() -> int
    Number of instructions to look back. This variable is not used by the kernel.
    Its value may be specified in ida.cfg: LOOKBACK = <number>. IDP may use it as
    you like it. (TMS module uses it)

Help on function get_printable_immvals in module ida_ua:

get_printable_immvals(*args) -> 'PyObject *'
    get_printable_immvals(ea, n, F=0) -> PyObject *
    Get immediate ready-to-print values at the specified address
    
    @param ea: (C++: ea_t) address to analyze
    @param n: (C++: int) number of operand (0..UA_MAXOP-1), -1 means all operands
    @param F: (C++: flags_t) flags for the specified address
    @return: number of immediate values (0..2*UA_MAXOP)

Help on function insn_add_cref in module ida_ua:

insn_add_cref(*args) -> 'void'
    insn_add_cref(insn, to, opoff, type)
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param to: ea_t
    @param opoff: int
    @param type: enum cref_t

Help on function insn_add_dref in module ida_ua:

insn_add_dref(*args) -> 'void'
    insn_add_dref(insn, to, opoff, type)
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param to: ea_t
    @param opoff: int
    @param type: enum dref_t

Help on function insn_add_off_drefs in module ida_ua:

insn_add_off_drefs(*args) -> 'ea_t'
    insn_add_off_drefs(insn, x, type, outf) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: op_t const &
    @param type: enum dref_t
    @param outf: int

Help on function insn_create_stkvar in module ida_ua:

insn_create_stkvar(*args) -> 'bool'
    insn_create_stkvar(insn, x, v, flags) -> bool
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param x: op_t const &
    @param v: adiff_t
    @param flags: int

Help on class insn_t in module ida_ua:

class insn_t(builtins.object)
 |  Proxy of C++ insn_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_auxpref__(self, *args) -> 'uint32'
 |      __get_auxpref__(self) -> uint32
 |  
 |  __get_operand__(self, *args) -> 'op_t *'
 |      __get_operand__(self, n) -> op_t
 |      
 |      @param n: int
 |  
 |  __get_ops__(self, *args) -> 'wrapped_array_t< op_t,8 >'
 |      __get_ops__(self) -> operands_array
 |  
 |  __getitem__(self, idx)
 |      Operands can be accessed directly as indexes
 |      @return: op_t: Returns an operand of type op_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> insn_t
 |  
 |  __iter__(self)
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __set_auxpref__(self, *args) -> 'void'
 |      __set_auxpref__(self, v)
 |      
 |      @param v: uint32
 |  
 |  __swig_destroy__ = delete_insn_t(...)
 |      delete_insn_t(self)
 |  
 |  add_cref(self, *args) -> 'void'
 |      add_cref(self, to, opoff, type)
 |      Add a code cross-reference from the instruction.
 |      
 |      @param to: (C++: ea_t) target linear address
 |      @param opoff: (C++: int) offset of the operand from the start of instruction. if the offset
 |                    is unknown, then 0.
 |      @param type: (C++: cref_t) type of xref
 |  
 |  add_dref(self, *args) -> 'void'
 |      add_dref(self, to, opoff, type)
 |      Add a data cross-reference from the instruction. See add_off_drefs() - usually
 |      it can be used in most cases.
 |      
 |      @param to: (C++: ea_t) target linear address
 |      @param opoff: (C++: int) offset of the operand from the start of instruction if the offset
 |                    is unknown, then 0
 |      @param type: (C++: dref_t) type of xref
 |  
 |  add_off_drefs(self, *args) -> 'ea_t'
 |      add_off_drefs(self, x, type, outf) -> ea_t
 |      Add xrefs for an operand of the instruction. This function creates all cross
 |      references for 'enum', 'offset' and 'structure offset' operands. Use
 |      add_off_drefs() in the presence of negative offsets.
 |      
 |      @param x: (C++: const op_t &) reference to operand
 |      @param type: (C++: dref_t) type of xref
 |      @param outf: (C++: int) out_value() flags. These flags should match the flags used to
 |                   output the operand
 |      @return: if is_off(): the reference target address (the same as
 |               calc_reference_data). if is_stroff(): BADADDR because for stroffs the
 |               target address is unknown else: BADADDR because enums do not represent
 |               addresses
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, other)
 |      
 |      @param other: an ida_ua.insn_t, or an address (C++: const insn_t &)
 |  
 |  create_op_data(self, *args) -> 'bool'
 |      create_op_data(self, ea_, opoff, dtype) -> bool
 |      Convenient alias.
 |      
 |      @param ea_: (C++: ea_t)
 |      @param opoff: int
 |      @param dtype: op_dtype_t
 |      
 |      create_op_data(self, ea_, op) -> bool
 |      
 |      @param ea_: ea_t
 |      @param op: op_t const &
 |  
 |  create_stkvar(self, *args) -> 'bool'
 |      create_stkvar(self, x, v, flags_) -> bool
 |      Create or modify a stack variable in the function frame. The emulator could use
 |      this function to create stack variables in the function frame before converting
 |      the operand to a stack variable. Please check with may_create_stkvars() before
 |      calling this function.
 |      
 |      @param x: (C++: const op_t &) operand (used to determine the addressing type)
 |      @param v: (C++: adiff_t) a displacement in the operand
 |      @param flags_: (C++: int) Stack variable flags
 |      @retval 1: ok, a stack variable exists now
 |      @retval 0: no, couldn't create stack variable
 |  
 |  get_canon_feature(self, *args) -> 'uint32'
 |      get_canon_feature(self, ph) -> uint32
 |      see instruc_t::feature
 |      
 |      @param ph: (C++: const processor_t &) processor_t const &
 |      
 |      get_canon_feature(self) -> uint32
 |  
 |  get_canon_mnem(self, *args) -> 'char const *'
 |      get_canon_mnem(self, ph) -> char const
 |      see instruc_t::name
 |      
 |      @param ph: (C++: const processor_t &) processor_t const &
 |      
 |      get_canon_mnem(self) -> char const *
 |  
 |  get_next_byte(self, *args) -> 'uint8'
 |      get_next_byte(self) -> uint8
 |  
 |  get_next_dword(self, *args) -> 'uint32'
 |      get_next_dword(self) -> uint32
 |  
 |  get_next_qword(self, *args) -> 'uint64'
 |      get_next_qword(self) -> uint64
 |  
 |  get_next_word(self, *args) -> 'uint16'
 |      get_next_word(self) -> uint16
 |  
 |  is_64bit(self, *args) -> 'bool'
 |      is_64bit(self) -> bool
 |      Belongs to a 64bit segment?
 |  
 |  is_canon_insn(self, *args) -> 'bool'
 |      is_canon_insn(self, ph) -> bool
 |      see processor_t::is_canon_insn()
 |      
 |      @param ph: (C++: const processor_t &) processor_t const &
 |      
 |      is_canon_insn(self) -> bool
 |  
 |  is_macro(self, *args) -> 'bool'
 |      is_macro(self) -> bool
 |      Is a macro instruction?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  Op1
 |  
 |  Op2
 |  
 |  Op3
 |  
 |  Op4
 |  
 |  Op5
 |  
 |  Op6
 |  
 |  Op7
 |  
 |  Op8
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  auxpref
 |      __get_auxpref__(self) -> uint32
 |  
 |  auxpref_u16
 |      auxpref_u16
 |  
 |  auxpref_u8
 |      auxpref_u8
 |  
 |  cs
 |      cs
 |  
 |  ea
 |      ea
 |  
 |  flags
 |      flags
 |  
 |  insnpref
 |      insnpref
 |  
 |  ip
 |      ip
 |  
 |  itype
 |      itype
 |  
 |  ops
 |      __get_ops__(self) -> operands_array
 |  
 |  segpref
 |      segpref
 |  
 |  size
 |      size
 |  
 |  thisown
 |      The membership flag

Help on function insn_t__from_ptrval__ in module ida_ua:

insn_t__from_ptrval__(*args) -> 'insn_t *'
    insn_t__from_ptrval__(ptrval) -> insn_t
    
    @param ptrval: size_t

Help on function is_floating_dtype in module ida_ua:

is_floating_dtype(*args) -> 'bool'
    is_floating_dtype(dtype) -> bool
    Is a floating type operand?
    
    @param dtype: (C++: op_dtype_t)

Help on class macro_constructor_t in module ida_ua:

class macro_constructor_t(builtins.object)
 |  Proxy of C++ macro_constructor_t class.
 |  
 |  Methods defined here:
 |  
 |  __disown__(self)
 |  
 |  __init__(self, *args)
 |      __init__(self) -> macro_constructor_t
 |      
 |      @param self: PyObject *
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_macro_constructor_t(...)
 |      delete_macro_constructor_t(self)
 |  
 |  build_macro(self, *args) -> 'bool'
 |      build_macro(self, insn, may_go_forward) -> bool
 |      Try to extend the instruction.
 |      
 |      @param insn: (C++: insn_t *) Instruction to modify, usually the first instruction of the macro
 |      @param may_go_forward: (C++: bool) Is it ok to consider the next instruction for the macro?
 |                             This argument may be false, for example, if there is a
 |                             cross reference to the end of INSN. In this case creating
 |                             a macro is not desired. However, it may still be useful
 |                             to perform minor tweaks to the instruction using the
 |                             information about the surrounding instructions.
 |      @return: true if created an macro instruction. This function may modify 'insn'
 |               and return false; these changes will be accepted by the kernel but the
 |               instruction will not be considered as a macro.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  reserved
 |      reserved
 |  
 |  thisown
 |      The membership flag

Help on function map_code_ea in module ida_ua:

map_code_ea(*args) -> 'ea_t'
    map_code_ea(insn, addr, opnum) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param addr: ea_t
    @param opnum: int
    
    map_code_ea(insn, op) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: op_t const &

Help on function map_data_ea in module ida_ua:

map_data_ea(*args) -> 'ea_t'
    map_data_ea(insn, addr, opnum=-1) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param addr: ea_t
    @param opnum: int
    
    map_data_ea(insn, op) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: op_t const &

Help on function map_ea in module ida_ua:

map_ea(*args) -> 'ea_t'
    map_ea(insn, op, iscode) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param op: op_t const &
    @param iscode: bool
    
    map_ea(insn, addr, opnum, iscode) -> ea_t
    
    @param insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
    @param addr: ea_t
    @param opnum: int
    @param iscode: bool

Help on class op_t in module ida_ua:

class op_t(builtins.object)
 |  Proxy of C++ op_t class.
 |  
 |  Methods defined here:
 |  
 |  __get_addr__(self, *args) -> 'ea_t'
 |      __get_addr__(self) -> ea_t
 |  
 |  __get_reg_phrase__(self, *args) -> 'uint16'
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  __get_specval__(self, *args) -> 'ea_t'
 |      __get_specval__(self) -> ea_t
 |  
 |  __get_value__(self, *args) -> 'ea_t'
 |      __get_value__(self) -> ea_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> op_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __set_addr__(self, *args) -> 'void'
 |      __set_addr__(self, v)
 |      
 |      @param v: ea_t
 |  
 |  __set_reg_phrase__(self, *args) -> 'void'
 |      __set_reg_phrase__(self, r)
 |      
 |      @param r: uint16
 |  
 |  __set_specval__(self, *args) -> 'void'
 |      __set_specval__(self, v)
 |      
 |      @param v: ea_t
 |  
 |  __set_value__(self, *args) -> 'void'
 |      __set_value__(self, v)
 |      
 |      @param v: ea_t
 |  
 |  __swig_destroy__ = delete_op_t(...)
 |      delete_op_t(self)
 |  
 |  assign(self, *args) -> 'void'
 |      assign(self, other)
 |      
 |      @param other: op_t const &
 |  
 |  clr_shown(self, *args) -> 'void'
 |      clr_shown(self)
 |      Set operand to hidden.
 |  
 |  has_reg(self, r)
 |      Checks if the operand accesses the given processor register
 |  
 |  is_imm(self, *args) -> 'bool'
 |      is_imm(self, v) -> bool
 |      Is immediate operand?
 |      
 |      @param v: (C++: uval_t)
 |  
 |  is_reg(self, *args) -> 'bool'
 |      is_reg(self, r) -> bool
 |      Is register operand?
 |      
 |      @param r: (C++: int)
 |  
 |  set_shown(self, *args) -> 'void'
 |      set_shown(self)
 |      Set operand to be shown.
 |  
 |  shown(self, *args) -> 'bool'
 |      shown(self) -> bool
 |      Is operand set to be shown?
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  addr
 |      __get_addr__(self) -> ea_t
 |  
 |  dtype
 |      dtype
 |  
 |  flags
 |      flags
 |  
 |  n
 |      n
 |  
 |  offb
 |      offb
 |  
 |  offo
 |      offo
 |  
 |  phrase
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  reg
 |      __get_reg_phrase__(self) -> uint16
 |  
 |  specflag1
 |      specflag1
 |  
 |  specflag2
 |      specflag2
 |  
 |  specflag3
 |      specflag3
 |  
 |  specflag4
 |      specflag4
 |  
 |  specval
 |      __get_specval__(self) -> ea_t
 |  
 |  thisown
 |      The membership flag
 |  
 |  type
 |      type
 |  
 |  value
 |      __get_value__(self) -> ea_t

Help on function op_t__from_ptrval__ in module ida_ua:

op_t__from_ptrval__(*args) -> 'op_t *'
    op_t__from_ptrval__(ptrval) -> op_t
    
    @param ptrval: size_t

Help on class operands_array in module ida_ua:

class operands_array(builtins.object)
 |  Proxy of C++ wrapped_array_t< op_t,8 > class.
 |  
 |  Methods defined here:
 |  
 |  __getitem__(self, *args) -> 'op_t const &'
 |      __getitem__(self, i) -> op_t
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self, data) -> operands_array
 |      
 |      @param data: op_t (&)[8]
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__(self, *args) -> 'size_t'
 |      __len__(self) -> size_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: op_t const &
 |  
 |  __swig_destroy__ = delete_operands_array(...)
 |      delete_operands_array(self)
 |  
 |  _get_bytes(self, *args) -> 'bytevec_t'
 |      _get_bytes(self) -> bytevec_t
 |  
 |  _set_bytes(self, *args) -> 'void'
 |      _set_bytes(self, bts)
 |      
 |      Parameters
 |      ----------
 |      bts: bytevec_t const &
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  bytes
 |      _get_bytes(self) -> bytevec_t
 |  
 |  data
 |      data
 |  
 |  thisown
 |      The membership flag

Help on class outctx_base_t in module ida_ua:

class outctx_base_t(builtins.object)
 |  Proxy of C++ outctx_base_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  close_comment(self, *args) -> 'void'
 |      close_comment(self)
 |  
 |  clr_gen_label(self, *args) -> 'void'
 |      clr_gen_label(self)
 |  
 |  display_voids(self, *args) -> 'bool'
 |      display_voids(self) -> bool
 |  
 |  flush_buf(self, *args) -> 'bool'
 |      flush_buf(self, buf, indent=-1) -> bool
 |      Append contents of 'buf' to the line array. Behaves like flush_outbuf but
 |      accepts an arbitrary buffer
 |      
 |      @param buf: (C++: const char *) char const *
 |      @param indent: (C++: int)
 |  
 |  flush_outbuf(self, *args) -> 'bool'
 |      flush_outbuf(self, indent=-1) -> bool
 |      Functions to populate the output line array (lnar) Move the contents of the
 |      output buffer to the line array (outbuf->lnar) The kernel augments the outbuf
 |      contents with additional text like the line prefix, user-defined comments,
 |      xrefs, etc at this call.
 |      
 |      @param indent: (C++: int)
 |  
 |  forbid_annotations(self, *args) -> 'int'
 |      forbid_annotations(self) -> int
 |  
 |  force_code(self, *args) -> 'bool'
 |      force_code(self) -> bool
 |  
 |  gen_block_cmt(self, *args) -> 'bool'
 |      gen_block_cmt(self, cmt, color) -> bool
 |      Generate big non-indented comment lines.
 |      
 |      @param cmt: (C++: const char *) comment text. may contain \n characters to denote new lines. should
 |                  not contain comment character (;)
 |      @param color: (C++: color_t) color of comment text (one of Color tags)
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_border_line(self, *args) -> 'bool'
 |      gen_border_line(self, solid=False) -> bool
 |      Generate thin border line. This function does nothing if generation of border
 |      lines is disabled.
 |      
 |      @param solid: (C++: bool) generate solid border line (with =), otherwise with -
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_cmt_line(self, *args) -> 'bool'
 |      gen_cmt_line(self, format) -> bool
 |      Generate one non-indented comment line, colored with COLOR_AUTOCMT.
 |      
 |      @param format: (C++: const char *) printf() style format line. The resulting comment line should not
 |                     include comment character (;)
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_collapsed_line(self, *args) -> 'bool'
 |      gen_collapsed_line(self, format) -> bool
 |      Generate one non-indented comment line, colored with COLOR_COLLAPSED.
 |      
 |      @param format: (C++: const char *) printf() style format line. The resulting comment line should not
 |                     include comment character (;)
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_empty_line(self, *args) -> 'bool'
 |      gen_empty_line(self) -> bool
 |      Generate empty line. This function does nothing if generation of empty lines is
 |      disabled.
 |      
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_empty_line_without_annotations(self, *args) -> 'void'
 |      gen_empty_line_without_annotations(self)
 |  
 |  gen_printf(self, *args) -> 'bool'
 |      gen_printf(self, indent, format) -> bool
 |      printf-like function to add lines to the line array.
 |      
 |      @param indent: (C++: int) indention of the line. if indent == -1, the kernel will indent
 |                     the line at idainfo::indent. if indent < 0, -indent will be used
 |                     for indention. The first line printed with indent < 0 is
 |                     considered as the most important line at the current address.
 |                     Usually it is the line with the instruction itself. This line
 |                     will be displayed in the cross-reference lists and other places.
 |                     If you need to output an additional line before the main line
 |                     then pass DEFAULT_INDENT instead of -1. The kernel will know that
 |                     your line is not the most important one.
 |      @param format: (C++: const char *) printf style colored line to generate
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_xref_lines(self, *args) -> 'bool'
 |      gen_xref_lines(self) -> bool
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
 |      
 |      @param arg2: op_t const &
 |      @param arg3: uval_t
 |      @param arg4: sval_t *
 |      @param arg5: int *
 |  
 |  init_lines_array(self, *args) -> 'void'
 |      init_lines_array(self, answers, maxsize)
 |      
 |      @param answers: qstrvec_t *
 |      @param maxsize: int
 |  
 |  multiline(self, *args) -> 'bool'
 |      multiline(self) -> bool
 |  
 |  only_main_line(self, *args) -> 'bool'
 |      only_main_line(self) -> bool
 |  
 |  out_addr_tag(self, *args) -> 'void'
 |      out_addr_tag(self, ea)
 |      Output "address" escape sequence.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  out_btoa(self, *args) -> 'void'
 |      out_btoa(self, Word, radix=0)
 |      Output a number with the specified base (binary, octal, decimal, hex) The number
 |      is output without color codes. see also out_long()
 |      
 |      @param Word: (C++: uval_t)
 |      @param radix: (C++: char)
 |  
 |  out_char(self, *args) -> 'void'
 |      out_char(self, c)
 |      Output one character. The character is output without color codes. see also
 |      out_symbol()
 |      
 |      @param c: (C++: char)
 |  
 |  out_chars(self, *args) -> 'void'
 |      out_chars(self, c, n)
 |      Append a character multiple times.
 |      
 |      @param c: (C++: char)
 |      @param n: (C++: int)
 |  
 |  out_colored_register_line(self, *args) -> 'void'
 |      out_colored_register_line(self, str)
 |      Output a colored line with register names in it. The register names will be
 |      substituted by user-defined names (regvar_t) Please note that out_tagoff tries
 |      to make substitutions too (when called with COLOR_REG)
 |      
 |      @param str: (C++: const char *) char const *
 |  
 |  out_keyword(self, *args) -> 'void'
 |      out_keyword(self, str)
 |      Output a string with COLOR_KEYWORD color.
 |      
 |      @param str: (C++: const char *) char const *
 |  
 |  out_line(self, *args) -> 'void'
 |      out_line(self, str, color=0)
 |      Output a string with the specified color.
 |      
 |      @param str: (C++: const char *) char const *
 |      @param color: (C++: color_t)
 |  
 |  out_long(self, *args) -> 'void'
 |      out_long(self, v, radix)
 |      Output a number with appropriate color. Low level function. Use out_value() if
 |      you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of
 |      COLOR_NUMBER. 'suspop' is initialized:
 |      * in out_one_operand()
 |      * in ..\ida\gl.cpp (before calling processor_t::d_out())
 |      
 |      @param v: (C++: sval_t) value to output
 |      @param radix: (C++: char) base (2,8,10,16)
 |  
 |  out_name_expr(self, *args) -> 'bool'
 |      out_name_expr(self, x, ea, off=BADADDR) -> bool
 |      Output a name expression.
 |      
 |      @param x: (C++: const op_t &) instruction operand referencing the name expression
 |      @param ea: (C++: ea_t) address to convert to name expression
 |      @param off: (C++: adiff_t) the value of name expression. this parameter is used only to check
 |                  that the name expression will have the wanted value. You may pass
 |                  BADADDR for this parameter but I discourage it because it prohibits
 |                  checks.
 |      @return: true if the name expression has been produced
 |  
 |  out_printf(self, *args) -> 'void'
 |      out_printf(self, format)
 |      Functions to append text to the current output buffer (outbuf) Append a
 |      formatted string to the output string.
 |      
 |      @param format: (C++: const char *) char const *
 |      @return: the number of characters appended
 |  
 |  out_register(self, *args) -> 'void'
 |      out_register(self, str)
 |      Output a character with COLOR_REG color.
 |      
 |      @param str: (C++: const char *) char const *
 |  
 |  out_spaces(self, *args) -> 'void'
 |      out_spaces(self, len)
 |      Appends spaces to outbuf until its tag_strlen becomes 'len'.
 |      
 |      @param len: (C++: ssize_t)
 |  
 |  out_symbol(self, *args) -> 'void'
 |      out_symbol(self, c)
 |      Output a character with COLOR_SYMBOL color.
 |      
 |      @param c: (C++: char)
 |  
 |  out_tagoff(self, *args) -> 'void'
 |      out_tagoff(self, tag)
 |      Output "turn color off" escape sequence.
 |      
 |      @param tag: (C++: color_t)
 |  
 |  out_tagon(self, *args) -> 'void'
 |      out_tagon(self, tag)
 |      Output "turn color on" escape sequence.
 |      
 |      @param tag: (C++: color_t)
 |  
 |  out_value(self, *args) -> 'flags_t'
 |      out_value(self, x, outf=0) -> flags_t
 |      Output immediate value. Try to use this function to output all constants of
 |      instruction operands. This function outputs a number from x.addr or x.value in
 |      the form determined by ::uFlag. It outputs a colored text.
 |      * -1 is output with COLOR_ERROR
 |      * 0 is output as a number or character or segment
 |      
 |      @param x: (C++: const op_t &) value to output
 |      @param outf: (C++: int) Output value flags
 |      @return: flags of the output value
 |  
 |  print_label_now(self, *args) -> 'bool'
 |      print_label_now(self) -> bool
 |  
 |  restore_ctxflags(self, *args) -> 'void'
 |      restore_ctxflags(self, saved_flags)
 |      
 |      @param saved_flags: int
 |  
 |  retrieve_cmt(self, *args) -> 'ssize_t'
 |      retrieve_cmt(self) -> ssize_t
 |  
 |  retrieve_name(self, *args) -> 'ssize_t'
 |      retrieve_name(self, arg2, arg3) -> ssize_t
 |      
 |      @param arg2: qstring *
 |      @param arg3: color_t *
 |  
 |  set_comment_addr(self, *args) -> 'void'
 |      set_comment_addr(self, ea)
 |      
 |      @param ea: ea_t
 |  
 |  set_dlbind_opnd(self, *args) -> 'void'
 |      set_dlbind_opnd(self)
 |  
 |  set_gen_cmt(self, *args) -> 'void'
 |      set_gen_cmt(self, on=True)
 |      
 |      @param on: bool
 |  
 |  set_gen_demangled_label(self, *args) -> 'void'
 |      set_gen_demangled_label(self)
 |  
 |  set_gen_label(self, *args) -> 'void'
 |      set_gen_label(self)
 |  
 |  set_gen_xrefs(self, *args) -> 'void'
 |      set_gen_xrefs(self, on=True)
 |      
 |      @param on: bool
 |  
 |  setup_outctx(self, *args) -> 'void'
 |      setup_outctx(self, prefix, makeline_flags)
 |      Initialization; normally used only by the kernel.
 |      
 |      @param prefix: (C++: const char *) char const *
 |      @param makeline_flags: (C++: int)
 |  
 |  stack_view(self, *args) -> 'bool'
 |      stack_view(self) -> bool
 |  
 |  term_outctx(self, *args) -> 'int'
 |      term_outctx(self, prefix=None) -> int
 |      Finalize the output context.
 |      
 |      @param prefix: (C++: const char *) char const *
 |      @return: the number of generated lines.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  default_lnnum
 |      default_lnnum
 |  
 |  insn_ea
 |      insn_ea
 |  
 |  outbuf
 |      outbuf
 |  
 |  thisown
 |      The membership flag

Help on function outctx_base_t__from_ptrval__ in module ida_ua:

outctx_base_t__from_ptrval__(*args) -> 'outctx_base_t *'
    outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t
    
    @param ptrval: size_t

Help on class outctx_t in module ida_ua:

class outctx_t(outctx_base_t)
 |  Proxy of C++ outctx_t class.
 |  
 |  Method resolution order:
 |      outctx_t
 |      outctx_base_t
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  gen_func_footer(self, *args) -> 'void'
 |      gen_func_footer(self, pfn)
 |      
 |      @param pfn: func_t const *
 |  
 |  gen_func_header(self, *args) -> 'void'
 |      gen_func_header(self, pfn)
 |      
 |      @param pfn: func_t *
 |  
 |  gen_header(self, *args) -> 'void'
 |      gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
 |      
 |      @param flags: int
 |      @param proc_name: char const *
 |      @param proc_flavour: char const *
 |  
 |  gen_header_extra(self, *args) -> 'void'
 |      gen_header_extra(self)
 |  
 |  gen_xref_lines(self, *args) -> 'bool'
 |      gen_xref_lines(self) -> bool
 |  
 |  out_btoa(self, *args) -> 'void'
 |      out_btoa(self, Word, radix=0)
 |      Output a number with the specified base (binary, octal, decimal, hex) The number
 |      is output without color codes. see also out_long()
 |      
 |      @param Word: (C++: uval_t)
 |      @param radix: (C++: char)
 |  
 |  out_custom_mnem(self, *args) -> 'void'
 |      out_custom_mnem(self, mnem, width=8, postfix=None)
 |      Output custom mnemonic for 'insn'. E.g. if it should differ from the one in
 |      'ph.instruc'. This function outputs colored text. See out_mnem
 |      
 |      @param mnem: (C++: const char *) custom mnemonic
 |      @param width: (C++: int) width of field with mnemonic. if < 0, then 'postfix' will be
 |                    output before the mnemonic, i.e. as a prefix
 |      @param postfix: (C++: const char *) optional postfix added to 'mnem'
 |  
 |  out_data(self, *args) -> 'void'
 |      out_data(self, analyze_only)
 |      
 |      @param analyze_only: bool
 |  
 |  out_immchar_cmts(self, *args) -> 'void'
 |      out_immchar_cmts(self)
 |      Print all operand values as commented character constants. This function is used
 |      to comment void operands with their representation in the form of character
 |      constants. This function outputs a colored text.
 |  
 |  out_mnem(self, *args) -> 'void'
 |      out_mnem(self, width=8, postfix=None)
 |      Output instruction mnemonic for 'insn' using information in 'ph.instruc' array.
 |      This function outputs a colored text. It should be called from
 |      processor_t::ev_out_insn() or processor_t::ev_out_mnem() handler. It will output
 |      at least one space after the instruction. mnemonic even if the specified 'width'
 |      is not enough.
 |      
 |      @param width: (C++: int) width of field with mnemonic. if < 0, then 'postfix' will be
 |                    output before the mnemonic, i.e. as a prefix
 |      @param postfix: (C++: const char *) optional postfix added to the instruction mnemonic
 |  
 |  out_mnemonic(self, *args) -> 'void'
 |      out_mnemonic(self)
 |      Output instruction mnemonic using information in 'insn'. It should be called
 |      from processor_t::ev_out_insn() and it will call processor_t::ev_out_mnem() or
 |      out_mnem. This function outputs a colored text.
 |  
 |  out_one_operand(self, *args) -> 'bool'
 |      out_one_operand(self, n) -> bool
 |      Use this function to output an operand of an instruction. This function checks
 |      for the existence of a manually defined operand and will output it if it exists.
 |      It should be called from processor_t::ev_out_insn() and it will call
 |      processor_t::ev_out_operand(). This function outputs a colored text.
 |      
 |      @param n: (C++: int) number of operand
 |      @retval 1: operand is displayed
 |      @retval 0: operand is hidden
 |  
 |  out_specea(self, *args) -> 'bool'
 |      out_specea(self, segtype) -> bool
 |      
 |      @param segtype: uchar
 |  
 |  retrieve_cmt(self, *args) -> 'ssize_t'
 |      retrieve_cmt(self) -> ssize_t
 |  
 |  retrieve_name(self, *args) -> 'ssize_t'
 |      retrieve_name(self, arg2, arg3) -> ssize_t
 |      
 |      @param arg2: qstring *
 |      @param arg3: color_t *
 |  
 |  set_bin_state(self, *args) -> 'void'
 |      set_bin_state(self, value)
 |      
 |      @param value: int
 |  
 |  setup_outctx(self, *args) -> 'void'
 |      setup_outctx(self, prefix, flags)
 |      Initialization; normally used only by the kernel.
 |      
 |      @param prefix: (C++: const char *) char const *
 |      @param flags: int
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  ash
 |      ash
 |  
 |  bin_ea
 |      bin_ea
 |  
 |  bin_state
 |      bin_state
 |  
 |  bin_width
 |      bin_width
 |  
 |  curlabel
 |      curlabel
 |  
 |  gl_bpsize
 |      gl_bpsize
 |  
 |  insn
 |      insn
 |  
 |  ph
 |      ph
 |  
 |  procmod
 |      procmod
 |  
 |  saved_immvals
 |      saved_immvals
 |  
 |  thisown
 |      The membership flag
 |  
 |  wif
 |      wif
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from outctx_base_t:
 |  
 |  close_comment(self, *args) -> 'void'
 |      close_comment(self)
 |  
 |  clr_gen_label(self, *args) -> 'void'
 |      clr_gen_label(self)
 |  
 |  display_voids(self, *args) -> 'bool'
 |      display_voids(self) -> bool
 |  
 |  flush_buf(self, *args) -> 'bool'
 |      flush_buf(self, buf, indent=-1) -> bool
 |      Append contents of 'buf' to the line array. Behaves like flush_outbuf but
 |      accepts an arbitrary buffer
 |      
 |      @param buf: (C++: const char *) char const *
 |      @param indent: (C++: int)
 |  
 |  flush_outbuf(self, *args) -> 'bool'
 |      flush_outbuf(self, indent=-1) -> bool
 |      Functions to populate the output line array (lnar) Move the contents of the
 |      output buffer to the line array (outbuf->lnar) The kernel augments the outbuf
 |      contents with additional text like the line prefix, user-defined comments,
 |      xrefs, etc at this call.
 |      
 |      @param indent: (C++: int)
 |  
 |  forbid_annotations(self, *args) -> 'int'
 |      forbid_annotations(self) -> int
 |  
 |  force_code(self, *args) -> 'bool'
 |      force_code(self) -> bool
 |  
 |  gen_block_cmt(self, *args) -> 'bool'
 |      gen_block_cmt(self, cmt, color) -> bool
 |      Generate big non-indented comment lines.
 |      
 |      @param cmt: (C++: const char *) comment text. may contain \n characters to denote new lines. should
 |                  not contain comment character (;)
 |      @param color: (C++: color_t) color of comment text (one of Color tags)
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_border_line(self, *args) -> 'bool'
 |      gen_border_line(self, solid=False) -> bool
 |      Generate thin border line. This function does nothing if generation of border
 |      lines is disabled.
 |      
 |      @param solid: (C++: bool) generate solid border line (with =), otherwise with -
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_cmt_line(self, *args) -> 'bool'
 |      gen_cmt_line(self, format) -> bool
 |      Generate one non-indented comment line, colored with COLOR_AUTOCMT.
 |      
 |      @param format: (C++: const char *) printf() style format line. The resulting comment line should not
 |                     include comment character (;)
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_collapsed_line(self, *args) -> 'bool'
 |      gen_collapsed_line(self, format) -> bool
 |      Generate one non-indented comment line, colored with COLOR_COLLAPSED.
 |      
 |      @param format: (C++: const char *) printf() style format line. The resulting comment line should not
 |                     include comment character (;)
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_empty_line(self, *args) -> 'bool'
 |      gen_empty_line(self) -> bool
 |      Generate empty line. This function does nothing if generation of empty lines is
 |      disabled.
 |      
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  gen_empty_line_without_annotations(self, *args) -> 'void'
 |      gen_empty_line_without_annotations(self)
 |  
 |  gen_printf(self, *args) -> 'bool'
 |      gen_printf(self, indent, format) -> bool
 |      printf-like function to add lines to the line array.
 |      
 |      @param indent: (C++: int) indention of the line. if indent == -1, the kernel will indent
 |                     the line at idainfo::indent. if indent < 0, -indent will be used
 |                     for indention. The first line printed with indent < 0 is
 |                     considered as the most important line at the current address.
 |                     Usually it is the line with the instruction itself. This line
 |                     will be displayed in the cross-reference lists and other places.
 |                     If you need to output an additional line before the main line
 |                     then pass DEFAULT_INDENT instead of -1. The kernel will know that
 |                     your line is not the most important one.
 |      @param format: (C++: const char *) printf style colored line to generate
 |      @return: overflow, lnar_maxsize has been reached
 |  
 |  get_stkvar(self, *args) -> 'member_t *'
 |      get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
 |      
 |      @param arg2: op_t const &
 |      @param arg3: uval_t
 |      @param arg4: sval_t *
 |      @param arg5: int *
 |  
 |  init_lines_array(self, *args) -> 'void'
 |      init_lines_array(self, answers, maxsize)
 |      
 |      @param answers: qstrvec_t *
 |      @param maxsize: int
 |  
 |  multiline(self, *args) -> 'bool'
 |      multiline(self) -> bool
 |  
 |  only_main_line(self, *args) -> 'bool'
 |      only_main_line(self) -> bool
 |  
 |  out_addr_tag(self, *args) -> 'void'
 |      out_addr_tag(self, ea)
 |      Output "address" escape sequence.
 |      
 |      @param ea: (C++: ea_t)
 |  
 |  out_char(self, *args) -> 'void'
 |      out_char(self, c)
 |      Output one character. The character is output without color codes. see also
 |      out_symbol()
 |      
 |      @param c: (C++: char)
 |  
 |  out_chars(self, *args) -> 'void'
 |      out_chars(self, c, n)
 |      Append a character multiple times.
 |      
 |      @param c: (C++: char)
 |      @param n: (C++: int)
 |  
 |  out_colored_register_line(self, *args) -> 'void'
 |      out_colored_register_line(self, str)
 |      Output a colored line with register names in it. The register names will be
 |      substituted by user-defined names (regvar_t) Please note that out_tagoff tries
 |      to make substitutions too (when called with COLOR_REG)
 |      
 |      @param str: (C++: const char *) char const *
 |  
 |  out_keyword(self, *args) -> 'void'
 |      out_keyword(self, str)
 |      Output a string with COLOR_KEYWORD color.
 |      
 |      @param str: (C++: const char *) char const *
 |  
 |  out_line(self, *args) -> 'void'
 |      out_line(self, str, color=0)
 |      Output a string with the specified color.
 |      
 |      @param str: (C++: const char *) char const *
 |      @param color: (C++: color_t)
 |  
 |  out_long(self, *args) -> 'void'
 |      out_long(self, v, radix)
 |      Output a number with appropriate color. Low level function. Use out_value() if
 |      you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of
 |      COLOR_NUMBER. 'suspop' is initialized:
 |      * in out_one_operand()
 |      * in ..\ida\gl.cpp (before calling processor_t::d_out())
 |      
 |      @param v: (C++: sval_t) value to output
 |      @param radix: (C++: char) base (2,8,10,16)
 |  
 |  out_name_expr(self, *args) -> 'bool'
 |      out_name_expr(self, x, ea, off=BADADDR) -> bool
 |      Output a name expression.
 |      
 |      @param x: (C++: const op_t &) instruction operand referencing the name expression
 |      @param ea: (C++: ea_t) address to convert to name expression
 |      @param off: (C++: adiff_t) the value of name expression. this parameter is used only to check
 |                  that the name expression will have the wanted value. You may pass
 |                  BADADDR for this parameter but I discourage it because it prohibits
 |                  checks.
 |      @return: true if the name expression has been produced
 |  
 |  out_printf(self, *args) -> 'void'
 |      out_printf(self, format)
 |      Functions to append text to the current output buffer (outbuf) Append a
 |      formatted string to the output string.
 |      
 |      @param format: (C++: const char *) char const *
 |      @return: the number of characters appended
 |  
 |  out_register(self, *args) -> 'void'
 |      out_register(self, str)
 |      Output a character with COLOR_REG color.
 |      
 |      @param str: (C++: const char *) char const *
 |  
 |  out_spaces(self, *args) -> 'void'
 |      out_spaces(self, len)
 |      Appends spaces to outbuf until its tag_strlen becomes 'len'.
 |      
 |      @param len: (C++: ssize_t)
 |  
 |  out_symbol(self, *args) -> 'void'
 |      out_symbol(self, c)
 |      Output a character with COLOR_SYMBOL color.
 |      
 |      @param c: (C++: char)
 |  
 |  out_tagoff(self, *args) -> 'void'
 |      out_tagoff(self, tag)
 |      Output "turn color off" escape sequence.
 |      
 |      @param tag: (C++: color_t)
 |  
 |  out_tagon(self, *args) -> 'void'
 |      out_tagon(self, tag)
 |      Output "turn color on" escape sequence.
 |      
 |      @param tag: (C++: color_t)
 |  
 |  out_value(self, *args) -> 'flags_t'
 |      out_value(self, x, outf=0) -> flags_t
 |      Output immediate value. Try to use this function to output all constants of
 |      instruction operands. This function outputs a number from x.addr or x.value in
 |      the form determined by ::uFlag. It outputs a colored text.
 |      * -1 is output with COLOR_ERROR
 |      * 0 is output as a number or character or segment
 |      
 |      @param x: (C++: const op_t &) value to output
 |      @param outf: (C++: int) Output value flags
 |      @return: flags of the output value
 |  
 |  print_label_now(self, *args) -> 'bool'
 |      print_label_now(self) -> bool
 |  
 |  restore_ctxflags(self, *args) -> 'void'
 |      restore_ctxflags(self, saved_flags)
 |      
 |      @param saved_flags: int
 |  
 |  set_comment_addr(self, *args) -> 'void'
 |      set_comment_addr(self, ea)
 |      
 |      @param ea: ea_t
 |  
 |  set_dlbind_opnd(self, *args) -> 'void'
 |      set_dlbind_opnd(self)
 |  
 |  set_gen_cmt(self, *args) -> 'void'
 |      set_gen_cmt(self, on=True)
 |      
 |      @param on: bool
 |  
 |  set_gen_demangled_label(self, *args) -> 'void'
 |      set_gen_demangled_label(self)
 |  
 |  set_gen_label(self, *args) -> 'void'
 |      set_gen_label(self)
 |  
 |  set_gen_xrefs(self, *args) -> 'void'
 |      set_gen_xrefs(self, on=True)
 |      
 |      @param on: bool
 |  
 |  stack_view(self, *args) -> 'bool'
 |      stack_view(self) -> bool
 |  
 |  term_outctx(self, *args) -> 'int'
 |      term_outctx(self, prefix=None) -> int
 |      Finalize the output context.
 |      
 |      @param prefix: (C++: const char *) char const *
 |      @return: the number of generated lines.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from outctx_base_t:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  default_lnnum
 |      default_lnnum
 |  
 |  insn_ea
 |      insn_ea
 |  
 |  outbuf
 |      outbuf

Help on function outctx_t__from_ptrval__ in module ida_ua:

outctx_t__from_ptrval__(*args) -> 'outctx_t *'
    outctx_t__from_ptrval__(ptrval) -> outctx_t
    
    @param ptrval: size_t

Help on function print_insn_mnem in module ida_ua:

print_insn_mnem(*args) -> 'qstring *'
    print_insn_mnem(ea) -> str
    Print instruction mnemonics.
    
    @param ea: (C++: ea_t) linear address of the instruction
    @return: success

Help on function print_operand in module ida_ua:

print_operand(*args) -> 'qstring *'
    print_operand(ea, n, getn_flags=0, newtype=None) -> str
    Generate text representation for operand #n. This function will generate the
    text representation of the specified operand (includes color codes.)
    
    @param ea: (C++: ea_t) the item address (instruction or data)
    @param n: (C++: int) operand number (0,1,2...). meaningful only for instructions
    @param getn_flags: (C++: int) Name expression flags Currently only GETN_NODUMMY is
                       accepted.
    @param newtype: (C++: struct printop_t *) if specified, print the operand using the specified type
    @return: success

Module "ida_xref"s docstring:
"""
Functions that deal with cross-references.

There are 2 types of xrefs: CODE and DATA references. All xrefs are kept in the
bTree except ordinary execution flow to the next instruction. Ordinary execution
flow to the next instruction is kept in flags (see bytes.hpp)

The source address of a cross-reference must be an item head (is_head) or a
structure member id.

Cross-references are automatically sorted."""

Help on function add_cref in module ida_xref:

add_cref(*args) -> 'bool'
    add_cref(frm, to, type) -> bool
    Create a code cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param to: (C++: ea_t) linear address of referenced instruction
    @param type: (C++: cref_t) cross-reference type
    @return: success

Help on function add_dref in module ida_xref:

add_dref(*args) -> 'bool'
    add_dref(frm, to, type) -> bool
    Create a data cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param to: (C++: ea_t) linear address of referenced data
    @param type: (C++: dref_t) cross-reference type
    @return: success (may fail if user-defined xref exists from->to)

Help on function calc_switch_cases in module ida_xref:

calc_switch_cases(*args) -> 'cases_and_targets_t *'
    calc_switch_cases(ea, si) -> cases_and_targets_t
    Get information about a switch's cases.
    
    The returned information can be used as follows:
    
        for idx in range(len(results.cases)):
            cur_case = results.cases[idx]
            for cidx in range(len(cur_case)):
                print("case: %d" % cur_case[cidx])
            print("  goto 0x%x" % results.targets[idx])
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: a structure with 2 members: 'cases', and 'targets'.

Help on class cases_and_targets_t in module ida_xref:

class cases_and_targets_t(builtins.object)
 |  Proxy of C++ cases_and_targets_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> cases_and_targets_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_cases_and_targets_t(...)
 |      delete_cases_and_targets_t(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  cases
 |      cases
 |  
 |  targets
 |      targets
 |  
 |  thisown
 |      The membership flag

Help on class casevec_t in module ida_xref:

class casevec_t(builtins.object)
 |  Proxy of C++ qvector< qvector< sval_t > > class.
 |  
 |  Methods defined here:
 |  
 |  __eq__(self, *args) -> 'bool'
 |      __eq__(self, r) -> bool
 |      
 |      @param r: qvector< qvector< signed-ea-like-numeric-type > > const &
 |  
 |  __getitem__(self, *args) -> 'qvector< signed-ea-like-numeric-type > const &'
 |      __getitem__(self, i) -> qvector< signed-ea-like-numeric-type > const &
 |      
 |      @param i: size_t
 |  
 |  __init__(self, *args)
 |      __init__(self) -> casevec_t
 |      __init__(self, x) -> casevec_t
 |      
 |      @param x: qvector< qvector< signed-ea-like-numeric-type > > const &
 |  
 |  __iter__ = _bounded_getitem_iterator(self)
 |      Helper function, to be set as __iter__ method for qvector-, or array-based classes.
 |  
 |  __len__ = size(self, *args) -> 'size_t'
 |  
 |  __ne__(self, *args) -> 'bool'
 |      __ne__(self, r) -> bool
 |      
 |      @param r: qvector< qvector< signed-ea-like-numeric-type > > const &
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __setitem__(self, *args) -> 'void'
 |      __setitem__(self, i, v)
 |      
 |      @param i: size_t
 |      @param v: qvector< signed-ea-like-numeric-type > const &
 |  
 |  __swig_destroy__ = delete_casevec_t(...)
 |      delete_casevec_t(self)
 |  
 |  _del(self, *args) -> 'bool'
 |      _del(self, x) -> bool
 |      
 |      Parameters
 |      ----------
 |      x: qvector< signed-ea-like-numeric-type > const &
 |  
 |  add_unique(self, *args) -> 'bool'
 |      add_unique(self, x) -> bool
 |      
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |  
 |  append = push_back(self, *args) -> 'qvector< signed-ea-like-numeric-type > &'
 |  
 |  at = __getitem__(self, *args) -> 'qvector< signed-ea-like-numeric-type > const &'
 |  
 |  back = _qvector_back(self)
 |      # -----------------------------------------------------------------------
 |  
 |  begin(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::const_iterator'
 |      begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      begin(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
 |  
 |  capacity(self, *args) -> 'size_t'
 |      capacity(self) -> size_t
 |  
 |  clear(self, *args) -> 'void'
 |      clear(self)
 |  
 |  empty(self, *args) -> 'bool'
 |      empty(self) -> bool
 |  
 |  end(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::const_iterator'
 |      end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      end(self) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
 |  
 |  erase(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::iterator'
 |      erase(self, it) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      
 |      @param it: qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      
 |      erase(self, first, last) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      
 |      @param first: qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      @param last: qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |  
 |  extract(self, *args) -> 'qvector< signed-ea-like-numeric-type > *'
 |      extract(self) -> qvector< signed-ea-like-numeric-type > *
 |  
 |  find(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::const_iterator'
 |      find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |      
 |      find(self, x) -> qvector< qvector< signed-ea-like-numeric-type > >::const_iterator
 |      
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |  
 |  front = _qvector_front(self)
 |      # -----------------------------------------------------------------------
 |  
 |  grow(self, *args) -> 'void'
 |      grow(self, x=qvector< signed-ea-like-numeric-type >())
 |      
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |  
 |  has(self, *args) -> 'bool'
 |      has(self, x) -> bool
 |      
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |  
 |  inject(self, *args) -> 'void'
 |      inject(self, s, len)
 |      
 |      @param s: qvector< signed-ea-like-numeric-type > *
 |      @param len: size_t
 |  
 |  insert(self, *args) -> 'qvector< qvector< signed-ea-like-numeric-type > >::iterator'
 |      insert(self, it, x) -> qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      
 |      @param it: qvector< qvector< signed-ea-like-numeric-type > >::iterator
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |  
 |  pop_back(self, *args) -> 'void'
 |      pop_back(self)
 |  
 |  push_back(self, *args) -> 'qvector< signed-ea-like-numeric-type > &'
 |      push_back(self, x)
 |      
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |      
 |      push_back(self) -> qvector< signed-ea-like-numeric-type > &
 |  
 |  qclear(self, *args) -> 'void'
 |      qclear(self)
 |  
 |  reserve(self, *args) -> 'void'
 |      reserve(self, cnt)
 |      
 |      @param cnt: size_t
 |  
 |  resize(self, *args) -> 'void'
 |      resize(self, _newsize, x)
 |      
 |      @param _newsize: size_t
 |      @param x: qvector< signed-ea-like-numeric-type > const &
 |      
 |      resize(self, _newsize)
 |      
 |      @param _newsize: size_t
 |  
 |  size(self, *args) -> 'size_t'
 |      size(self) -> size_t
 |  
 |  swap(self, *args) -> 'void'
 |      swap(self, r)
 |      
 |      @param r: qvector< qvector< signed-ea-like-numeric-type > > &
 |  
 |  truncate(self, *args) -> 'void'
 |      truncate(self)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  thisown
 |      The membership flag
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __hash__ = None

Help on function create_switch_table in module ida_xref:

create_switch_table(*args) -> 'bool'
    create_switch_table(ea, si) -> bool
    Create switch table from the switch information
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

Help on function create_switch_xrefs in module ida_xref:

create_switch_xrefs(*args) -> 'bool'
    create_switch_xrefs(ea, si) -> bool
    This function creates xrefs from the indirect jump.
    
    Usually there is no need to call this function directly because the kernel
    will call it for switch tables
    
    Note: Custom switch information are not supported yet.
    
    @param ea: address of the 'indirect jump' instruction
    @param si: switch information
    
    @return: Boolean

Help on function del_cref in module ida_xref:

del_cref(*args) -> 'bool'
    del_cref(frm, to, expand) -> bool
    Delete a code cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param to: (C++: ea_t) linear address of referenced instruction
    @param expand: (C++: bool) policy to delete the referenced instruction
    * 1: plan to delete the referenced instruction if it has no more references.
    * 0: don't delete the referenced instruction even if no more cross-references
    point to it
    @retval true: if the referenced instruction will be deleted

Help on function del_dref in module ida_xref:

del_dref(*args) -> 'void'
    del_dref(frm, to)
    Delete a data cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param to: (C++: ea_t) linear address of referenced data

Help on function delete_switch_table in module ida_xref:

delete_switch_table(*args) -> 'void'
    delete_switch_table(jump_ea, si)
    
    @param jump_ea: ea_t
    @param si: switch_info_t const &

Help on function get_first_cref_from in module ida_xref:

get_first_cref_from(*args) -> 'ea_t'
    get_first_cref_from(frm) -> ea_t
    Get first instruction referenced from the specified instruction. If the
    specified instruction passes execution to the next instruction then the next
    instruction is returned. Otherwise the lowest referenced address is returned
    (remember that xrefs are kept sorted!).
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @return: first referenced address. If the specified instruction doesn't
             reference to other instructions then returns BADADDR.

Help on function get_first_cref_to in module ida_xref:

get_first_cref_to(*args) -> 'ea_t'
    get_first_cref_to(to) -> ea_t
    Get first instruction referencing to the specified instruction. If the specified
    instruction may be executed immediately after its previous instruction then the
    previous instruction is returned. Otherwise the lowest referencing address is
    returned. (remember that xrefs are kept sorted!).
    
    @param to: (C++: ea_t) linear address of referenced instruction
    @return: linear address of the first referencing instruction or BADADDR.

Help on function get_first_dref_from in module ida_xref:

get_first_dref_from(*args) -> 'ea_t'
    get_first_dref_from(frm) -> ea_t
    Get first data referenced from the specified address.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @return: linear address of first (lowest) data referenced from the specified
             address. Return BADADDR if the specified instruction/data doesn't
             reference to anything.

Help on function get_first_dref_to in module ida_xref:

get_first_dref_to(*args) -> 'ea_t'
    get_first_dref_to(to) -> ea_t
    Get address of instruction/data referencing to the specified data.
    
    @param to: (C++: ea_t) linear address of referencing instruction or data
    @return: BADADDR if nobody refers to the specified data.

Help on function get_first_fcref_from in module ida_xref:

get_first_fcref_from(*args) -> 'ea_t'
    get_first_fcref_from(frm) -> ea_t
    
    @param from: ea_t

Help on function get_first_fcref_to in module ida_xref:

get_first_fcref_to(*args) -> 'ea_t'
    get_first_fcref_to(to) -> ea_t
    
    @param to: ea_t

Help on function get_next_cref_from in module ida_xref:

get_next_cref_from(*args) -> 'ea_t'
    get_next_cref_from(frm, current) -> ea_t
    Get next instruction referenced from the specified instruction.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param current: (C++: ea_t) linear address of current referenced instruction This value is
                    returned by get_first_cref_from() or previous call to
                    get_next_cref_from() functions.
    @return: next referenced address or BADADDR.

Help on function get_next_cref_to in module ida_xref:

get_next_cref_to(*args) -> 'ea_t'
    get_next_cref_to(to, current) -> ea_t
    Get next instruction referencing to the specified instruction.
    
    @param to: (C++: ea_t) linear address of referenced instruction
    @param current: (C++: ea_t) linear address of current referenced instruction This value is
                    returned by get_first_cref_to() or previous call to
                    get_next_cref_to() functions.
    @return: linear address of the next referencing instruction or BADADDR.

Help on function get_next_dref_from in module ida_xref:

get_next_dref_from(*args) -> 'ea_t'
    get_next_dref_from(frm, current) -> ea_t
    Get next data referenced from the specified address.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param current: (C++: ea_t) linear address of current referenced data. This value is
                    returned by get_first_dref_from() or previous call to
                    get_next_dref_from() functions.
    @return: linear address of next data or BADADDR.

Help on function get_next_dref_to in module ida_xref:

get_next_dref_to(*args) -> 'ea_t'
    get_next_dref_to(to, current) -> ea_t
    Get address of instruction/data referencing to the specified data
    
    @param to: (C++: ea_t) linear address of referencing instruction or data
    @param current: (C++: ea_t) current linear address. This value is returned by
                    get_first_dref_to() or previous call to get_next_dref_to()
                    functions.
    @return: BADADDR if nobody refers to the specified data.

Help on function get_next_fcref_from in module ida_xref:

get_next_fcref_from(*args) -> 'ea_t'
    get_next_fcref_from(frm, current) -> ea_t
    
    @param from: ea_t
    @param current: ea_t

Help on function get_next_fcref_to in module ida_xref:

get_next_fcref_to(*args) -> 'ea_t'
    get_next_fcref_to(to, current) -> ea_t
    
    @param to: ea_t
    @param current: ea_t

Help on function has_external_refs in module ida_xref:

has_external_refs(*args) -> 'bool'
    has_external_refs(pfn, ea) -> bool
    Does 'ea' have references from outside of 'pfn'?
    
    @param pfn: (C++: func_t *)
    @param ea: (C++: ea_t)

Help on class xrefblk_t in module ida_xref:

class xrefblk_t(builtins.object)
 |  Proxy of C++ xrefblk_t class.
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *args)
 |      __init__(self) -> xrefblk_t
 |  
 |  __repr__ = _swig_repr(self)
 |  
 |  __swig_destroy__ = delete_xrefblk_t(...)
 |      delete_xrefblk_t(self)
 |  
 |  crefs_from(self, ea)
 |      Provide an iterator on code references from ea including flow references
 |  
 |  crefs_to(self, ea)
 |      Provide an iterator on code references to ea including flow references
 |  
 |  drefs_from(self, ea)
 |      Provide an iterator on data references from ea
 |  
 |  drefs_to(self, ea)
 |      Provide an iterator on data references to ea
 |  
 |  fcrefs_from(self, ea)
 |      Provide an iterator on code references from ea
 |  
 |  fcrefs_to(self, ea)
 |      Provide an iterator on code references to ea
 |  
 |  first_from(self, *args) -> 'bool'
 |      first_from(self, _from, flags) -> bool
 |      Get first xref from the given address (store in to)
 |      
 |      @param _from: (C++: ea_t)
 |      @param flags: (C++: int)
 |  
 |  first_to(self, *args) -> 'bool'
 |      first_to(self, _to, flags) -> bool
 |      Get xref to given address (store in from)
 |      
 |      @param _to: (C++: ea_t)
 |      @param flags: (C++: int)
 |  
 |  next_from(self, *args) -> 'bool'
 |      next_from(self) -> bool
 |      Get xref from '_from' that comes after '_to'.
 |      next_from(self, _from, _to, flags) -> bool
 |      
 |      @param _from: ea_t
 |      @param _to: ea_t
 |      @param flags: int
 |  
 |  next_to(self, *args) -> 'bool'
 |      next_to(self) -> bool
 |      Get xref to '_to' that comes after '_from'.
 |      next_to(self, _from, _to, flags) -> bool
 |      
 |      @param _from: ea_t
 |      @param _to: ea_t
 |      @param flags: int
 |  
 |  refs_from(self, ea, flag)
 |      Provide an iterator on from reference represented by flag
 |  
 |  refs_to(self, ea, flag)
 |      Provide an iterator on to reference represented by flag
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  frm
 |      frm
 |  
 |  iscode
 |      iscode
 |  
 |  thisown
 |      The membership flag
 |  
 |  to
 |      to
 |  
 |  type
 |      type
 |  
 |  user
 |      user

Help on function xrefchar in module ida_xref:

xrefchar(*args) -> 'char'
    xrefchar(xrtype) -> char
    Get character describing the xref type.
    
    @param xrtype: (C++: char) combination of Cross-Reference type flags and a cref_t of dref_t
                   value

Module "idc"s docstring:
"""
IDC compatibility module

This file contains IDA built-in function declarations and internal bit
definitions.  Each byte of the program has 32-bit flags (low 8 bits keep
the byte value). These 32 bits are used in get_full_flags/get_flags functions.

This file is subject to change without any notice.
Future versions of IDA may use other definitions.
"""

Help on function AddSeg in module idc:

AddSeg(startea, endea, base, use32, align, comb)

Help on function AutoMark in module idc:

AutoMark(ea, qtype)
    Plan to analyze an address

Help on class DeprecatedIDCError in module idc:

class DeprecatedIDCError(builtins.Exception)
 |  Exception for deprecated function calls
 |  
 |  Method resolution order:
 |      DeprecatedIDCError
 |      builtins.Exception
 |      builtins.BaseException
 |      builtins.object
 |  
 |  Data descriptors defined here:
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.Exception:
 |  
 |  __init__(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __new__(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from builtins.BaseException:
 |  
 |  __delattr__(self, name, /)
 |      Implement delattr(self, name).
 |  
 |  __getattribute__(self, name, /)
 |      Return getattr(self, name).
 |  
 |  __reduce__(...)
 |      helper for pickle
 |  
 |  __repr__(self, /)
 |      Return repr(self).
 |  
 |  __setattr__(self, name, value, /)
 |      Implement setattr(self, name, value).
 |  
 |  __setstate__(...)
 |  
 |  __str__(self, /)
 |      Return str(self).
 |  
 |  with_traceback(...)
 |      Exception.with_traceback(tb) --
 |      set self.__traceback__ to tb and return self.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from builtins.BaseException:
 |  
 |  __cause__
 |      exception cause
 |  
 |  __context__
 |      exception context
 |  
 |  __dict__
 |  
 |  __suppress_context__
 |  
 |  __traceback__
 |  
 |  args

Help on function EVAL_FAILURE in module idc:

EVAL_FAILURE(code)
    Check the result of eval_idc() for evaluation failures
    
    @param code: result of eval_idc()
    
    @return: True if there was an evaluation error

Help on function get_cmt in module ida_bytes:

get_cmt(*args) -> 'qstring *'
    get_cmt(ea, rptble) -> str
    Get an indented comment.
    
    @param ea: (C++: ea_t) linear address. may point to tail byte, the function will find start
               of the item
    @param rptble: (C++: bool) get repeatable comment?
    @return: size of comment or -1

Help on function GetDisasm in module idc:

GetDisasm(ea)
    Get disassembly line
    
    @param ea: linear address of instruction
    
    @return: "" - could not decode instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
           as you see on the screen.

Help on function GetDouble in module idc:

GetDouble(ea)
    Get value of a floating point number (8 bytes)
    This function assumes number stored using IEEE format
    and in the same endianness as integers.
    
    @param ea: linear address
    
    @return: double

Help on function GetFloat in module idc:

GetFloat(ea)
    Get value of a floating point number (4 bytes)
    This function assumes number stored using IEEE format
    and in the same endianness as integers.
    
    @param ea: linear address
    
    @return: float

Help on function GetLocalType in module idc:

GetLocalType(ordinal, flags)
    Retrieve a local type declaration
    @param flags: any of PRTYPE_* constants
    @return: local type as a C declaration or ""

Help on function LoadFile in module idc:

LoadFile(filepath, pos, ea, size)
    Load file into IDA database
    
    @param filepath: path to input file
    @param pos: position in the file
    @param ea: linear address to load
    @param size: number of bytes to load
    
    @return: 0 - error, 1 - ok

Help on function MakeVar in module idc:

MakeVar(ea)

Help on function SaveFile in module idc:

SaveFile(filepath, pos, ea, size)
    Save from IDA database to file
    
    @param filepath: path to output file
    @param pos: position in the file
    @param ea: linear address to save from
    @param size: number of bytes to save
    
    @return: 0 - error, 1 - ok

Help on function SetPrcsr in module idc:

SetPrcsr(processor)

Help on function SetType in module idc:

SetType(ea, newtype)
    Set type of function/variable
    
    @param ea: the address of the object
    @param newtype: the type string in C declaration form.
                Must contain the closing ';'
                if specified as an empty string, then the
                item associated with 'ea' will be deleted.
    
    @return: 1-ok, 0-failed.

Help on function SizeOf in module idc:

SizeOf(typestr)
    Returns the size of the type. It is equivalent to IDC's sizeof().
    Use name, tp, fld = idc.parse_decl() ; SizeOf(tp) to retrieve the size
    @return: -1 if typestring is not valid otherwise the size of the type

Help on function _IDC_GetAttr in module idc:

_IDC_GetAttr(obj, attrmap, attroffs)
    Internal function to generically get object attributes
    Do not use unless you know what you are doing

Help on function _IDC_SetAttr in module idc:

_IDC_SetAttr(obj, attrmap, attroffs, value)
    Internal function to generically set object attributes
    Do not use unless you know what you are doing

Help on function __DbgValue in module idc:

__DbgValue(ea, len)

Help on function __GetArrayById in module idc:

__GetArrayById(array_id)
    Get an array, by its ID.
    
    This (internal) wrapper around 'idaaip.netnode(array_id)'
    will ensure a certain safety around the retrieval of
    arrays (by catching quite unexpect[ed|able] exceptions,
    and making sure we don't create & use `transient' netnodes).
    
    @param array_id: A positive, valid array ID.

Help on class __dummy_netnode in module idc:

class __dummy_netnode(builtins.object)
 |  Implements, in an "always failing" fashion, the
 |  netnode functions that are necessary for the
 |  array-related functions.
 |  
 |  The sole purpose of this singleton class is to
 |  serve as a placeholder for netnode-manipulating
 |  functions, that don't want to each have to perform
 |  checks on the existence of the netnode.
 |  (..in other words: it avoids a bunch of if/else's).
 |  
 |  See __GetArrayById() for more info.
 |  
 |  Methods defined here:
 |  
 |  altdel(self, *args)
 |  
 |  altfirst(self, *args)
 |  
 |  altlast(self, *args)
 |  
 |  altnext(self, *args)
 |  
 |  altprev(self, *args)
 |  
 |  altset(self, *args)
 |  
 |  altval(self, *args)
 |  
 |  hashdel(self, *args)
 |  
 |  hashfirst(self, *args)
 |  
 |  hashlast(self, *args)
 |  
 |  hashnext(self, *args)
 |  
 |  hashprev(self, *args)
 |  
 |  hashset(self, *args)
 |  
 |  hashset_buf(self, *args)
 |  
 |  hashset_idx(self, *args)
 |  
 |  hashstr(self, *args)
 |  
 |  hashstr_buf(self, *args)
 |  
 |  hashval(self, *args)
 |  
 |  hashval_long(self, *args)
 |  
 |  index(self, *args)
 |  
 |  kill(self, *args)
 |  
 |  rename(self, *args)
 |  
 |  supdel(self, *args)
 |  
 |  supfirst(self, *args)
 |  
 |  suplast(self, *args)
 |  
 |  supnext(self, *args)
 |  
 |  supprev(self, *args)
 |  
 |  supset(self, *args)
 |  
 |  supval(self, *args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  instance = <idc.__dummy_netnode object>

Help on function __l2m1 in module idc:

__l2m1(v)
    Long to minus 1: If the 'v' appears to be the
    'signed long' version of -1, then return -1.
    Otherwise, return 'v'.

Help on function __m1tol in module idc:

__m1tol(v)
    Long -1 to BADNODE: If the 'v' appears to be the
    'signed long' version of -1, then return BADNODE.
    Otherwise, return 'v'.

Help on function __warn_once_deprecated_proto_confusion in module idc:

__warn_once_deprecated_proto_confusion(what, alternative)

Help on function _get_modules in module idc:

_get_modules()
    INTERNAL: Enumerate process modules

Help on function _import_module_flag_sets in module idc:

_import_module_flag_sets(module, prefixes)

Help on function add_auto_stkpnt in module idc:

add_auto_stkpnt(func_ea, ea, delta)
    Add automatical SP register change point
    @param func_ea: function start
    @param ea: linear address where SP changes
               usually this is the end of the instruction which
               modifies the stack pointer (insn.ea+insn.size)
    @param delta: difference between old and new values of SP
    @return: 1-ok, 0-failed

Help on function add_bpt in module ida_dbg:

add_bpt(*args) -> 'bool'
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    @param bpt: (C++: const bpt_t &) Breakpoint to add. It describes the break condition, type, flags,
                location (module relative, source breakpoint or absolute) and other
                attributes.
    @param size: asize_t
    @param type: bpttype_t
    
    add_bpt(bpt) -> bool
    
    @param bpt: bpt_t const &

Help on function add_cref in module ida_xref:

add_cref(*args) -> 'bool'
    add_cref(frm, to, type) -> bool
    Create a code cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param to: (C++: ea_t) linear address of referenced instruction
    @param type: (C++: cref_t) cross-reference type
    @return: success

Help on function add_default_til in module idc:

add_default_til(name)
    Load a type library
    
    @param name: name of type library.
    @return: 1-ok, 0-failed.

Help on function add_dref in module ida_xref:

add_dref(*args) -> 'bool'
    add_dref(frm, to, type) -> bool
    Create a data cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param to: (C++: ea_t) linear address of referenced data
    @param type: (C++: dref_t) cross-reference type
    @return: success (may fail if user-defined xref exists from->to)

Help on function add_entry in module ida_entry:

add_entry(*args) -> 'bool'
    add_entry(ord, ea, name, makecode, flags=0) -> bool
    Add an entry point to the list of entry points.
    
    @param ord: (C++: uval_t) ordinal number if ordinal number is equal to 'ea' then ordinal is
                not used
    @param ea: (C++: ea_t) linear address
    @param name: (C++: const char *) name of entry point. If the specified location already has a name,
                 the old name will be appended to the regular comment. If name ==
                 nullptr, then the old name will be retained.
    @param makecode: (C++: bool) should the kernel convert bytes at the entry point to
                     instruction(s)
    @param flags: (C++: int) See AEF_*
    @return: success (currently always true)

Help on function add_enum in module idc:

add_enum(idx, name, flag)
    Add a new enum type
    
    @param idx: serial number of the new enum.
            If another enum with the same serial number
            exists, then all enums with serial
            numbers >= the specified idx get their
            serial numbers incremented (in other words,
            the new enum is put in the middle of the list of enums).
    
            If idx >= get_enum_qty() or idx == idaapi.BADNODE
            then the new enum is created at the end of
            the list of enums.
    
    @param name: name of the enum.
    @param flag: flags for representation of numeric constants
                 in the definition of enum.
    
    @return: id of new enum or BADADDR

Help on function add_enum_member in module idc:

add_enum_member(enum_id, name, value, bmask)
    Add a member of enum - a symbolic constant
    
    @param enum_id: id of enum
    @param name: name of symbolic constant. Must be unique in the program.
    @param value: value of symbolic constant.
    @param bmask: bitmask of the constant
        ordinary enums accept only ida_enum.DEFMASK as a bitmask
        all bits set in value should be set in bmask too
    
    @return: 0-ok, otherwise error code (one of ENUM_MEMBER_ERROR_*)

Help on function add_func in module ida_funcs:

add_func(*args) -> 'bool'
    add_func(ea1, ea2=BADADDR) -> bool
    Add a new function. If the function end address is BADADDR, then IDA will try to
    determine the function bounds by calling find_func_bounds(...,
    FIND_FUNC_DEFINE).
    
    @param ea1: (C++: ea_t) start address
    @param ea2: (C++: ea_t) end address
    @return: success

Help on function add_hidden_range in module ida_bytes:

add_hidden_range(*args) -> 'bool'
    add_hidden_range(ea1, ea2, description, header, footer, color=bgcolor_t(-1)) -> bool
    Mark a range of addresses as hidden. The range will be created in the invisible
    state with the default color
    
    @param ea1: (C++: ea_t) linear address of start of the address range
    @param ea2: (C++: ea_t) linear address of end of the address range
    @param description: (C++: const char *) ,header,footer: range parameters
    @param header: (C++: const char *) char const *
    @param footer: (C++: const char *) char const *
    @param color: (C++: bgcolor_t) the range color
    @return: success

Help on function add_idc_hotkey in module ida_kernwin:

add_idc_hotkey(*args) -> 'int'
    add_idc_hotkey(hotkey, idcfunc) -> int
    Add hotkey for IDC function (ui_add_idckey).
    
    @param hotkey: (C++: const char *) hotkey name
    @param idcfunc: (C++: const char *) IDC function name
    @return: IDC hotkey error codes

Help on function add_segm_ex in module idc:

add_segm_ex(startea, endea, base, use32, align, comb, flags)
    Create a new segment
    
    @param startea: linear address of the start of the segment
    @param endea: linear address of the end of the segment
               this address will not belong to the segment
               'endea' should be higher than 'startea'
    @param base: base paragraph or selector of the segment.
               a paragraph is 16byte memory chunk.
               If a selector value is specified, the selector should be
               already defined.
    @param use32: 0: 16bit segment, 1: 32bit segment, 2: 64bit segment
    @param align: segment alignment. see below for alignment values
    @param comb: segment combination. see below for combination values.
    @param flags: combination of ADDSEG_... bits
    
    @return: 0-failed, 1-ok

Help on function add_sourcefile in module ida_lines:

add_sourcefile(*args) -> 'bool'
    add_sourcefile(ea1, ea2, filename) -> bool
    Mark a range of address as belonging to a source file. An address range may
    belong only to one source file. A source file may be represented by several
    address ranges.
    
    @param ea1: (C++: ea_t) linear address of start of the address range
    @param ea2: (C++: ea_t) linear address of end of the address range (excluded)
    @param filename: (C++: const char *) name of source file.
    @return: success

Help on function add_struc in module idc:

add_struc(index, name, is_union)
    Define a new structure type
    
    @param index: index of new structure type
                  If another structure has the specified index,
                  then index of that structure and all other
                  structures will be incremented, freeing the specifed
                  index. If index is == -1, then the biggest index
                  number will be used.
                  See get_first_struc_idx() for the explanation of
                  structure indices and IDs.
    @param name: name of the new structure type.
    @param is_union: 0: structure
                     1: union
    
    @return: -1 if can't define structure type because of
             bad structure name: the name is ill-formed or is
             already used in the program.
             otherwise returns ID of the new structure type

Help on function add_struc_member in module idc:

add_struc_member(sid, name, offset, flag, typeid, nbytes, target=-1, tdelta=0, reftype=2)
    Add structure member
    
    @param sid: structure type ID
    @param name: name of the new member
    @param offset: offset of the new member
                   -1 means to add at the end of the structure
    @param flag: type of the new member. Should be one of
                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
    @param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                   if is_off0(flag) then typeid specifies the offset base.
                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                   if is_stroff(flag) then typeid specifies the structure id
                   if is_enum(flag) then typeid specifies the enum id
                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                   Otherwise typeid should be -1.
    @param nbytes: number of bytes in the new member
    
    @param target: target address of the offset expr. You may specify it as
                   -1, ida will calculate it itself
    @param tdelta: offset target delta. usually 0
    @param reftype: see REF_... definitions
    
    @note: The remaining arguments are allowed only if is_off0(flag) and you want
           to specify a complex offset expression
    
    @return: 0 - ok, otherwise error code (one of STRUC_ERROR_*)

Help on function add_user_stkpnt in module ida_frame:

add_user_stkpnt(*args) -> 'bool'
    add_user_stkpnt(ea, delta) -> bool
    Add user-defined SP register change point.
    
    @param ea: (C++: ea_t) linear address where SP changes
    @param delta: (C++: sval_t) difference between old and new values of SP
    @return: success

Help on function append_func_tail in module idc:

append_func_tail(funcea, ea1, ea2)
    Append a function chunk to the function
    
    @param funcea: any address in the function
    @param ea1: start of function tail
    @param ea2: end of function tail
    @return: 0 if failed, 1 if success
    
    @note: If a chunk exists at the specified addresses, it must have exactly
           the specified boundaries

Help on function apply_type in module idc:

apply_type(ea, py_type, flags=1)
    Apply the specified type to the address
    
    @param ea: the address of the object
    @param py_type: typeinfo tuple (type, fields) as get_tinfo() returns
                 or tuple (name, type, fields) as parse_decl() returns
                 or None
                if specified as None, then the
                item associated with 'ea' will be deleted.
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean

Help on function ask_seg in module ida_kernwin:

ask_seg(defval, format)
    Display a dialog box and wait for the user to input an segment name
    (ui_ask_seg). This function allows to enter segment register names, segment base
    paragraphs, segment names to denote a segment.
    
    @retval 0: if the user pressed Esc.
    @retval 1: ok, the user entered an segment name

Help on function ask_yn in module ida_kernwin:

ask_yn(*args) -> 'int'
    ask_yn(deflt, format) -> int
    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    @param deflt: (C++: int) default choice: one of Button IDs
    @param format: (C++: const char *) The question in printf() style format
    @return: the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.

Help on function atoa in module idc:

atoa(ea)
    Convert address value to a string
    Return address in the form 'seg000:1234'
    (the same as in line prefixes)
    
    @param ea: address to format

Help on function atol in module idc:

atol(s)

Help on function attach_process in module ida_dbg:

attach_process(*args) -> 'int'
    attach_process(pid=pid_t(-1), event_id=-1) -> int
    Attach the debugger to a running process. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_process_attach}
    @note: This function shouldn't be called as a request if NO_PROCESS is used.
    
    @param pid: (C++: pid_t) PID of the process to attach to. If NO_PROCESS, a dialog box will
                interactively ask the user for the process to attach to.
    @retval -4: debugger was not inited
    @retval -3: the attaching is not supported
    @retval -2: impossible to find a compatible process
    @retval -1: impossible to attach to the given process (process died, privilege
                needed, not supported by the debugger plugin, ...)
    @retval 0: the user cancelled the attaching to the process
    @retval 1: the debugger properly attached to the process

Help on function auto_mark_range in module ida_auto:

auto_mark_range(*args) -> 'void'
    auto_mark_range(start, end, type)
    Put range of addresses into a queue. 'start' may be higher than 'end', the
    kernel will swap them in this case. 'end' doesn't belong to the range.
    
    @param start: (C++: ea_t)
    @param end: (C++: ea_t)
    @param type: (C++: atype_t)

Help on function auto_unmark in module ida_auto:

auto_unmark(*args) -> 'void'
    auto_unmark(start, end, type)
    Remove range of addresses from a queue. 'start' may be higher than 'end', the
    kernel will swap them in this case. 'end' doesn't belong to the range.
    
    @param start: (C++: ea_t)
    @param end: (C++: ea_t)
    @param type: (C++: atype_t)

Help on function auto_wait in module ida_auto:

auto_wait(*args) -> 'bool'
    auto_wait() -> bool
    Process everything in the queues and return true.
    
    @return: false if the user clicked cancel. (the wait box must be displayed by
             the caller if desired)

Help on function batch in module idc:

batch(batch)
    Enable/disable batch mode of operation
    
    @param batch: batch mode
            0 - ida will display dialog boxes and wait for the user input
            1 - ida will not display dialog boxes, warnings, etc.
    
    @return: old balue of batch flag

Help on function byte_value in module idc:

byte_value(F)
    Get byte value from flags
    Get value of byte provided that the byte is initialized.
    This macro works ok only for 8-bit byte machines.

Help on function calc_gtn_flags in module ida_name:

calc_gtn_flags(fromaddr, ea)
    Calculate flags for get_ea_name() function
    
    @param fromaddr: the referring address. May be BADADDR.
    @param ea: linear address
    
    @return: flags

Help on function call_system in module idc:

call_system(command)
    Execute an OS command.
    
    @param command: command line to execute
    
    @return: error code from OS
    
    @note:
    IDA will wait for the started program to finish.
    In order to start the command in parallel, use OS methods.
    For example, you may start another program in parallel using
    "start" command.

Help on function can_exc_continue in module idc:

can_exc_continue()
    Can it continue after EXCEPTION event?
    
    @return: boolean

Help on function check_bpt in module ida_dbg:

check_bpt(*args) -> 'int'
    check_bpt(ea) -> int
    Check the breakpoint at the specified address.
    
    @param ea: (C++: ea_t)
    @return: one of Breakpoint status codes

Help on function choose_func in module idc:

choose_func(title)
    Ask the user to select a function
    
    Arguments:
    
    @param title: title of the dialog box
    
    @return: -1 - user refused to select a function
             otherwise returns the selected function start address

Help on function clear_trace in module idc:

clear_trace(filename)
    Clear the current trace buffer

Help on function create_align in module ida_bytes:

create_align(*args) -> 'bool'
    create_align(ea, length, alignment) -> bool
    Create an alignment item.
    
    @param ea: (C++: ea_t) linear address
    @param length: (C++: asize_t) size of the item in bytes. 0 means to infer from ALIGNMENT
    @param alignment: (C++: int) alignment exponent. Example: 3 means align to 8 bytes. 0 means
                      to infer from LENGTH It is forbidden to specify both LENGTH
                      and ALIGNMENT as 0.
    @return: success

Help on function create_array in module idc:

create_array(name)
    Create array.
    
    @param name: The array name.
    
    @return: -1 in case of failure, a valid array_id otherwise.

Help on function create_byte in module idc:

create_byte(ea)
    Convert the current item to a byte
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_custdata in module ida_bytes:

create_custdata(*args) -> 'bool'
    create_custdata(ea, length, dtid, fid, force=False) -> bool
    Convert to custom data type.
    
    @param ea: (C++: ea_t)
    @param length: (C++: asize_t)
    @param dtid: (C++: int)
    @param fid: (C++: int)
    @param force: (C++: bool)

Help on function create_data in module ida_bytes:

create_data(*args) -> 'bool'
    create_data(ea, dataflag, size, tid) -> bool
    Convert to data (byte, word, dword, etc). This function may be used to create
    arrays.
    
    @param ea: (C++: ea_t) linear address
    @param dataflag: (C++: flags_t) type of data. Value of function byte_flag(), word_flag(), etc.
    @param size: (C++: asize_t) size of array in bytes. should be divisible by the size of one item
                 of the specified type. for variable sized items it can be specified
                 as 0, and the kernel will try to calculate the size.
    @param tid: (C++: tid_t) type id. If the specified type is a structure, then tid is structure
                id. Otherwise should be BADNODE.
    @return: success

Help on function create_double in module idc:

create_double(ea)
    Convert the current item to a double floating point (8 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_dword in module idc:

create_dword(ea)
    Convert the current item to a double word (4 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_float in module idc:

create_float(ea)
    Convert the current item to a floating point (4 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_insn in module ida_ua:

create_insn(*args) -> 'int'
    create_insn(ea, out=None) -> int
    Create an instruction at the specified address. This function checks if an
    instruction is present at the specified address and will try to create one if
    there is none. It will fail if there is a data item or other items hindering the
    creation of the new instruction. This function will also fill the 'out'
    structure.
    
    @param ea: (C++: ea_t) linear address
    @param out: (C++: insn_t *) the resulting instruction
    @return: the length of the instruction or 0

Help on function create_oword in module idc:

create_oword(ea)
    Convert the current item to an octa word (16 bytes/128 bits)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_pack_real in module idc:

create_pack_real(ea)
    Convert the current item to a packed real (10 or 12 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_qword in module idc:

create_qword(ea)
    Convert the current item to a quadro word (8 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_strlit in module idc:

create_strlit(ea, endea)
    Create a string.
    
    This function creates a string (the string type is determined by the
    value of get_inf_attr(INF_STRTYPE))
    
    @param ea: linear address
    @param endea: ending address of the string (excluded)
        if endea == BADADDR, then length of string will be calculated
        by the kernel
    
    @return: 1-ok, 0-failure
    
    @note: The type of an existing string is returned by get_str_type()

Help on function create_struct in module idc:

create_struct(ea, size, strname)
    Convert the current item to a structure instance
    
    @param ea: linear address
    @param size: structure size in bytes. -1 means that the size
        will be calculated automatically
    @param strname: name of a structure type
    
    @return: 1-ok, 0-failure

Help on function create_tbyte in module idc:

create_tbyte(ea)
    Convert the current item to a tbyte (10 or 12 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_word in module idc:

create_word(ea)
    Convert the current item to a word (2 bytes)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function create_yword in module idc:

create_yword(ea)
    Convert the current item to a ymm word (32 bytes/256 bits)
    
    @param ea: linear address
    
    @return: 1-ok, 0-failure

Help on function define_exception in module ida_dbg:

define_exception(*args) -> 'char const *'
    define_exception(code, name, desc, flags) -> char const *
    Convenience function: define new exception code.
    
    @param code: (C++: uint) exception code (cannot be 0)
    @param name: (C++: const char *) exception name (cannot be empty or nullptr)
    @param desc: (C++: const char *) exception description (maybe nullptr)
    @param flags: (C++: int) combination of Exception info flags
    @return: failure message or nullptr. You must call store_exceptions() if this
             function succeeds

Help on function define_local_var in module idc:

define_local_var(start, end, location, name)
    Create a local variable
    
    @param start: start of address range for the local variable
    @param end: end of address range for the local variable
    @param location: the variable location in the "[bp+xx]" form where xx is
                     a number. The location can also be specified as a
                     register name.
    @param name: name of the local variable
    
    @return: 1-ok, 0-failure
    
    @note: For the stack variables the end address is ignored.
           If there is no function at 'start' then this function.
           will fail.

Help on function del_array_element in module idc:

del_array_element(tag, array_id, idx)
    Delete an array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of an element.
    
    @return: 1 in case of success, 0 otherwise.

Help on function del_bpt in module ida_dbg:

del_bpt(*args) -> 'bool'
    del_bpt(ea) -> bool
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous function)}
    
    @param bptloc: (C++: const bpt_location_t &) Breakpoint location
    del_bpt(bptloc) -> bool
    
    @param bptloc: bpt_location_t const &

Help on function del_cref in module ida_xref:

del_cref(*args) -> 'bool'
    del_cref(frm, to, expand) -> bool
    Delete a code cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param to: (C++: ea_t) linear address of referenced instruction
    @param expand: (C++: bool) policy to delete the referenced instruction
    * 1: plan to delete the referenced instruction if it has no more references.
    * 0: don't delete the referenced instruction even if no more cross-references
    point to it
    @retval true: if the referenced instruction will be deleted

Help on function del_dref in module ida_xref:

del_dref(*args) -> 'void'
    del_dref(frm, to)
    Delete a data cross-reference.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param to: (C++: ea_t) linear address of referenced data

Help on function del_enum in module ida_enum:

del_enum(*args) -> 'void'
    del_enum(id)
    Delete an enum type.
    
    @param id: (C++: enum_t)

Help on function del_enum_member in module idc:

del_enum_member(enum_id, value, serial, bmask)
    Delete a member of enum - a symbolic constant
    
    @param enum_id: id of enum
    @param value: value of symbolic constant.
    @param serial: serial number of the constant in the
        enumeration. See op_enum() for for details.
    @param bmask: bitmask of the constant ordinary enums accept
        only ida_enum.DEFMASK as a bitmask
    
    @return: 1-ok, 0-failed

Help on function del_extra_cmt in module ida_lines:

del_extra_cmt(*args) -> 'void'
    del_extra_cmt(ea, what)
    
    @param ea: ea_t
    @param what: int

Help on function del_fixup in module ida_fixup:

del_fixup(*args) -> 'void'
    del_fixup(source)
    Delete fixup information.
    
    @param source: (C++: ea_t)

Help on function del_func in module ida_funcs:

del_func(*args) -> 'bool'
    del_func(ea) -> bool
    Delete a function.
    
    @param ea: (C++: ea_t) any address in the function entry chunk
    @return: success

Help on function del_hash_string in module idc:

del_hash_string(hash_id, key)
    Delete a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element
    
    @return: 1 upon success, 0 otherwise.

Help on function del_hidden_range in module ida_bytes:

del_hidden_range(*args) -> 'bool'
    del_hidden_range(ea) -> bool
    Delete hidden range.
    
    @param ea: (C++: ea_t) any address in the hidden range
    @return: success

Help on function del_idc_hotkey in module ida_kernwin:

del_idc_hotkey(*args) -> 'bool'
    del_idc_hotkey(hotkey) -> bool
    
    @param hotkey: char const *

Help on function del_items in module ida_bytes:

del_items(*args) -> 'bool'
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
    Convert item (instruction/data) to unexplored bytes. The whole item (including
    the head and tail bytes) will be destroyed. It is allowed to pass any address in
    the item to this function
    
    @param ea: (C++: ea_t) any address within the first item to delete
    @param flags: (C++: int) combination of Unexplored byte conversion flags
    @param nbytes: (C++: asize_t) number of bytes in the range to be undefined
    @param may_destroy: (C++: may_destroy_cb_t *) optional routine invoked before deleting a head item. If
                        callback returns false then item is not to be deleted and
                        operation fails
    @return: true on sucessful operation, otherwise false

Help on function del_segm in module ida_segment:

del_segm(*args) -> 'bool'
    del_segm(ea, flags) -> bool
    Delete a segment.
    
    @param ea: (C++: ea_t) any address belonging to the segment
    @param flags: (C++: int) Segment modification flags
    @retval 1: ok
    @retval 0: failed, no segment at 'ea'.

Help on function del_selector in module ida_segment:

del_selector(*args) -> 'void'
    del_selector(selector)
    Delete mapping of a selector. Be wary of deleting selectors that are being used
    in the program, this can make a mess in the segments.
    
    @param selector: (C++: sel_t) number of selector to remove from the translation table

Help on function del_source_linnum in module ida_nalt:

del_source_linnum(*args) -> 'void'
    del_source_linnum(ea)
    
    @param ea: ea_t

Help on function del_sourcefile in module ida_lines:

del_sourcefile(*args) -> 'bool'
    del_sourcefile(ea) -> bool
    Delete information about the source file.
    
    @param ea: (C++: ea_t) linear address
    @return: success

Help on function del_stkpnt in module idc:

del_stkpnt(func_ea, ea)
    Delete SP register change point
    
    @param func_ea: function start
    @param ea: linear address
    @return: 1-ok, 0-failed

Help on function del_struc in module idc:

del_struc(sid)
    Delete a structure type
    
    @param sid: structure type ID
    
    @return: 0 if bad structure type ID is passed
             1 otherwise the structure type is deleted. All data
             and other structure types referencing to the
             deleted structure type will be displayed as array
             of bytes.

Help on function del_struc_member in module idc:

del_struc_member(sid, member_offset)
    Delete structure member
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    
    @return: != 0 - ok.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.

Help on function delete_all_segments in module idc:

delete_all_segments()
    Delete all segments, instructions, comments, i.e. everything
    except values of bytes.

Help on function delete_array in module idc:

delete_array(array_id)
    Delete array, by its ID.
    
    @param array_id: The ID of the array to delete.

Help on function demangle_name in module idc:

demangle_name(name, disable_mask)
    demangle_name a name
    
    @param name: name to demangle
    @param disable_mask: a mask that tells how to demangle the name
            it is a good idea to get this mask using
            get_inf_attr(INF_SHORT_DN) or get_inf_attr(INF_LONG_DN)
    
    @return: a demangled name
        If the input name cannot be demangled, returns None

Help on function detach_process in module ida_dbg:

detach_process(*args) -> 'bool'
    detach_process() -> bool
    Detach the debugger from the debugged process. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_process_detach}

Help on function diff_trace_file in module ida_dbg:

diff_trace_file(*args) -> 'bool'
    diff_trace_file(NONNULL_filename) -> bool
    Show difference between the current trace and the one from 'filename'.
    
    @param NONNULL_filename: (C++: const char *) char const *

Help on function enable_bpt in module ida_dbg:

enable_bpt(*args) -> 'bool'
    enable_bpt(ea, enable=True) -> bool
    
    @param ea: ea_t
    @param enable: bool
    
    enable_bpt(bptloc, enable=True) -> bool
    
    @param bptloc: bpt_location_t const &
    @param enable: bool

Help on function enable_tracing in module idc:

enable_tracing(trace_level, enable)
    Enable step tracing
    
    @param trace_level:  what kind of trace to modify
    @param enable: 0: turn off, 1: turn on
    
    @return: success

Help on function error in module ida_kernwin:

error(*args) -> 'void'
    error(format)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print

Help on function eval_idc in module idc:

eval_idc(expr)
    Evaluate an IDC expression
    
    @param expr: an expression
    
    @return: the expression value. If there are problems, the returned value will be "IDC_FAILURE: xxx"
             where xxx is the error description
    
    @note: Python implementation evaluates IDC only, while IDC can call other registered languages

Help on function exit_process in module ida_dbg:

exit_process(*args) -> 'bool'
    exit_process() -> bool
    Terminate the debugging of the current process. \sq{Type, Asynchronous function
    - available as Request, Notification, dbg_process_exit}

Help on function expand_struc in module idc:

expand_struc(sid, offset, delta, recalc)
    Expand or shrink a structure type
    @param id: structure type ID
    @param offset: offset in the structure
    @param delta: how many bytes to add or remove
    @param recalc: recalculate the locations where the structure
                               type is used
    @return: != 0 - ok

Help on function fclose in module idc:

fclose(handle)

Help on function fgetc in module idc:

fgetc(handle)

Help on function filelength in module idc:

filelength(handle)

Help on function find_binary in module idc:

find_binary(ea, flag, searchstr, radix=16)

Help on function find_code in module ida_search:

find_code(*args) -> 'ea_t'
    find_code(ea, sflag) -> ea_t
    Find next code address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_data in module ida_search:

find_data(*args) -> 'ea_t'
    find_data(ea, sflag) -> ea_t
    Find next data address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_defined in module ida_search:

find_defined(*args) -> 'ea_t'
    find_defined(ea, sflag) -> ea_t
    Find next ea that is the start of an instruction or data.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_func_end in module idc:

find_func_end(ea)
    Determine a new function boundaries
    
    @param ea: starting address of a new function
    
    @return: if a function already exists, then return its end address.
            If a function end cannot be determined, the return BADADDR
            otherwise return the end address of the new function

Help on function find_imm in module ida_search:

find_imm(*args) -> 'int *'
    find_imm(ea, sflag, search_value) -> ea_t
    Find next immediate operand with the given value.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)
    @param search_value: (C++: uval_t)

Help on function find_selector in module idc:

find_selector(val)
    Find a selector which has the specifed value
    
    @param val: value to search for
    
    @return: the selector number if found,
             otherwise the input value (val & 0xFFFF)
    
    @note: selector values are always in paragraphs

Help on function find_suspop in module ida_search:

find_suspop(*args) -> 'int *'
    find_suspop(ea, sflag) -> ea_t
    Find next suspicious operand.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function find_text in module idc:

find_text(ea, flag, y, x, searchstr)

Help on function find_unknown in module ida_search:

find_unknown(*args) -> 'ea_t'
    find_unknown(ea, sflag) -> ea_t
    Find next unexplored address.
    
    @param ea: (C++: ea_t)
    @param sflag: (C++: int)

Help on function first_func_chunk in module idc:

first_func_chunk(funcea)
    Get the first function chunk of the specified function
    
    @param funcea: any address in the function
    
    @return: the function entry point or BADADDR
    
    @note: This function returns the first (main) chunk of the specified function

Help on function fopen in module idc:

fopen(f, mode)
    #----------------------------------------------------------------------------
    #                            F I L E   I / O
    #----------------------------------------------------------------------------

Help on function force_bl_call in module idc:

force_bl_call(ea)
    Force BL instruction to be a call
    
    @param ea: address of the BL instruction
    
    @return: 1-ok, 0-failed

Help on function force_bl_jump in module idc:

force_bl_jump(ea)
    Some ARM compilers in Thumb mode use BL (branch-and-link)
    instead of B (branch) for long jumps, since BL has more range.
    By default, IDA tries to determine if BL is a jump or a call.
    You can override IDA's decision using commands in Edit/Other menu
    (Force BL call/Force BL jump) or the following two functions.
    
    Force BL instruction to be a jump
    
    @param ea: address of the BL instruction
    
    @return: 1-ok, 0-failed

Help on function form in module idc:

form(format, *args)

Help on function fprintf in module idc:

fprintf(handle, format, *args)

Help on function fputc in module idc:

fputc(byte, handle)

Help on function fseek in module idc:

fseek(handle, offset, origin)

Help on function ftell in module idc:

ftell(handle)

Help on function func_contains in module idc:

func_contains(func_ea, ea)
    Does the given function contain the given address?
    
    @param func_ea: any address belonging to the function
    @param ea: linear address
    
    @return:  success

Help on function gen_file in module idc:

gen_file(filetype, path, ea1, ea2, flags)
    Generate an output file
    
    @param filetype:  type of output file. One of OFILE_... symbols. See below.
    @param path:  the output file path (will be overwritten!)
    @param ea1:   start address. For some file types this argument is ignored
    @param ea2:   end address. For some file types this argument is ignored
    @param flags: bit combination of GENFLG_...
    
    @returns: number of the generated lines.
                -1 if an error occurred
                OFILE_EXE: 0-can't generate exe file, 1-ok

Help on function gen_flow_graph in module idc:

gen_flow_graph(outfile, title, ea1, ea2, flags)
    Generate a flow chart GDL file
    
    @param outfile: output file name. GDL extension will be used
    @param title: graph title
    @param ea1: beginning of the range to flow chart
    @param ea2: end of the range to flow chart.
    @param flags: combination of CHART_... constants
    
    @note: If ea2 == BADADDR then ea1 is treated as an address within a function.
           That function will be flow charted.

Help on function gen_simple_call_chart in module idc:

gen_simple_call_chart(outfile, title, flags)
    Generate a function call graph GDL file
    
    @param outfile: output file name. GDL extension will be used
    @param title:   graph title
    @param flags:   combination of CHART_GEN_GDL, CHART_WINGRAPH, CHART_NOLIBFUNCS

Help on function generate_disasm_line in module idc:

generate_disasm_line(ea, flags)
    Get disassembly line
    
    @param ea: linear address of instruction
    
    @param flags: combination of the GENDSM_ flags, or 0
    
    @return: "" - could not decode instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
           as you see on the screen.

Help on function get_array_element in module idc:

get_array_element(tag, array_id, idx)
    Get value of array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of an element.
    
    @return: Value of the specified array element. Note that
             this function may return char or long result. Unexistent
             array elements give zero as a result.

Help on function get_array_id in module idc:

get_array_id(name)
    Get array array_id, by name.
    
    @param name: The array name.
    
    @return: -1 in case of failure (i.e., no array with that
             name exists), a valid array_id otherwise.

Help on function get_bmask_cmt in module idc:

get_bmask_cmt(enum_id, bmask, repeatable)
    Get bitmask comment (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param repeatable: type of comment, 0-regular, 1-repeatable
    
    @return: comment attached to bitmask or None

Help on function get_bmask_name in module idc:

get_bmask_name(enum_id, bmask)
    Get bitmask name (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    
    @return: name of bitmask or None

Help on function get_marked_pos in module ida_idc:

get_marked_pos(*args) -> 'ea_t'
    get_marked_pos(slot) -> ea_t
    
    @param slot: int32

Help on function get_mark_comment in module ida_idc:

get_mark_comment(*args) -> 'PyObject *'
    get_mark_comment(slot) -> PyObject *
    
    @param slot: int32

Help on function get_bpt_attr in module idc:

get_bpt_attr(ea, bptattr)
    Get the characteristics of a breakpoint
    
    @param ea: any address in the breakpoint range
    @param bptattr: the desired attribute code, one of BPTATTR_... constants
    
    @return: the desired attribute value or -1

Help on function get_bpt_ea in module idc:

get_bpt_ea(n)
    Get breakpoint address
    
    @param n: number of breakpoint, is in range 0..get_bpt_qty()-1
    
    @return: address of the breakpoint or BADADDR

Help on function get_bpt_qty in module ida_dbg:

get_bpt_qty(*args) -> 'int'
    get_bpt_qty() -> int
    Get number of breakpoints. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_bpt_tev_ea in module ida_dbg:

get_bpt_tev_ea(*args) -> 'ea_t'
    get_bpt_tev_ea(n) -> ea_t
    Get the address associated to a read, read/write or execution trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a read, read/write or execution trace event.
    @note: Usually, a breakpoint is associated with a read, read/write or execution
           trace event. However, the returned address could be any address in the
           range of this breakpoint. If the breakpoint was deleted after the trace
           event, the address no longer corresponds to a valid breakpoint.

Help on function get_bytes in module idc:

get_bytes(ea, size, use_dbg=False)
    Return the specified number of bytes of the program
    
    @param ea: linear address
    
    @param size: size of buffer in normal 8-bit bytes
    
    @param use_dbg: if True, use debugger memory, otherwise just the database
    
    @return: None on failure
             otherwise a string containing the read bytes

Help on function get_call_tev_callee in module ida_dbg:

get_call_tev_callee(*args) -> 'ea_t'
    get_call_tev_callee(n) -> ea_t
    Get the called function from a function call trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a function call event.

Help on function get_color in module idc:

get_color(ea, what)
    Get item color
    
    @param ea: address of the item
    @param what: type of the item (one of  CIC_* constants)
    
    @return: color code in RGB (hex 0xBBGGRR)

Help on function get_curline in module idc:

get_curline()
    Get the disassembly line at the cursor
    
    @return: string

Help on function get_current_thread in module ida_dbg:

get_current_thread(*args) -> 'thid_t'
    get_current_thread() -> thid_t
    Get current thread ID. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_db_byte in module ida_bytes:

get_db_byte(*args) -> 'uchar'
    get_db_byte(ea) -> uchar
    Get one byte (8-bit) of the program at 'ea' from the database. Works even if the
    debugger is active. See also get_dbg_byte() to read the process memory directly.
    This function works only for 8bit byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_debugger_event_cond in module ida_dbg:

get_debugger_event_cond(*args) -> 'char const *'
    get_debugger_event_cond() -> char const *

Help on function get_entry in module ida_entry:

get_entry(*args) -> 'ea_t'
    get_entry(ord) -> ea_t
    Get entry point address by its ordinal
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: address or BADADDR

Help on function get_entry_name in module ida_entry:

get_entry_name(*args) -> 'qstring *'
    get_entry_name(ord) -> str
    Get name of the entry point by its ordinal.
    
    @param ord: (C++: uval_t) ordinal number of entry point
    @return: size of entry name or -1

Help on function get_entry_ordinal in module ida_entry:

get_entry_ordinal(*args) -> 'uval_t'
    get_entry_ordinal(idx) -> uval_t
    Get ordinal number of an entry point.
    
    @param idx: (C++: size_t) internal number of entry point. Should be in the range
                0..get_entry_qty()-1
    @return: ordinal number or 0.

Help on function get_entry_qty in module ida_entry:

get_entry_qty(*args) -> 'size_t'
    get_entry_qty() -> size_t
    Get number of entry points.

Help on function get_enum in module ida_enum:

get_enum(*args) -> 'enum_t'
    get_enum(name) -> enum_t
    Get enum by name.
    
    @param name: (C++: const char *) char const *

Help on function get_enum_cmt in module ida_enum:

get_enum_cmt(*args) -> 'qstring *'
    get_enum_cmt(id, repeatable) -> str
    Get enum comment.
    
    @param id: (C++: enum_t)
    @param repeatable: (C++: bool)

Help on function get_enum_flag in module ida_enum:

get_enum_flag(*args) -> 'flags_t'
    get_enum_flag(id) -> flags_t
    Get flags determining the representation of the enum. (currently they define the
    numeric base: octal, decimal, hex, bin) and signness.
    
    @param id: (C++: enum_t)

Help on function get_enum_idx in module ida_enum:

get_enum_idx(*args) -> 'uval_t'
    get_enum_idx(id) -> uval_t
    Get the index in the list of enums.
    
    @param id: (C++: enum_t)

Help on function get_enum_member in module idc:

get_enum_member(enum_id, value, serial, bmask)
    Get id of constant
    
    @param enum_id: id of enum
    @param value: value of constant
    @param serial: serial number of the constant in the
              enumeration. See op_enum() for details.
    @param bmask: bitmask of the constant
              ordinary enums accept only ida_enum.DEFMASK as a bitmask
    
    @return: id of constant or -1 if error

Help on function get_enum_member_bmask in module ida_enum:

get_enum_member_bmask(*args) -> 'bmask_t'
    get_enum_member_bmask(id) -> bmask_t
    Get bitmask of an enum member.
    
    @param id: (C++: const_t)

Help on function get_enum_member_by_name in module ida_enum:

get_enum_member_by_name(*args) -> 'const_t'
    get_enum_member_by_name(name) -> const_t
    Get a reference to an enum member by its name.
    
    @param name: (C++: const char *) char const *

Help on function get_enum_member_cmt in module idc:

get_enum_member_cmt(const_id, repeatable)
    Get comment of a constant
    
    @param const_id: id of const
    @param repeatable: 0:get regular comment, 1:get repeatable comment
    
    @return: comment string

Help on function get_enum_member_enum in module ida_enum:

get_enum_member_enum(*args) -> 'enum_t'
    get_enum_member_enum(id) -> enum_t
    Get the parent enum of an enum member.
    
    @param id: (C++: const_t)

Help on function get_enum_member_name in module idc:

get_enum_member_name(const_id)
    Get name of a constant
    
    @param const_id: id of const
    
    Returns: name of constant

Help on function get_enum_member_value in module ida_enum:

get_enum_member_value(*args) -> 'uval_t'
    get_enum_member_value(id) -> uval_t
    Get value of an enum member.
    
    @param id: (C++: const_t)

Help on function get_enum_name in module ida_enum:

get_enum_name(*args) -> 'qstring *'
    get_enum_name(id) -> str
    
    @param id: enum_t

Help on function get_enum_qty in module ida_enum:

get_enum_qty(*args) -> 'size_t'
    get_enum_qty() -> size_t
    Get number of declared enum_t types.

Help on function get_enum_size in module ida_enum:

get_enum_size(*args) -> 'size_t'
    get_enum_size(id) -> size_t
    Get the number of the members of the enum.
    
    @param id: (C++: enum_t)

Help on function get_enum_width in module ida_enum:

get_enum_width(*args) -> 'size_t'
    get_enum_width(id) -> size_t
    Get the width of a enum element allowed values: 0 (unspecified),1,2,4,8,16,32,64
    
    @param id: (C++: enum_t)

Help on function get_event_bpt_hea in module idc:

get_event_bpt_hea()
    Get hardware address for BREAKPOINT event
    
    @return: hardware address

Help on function get_event_ea in module idc:

get_event_ea()
    Get ea for debug event
    
    @return: ea

Help on function get_event_exc_code in module idc:

get_event_exc_code()
    Get exception code for EXCEPTION event
    
    @return: exception code

Help on function get_event_exc_ea in module idc:

get_event_exc_ea()
    Get address for EXCEPTION event
    
    @return: adress of exception

Help on function get_event_exc_info in module idc:

get_event_exc_info()
    Get info for EXCEPTION event
    
    @return: info string

Help on function get_event_exit_code in module idc:

get_event_exit_code()
    Get exit code for debug event
    
    @return: exit code for PROCESS_EXITED, THREAD_EXITED events

Help on function get_event_id in module idc:

get_event_id()
    Get ID of debug event
    
    @return: event ID

Help on function get_event_info in module idc:

get_event_info()
    Get debug event info
    
    @return: event info: for THREAD_STARTED (thread name)
                         for LIB_UNLOADED (unloaded library name)
                         for INFORMATION (message to display)

Help on function get_event_module_base in module idc:

get_event_module_base()
    Get module base for debug event
    
    @return: module base

Help on function get_event_module_name in module idc:

get_event_module_name()
    Get module name for debug event
    
    @return: module name

Help on function get_event_module_size in module idc:

get_event_module_size()
    Get module size for debug event
    
    @return: module size

Help on function get_event_pid in module idc:

get_event_pid()
    Get process ID for debug event
    
    @return: process ID

Help on function get_event_tid in module idc:

get_event_tid()
    Get type ID for debug event
    
    @return: type ID

Help on function get_extra_cmt in module ida_lines:

get_extra_cmt(*args) -> 'int'
    get_extra_cmt(ea, what) -> ssize_t
    
    @param ea: ea_t
    @param what: int

Help on function get_fchunk_attr in module idc:

get_fchunk_attr(ea, attr)
    Get a function chunk attribute
    
    @param ea: any address in the chunk
    @param attr: one of: FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER, FUNCATTR_REFQTY
    
    @return: desired attribute or -1

Help on function get_fchunk_referer in module ida_funcs:

get_fchunk_referer(*args) -> 'ea_t'
    get_fchunk_referer(ea, idx) -> ea_t
    
    @param ea: ea_t
    @param idx: size_t

Help on function get_first_bmask in module ida_enum:

get_first_bmask(*args) -> 'bmask_t'
    get_first_bmask(enum_id) -> bmask_t
    Get first bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum (bitfield)
    @return: the smallest bitmask for enum, or DEFMASK

Help on function get_first_cref_from in module ida_xref:

get_first_cref_from(*args) -> 'ea_t'
    get_first_cref_from(frm) -> ea_t
    Get first instruction referenced from the specified instruction. If the
    specified instruction passes execution to the next instruction then the next
    instruction is returned. Otherwise the lowest referenced address is returned
    (remember that xrefs are kept sorted!).
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @return: first referenced address. If the specified instruction doesn't
             reference to other instructions then returns BADADDR.

Help on function get_first_cref_to in module ida_xref:

get_first_cref_to(*args) -> 'ea_t'
    get_first_cref_to(to) -> ea_t
    Get first instruction referencing to the specified instruction. If the specified
    instruction may be executed immediately after its previous instruction then the
    previous instruction is returned. Otherwise the lowest referencing address is
    returned. (remember that xrefs are kept sorted!).
    
    @param to: (C++: ea_t) linear address of referenced instruction
    @return: linear address of the first referencing instruction or BADADDR.

Help on function get_first_dref_from in module ida_xref:

get_first_dref_from(*args) -> 'ea_t'
    get_first_dref_from(frm) -> ea_t
    Get first data referenced from the specified address.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @return: linear address of first (lowest) data referenced from the specified
             address. Return BADADDR if the specified instruction/data doesn't
             reference to anything.

Help on function get_first_dref_to in module ida_xref:

get_first_dref_to(*args) -> 'ea_t'
    get_first_dref_to(to) -> ea_t
    Get address of instruction/data referencing to the specified data.
    
    @param to: (C++: ea_t) linear address of referencing instruction or data
    @return: BADADDR if nobody refers to the specified data.

Help on function get_first_enum_member in module idc:

get_first_enum_member(enum_id, bmask)
    Get first constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
    
    @return: value of constant or idaapi.BADNODE no constants are defined
             All constants are sorted by their values as unsigned longs.

Help on function get_first_fcref_from in module ida_xref:

get_first_fcref_from(*args) -> 'ea_t'
    get_first_fcref_from(frm) -> ea_t
    
    @param from: ea_t

Help on function get_first_fcref_to in module ida_xref:

get_first_fcref_to(*args) -> 'ea_t'
    get_first_fcref_to(to) -> ea_t
    
    @param to: ea_t

Help on function get_first_hash_key in module idc:

get_first_hash_key(hash_id)
    Get the first key in the hash.
    
    @param hash_id: The hash ID.
    
    @return: the key, 0 otherwise.

Help on function get_first_index in module idc:

get_first_index(tag, array_id)
    Get index of the first existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    
    @return: -1 if the array is empty, otherwise index of first array
             element of given type.

Help on function get_first_member in module idc:

get_first_member(sid)
    Get offset of the first member of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if structure has no members,
             otherwise returns offset of the first member.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_first_module in module idc:

get_first_module()
    Enumerate process modules
    
    @return: first module's base address or None on failure

Help on function get_first_seg in module idc:

get_first_seg()
    Get first segment
    
    @return: address of the start of the first segment
        BADADDR - no segments are defined

Help on function get_first_struc_idx in module ida_struct:

get_first_struc_idx(*args) -> 'uval_t'
    get_first_struc_idx() -> uval_t
    Get index of first structure.
    
    @return: BADADDR if no known structures, 0 otherwise

Help on function get_fixup_target_dis in module idc:

get_fixup_target_dis(ea)
    Get fixup target displacement
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup target displacement

Help on function get_fixup_target_flags in module idc:

get_fixup_target_flags(ea)
    Get fixup target flags
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup target flags

Help on function get_fixup_target_off in module idc:

get_fixup_target_off(ea)
    Get fixup target offset
    
    @param ea: address to get information about
    
    @return: BADADDR - no fixup at the specified address
                       otherwise returns fixup target offset

Help on function get_fixup_target_sel in module idc:

get_fixup_target_sel(ea)
    Get fixup target selector
    
    @param ea: address to get information about
    
    @return: BADSEL - no fixup at the specified address
                      otherwise returns fixup target selector

Help on function get_fixup_target_type in module idc:

get_fixup_target_type(ea)
    Get fixup target type
    
    @param ea: address to get information about
    
    @return: 0 - no fixup at the specified address
                 otherwise returns fixup type

Help on function get_forced_operand in module ida_bytes:

get_forced_operand(*args) -> 'qstring *'
    get_forced_operand(ea, n) -> str
    Get forced operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, 2)
    @return: size of forced operand or -1

Help on function get_frame_args_size in module idc:

get_frame_args_size(ea)
    Get size of arguments in function frame which are purged upon return
    
    @param ea: any address belonging to the function
    
    @return: Size of function arguments in bytes.
             If the function doesn't have a frame, return 0
             If the function does't exist, return -1

Help on function get_frame_id in module idc:

get_frame_id(ea)
    Get ID of function frame structure
    
    @param ea: any address belonging to the function
    
    @return: ID of function frame or None In order to access stack variables
             you need to use structure member manipulaion functions with the
             obtained ID.

Help on function get_frame_lvar_size in module idc:

get_frame_lvar_size(ea)
    Get size of local variables in function frame
    
    @param ea: any address belonging to the function
    
    @return: Size of local variables in bytes.
             If the function doesn't have a frame, return 0
             If the function does't exist, return None

Help on function get_frame_regs_size in module idc:

get_frame_regs_size(ea)
    Get size of saved registers in function frame
    
    @param ea: any address belonging to the function
    
    @return: Size of saved registers in bytes.
             If the function doesn't have a frame, return 0
             This value is used as offset for BP (if FUNC_FRAME is set)
             If the function does't exist, return None

Help on function get_frame_size in module idc:

get_frame_size(ea)
    Get full size of function frame
    
    @param ea: any address belonging to the function
    @returns: Size of function frame in bytes.
                This function takes into account size of local
                variables + size of saved registers + size of
                return address + size of function arguments
                If the function doesn't have a frame, return size of
                function return address in the stack.
                If the function does't exist, return 0

Help on function get_full_flags in module ida_bytes:

get_full_flags(*args) -> 'flags_t'
    get_full_flags(ea) -> flags_t
    Get flags value for address 'ea'.
    
    @param ea: (C++: ea_t)
    @return: 0 if address is not present in the program

Help on function get_func_attr in module idc:

get_func_attr(ea, attr)
    Get a function attribute
    
    @param ea: any address belonging to the function
    @param attr: one of FUNCATTR_... constants
    
    @return: BADADDR - error otherwise returns the attribute value

Help on function get_func_cmt in module idc:

get_func_cmt(ea, repeatable)
    Retrieve function comment
    
    @param ea: any address belonging to the function
    @param repeatable: 1: get repeatable comment
            0: get regular comment
    
    @return: function comment string

Help on function get_func_flags in module idc:

get_func_flags(ea)
    Retrieve function flags
    
    @param ea: any address belonging to the function
    
    @return: -1 - function doesn't exist otherwise returns the flags

Help on function get_func_name in module idc:

get_func_name(ea)
    Retrieve function name
    
    @param ea: any address belonging to the function
    
    @return: null string - function doesn't exist
            otherwise returns function name

Help on function get_func_off_str in module idc:

get_func_off_str(ea)
    Convert address to 'funcname+offset' string
    
    @param ea: address to convert
    
    @return: if the address belongs to a function then return a string
             formed as 'name+offset' where 'name' is a function name
             'offset' is offset within the function else return null string

Help on function get_hash_long in module idc:

get_hash_long(hash_id, key)
    Gets the long value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    
    @return: the 32bit or 64bit value of the element, or 0 if no such
             element.

Help on function get_hash_string in module idc:

get_hash_string(hash_id, key)
    Gets the string value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    
    @return: the string value of the element, or None if no such
             element.

Help on function get_idb_path in module idc:

get_idb_path()
    Get IDB full path
    
    This function returns full path of the current IDB database

Help on function get_inf_attr in module idc:

get_inf_attr(attr)
    Deprecated. Please ida_ida.inf_get_* instead.

Help on function get_input_file_path in module ida_nalt:

get_input_file_path(*args) -> 'size_t'
    get_input_file_path() -> str
    Get full path of the input file.

Help on function get_item_end in module ida_bytes:

get_item_end(*args) -> 'ea_t'
    get_item_end(ea) -> ea_t
    Get the end address of the item at 'ea'. The returned address doesn't belong to
    the current item. Unexplored bytes are counted as 1 byte entities.
    
    @param ea: (C++: ea_t)

Help on function get_item_head in module ida_bytes:

get_item_head(*args) -> 'ea_t'
    get_item_head(ea) -> ea_t
    Get the start address of the item at 'ea'. If there is no current item, then
    'ea' will be returned (see definition at the end of bytes.hpp source)
    
    @param ea: (C++: ea_t)

Help on function get_item_size in module idc:

get_item_size(ea)
    Get size of instruction or data item in bytes
    
    @param ea: linear address
    
    @return: 1..n

Help on function get_last_bmask in module ida_enum:

get_last_bmask(*args) -> 'bmask_t'
    get_last_bmask(enum_id) -> bmask_t
    Get last bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @return: the biggest bitmask for enum, or DEFMASK

Help on function get_last_enum_member in module idc:

get_last_enum_member(enum_id, bmask)
    Get last constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant (ordinary enums accept only ida_enum.DEFMASK as a bitmask)
    
    @return: value of constant or idaapi.BADNODE no constants are defined
             All constants are sorted by their values
             as unsigned longs.

Help on function get_last_hash_key in module idc:

get_last_hash_key(hash_id)
    Get the last key in the hash.
    
    @param hash_id: The hash ID.
    
    @return: the key, 0 otherwise.

Help on function get_last_index in module idc:

get_last_index(tag, array_id)
    Get index of last existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    
    @return: -1 if the array is empty, otherwise index of first array
             element of given type.

Help on function get_last_member in module idc:

get_last_member(sid)
    Get offset of the last member of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if structure has no members,
             otherwise returns offset of the last member.
    
    @note: IDA allows 'holes' between members of a
          structure. It treats these 'holes'
          as unnamed arrays of bytes.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_last_struc_idx in module ida_struct:

get_last_struc_idx(*args) -> 'uval_t'
    get_last_struc_idx() -> uval_t
    Get index of last structure.
    
    @return: BADADDR if no known structures, get_struc_qty()-1 otherwise

Help on function get_local_tinfo in module idc:

get_local_tinfo(ordinal)
    Get local type information as 'typeinfo' object
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
    @return: None on failure, or (type, fields) tuple.

Help on function get_manual_insn in module ida_bytes:

get_manual_insn(*args) -> 'qstring *'
    get_manual_insn(ea) -> str
    Retrieve the user-specified string for the manual instruction.
    
    @param ea: (C++: ea_t) linear address of the instruction or data item
    @return: size of manual instruction or -1

Help on function get_member_cmt in module idc:

get_member_cmt(sid, member_offset, repeatable)
    Get comment of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    @param repeatable: 1: get repeatable comment
                       0: get regular comment
    
    @return: None if bad structure type ID is passed
             or no such member in the structure
             otherwise returns comment of the specified member.

Help on function get_member_flag in module idc:

get_member_flag(sid, member_offset)
    Get type of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns type of the member, see bit
             definitions above. If the member type is a structure
             then function GetMemberStrid() should be used to
             get the structure type id.

Help on function get_member_id in module idc:

get_member_id(sid, member_offset)
    @param sid: structure type ID
    @param member_offset:. The offset can be
    any offset in the member. For example,
    is a member is 4 bytes long and starts
    at offset 2, then 2,3,4,5 denote
    the same structure member.
    
    @return: -1 if bad structure type ID is passed or there is
    no member at the specified offset.
    otherwise returns the member id.

Help on function get_member_name in module idc:

get_member_name(sid, member_offset)
    Get name of a member of a structure
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: None if bad structure type ID is passed
             or no such member in the structure
             otherwise returns name of the specified member.

Help on function get_member_offset in module idc:

get_member_offset(sid, member_name)
    Get offset of a member of a structure by the member name
    
    @param sid: structure type ID
    @param member_name: name of structure member
    
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns offset of the specified member.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_member_qty in module idc:

get_member_qty(sid)
    Get number of members of a structure
    
    @param sid: structure type ID
    
    @return: -1 if bad structure type ID is passed otherwise
             returns number of members.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_member_size in module idc:

get_member_size(sid, member_offset)
    Get size of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    
    @return: None if bad structure type ID is passed,
             or no such member in the structure
             otherwise returns size of the specified
             member in bytes.

Help on function get_member_strid in module idc:

get_member_strid(sid, member_offset)
    Get structure id of a member
    
    @param sid: structure type ID
    @param member_offset: member offset. The offset can be
                          any offset in the member. For example,
                          is a member is 4 bytes long and starts
                          at offset 2, then 2,3,4,5 denote
                          the same structure member.
    @return: -1 if bad structure type ID is passed
             or no such member in the structure
             otherwise returns structure id of the member.
             If the current member is not a structure, returns -1.

Help on function get_min_spd_ea in module idc:

get_min_spd_ea(func_ea)
    Return the address with the minimal spd (stack pointer delta)
    If there are no SP change points, then return BADADDR.
    
    @param func_ea: function start
    @return: BADDADDR - no such function

Help on function get_module_name in module idc:

get_module_name(base)
    Get process module name
    
    @param base: the base address of the module
    
    @return: required info or None

Help on function get_module_size in module idc:

get_module_size(base)
    Get process module size
    
    @param base: the base address of the module
    
    @return: required info or -1

Help on function get_name in module idc:

get_name(ea, gtn_flags=0)
    Get name at the specified address
    
    @param ea: linear address
    @param gtn_flags: how exactly the name should be retrieved.
                      combination of GN_ bits
    
    @return: "" - byte has no name

Help on function get_name_ea in module ida_name:

get_name_ea(*args) -> 'ea_t'
    get_name_ea(_from, name) -> ea_t
    Get the address of a name. This function resolves a name into an address. It can
    handle regular global and local names, as well as debugger names.
    
    @param from: (C++: ea_t) linear address where the name is used. If specified, the local
                 labels of the function at the specified address will will be
                 checked. BADADDR means that local names won't be consulted.
    @param name: (C++: const char *) any name in the program or nullptr
    @return: address of the name or BADADDR

Help on function get_name_ea_simple in module idc:

get_name_ea_simple(name)
    Get linear address of a name
    
    @param name: name of program byte
    
    @return: address of the name
             BADADDR - No such name

Help on function get_next_bmask in module ida_enum:

get_next_bmask(*args) -> 'bmask_t'
    get_next_bmask(enum_id, bmask) -> bmask_t
    Get next bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @param bmask: (C++: bmask_t) the current bitmask
    @return: value of a bitmask with value higher than the specified value, or
             DEFMASK

Help on function get_next_cref_from in module ida_xref:

get_next_cref_from(*args) -> 'ea_t'
    get_next_cref_from(frm, current) -> ea_t
    Get next instruction referenced from the specified instruction.
    
    @param from: (C++: ea_t) linear address of referencing instruction
    @param current: (C++: ea_t) linear address of current referenced instruction This value is
                    returned by get_first_cref_from() or previous call to
                    get_next_cref_from() functions.
    @return: next referenced address or BADADDR.

Help on function get_next_cref_to in module ida_xref:

get_next_cref_to(*args) -> 'ea_t'
    get_next_cref_to(to, current) -> ea_t
    Get next instruction referencing to the specified instruction.
    
    @param to: (C++: ea_t) linear address of referenced instruction
    @param current: (C++: ea_t) linear address of current referenced instruction This value is
                    returned by get_first_cref_to() or previous call to
                    get_next_cref_to() functions.
    @return: linear address of the next referencing instruction or BADADDR.

Help on function get_next_dref_from in module ida_xref:

get_next_dref_from(*args) -> 'ea_t'
    get_next_dref_from(frm, current) -> ea_t
    Get next data referenced from the specified address.
    
    @param from: (C++: ea_t) linear address of referencing instruction or data
    @param current: (C++: ea_t) linear address of current referenced data. This value is
                    returned by get_first_dref_from() or previous call to
                    get_next_dref_from() functions.
    @return: linear address of next data or BADADDR.

Help on function get_next_dref_to in module ida_xref:

get_next_dref_to(*args) -> 'ea_t'
    get_next_dref_to(to, current) -> ea_t
    Get address of instruction/data referencing to the specified data
    
    @param to: (C++: ea_t) linear address of referencing instruction or data
    @param current: (C++: ea_t) current linear address. This value is returned by
                    get_first_dref_to() or previous call to get_next_dref_to()
                    functions.
    @return: BADADDR if nobody refers to the specified data.

Help on function get_next_enum_member in module idc:

get_next_enum_member(enum_id, value, bmask)
    Get next constant in the enum
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant ordinary enums accept only ida_enum.DEFMASK as a bitmask
    @param value: value of the current constant
    
    @return: value of a constant with value higher than the specified
             value. idaapi.BADNODE no such constants exist.
             All constants are sorted by their values as unsigned longs.

Help on function get_next_fchunk in module idc:

get_next_fchunk(ea)
    Get next function chunk
    
    @param ea: any address
    
    @return:  the starting address of the next function chunk or BADADDR
    
    @note: This function enumerates all chunks of all functions in the database

Help on function get_next_fcref_from in module ida_xref:

get_next_fcref_from(*args) -> 'ea_t'
    get_next_fcref_from(frm, current) -> ea_t
    
    @param from: ea_t
    @param current: ea_t

Help on function get_next_fcref_to in module ida_xref:

get_next_fcref_to(*args) -> 'ea_t'
    get_next_fcref_to(to, current) -> ea_t
    
    @param to: ea_t
    @param current: ea_t

Help on function get_next_fixup_ea in module ida_fixup:

get_next_fixup_ea(*args) -> 'ea_t'
    get_next_fixup_ea(ea) -> ea_t
    Find next address with fixup information
    
    @param ea: (C++: ea_t) current address
    @return: the next address with fixup information, or BADADDR

Help on function get_next_func in module idc:

get_next_func(ea)
    Find next function
    
    @param ea: any address belonging to the function
    
    @return:        BADADDR - no more functions
            otherwise returns the next function start address

Help on function get_next_hash_key in module idc:

get_next_hash_key(hash_id, key)
    Get the next key in the hash.
    
    @param hash_id: The hash ID.
    @param key: The current key.
    
    @return: the next key, 0 otherwise

Help on function get_next_index in module idc:

get_next_index(tag, array_id, idx)
    Get index of the next existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of the current element.
    
    @return: -1 if no more elements, otherwise returns index of the
             next array element of given type.

Help on function get_next_module in module idc:

get_next_module(base)
    Enumerate process modules
    
    @param base: previous module's base address
    
    @return: next module's base address or None on failure

Help on function get_next_offset in module idc:

get_next_offset(sid, offset)
    Get next offset in a structure
    
    @param sid:     structure type ID
    @param offset: current offset
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if no (more) offsets in the structure,
             otherwise returns next offset in a structure.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
           This function returns a member offset or a hole offset.
           It will return size of the structure if input
           'offset' belongs to the last member of the structure.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_next_seg in module idc:

get_next_seg(ea)
    Get next segment
    
    @param ea: linear address
    
    @return: start of the next segment
             BADADDR - no next segment

Help on function get_next_struc_idx in module ida_struct:

get_next_struc_idx(*args) -> 'uval_t'
    get_next_struc_idx(idx) -> uval_t
    Get next struct index.
    
    @param idx: (C++: uval_t)
    @return: BADADDR if resulting index is out of bounds, otherwise idx++

Help on function get_numbered_type_name in module idc:

get_numbered_type_name(ordinal)
    Retrieve a local type name
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
    
    returns: local type name or None

Help on function get_operand_type in module idc:

get_operand_type(ea, n)
    Get type of instruction operand
    
    @param ea: linear address of instruction
    @param n: number of operand:
        0 - the first operand
        1 - the second operand
    
    @return: any of o_* constants or -1 on error

Help on function get_operand_value in module idc:

get_operand_value(ea, n)
    Get number used in the operand
    
    This function returns an immediate number used in the operand
    
    @param ea: linear address of instruction
    @param n: the operand number
    
    @return: value
        operand is an immediate value  => immediate value
        operand has a displacement     => displacement
        operand is a direct memory ref => memory address
        operand is a register          => register number
        operand is a register phrase   => phrase number
        otherwise                      => -1

Help on function get_ordinal_qty in module idc:

get_ordinal_qty()
    Get number of local types + 1
    
    @return: value >= 1. 1 means that there are no local types.

Help on function get_original_byte in module ida_bytes:

get_original_byte(*args) -> 'uint64'
    get_original_byte(ea) -> uint64
    Get original byte value (that was before patching). This function works for wide
    byte processors too.
    
    @param ea: (C++: ea_t)

Help on function get_prev_bmask in module ida_enum:

get_prev_bmask(*args) -> 'bmask_t'
    get_prev_bmask(enum_id, bmask) -> bmask_t
    Get prev bitmask in the enum (bitfield)
    
    @param enum_id: (C++: enum_t) id of enum
    @param bmask: (C++: bmask_t) the current bitmask
    @return: value of a bitmask with value lower than the specified value, or
             DEFMASK

Help on function get_prev_enum_member in module idc:

get_prev_enum_member(enum_id, value, bmask)
    Get prev constant in the enum
    
    @param enum_id: id of enum
    @param bmask  : bitmask of the constant
              ordinary enums accept only ida_enum.DEFMASK as a bitmask
    @param value: value of the current constant
    
    @return: value of a constant with value lower than the specified
        value. idaapi.BADNODE no such constants exist.
        All constants are sorted by their values as unsigned longs.

Help on function get_prev_fchunk in module idc:

get_prev_fchunk(ea)
    Get previous function chunk
    
    @param ea: any address
    
    @return: the starting address of the function chunk or BADADDR
    
    @note: This function enumerates all chunks of all functions in the database

Help on function get_prev_fixup_ea in module ida_fixup:

get_prev_fixup_ea(*args) -> 'ea_t'
    get_prev_fixup_ea(ea) -> ea_t
    Find previous address with fixup information
    
    @param ea: (C++: ea_t) current address
    @return: the previous address with fixup information, or BADADDR

Help on function get_prev_func in module idc:

get_prev_func(ea)
    Find previous function
    
    @param ea: any address belonging to the function
    
    @return: BADADDR - no more functions
            otherwise returns the previous function start address

Help on function get_prev_hash_key in module idc:

get_prev_hash_key(hash_id, key)
    Get the previous key in the hash.
    
    @param hash_id: The hash ID.
    @param key: The current key.
    
    @return: the previous key, 0 otherwise

Help on function get_prev_index in module idc:

get_prev_index(tag, array_id, idx)
    Get index of the previous existing array element.
    
    @param tag: Tag of array, specifies one of two array types: AR_LONG, AR_STR
    @param array_id: The array ID.
    @param idx: Index of the current element.
    
    @return: -1 if no more elements, otherwise returns index of the
             previous array element of given type.

Help on function get_prev_offset in module idc:

get_prev_offset(sid, offset)
    Get previous offset in a structure
    
    @param sid: structure type ID
    @param offset: current offset
    
    @return: -1 if bad structure type ID is passed,
             ida_idaapi.BADADDR if no (more) offsets in the structure,
             otherwise returns previous offset in a structure.
    
    @note: IDA allows 'holes' between members of a
           structure. It treats these 'holes'
           as unnamed arrays of bytes.
           This function returns a member offset or a hole offset.
           It will return size of the structure if input
           'offset' is bigger than the structure size.
    
    @note: Union members are, in IDA's internals, located
           at subsequent byte offsets: member 0 -> offset 0x0,
           member 1 -> offset 0x1, etc...

Help on function get_prev_struc_idx in module ida_struct:

get_prev_struc_idx(*args) -> 'uval_t'
    get_prev_struc_idx(idx) -> uval_t
    Get previous struct index.
    
    @param idx: (C++: uval_t)
    @return: BADADDR if resulting index is negative, otherwise idx - 1

Help on function get_process_state in module ida_dbg:

get_process_state(*args) -> 'int'
    get_process_state() -> int
    Return the state of the currently debugged process. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @return: one of Debugged process states

Help on function get_processes in module ida_dbg:

get_processes(*args) -> 'ssize_t'
    get_processes(proclist) -> ssize_t
    Take a snapshot of running processes and return their description. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    @param proclist: (C++: procinfo_vec_t *) array with information about each running process
    @return: number of processes or -1 on error

Help on function get_qword in module ida_bytes:

get_qword(*args) -> 'uint64'
    get_qword(ea) -> uint64
    Get one qword (64-bit) of the program at 'ea'. This function takes into account
    order of bytes specified in idainfo::is_be() This function works only for 8bit
    byte processors.
    
    @param ea: (C++: ea_t)

Help on function get_reg_val in module ida_dbg:

get_reg_val(*args) -> 'PyObject *'
    get_reg_val(regname, regval) -> bool
    Get register value as an unsigned 64-bit int.
    
    @param regname: (C++: const char *) char const *
    @param regval: regval_t *
    
    get_reg_val(regname, ival) -> bool
    
    @param regname: char const *
    @param ival: uint64 *
    
    get_reg_val(regname) -> bool, float, int
    
    @param regname: char const *

Help on function get_ret_tev_return in module ida_dbg:

get_ret_tev_return(*args) -> 'ea_t'
    get_ret_tev_return(n) -> ea_t
    Get the return address from a function return trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    @param n: (C++: int) number of trace event, is in range 0..get_tev_qty()-1. 0 represents
              the latest added trace event.
    @return: BADADDR if not a function return event.

Help on function get_root_filename in module ida_nalt:

get_root_filename(*args) -> 'size_t'
    get_root_filename() -> str
    Get file name only of the input file.

Help on function get_screen_ea in module ida_kernwin:

get_screen_ea(*args) -> 'ea_t'
    get_screen_ea() -> ea_t
    Get the address at the screen cursor (ui_screenea)

Help on function get_segm_attr in module idc:

get_segm_attr(segea, attr)
    Get segment attribute
    
    @param segea: any address within segment
    @param attr: one of SEGATTR_... constants

Help on function get_segm_by_sel in module idc:

get_segm_by_sel(base)
    Get segment by segment base
    
    @param base: segment base paragraph or selector
    
    @return: linear address of the start of the segment or BADADDR
             if no such segment

Help on function get_segm_end in module idc:

get_segm_end(ea)
    Get end address of a segment
    
    @param ea: any address in the segment
    
    @return: end of segment (an address past end of the segment)
             BADADDR - the specified address doesn't belong to any segment

Help on function get_segm_name in module idc:

get_segm_name(ea)
    Get name of a segment
    
    @param ea: any address in the segment
    
    @return: "" - no segment at the specified address

Help on function get_segm_start in module idc:

get_segm_start(ea)
    Get start address of a segment
    
    @param ea: any address in the segment
    
    @return: start of segment
             BADADDR - the specified address doesn't belong to any segment

Help on function get_source_linnum in module ida_nalt:

get_source_linnum(*args) -> 'uval_t'
    get_source_linnum(ea) -> uval_t
    
    @param ea: ea_t

Help on function get_sourcefile in module ida_lines:

get_sourcefile(*args) -> 'char const *'
    get_sourcefile(ea, bounds=None) -> char const *
    Get name of source file occupying the given address.
    
    @param ea: (C++: ea_t) linear address
    @param bounds: (C++: range_t *) pointer to the output buffer with the address range for the
                   current file. May be nullptr.
    @return: nullptr if source file information is not found, otherwise returns
             pointer to file name

Help on function get_sp_delta in module idc:

get_sp_delta(ea)
    Get modification of SP made by the instruction
    
    @param ea: end address of the instruction
               i.e.the last address of the instruction+1
    
    @return: Get modification of SP made at the specified location
             If the specified location doesn't contain a SP change point, return 0
             Otherwise return delta of SP modification

Help on function get_spd in module idc:

get_spd(ea)
    Get current delta for the stack pointer
    
    @param ea: end address of the instruction
               i.e.the last address of the instruction+1
    
    @return: The difference between the original SP upon
             entering the function and SP for the specified address

Help on function get_sreg in module idc:

get_sreg(ea, reg)
    Get value of segment register at the specified address
    
    @param ea: linear address
    @param reg: name of segment register
    
    @return: the value of the segment register or -1 on error
    
    @note: The segment registers in 32bit program usually contain selectors,
           so to get paragraph pointed to by the segment register you need to
           call sel2para() function.

Help on function get_step_trace_options in module ida_dbg:

get_step_trace_options(*args) -> 'int'
    get_step_trace_options() -> int
    Get current step tracing options. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    @return: Step trace options

Help on function get_str_type in module idc:

get_str_type(ea)
    Get string type
    
    @param ea: linear address
    
    @return: One of STRTYPE_... constants

Help on function get_strlit_contents in module idc:

get_strlit_contents(ea, length=-1, strtype=0)
    Get string contents
    @param ea: linear address
    @param length: string length. -1 means to calculate the max string length
    @param strtype: the string type (one of STRTYPE_... constants)
    
    @return: string contents or empty string

Help on function get_struc_by_idx in module ida_struct:

get_struc_by_idx(*args) -> 'tid_t'
    get_struc_by_idx(idx) -> tid_t
    Get struct id by struct number.
    
    @param idx: (C++: uval_t)

Help on function get_struc_cmt in module ida_struct:

get_struc_cmt(*args) -> 'qstring *'
    get_struc_cmt(id, repeatable) -> str
    Get struct comment.
    
    @param id: (C++: tid_t)
    @param repeatable: (C++: bool)

Help on function get_struc_id in module ida_struct:

get_struc_id(*args) -> 'tid_t'
    get_struc_id(name) -> tid_t
    Get struct id by name.
    
    @param name: (C++: const char *) char const *

Help on function get_struc_idx in module ida_struct:

get_struc_idx(*args) -> 'uval_t'
    get_struc_idx(id) -> uval_t
    Get internal number of the structure.
    
    @param id: (C++: tid_t)

Help on function get_struc_name in module ida_struct:

get_struc_name(*args) -> 'qstring *'
    get_struc_name(id, flags=0) -> str
    
    @param id: tid_t
    @param flags: int

Help on function get_struc_qty in module ida_struct:

get_struc_qty(*args) -> 'size_t'
    get_struc_qty() -> size_t
    Get number of known structures.

Help on function get_struc_size in module ida_struct:

get_struc_size(*args) -> 'asize_t'
    get_struc_size(sptr) -> asize_t
    Get struct size (also see get_struc_size(const struc_t *))
    
    @param sptr: struc_t const *
    
    get_struc_size(id) -> asize_t
    
    @param id: tid_t

Help on function get_tev_ea in module ida_dbg:

get_tev_ea(*args) -> 'ea_t'
    get_tev_ea(n) -> ea_t
    
    @param n: int

Help on function get_tev_reg_mem in module ida_dbg:

get_tev_reg_mem(tev, idx)

Help on function get_tev_reg_mem_ea in module ida_dbg:

get_tev_reg_mem_ea(tev, idx)

Help on function get_tev_reg_mem_qty in module ida_dbg:

get_tev_reg_mem_qty(tev)

Help on function get_tev_qty in module ida_dbg:

get_tev_qty(*args) -> 'int'
    get_tev_qty() -> int
    Get number of trace events available in trace buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}

Help on function get_tev_reg_val in module ida_dbg:

get_tev_reg_val(tev, reg)

Help on function get_tev_tid in module ida_dbg:

get_tev_tid(*args) -> 'int'
    get_tev_tid(n) -> int
    
    @param n: int

Help on function get_tev_type in module ida_dbg:

get_tev_type(*args) -> 'int'
    get_tev_type(n) -> int
    
    @param n: int

Help on function get_thread_qty in module ida_dbg:

get_thread_qty(*args) -> 'int'
    get_thread_qty() -> int
    Get number of threads. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}

Help on function get_tinfo in module idc:

get_tinfo(ea)
    Get type information of function/variable as 'typeinfo' object
    
    @param ea: the address of the object
    @return: None on failure, or (type, fields) tuple.

Help on function get_trace_file_desc in module ida_dbg:

get_trace_file_desc(*args) -> 'qstring *'
    get_trace_file_desc(filename) -> str
    Get the file header of the specified trace file.
    
    @param filename: (C++: const char *) char const *

Help on function get_type in module idc:

get_type(ea)
    Get type of function/variable
    
    @param ea: the address of the object
    
    @return: type string or None if failed

Help on function get_wide_byte in module ida_bytes:

get_wide_byte(*args) -> 'uint64'
    get_wide_byte(ea) -> uint64
    Get one wide byte of the program at 'ea'. Some processors may access more than
    8bit quantity at an address. These processors have 32-bit byte organization from
    the IDA's point of view.
    
    @param ea: (C++: ea_t)

Help on function get_wide_dword in module ida_bytes:

get_wide_dword(*args) -> 'uint64'
    get_wide_dword(ea) -> uint64
    Get two wide words (4 'bytes') of the program at 'ea'. Some processors may
    access more than 8bit quantity at an address. These processors have 32-bit byte
    organization from the IDA's point of view. This function takes into account
    order of bytes specified in idainfo::is_be()
    @note: this function works incorrectly if processor_t::nbits > 16
    
    @param ea: (C++: ea_t)

Help on function get_wide_word in module ida_bytes:

get_wide_word(*args) -> 'uint64'
    get_wide_word(ea) -> uint64
    Get one wide word (2 'byte') of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit byte
    organization from the IDA's point of view. This function takes into account
    order of bytes specified in idainfo::is_be()
    
    @param ea: (C++: ea_t)

Help on function get_xref_type in module idc:

get_xref_type()
    Return type of the last xref obtained by
    [RD]first/next[B0] functions.
    
    @return: constants fl_* or dr_*

Help on function getn_enum in module ida_enum:

getn_enum(*args) -> 'enum_t'
    getn_enum(idx) -> enum_t
    Get enum by its index in the list of enums (0..get_enum_qty()-1).
    
    @param idx: (C++: size_t)

Help on function getn_thread in module ida_dbg:

getn_thread(*args) -> 'thid_t'
    getn_thread(n) -> thid_t
    Get the ID of a thread. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: (C++: int) number of thread, is in range 0..get_thread_qty()-1
    @return: NO_THREAD if the thread doesn't exist.

Help on function getn_thread_name in module ida_dbg:

getn_thread_name(*args) -> 'char const *'
    getn_thread_name(n) -> char const *
    Get the NAME of a thread \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    @param n: (C++: int) number of thread, is in range 0..get_thread_qty()-1 or -1 for the
              current thread
    @return: thread name or nullptr if the thread doesn't exist.

Help on function guess_type in module idc:

guess_type(ea)
    Guess type of function/variable
    
    @param ea: the address of the object, can be the structure member id too
    
    @return: type string or None if failed

Help on function hasName in module idc:

hasName(F)

Help on function hasUserName in module idc:

hasUserName(F)

Help on function has_value in module idc:

has_value(F)

Help on function here in module idc:

here()
    # Convenience functions:

Help on function idadir in module idc:

idadir()
    Get IDA directory
    
    This function returns the directory where IDA.EXE resides

Help on function import_type in module idc:

import_type(idx, type_name)
    Copy information from type library to database
    Copy structure, union, or enum definition from the type library
    to the IDA database.
    
    @param idx: the position of the new type in the list of
                types (structures or enums) -1 means at the end of the list
    @param type_name: name of type to copy
    
    @return: BADNODE-failed, otherwise the type id (structure id or enum id)

Help on function isBin0 in module idc:

isBin0(F)

Help on function isBin1 in module idc:

isBin1(F)

Help on function isDec0 in module idc:

isDec0(F)

Help on function isDec1 in module idc:

isDec1(F)

Help on function isExtra in module idc:

isExtra(F)

Help on function isHex0 in module idc:

isHex0(F)

Help on function isHex1 in module idc:

isHex1(F)

Help on function isOct0 in module idc:

isOct0(F)

Help on function isOct1 in module idc:

isOct1(F)

Help on function isRef in module idc:

isRef(F)

Help on function is_align in module idc:

is_align(F)

Help on function is_bf in module ida_enum:

is_bf(*args) -> 'bool'
    is_bf(id) -> bool
    Is enum a bitfield? (otherwise - plain enum, no bitmasks except for DEFMASK are
    allowed)
    
    @param id: (C++: enum_t)

Help on function is_byte in module idc:

is_byte(F)

Help on function is_char0 in module idc:

is_char0(F)

Help on function is_char1 in module idc:

is_char1(F)

Help on function is_code in module idc:

is_code(F)

Help on function is_data in module idc:

is_data(F)

Help on function is_defarg0 in module idc:

is_defarg0(F)

Help on function is_defarg1 in module idc:

is_defarg1(F)

Help on function is_double in module idc:

is_double(F)

Help on function is_dword in module idc:

is_dword(F)

Help on function is_enum0 in module idc:

is_enum0(F)

Help on function is_enum1 in module idc:

is_enum1(F)

Help on function is_event_handled in module idc:

is_event_handled()
    Is the debug event handled?
    
    @return: boolean

Help on function is_float in module idc:

is_float(F)

Help on function is_flow in module idc:

is_flow(F)

Help on function is_head in module idc:

is_head(F)

Help on function is_loaded in module idc:

is_loaded(ea)
    Is the byte initialized?

Help on function is_manual0 in module idc:

is_manual0(F)

Help on function is_manual1 in module idc:

is_manual1(F)

Help on function is_mapped in module idc:

is_mapped(ea)

Help on function is_off0 in module idc:

is_off0(F)

Help on function is_off1 in module idc:

is_off1(F)

Help on function is_oword in module idc:

is_oword(F)

Help on function is_pack_real in module idc:

is_pack_real(F)

Help on function is_qword in module idc:

is_qword(F)

Help on function is_seg0 in module idc:

is_seg0(F)

Help on function is_seg1 in module idc:

is_seg1(F)

Help on function is_stkvar0 in module idc:

is_stkvar0(F)

Help on function is_stkvar1 in module idc:

is_stkvar1(F)

Help on function is_strlit in module idc:

is_strlit(F)

Help on function is_stroff0 in module idc:

is_stroff0(F)

Help on function is_stroff1 in module idc:

is_stroff1(F)

Help on function is_struct in module idc:

is_struct(F)

Help on function is_tail in module idc:

is_tail(F)

Help on function is_tbyte in module idc:

is_tbyte(F)

Help on function is_union in module idc:

is_union(sid)
    Is a structure a union?
    
    @param sid: structure type ID
    
    @return: 1: yes, this is a union id
             0: no
    
    @note: Unions are a special kind of structures

Help on function is_unknown in module idc:

is_unknown(F)

Help on function is_valid_trace_file in module ida_dbg:

is_valid_trace_file(*args) -> 'bool'
    is_valid_trace_file(filename) -> bool
    Is the specified file a valid trace file for the current database?
    
    @param filename: (C++: const char *) char const *

Help on function is_word in module idc:

is_word(F)

Help on function jumpto in module ida_kernwin:

jumpto(*args) -> 'bool'
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
    Set cursor position in custom ida viewer.
    
    @param custom_viewer: (C++: TWidget *) view
    @param place: (C++: place_t *) target position
    @param uijmp_flags: int
    
    @return: success
    jumpto(custom_viewer, place, x, y) -> bool
    
    @param custom_viewer: TWidget *
    @param place: place_t *
    @param x: int

Help on function load_and_run_plugin in module ida_loader:

load_and_run_plugin(*args) -> 'bool'
    load_and_run_plugin(name, arg) -> bool
    Load & run a plugin.
    
    @param name: (C++: const char *) char const *
    @param arg: (C++: size_t)

Help on function load_debugger in module ida_dbg:

load_debugger(*args) -> 'bool'
    load_debugger(dbgname, use_remote) -> bool
    
    @param dbgname: char const *
    @param use_remote: bool

Help on function load_trace_file in module ida_dbg:

load_trace_file(*args) -> 'qstring *'
    load_trace_file(filename) -> str
    Load a recorded trace file in the 'Tracing' window. If the call succeeds and
    'buf' is not null, the description of the trace stored in the binary trace file
    will be returned in 'buf'
    
    @param filename: (C++: const char *) char const *

Help on function loadfile in module idc:

loadfile(filepath, pos, ea, size)

Help on function ltoa in module idc:

ltoa(n, radix)

Help on function make_array in module idc:

make_array(ea, nitems)
    Create an array.
    
    @param ea: linear address
    @param nitems: size of array in items
    
    @note: This function will create an array of the items with the same type as
    the type of the item at 'ea'. If the byte at 'ea' is undefined, then
    this function will create an array of bytes.

Help on function move_segm in module idc:

move_segm(ea, to, flags)
    Move a segment to a new address
    This function moves all information to the new address
    It fixes up address sensitive information in the kernel
    The total effect is equal to reloading the segment to the target address
    
    @param ea: any address within the segment to move
    @param to: new segment start address
    @param flags: combination MFS_... constants
    
    @returns: MOVE_SEGM_... error code

Help on function msg in module ida_kernwin:

msg(*args) -> 'PyObject *'
    msg(o) -> int
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts

Help on function next_addr in module ida_bytes:

next_addr(*args) -> 'ea_t'
    next_addr(ea) -> ea_t
    Get next address in the program (i.e. next address which has flags).
    
    @param ea: (C++: ea_t)
    @return: BADADDR if no such address exist.

Help on function next_func_chunk in module idc:

next_func_chunk(funcea, tailea)
    Get the next function chunk of the specified function
    
    @param funcea: any address in the function
    @param tailea: any address in the current chunk
    
    @return: the starting address of the next function chunk or BADADDR
    
    @note: This function returns the next chunk of the specified function

Help on function next_head in module idc:

next_head(ea, maxea=BADADDR)
    Get next defined item (instruction or data) in the program
    
    @param ea: linear address to start search from
    @param maxea: the search will stop at the address
        maxea is not included in the search range
    
    @return: BADADDR - no (more) defined items

Help on function next_not_tail in module ida_bytes:

next_not_tail(*args) -> 'ea_t'
    next_not_tail(ea) -> ea_t
    Get address of next non-tail byte.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

Help on function op_bin in module ida_bytes:

op_bin(*args) -> 'bool'
    op_bin(ea, n) -> bool
    set op type to bin_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_chr in module ida_bytes:

op_chr(*args) -> 'bool'
    op_chr(ea, n) -> bool
    set op type to char_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_dec in module ida_bytes:

op_dec(*args) -> 'bool'
    op_dec(ea, n) -> bool
    set op type to dec_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_enum in module ida_bytes:

op_enum(*args) -> 'bool'
    op_enum(ea, n, id, serial) -> bool
    Set operand representation to be 'enum_t'. If applied to unexplored bytes,
    converts them to 16/32bit word data
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @param id: (C++: enum_t) id of enum
    @param serial: (C++: uchar) the serial number of the constant in the enumeration, usually 0.
                   the serial numbers are used if the enumeration contains several
                   constants with the same value
    @return: success

Help on function op_flt in module ida_bytes:

op_flt(*args) -> 'bool'
    op_flt(ea, n) -> bool
    set op type to flt_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_hex in module ida_bytes:

op_hex(*args) -> 'bool'
    op_hex(ea, n) -> bool
    set op type to hex_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function set_forced_operand in module ida_bytes:

set_forced_operand(*args) -> 'bool'
    set_forced_operand(ea, n, op) -> bool
    Set forced operand.
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, 2)
    @param op: (C++: const char *) text of operand
    * nullptr: do nothing (return 0)
    * "" : delete forced operand
    @return: success

Help on function op_num in module ida_bytes:

op_num(*args) -> 'bool'
    op_num(ea, n) -> bool
    set op type to num_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_oct in module ida_bytes:

op_oct(*args) -> 'bool'
    op_oct(ea, n) -> bool
    set op type to oct_flag()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function op_offset in module ida_offset:

op_offset(*args) -> 'bool'
    op_offset(ea, n, type_and_flags, target=BADADDR, base=0, tdelta=0) -> bool
    See op_offset_ex()
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)
    @param type_and_flags: (C++: uint32)
    @param target: (C++: ea_t)
    @param base: (C++: ea_t)
    @param tdelta: (C++: adiff_t)

Help on function op_offset_high16 in module idc:

op_offset_high16(ea, n, target)
    Convert operand to a high offset
    High offset is the upper 16bits of an offset.
    This type is used by TMS320C6 processors (and probably by other
    RISC processors too)
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param target: the full value (all 32bits) of the offset

Help on function op_plain_offset in module idc:

op_plain_offset(ea, n, base)
    Convert operand to an offset
    (for the explanations of 'ea' and 'n' please see op_bin())
    
    Example:
    ========
    
        seg000:2000 dw      1234h
    
        and there is a segment at paragraph 0x1000 and there is a data item
        within the segment at 0x1234:
    
        seg000:1234 MyString        db 'Hello, world!',0
    
        Then you need to specify a linear address of the segment base to
        create a proper offset:
    
        op_plain_offset(["seg000",0x2000],0,0x10000);
    
        and you will have:
    
        seg000:2000 dw      offset MyString
    
    Motorola 680x0 processor have a concept of "outer offsets".
    If you want to create an outer offset, you need to combine number
    of the operand with the following bit:
    
    Please note that the outer offsets are meaningful only for
    Motorola 680x0.
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param base: base of the offset as a linear address
        If base == BADADDR then the current operand becomes non-offset

Help on function op_seg in module ida_bytes:

op_seg(*args) -> 'bool'
    op_seg(ea, n) -> bool
    Set operand representation to be 'segment'. If applied to unexplored bytes,
    converts them to 16/32bit word data
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: success

Help on function op_stkvar in module ida_bytes:

op_stkvar(*args) -> 'bool'
    op_stkvar(ea, n) -> bool
    Set operand representation to be 'stack variable'. Should be applied to an
    instruction within a function. Should be applied after creating a stack var
    using insn_t::create_stkvar().
    
    @param ea: (C++: ea_t) linear address
    @param n: (C++: int) number of operand (0, 1, -1)
    @return: success

Help on function op_stroff in module idc:

op_stroff(ea, n, strid, delta)
    Convert operand to an offset in a structure
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands
    @param strid: id of a structure type
    @param delta: struct offset delta. usually 0. denotes the difference
                    between the structure base and the pointer into the structure.

Help on function parse_decl in module idc:

parse_decl(inputtype, flags)
    Parse type declaration
    
    @param inputtype: file name or C declarations (depending on the flags)
    @param flags: combination of PT_... constants or 0
    
    @return: None on failure or (name, type, fields) tuple

Help on function parse_decls in module idc:

parse_decls(inputtype, flags=0)
    Parse type declarations
    
    @param inputtype: file name or C declarations (depending on the flags)
    @param flags: combination of PT_... constants or 0
    
    @return: number of parsing errors (0 no errors)

Help on function patch_byte in module ida_bytes:

patch_byte(*args) -> 'bool'
    patch_byte(ea, x) -> bool
    Patch a byte of the program. The original value of the byte is saved and can be
    obtained by get_original_byte(). This function works for wide byte processors
    too.
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function put_dbg_byte in module ida_dbg:

put_dbg_byte(*args) -> 'bool'
    put_dbg_byte(ea, x) -> bool
    Change one byte of the debugged process memory.
    
    @param ea: (C++: ea_t) linear address
    @param x: (C++: uint32) byte value
    @return: true if the process memory has been modified

Help on function patch_dword in module ida_bytes:

patch_dword(*args) -> 'bool'
    patch_dword(ea, x) -> bool
    Patch a dword of the program. The original value of the dword is saved and can
    be obtained by get_original_dword(). This function DOESN'T work for wide byte
    processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function patch_qword in module ida_bytes:

patch_qword(*args) -> 'bool'
    patch_qword(ea, x) -> bool
    Patch a qword of the program. The original value of the qword is saved and can
    be obtained by get_original_qword(). This function DOESN'T work for wide byte
    processors. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function patch_word in module ida_bytes:

patch_word(*args) -> 'bool'
    patch_word(ea, x) -> bool
    Patch a word of the program. The original value of the word is saved and can be
    obtained by get_original_word(). This function works for wide byte processors
    too. This function takes into account order of bytes specified in
    idainfo::is_be()
    @retval true: the database has been modified,
    @retval false: the debugger is running and the process' memory has value 'x' at
                   address 'ea', or the debugger is not running, and the IDB has
                   value 'x' at address 'ea already.
    
    @param ea: (C++: ea_t)
    @param x: (C++: uint64)

Help on function plan_and_wait in module idc:

plan_and_wait(sEA, eEA, final_pass=True)
    Perform full analysis of the range
    
    @param sEA: starting linear address
    @param eEA: ending linear address (excluded)
    @param final_pass: make the final pass over the specified range
    
    @return: 1-ok, 0-Ctrl-Break was pressed.

Help on function plan_to_apply_idasgn in module ida_funcs:

plan_to_apply_idasgn(*args) -> 'int'
    plan_to_apply_idasgn(fname) -> int
    Add a signature file to the list of planned signature files.
    
    @param fname: (C++: const char *) file name. should not contain directory part.
    @return: 0 if failed, otherwise number of planned (and applied) signatures

Help on function prev_addr in module ida_bytes:

prev_addr(*args) -> 'ea_t'
    prev_addr(ea) -> ea_t
    Get previous address in the program.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if no such address exist.

Help on function prev_head in module idc:

prev_head(ea, minea=0)
    Get previous defined item (instruction or data) in the program
    
    @param ea: linear address to start search from
    @param minea: the search will stop at the address
            minea is included in the search range
    
    @return: BADADDR - no (more) defined items

Help on function prev_not_tail in module ida_bytes:

prev_not_tail(*args) -> 'ea_t'
    prev_not_tail(ea) -> ea_t
    Get address of previous non-tail byte.
    
    @param ea: (C++: ea_t)
    @return: BADADDR if none exists.

Help on function print_decls in module idc:

print_decls(ordinals, flags)
    Print types in a format suitable for use in a header file
    
    @param ordinals: comma-separated list of type ordinals
    @param flags: combination of PDF_... constants or 0
    
    @return: string containing the type definitions

Help on _Feature in module __future__ object:

class _Feature(builtins.object)
 |  Methods defined here:
 |  
 |  __init__(self, optionalRelease, mandatoryRelease, compiler_flag)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  __repr__(self)
 |      Return repr(self).
 |  
 |  getMandatoryRelease(self)
 |      Return release in which this feature will become mandatory.
 |      
 |      This is a 5-tuple, of the same form as sys.version_info, or, if
 |      the feature was dropped, is None.
 |  
 |  getOptionalRelease(self)
 |      Return first release in which this feature was recognized.
 |      
 |      This is a 5-tuple, of the same form as sys.version_info.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

Help on function print_insn_mnem in module idc:

print_insn_mnem(ea)
    Get instruction mnemonics
    
    @param ea: linear address of instruction
    
    @return: "" - no instruction at the specified location
    
    @note: this function may not return exactly the same mnemonics
    as you see on the screen.

Help on function print_operand in module idc:

print_operand(ea, n)
    Get operand of an instruction or data
    
    @param ea: linear address of the item
    @param n: number of operand:
        0 - the first operand
        1 - the second operand
    
    @return: the current text representation of operand or ""

Help on function process_config_line in module idc:

process_config_line(directive)
    Obsolete. Please use ida_idp.process_config_directive().

Help on function process_ui_action in module idc:

process_ui_action(name, flags=0)
    Invokes an IDA UI action by name
    
    @param name: Command name
    @param flags: Reserved. Must be zero
    @return: Boolean

Help on function mark_position in module ida_idc:

mark_position(*args) -> 'void'
    mark_position(ea, lnnum, x, y, slot, comment)
    
    @param ea: ea_t
    @param lnnum: int
    @param x: short
    @param y: short
    @param slot: int32
    @param comment: char const *

Help on function qexit in module ida_pro:

qexit(*args) -> 'void'
    qexit(code)
    Call qatexit functions, shut down UI and kernel, and exit.
    
    @param code: (C++: int) exit code

Help on function qsleep in module idc:

qsleep(milliseconds)
    qsleep the specified number of milliseconds
    This function suspends IDA for the specified amount of time
    
    @param milliseconds: time to sleep

Help on function read_dbg_byte in module idc:

read_dbg_byte(ea)
    Get value of program byte using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_dbg_dword in module idc:

read_dbg_dword(ea)
    Get value of program double-word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function dbg_read_memory in module ida_idd:

dbg_read_memory(*args) -> 'PyObject *'
    dbg_read_memory(ea, sz) -> PyObject *
    Reads from the debugee's memory at the specified ea
    
    @param ea: ea_t
    @param sz: size_t
    @return:     - The read buffer (as a string)
        - Or None on failure

Help on function read_dbg_qword in module idc:

read_dbg_qword(ea)
    Get value of program quadro-word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_dbg_word in module idc:

read_dbg_word(ea)
    Get value of program word using the debugger memory
    
    @param ea: linear address
    @return: The value or None on failure.

Help on function read_selection_end in module idc:

read_selection_end()
    Get end address of the selected range
    
    @return: BADADDR - the user has not selected an range

Help on function read_selection_start in module idc:

read_selection_start()
    Get start address of the selected range
    returns BADADDR - the user has not selected an range

Help on function readlong in module idc:

readlong(handle, mostfirst)

Help on function readshort in module idc:

readshort(handle, mostfirst)

Help on function readstr in module idc:

readstr(handle)

Help on function rebase_program in module ida_segment:

rebase_program(*args) -> 'int'
    rebase_program(delta, flags) -> int
    Rebase the whole program by 'delta' bytes.
    
    @param delta: (C++: adiff_t) number of bytes to move the program
    @param flags: (C++: int) Move segment flags it is recommended to use MSF_FIXONCE so that
                  the loader takes care of global variables it stored in the
                  database
    @return: Move segment result codes

Help on function recalc_spd in module ida_frame:

recalc_spd(*args) -> 'bool'
    recalc_spd(cur_ea) -> bool
    Recalculate SP delta for an instruction that stops execution. The next
    instruction is not reached from the current instruction. We need to recalculate
    SP for the next instruction.
    
    This function will create a new automatic SP register change point if necessary.
    It should be called from the emulator (emu.cpp) when auto_state == AU_USED if
    the current instruction doesn't pass the execution flow to the next instruction.
    
    @param cur_ea: (C++: ea_t) linear address of the current instruction
    @retval 1: new stkpnt is added
    @retval 0: nothing is changed

Help on function refresh_debugger_memory in module ida_dbg:

refresh_debugger_memory(*args) -> 'PyObject *'
    refresh_debugger_memory() -> PyObject *
    Refreshes the debugger memory
    
    @return: Nothing

Help on function refresh_idaview_anyway in module ida_kernwin:

refresh_idaview_anyway(*args) -> 'void'
    refresh_idaview_anyway()
    Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please
    consider request_refresh() instead

Help on function refresh_choosers in module ida_kernwin:

refresh_choosers(*args) -> 'void'
    refresh_choosers()

Help on function remove_fchunk in module idc:

remove_fchunk(funcea, tailea)
    Remove a function chunk from the function
    
    @param funcea: any address in the function
    @param tailea: any address in the function chunk to remove
    
    @return: 0 if failed, 1 if success

Help on function rename_array in module idc:

rename_array(array_id, newname)
    Rename array, by its ID.
    
    @param id: The ID of the array to rename.
    @param newname: The new name of the array.
    
    @return: 1 in case of success, 0 otherwise

Help on function rename_entry in module ida_entry:

rename_entry(*args) -> 'bool'
    rename_entry(ord, name, flags=0) -> bool
    Rename entry point.
    
    @param ord: (C++: uval_t) ordinal number of the entry point
    @param name: (C++: const char *) name of entry point. If the specified location already has a name,
                 the old name will be appended to a repeatable comment.
    @param flags: (C++: int) See AEF_*
    @return: success

Help on function resume_process in module idc:

resume_process()

Help on function resume_thread in module ida_dbg:

resume_thread(*args) -> 'int'
    resume_thread(tid) -> int
    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

Help on function retrieve_input_file_md5 in module ida_nalt:

retrieve_input_file_md5(*args) -> 'uchar [ANY]'
    retrieve_input_file_md5() -> bytes
    Get input file md5.

Help on function rotate_byte in module idc:

rotate_byte(x, count)

Help on function rotate_dword in module idc:

rotate_dword(x, count)

Help on function rotate_left in module idc:

rotate_left(value, count, nbits, offset)
    Rotate a value to the left (or right)
    
    @param value: value to rotate
    @param count: number of times to rotate. negative counter means
                  rotate to the right
    @param nbits: number of bits to rotate
    @param offset: offset of the first bit to rotate
    
    @return: the value with the specified field rotated
             all other bits are not modified

Help on function rotate_word in module idc:

rotate_word(x, count)

Help on function run_to in module ida_dbg:

run_to(*args) -> 'bool'
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
    Execute the process until the given address is reached. If no process is active,
    a new process is started. Technically, the debugger sets up a temporary
    breakpoint at the given address, and continues (or starts) the execution of the
    whole process. So, all threads continue their execution! \sq{Type, Asynchronous
    function - available as Request, Notification, dbg_run_to}
    
    @param ea: (C++: ea_t) target address
    @param pid: (C++: pid_t) not used yet. please do not specify this parameter.

Help on function save_database in module idc:

save_database(idbname, flags=0)
    Save current database to the specified idb file
    
    @param idbname: name of the idb file. if empty, the current idb
                    file will be used.
    @param flags: combination of ida_loader.DBFL_... bits or 0

Help on function save_trace_file in module ida_dbg:

save_trace_file(*args) -> 'bool'
    save_trace_file(filename, description) -> bool
    Save the current trace in the specified file.
    
    @param filename: (C++: const char *) char const *
    @param description: (C++: const char *) char const *

Help on function savefile in module idc:

savefile(filepath, pos, ea, size)

Help on function sel2para in module idc:

sel2para(sel)
    Get a selector value
    
    @param sel: the selector number
    
    @return: selector value if found
             otherwise the input value (sel)
    
    @note: selector values are always in paragraphs

Help on function select_thread in module ida_dbg:

select_thread(*args) -> 'bool'
    select_thread(tid) -> bool
    Select the given thread as the current debugged thread. All thread related
    execution functions will work on this thread. The process must be suspended to
    select a new thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) ID of the thread to select
    @return: false if the thread doesn't exist.

Help on function selector_by_name in module idc:

selector_by_name(segname)
    Get segment selector by name
    
    @param segname: name of segment
    
    @return: segment selector or BADADDR

Help on function send_dbg_command in module idc:

send_dbg_command(cmd)
    Sends a command to the debugger module and returns the output string.
    An exception will be raised if the debugger is not running or the current debugger does not export
    the 'send_dbg_command' IDC command.

Help on function set_array_long in module idc:

set_array_long(array_id, idx, value)
    Sets the long value of an array element.
    
    @param array_id: The array ID.
    @param idx: Index of an element.
    @param value: 32bit or 64bit value to store in the array
    
    @return: 1 in case of success, 0 otherwise

Help on function set_array_params in module idc:

set_array_params(ea, flags, litems, align)
    Set array representation format
    
    @param ea: linear address
    @param flags: combination of AP_... constants or 0
    @param litems: number of items per line. 0 means auto
    @param align: element alignment
                  - -1: do not align
                  - 0:  automatic alignment
                  - other values: element width
    
    @return: 1-ok, 0-failure

Help on function set_array_string in module idc:

set_array_string(array_id, idx, value)
    Sets the string value of an array element.
    
    @param array_id: The array ID.
    @param idx: Index of an element.
    @param value: String value to store in the array
    
    @return: 1 in case of success, 0 otherwise

Help on function set_bmask_cmt in module idc:

set_bmask_cmt(enum_id, bmask, cmt, repeatable)
    Set bitmask comment (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param cmt: comment
    repeatable - type of comment, 0-regular, 1-repeatable
    
    @return: 1-ok, 0-failed

Help on function set_bmask_name in module idc:

set_bmask_name(enum_id, bmask, name)
    Set bitmask name (only for bitfields)
    
    @param enum_id: id of enum
    @param bmask: bitmask of the constant
    @param name: name of bitmask
    
    @return: 1-ok, 0-failed

Help on function set_bpt_attr in module idc:

set_bpt_attr(address, bptattr, value)
        modifiable characteristics of a breakpoint
    
    @param address: any address in the breakpoint range
    @param bptattr: the attribute code, one of BPTATTR_* constants
                    BPTATTR_CND is not allowed, see set_bpt_cond()
    @param value: the attibute value
    
    @return: success

Help on function set_bpt_cond in module idc:

set_bpt_cond(ea, cnd, is_lowcnd=0)
    Set breakpoint condition
    
    @param ea: any address in the breakpoint range
    @param cnd: breakpoint condition
    @param is_lowcnd: 0 - regular condition, 1 - low level condition
    
    @return: success

Help on function set_cmt in module ida_bytes:

set_cmt(*args) -> 'bool'
    set_cmt(ea, comm, rptble) -> bool
    Set an indented comment.
    
    @param ea: (C++: ea_t) linear address
    @param comm: (C++: const char *) comment string
    * nullptr: do nothing (return 0)
    * "" : delete comment
    @param rptble: (C++: bool) is repeatable?
    @return: success

Help on function set_color in module idc:

set_color(ea, what, color)
    Set item color
    
    @param ea: address of the item
    @param what: type of the item (one of CIC_* constants)
    @param color: new color code in RGB (hex 0xBBGGRR)
    
    @return: success (True or False)

Help on function set_debugger_event_cond in module ida_dbg:

set_debugger_event_cond(*args) -> 'void'
    set_debugger_event_cond(NONNULL_evcond)
    
    @param NONNULL_evcond: char const *

Help on function set_debugger_options in module ida_dbg:

set_debugger_options(*args) -> 'uint'
    set_debugger_options(options) -> uint
    Set debugger options. Replaces debugger options with the specification
    combination Debugger options
    
    @param options: (C++: uint)
    @return: the old debugger options

Help on function set_default_sreg_value in module idc:

set_default_sreg_value(ea, reg, value)
    Set default segment register value for a segment
    
    @param ea: any address in the segment
               if no segment is present at the specified address
               then all segments will be affected
    @param reg: name of segment register
    @param value: default value of the segment register. -1-undefined.

Help on function set_enum_bf in module ida_enum:

set_enum_bf(*args) -> 'bool'
    set_enum_bf(id, bf) -> bool
    Set 'bitfield' bit of enum (i.e. convert it to a bitfield)
    
    @param id: (C++: enum_t)
    @param bf: (C++: bool)

Help on function set_enum_cmt in module ida_enum:

set_enum_cmt(*args) -> 'bool'
    set_enum_cmt(id, cmt, repeatable) -> bool
    Set comment for enum type.
    
    @param id: (C++: enum_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_enum_flag in module ida_enum:

set_enum_flag(*args) -> 'bool'
    set_enum_flag(id, flag) -> bool
    Set data representation flags.
    
    @param id: (C++: enum_t)
    @param flag: (C++: flags_t)

Help on function set_enum_idx in module ida_enum:

set_enum_idx(*args) -> 'bool'
    set_enum_idx(id, idx) -> bool
    Set serial number of enum. Also see get_enum_idx().
    
    @param id: (C++: enum_t)
    @param idx: (C++: size_t)

Help on function set_enum_member_cmt in module ida_enum:

set_enum_member_cmt(*args) -> 'bool'
    set_enum_member_cmt(id, cmt, repeatable) -> bool
    Set comment for enum member.
    
    @param id: (C++: const_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_enum_member_name in module ida_enum:

set_enum_member_name(*args) -> 'bool'
    set_enum_member_name(id, name) -> bool
    Set name of enum member.
    
    @param id: (C++: const_t)
    @param name: (C++: const char *) char const *

Help on function set_enum_name in module ida_enum:

set_enum_name(*args) -> 'bool'
    set_enum_name(id, name) -> bool
    Set name of enum type.
    
    @param id: (C++: enum_t)
    @param name: (C++: const char *) char const *

Help on function set_enum_width in module ida_enum:

set_enum_width(*args) -> 'bool'
    set_enum_width(id, width) -> bool
    See comment for get_enum_width()
    
    @param id: (C++: enum_t)
    @param width: (C++: int)

Help on function set_fchunk_attr in module idc:

set_fchunk_attr(ea, attr, value)
    Set a function chunk attribute
    
    @param ea: any address in the chunk
    @param attr: only FUNCATTR_START, FUNCATTR_END, FUNCATTR_OWNER
    @param value: desired value
    
    @return: 0 if failed, 1 if success

Help on function set_fixup in module idc:

set_fixup(ea, fixuptype, fixupflags, targetsel, targetoff, displ)
    Set fixup information
    
    @param ea: address to set fixup information about
    @param fixuptype:  fixup type. see get_fixup_target_type()
                       for possible fixup types.
    @param fixupflags: fixup flags. see get_fixup_target_flags()
                       for possible fixup types.
    @param targetsel:  target selector
    @param targetoff:  target offset
    @param displ:      displacement
    
    @return:        none

Help on function set_flag in module idc:

set_flag(off, bit, value)
    #--------------------------------------------------------------------------

Help on function set_frame_size in module idc:

set_frame_size(ea, lvsize, frregs, argsize)
    Make function frame
    
    @param ea: any address belonging to the function
    @param lvsize: size of function local variables
    @param frregs: size of saved registers
    @param argsize: size of function arguments
    
    @return: ID of function frame or -1
             If the function did not have a frame, the frame
             will be created. Otherwise the frame will be modified

Help on function set_func_attr in module idc:

set_func_attr(ea, attr, value)
    Set a function attribute
    
    @param ea: any address belonging to the function
    @param attr: one of FUNCATTR_... constants
    @param value: new value of the attribute
    
    @return: 1-ok, 0-failed

Help on function set_func_cmt in module idc:

set_func_cmt(ea, cmt, repeatable)
    Set function comment
    
    @param ea: any address belonging to the function
    @param cmt: a function comment line
    @param repeatable: 1: get repeatable comment
            0: get regular comment

Help on function set_func_end in module ida_funcs:

set_func_end(*args) -> 'bool'
    set_func_end(ea, newend) -> bool
    Move function chunk end address.
    
    @param ea: (C++: ea_t) any address in the function
    @param newend: (C++: ea_t) new end address of the function
    @return: success

Help on function set_func_flags in module idc:

set_func_flags(ea, flags)
    Change function flags
    
    @param ea: any address belonging to the function
    @param flags: see get_func_flags() for explanations
    
    @return: !=0 - ok

Help on function set_hash_long in module idc:

set_hash_long(hash_id, key, value)
    Sets the long value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    @param value: 32bit or 64bit value to store in the hash
    
    @return: 1 in case of success, 0 otherwise

Help on function set_hash_string in module idc:

set_hash_string(hash_id, key, value)
    Sets the string value of a hash element.
    
    @param hash_id: The hash ID.
    @param key: Key of an element.
    @param value: string value to store in the hash
    
    @return: 1 in case of success, 0 otherwise

Help on function set_ida_state in module ida_auto:

set_ida_state(*args) -> 'idastate_t'
    set_ida_state(st) -> idastate_t
    Change IDA status indicator value
    
    @param st: (C++: idastate_t) - new indicator status
    @return: old indicator status

Help on function set_inf_attr in module idc:

set_inf_attr(attr, value)
    Deprecated. Please ida_ida.inf_set_* instead.

Help on function set_local_type in module idc:

set_local_type(ordinal, input, flags)
    Parse one type declaration and store it in the specified slot
    
    @param ordinal:  slot number (1...NumberOfLocalTypes)
                     -1 means allocate new slot or reuse the slot
                     of the existing named type
    @param input:  C declaration. Empty input empties the slot
    @param flags:  combination of PT_... constants or 0
    
    @return: slot number or 0 if error

Help on function set_manual_insn in module ida_bytes:

set_manual_insn(*args) -> 'void'
    set_manual_insn(ea, manual_insn)
    Set manual instruction string.
    
    @param ea: (C++: ea_t) linear address of the instruction or data item
    @param manual_insn: (C++: const char *) "" - delete manual string. nullptr - do nothing

Help on function set_member_cmt in module idc:

set_member_cmt(sid, member_offset, comment, repeatable)
    Change structure member comment
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param comment: new comment of the structure member
    @param repeatable: 1: change repeatable comment
                       0: change regular comment
    
    @return: != 0 - ok

Help on function set_member_name in module idc:

set_member_name(sid, member_offset, name)
    Change structure member name
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param name: new name of the member
    
    @return: != 0 - ok.

Help on function set_member_type in module idc:

set_member_type(sid, member_offset, flag, typeid, nitems, target=-1, tdelta=0, reftype=2)
    Change structure member type
    
    @param sid: structure type ID
    @param member_offset: offset of the member
    @param flag: new type of the member. Should be one of
                 FF_BYTE..FF_PACKREAL (see above) combined with FF_DATA
    @param typeid: if is_struct(flag) then typeid specifies the structure id for the member
                   if is_off0(flag) then typeid specifies the offset base.
                   if is_strlit(flag) then typeid specifies the string type (STRTYPE_...).
                   if is_stroff(flag) then typeid specifies the structure id
                   if is_enum(flag) then typeid specifies the enum id
                   if is_custom(flags) then typeid specifies the dtid and fid: dtid|(fid<<16)
                   Otherwise typeid should be -1.
    @param nitems: number of items in the member
    
    @param target: target address of the offset expr. You may specify it as
                   -1, ida will calculate it itself
    @param tdelta: offset target delta. usually 0
    @param reftype: see REF_... definitions
    
    @note: The remaining arguments are allowed only if is_off0(flag) and you want
           to specify a complex offset expression
    
    @return: !=0 - ok.

Help on function set_name in module idc:

set_name(ea, name, flags=0)
    Rename an address
    
    @param ea: linear address
    @param name: new name of address. If name == "", then delete old name
    @param flags: combination of SN_... constants
    
    @return: 1-ok, 0-failure

Help on function set_processor_type in module ida_idp:

set_processor_type(*args) -> 'bool'
    set_processor_type(procname, level) -> bool
    Set target processor type. Once a processor module is loaded, it cannot be
    replaced until we close the idb.
    
    @param procname: (C++: const char *) name of processor type (one of names present in
                     processor_t::psnames)
    @param level: (C++: setproc_level_t) SETPROC_
    @return: success

Help on function set_reg_value in module idc:

set_reg_value(value, name)
    Set register value
    
    @param name: the register name
    @param value: new register value
    
    @note: The debugger should be running
           It is not necessary to use this function to set register values.
           A register name in the left side of an assignment will do too.

Help on function set_remote_debugger in module ida_dbg:

set_remote_debugger(*args) -> 'void'
    set_remote_debugger(host, _pass, port=-1)
    Set remote debugging options. Should be used before starting the debugger.
    
    @param host: (C++: const char *) If empty, IDA will use local debugger. If nullptr, the host will
                 not be set.
    @param pass: (C++: const char *) If nullptr, the password will not be set
    @param port: (C++: int) If -1, the default port number will be used

Help on function set_root_filename in module ida_nalt:

set_root_filename(*args) -> 'void'
    set_root_filename(file)
    Set full path of the input file.
    
    @param file: (C++: const char *) char const *

Help on function set_segm_addressing in module idc:

set_segm_addressing(ea, bitness)
    Change segment addressing
    
    @param ea: any address in the segment
    @param bitness: 0: 16bit, 1: 32bit, 2: 64bit
    
    @return: success (boolean)

Help on function set_segm_alignment in module idc:

set_segm_alignment(ea, alignment)
    Change alignment of the segment
    
    @param ea: any address in the segment
    @param alignment: new alignment of the segment (one of the sa... constants)
    
    @return: success (boolean)

Help on function set_segm_attr in module idc:

set_segm_attr(segea, attr, value)
    Set segment attribute
    
    @param segea: any address within segment
    @param attr: one of SEGATTR_... constants
    
    @note: Please note that not all segment attributes are modifiable.
           Also some of them should be modified using special functions
           like set_segm_addressing, etc.

Help on function set_segm_class in module idc:

set_segm_class(ea, segclass)
    Change class of the segment
    
    @param ea: any address in the segment
    @param segclass: new class of the segment
    
    @return: success (boolean)

Help on function set_segm_combination in module idc:

set_segm_combination(segea, comb)
    Change combination of the segment
    
    @param segea: any address in the segment
    @param comb: new combination of the segment (one of the sc... constants)
    
    @return: success (boolean)

Help on function set_segm_name in module idc:

set_segm_name(ea, name)
    Change name of the segment
    
    @param ea: any address in the segment
    @param name: new name of the segment
    
    @return: success (boolean)

Help on function set_segm_type in module idc:

set_segm_type(segea, segtype)
    Set segment type
    
    @param segea: any address within segment
    @param segtype: new segment type:
    
    @return: !=0 - ok

Help on function set_segment_bounds in module idc:

set_segment_bounds(ea, startea, endea, flags)
    Change segment boundaries
    
    @param ea: any address in the segment
    @param startea: new start address of the segment
    @param endea: new end address of the segment
    @param flags: combination of SEGMOD_... flags
    
    @return: boolean success

Help on function set_selector in module ida_segment:

set_selector(*args) -> 'int'
    set_selector(selector, paragraph) -> int
    Set mapping of selector to a paragraph. You should call this function _before_
    creating a segment which uses the selector, otherwise the creation of the
    segment will fail.
    
    @param selector: (C++: sel_t) number of selector to map
    * if selector == BADSEL, then return 0 (fail)
    * if the selector has had a mapping, old mapping is destroyed
    * if the selector number is equal to paragraph value, then the mapping is
    destroyed because we don't need to keep trivial mappings.
    @param paragraph: (C++: ea_t) paragraph to map selector
    @retval 1: ok
    @retval 0: failure (bad selector or too many mappings)

Help on function set_source_linnum in module ida_nalt:

set_source_linnum(*args) -> 'void'
    set_source_linnum(ea, lnnum)
    
    @param ea: ea_t
    @param lnnum: uval_t

Help on function set_step_trace_options in module ida_dbg:

set_step_trace_options(*args) -> 'void'
    set_step_trace_options(options)
    Modify step tracing options. \sq{Type, Synchronous function - available as
    request, Notification, none (synchronous function)}
    
    @param options: (C++: int)

Help on function change_storage_type in module ida_bytes:

change_storage_type(*args) -> 'error_t'
    change_storage_type(start_ea, end_ea, stt) -> error_t
    Change flag storage type for address range.
    
    @param start_ea: (C++: ea_t) should be lower than end_ea.
    @param end_ea: (C++: ea_t) does not belong to the range.
    @param stt: (C++: storage_type_t)
    @return: error code

Help on function set_struc_cmt in module ida_struct:

set_struc_cmt(*args) -> 'bool'
    set_struc_cmt(id, cmt, repeatable) -> bool
    Set structure comment.
    
    @param id: (C++: tid_t)
    @param cmt: (C++: const char *) char const *
    @param repeatable: (C++: bool)

Help on function set_struc_idx in module idc:

set_struc_idx(sid, index)
    Change structure index
    
    @param sid: structure type ID
    @param index: new index of the structure
    
    @return: != 0 - ok
    
    @note: See get_first_struc_idx() for the explanation of
           structure indices and IDs.

Help on function set_struc_name in module ida_struct:

set_struc_name(*args) -> 'bool'
    set_struc_name(id, name) -> bool
    Set structure name.
    
    @param id: (C++: tid_t)
    @param name: (C++: const char *) char const *

Help on function set_tail_owner in module idc:

set_tail_owner(tailea, funcea)
    Change the function chunk owner
    
    @param tailea: any address in the function chunk
    @param funcea: the starting address of the new owner
    
    @return: False if failed, True if success
    
    @note: The new owner must already have the chunk appended before the call

Help on function set_target_assembler in module ida_idp:

set_target_assembler(*args) -> 'bool'
    set_target_assembler(asmnum) -> bool
    Set target assembler.
    
    @param asmnum: (C++: int) number of assembler in the current processor module
    @return: success

Help on function set_trace_file_desc in module ida_dbg:

set_trace_file_desc(*args) -> 'bool'
    set_trace_file_desc(filename, description) -> bool
    Change the description of the specified trace file.
    
    @param filename: (C++: const char *) char const *
    @param description: (C++: const char *) char const *

Help on function split_sreg_range in module idc:

split_sreg_range(ea, reg, value, tag=2)
    Set value of a segment register.
    
    @param ea: linear address
    @param reg: name of a register, like "cs", "ds", "es", etc.
    @param value: new value of the segment register.
    @param tag: of SR_... constants
    
    @note: IDA keeps tracks of all the points where segment register change their
           values. This function allows you to specify the correct value of a segment
           register if IDA is not able to find the corrent value.

Help on function start_process in module ida_dbg:

start_process(*args) -> 'int'
    start_process(path=None, args=None, sdir=None) -> int
    Start a process in the debugger. \sq{Type, Asynchronous function - available as
    Request, Notification, dbg_process_start}
    @note: You can also use the run_to() function to easily start the execution of a
           process until a given address is reached.
    @note: For all parameters, a nullptr value indicates the debugger will take the
           value from the defined Process Options.
    
    @param path: (C++: const char *) path to the executable to start
    @param args: (C++: const char *) arguments to pass to process
    @param sdir: (C++: const char *) starting directory for the process
    @retval -1: impossible to create the process
    @retval 0: the starting of the process was cancelled by the user
    @retval 1: the process was properly started

Help on function step_into in module ida_dbg:

step_into(*args) -> 'bool'
    step_into() -> bool
    Execute one instruction in the current thread. Other threads are kept suspended.
    \sq{Type, Asynchronous function - available as Request, Notification,
    dbg_step_into}

Help on function step_over in module ida_dbg:

step_over(*args) -> 'bool'
    step_over() -> bool
    Execute one instruction in the current thread, but without entering into
    functions. Others threads keep suspended. \sq{Type, Asynchronous function -
    available as Request, Notification, dbg_step_over}

Help on function step_until_ret in module ida_dbg:

step_until_ret(*args) -> 'bool'
    step_until_ret() -> bool
    Execute instructions in the current thread until a function return instruction
    is executed (aka "step out"). Other threads are kept suspended. \sq{Type,
    Asynchronous function - available as Request, Notification, dbg_step_until_ret}

Help on function strlen in module idc:

strlen(s)

Help on function strstr in module idc:

strstr(s1, s2)

Help on function substr in module idc:

substr(s, x1, x2)

Help on function suspend_process in module ida_dbg:

suspend_process(*args) -> 'bool'
    suspend_process() -> bool
    Suspend the process in the debugger. \sq{ Type,
    * Synchronous function (if in a notification handler)
    * Asynchronous function (everywhere else)
    * available as Request, Notification,
    * none (if in a notification handler)
    * dbg_suspend_process (everywhere else) }
    @note: The suspend_process() function can be called from a notification handler
           to force the stopping of the process. In this case, no notification will
           be generated. When you suspend a process, the running command is always
           aborted.

Help on function suspend_thread in module ida_dbg:

suspend_thread(*args) -> 'int'
    suspend_thread(tid) -> int
    Suspend thread. Suspending a thread may deadlock the whole application if the
    suspended was owning some synchronization objects. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous function)}
    
    @param tid: (C++: thid_t) thread id
    @retval -1: network error
    @retval 0: failed
    @retval 1: ok

Help on function take_memory_snapshot in module ida_segment:

take_memory_snapshot(*args) -> 'bool'
    take_memory_snapshot(only_loader_segs) -> bool
    Take a memory snapshot of the running process.
    
    @param only_loader_segs: (C++: bool) only is_loader_segm() segments will be affected
    @return: success

Help on function to_ea in module idc:

to_ea(seg, off)
    Return value of expression: ((seg<<4) + off)

Help on function toggle_bnot in module idc:

toggle_bnot(ea, n)
    Toggle the bitwise not operator for the operand
    
    @param ea: linear address
    @param n: number of operand
        - 0 - the first operand
        - 1 - the second, third and all other operands
        - -1 - all operands

Help on function toggle_sign in module ida_bytes:

toggle_sign(*args) -> 'bool'
    toggle_sign(ea, n) -> bool
    Toggle sign of n-th operand. allowed values of n: 0-first operand, 1-other
    operands
    
    @param ea: (C++: ea_t)
    @param n: (C++: int)

Help on function update_extra_cmt in module ida_lines:

update_extra_cmt(*args) -> 'void'
    update_extra_cmt(ea, what, str)
    
    @param ea: ea_t
    @param what: int
    @param str: char const *

Help on function update_hidden_range in module idc:

update_hidden_range(ea, visible)
    Set hidden range state
    
    @param ea:      any address belonging to the hidden range
    @param visible: new state of the range
    
    @return: != 0 - ok

Help on function validate_idb_names in module idc:

validate_idb_names(do_repair=0)
    check consistency of IDB name records
    @param do_repair: try to repair netnode header it TRUE
    @return: number of inconsistent name records

Help on function value_is_float in module idc:

value_is_float(var)

Help on function value_is_func in module idc:

value_is_func(var)

Help on function value_is_int64 in module idc:

value_is_int64(var)

Help on function value_is_long in module idc:

value_is_long(var)

Help on function value_is_pvoid in module idc:

value_is_pvoid(var)

Help on function value_is_string in module idc:

value_is_string(var)
    #         List of built-in functions
    #         --------------------------
    #
    # The following conventions are used in this list:
    #   'ea' is a linear address
    #   'success' is 0 if a function failed, 1 otherwise
    #   'void' means that function returns no meaningful value (always 0)
    #
    #  All function parameter conversions are made automatically.
    #
    # ----------------------------------------------------------------------------
    #                       M I S C E L L A N E O U S
    # ----------------------------------------------------------------------------

Help on function wait_for_next_event in module ida_dbg:

wait_for_next_event(*args) -> 'dbg_event_code_t'
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
    Wait for the next event.
    
    This function (optionally) resumes the process execution, and waits for a
    debugger event until a possible timeout occurs.
    
    @param wfne: (C++: int) combination of Wait for debugger event flags constants
    @param timeout: (C++: int) number of seconds to wait, -1-infinity
    @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <= 0)

Help on function warning in module ida_kernwin:

warning(*args) -> 'void'
    warning(format)
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen

Help on function write_dbg_memory in module idc:

write_dbg_memory(ea, data)
    Write to debugger memory.
    
    @param ea: linear address
    @param data: string to write
    @return: number of written bytes (-1 - network/debugger error)
    
    Thread-safe function (may be called only from the main thread and debthread)

Help on function writelong in module idc:

writelong(handle, dword, mostfirst)

Help on function writeshort in module idc:

writeshort(handle, word, mostfirst)

Help on function writestr in module idc:

writestr(handle, s)

Help on function xtol in module idc:

xtol(s)


=== DOCUMENTATION FOR VARIABLES ===

Documentation on variable AU_NONE in module ida_auto:

    placeholder, not used

Documentation on variable AU_UNK in module ida_auto:

    0: convert to unexplored

Documentation on variable AU_CODE in module ida_auto:

    1: convert to instruction

Documentation on variable AU_WEAK in module ida_auto:

    2: convert to instruction (ida decision)

Documentation on variable AU_PROC in module ida_auto:

    3: convert to procedure start

Documentation on variable AU_TAIL in module ida_auto:

    4: add a procedure tail

Documentation on variable AU_FCHUNK in module ida_auto:

    5: find func chunks

Documentation on variable AU_USED in module ida_auto:

    6: reanalyze

Documentation on variable AU_TYPE in module ida_auto:

    7: apply type information

Documentation on variable AU_LIBF in module ida_auto:

    8: apply signature to address

Documentation on variable AU_LBF2 in module ida_auto:

    9: the same, second pass

Documentation on variable AU_LBF3 in module ida_auto:

    10: the same, third pass

Documentation on variable AU_CHLB in module ida_auto:

    11: load signature file (file name is kept separately)

Documentation on variable AU_FINAL in module ida_auto:

    12: final pass

Documentation on variable ITEM_END_FIXUP in module ida_bytes:

    stop at the first fixup

Documentation on variable ITEM_END_INITED in module ida_bytes:

    stop when initialization changes i.e.
    * if is_loaded(ea): stop if uninitialized byte is encountered
    * if !is_loaded(ea): stop if initialized byte is encountered

Documentation on variable ITEM_END_NAME in module ida_bytes:

    stop at the first named location

Documentation on variable ITEM_END_XREF in module ida_bytes:

    stop at the first referenced location

Documentation on variable GFE_VALUE in module ida_bytes:

    get flags with FF_IVL & MS_VAL. It is much slower under remote debugging because
    the kernel needs to read the process memory.

Documentation on variable GFE_IDB_VALUE in module ida_bytes:

    get flags with FF_IVL & MS_VAL. but never use the debugger memory.

Documentation on variable MS_VAL in module ida_bytes:

    Mask for byte value.

Documentation on variable FF_IVL in module ida_bytes:

    Byte has value ?

Documentation on variable GMB_READALL in module ida_bytes:

    try to read all bytes; if this bit is not set, fail at first uninited byte

Documentation on variable GMB_WAITBOX in module ida_bytes:

    show wait box (may return -1 in this case)

Documentation on variable MS_CLS in module ida_bytes:

    Mask for typing.

Documentation on variable FF_CODE in module ida_bytes:

    Code ?

Documentation on variable FF_DATA in module ida_bytes:

    Data ?

Documentation on variable FF_TAIL in module ida_bytes:

    Tail ?

Documentation on variable FF_UNK in module ida_bytes:

    Unknown ?

Documentation on variable DELIT_SIMPLE in module ida_bytes:

    simply undefine the specified item(s)

Documentation on variable DELIT_EXPAND in module ida_bytes:

    propagate undefined items; for example if removing an instruction removes all
    references to the next instruction, then plan to convert to unexplored the next
    instruction too.

Documentation on variable DELIT_DELNAMES in module ida_bytes:

    delete any names at the specified address range (except for the starting
    address). this bit is valid if nbytes > 1

Documentation on variable DELIT_NOTRUNC in module ida_bytes:

    don't truncate the current function even if AF_TRFUNC is set

Documentation on variable DELIT_NOUNAME in module ida_bytes:

    reject to delete if a user name is in address range (except for the starting
    address). this bit is valid if nbytes > 1

Documentation on variable DELIT_NOCMT in module ida_bytes:

    reject to delete if a comment is in address range (except for the starting
    address). this bit is valid if nbytes > 1

Documentation on variable DELIT_KEEPFUNC in module ida_bytes:

    do not undefine the function start. Just delete xrefs, ops e.t.c.

Documentation on variable MS_COMM in module ida_bytes:

    Mask of common bits.

Documentation on variable FF_COMM in module ida_bytes:

    Has comment ?

Documentation on variable FF_REF in module ida_bytes:

    has references

Documentation on variable FF_LINE in module ida_bytes:

    Has next or prev lines ?

Documentation on variable FF_NAME in module ida_bytes:

    Has name ?

Documentation on variable FF_LABL in module ida_bytes:

    Has dummy name?

Documentation on variable FF_FLOW in module ida_bytes:

    Exec flow from prev instruction.

Documentation on variable FF_SIGN in module ida_bytes:

    Inverted sign of operands.

Documentation on variable FF_BNOT in module ida_bytes:

    Bitwise negation of operands.

Documentation on variable FF_UNUSED in module ida_bytes:

    unused bit (was used for variable bytes)

Documentation on variable MS_0TYPE in module ida_bytes:

    Mask for 1st arg typing.

Documentation on variable FF_0VOID in module ida_bytes:

    Void (unknown)?

Documentation on variable FF_0NUMH in module ida_bytes:

    Hexadecimal number?

Documentation on variable FF_0NUMD in module ida_bytes:

    Decimal number?

Documentation on variable FF_0CHAR in module ida_bytes:

    Char ('x')?

Documentation on variable FF_0SEG in module ida_bytes:

    Segment?

Documentation on variable FF_0OFF in module ida_bytes:

    Offset?

Documentation on variable FF_0NUMB in module ida_bytes:

    Binary number?

Documentation on variable FF_0NUMO in module ida_bytes:

    Octal number?

Documentation on variable FF_0ENUM in module ida_bytes:

    Enumeration?

Documentation on variable FF_0FOP in module ida_bytes:

    Forced operand?

Documentation on variable FF_0STRO in module ida_bytes:

    Struct offset?

Documentation on variable FF_0STK in module ida_bytes:

    Stack variable?

Documentation on variable FF_0FLT in module ida_bytes:

    Floating point number?

Documentation on variable FF_0CUST in module ida_bytes:

    Custom representation?

Documentation on variable MS_1TYPE in module ida_bytes:

    Mask for the type of other operands.

Documentation on variable FF_1VOID in module ida_bytes:

    Void (unknown)?

Documentation on variable FF_1NUMH in module ida_bytes:

    Hexadecimal number?

Documentation on variable FF_1NUMD in module ida_bytes:

    Decimal number?

Documentation on variable FF_1CHAR in module ida_bytes:

    Char ('x')?

Documentation on variable FF_1SEG in module ida_bytes:

    Segment?

Documentation on variable FF_1OFF in module ida_bytes:

    Offset?

Documentation on variable FF_1NUMB in module ida_bytes:

    Binary number?

Documentation on variable FF_1NUMO in module ida_bytes:

    Octal number?

Documentation on variable FF_1ENUM in module ida_bytes:

    Enumeration?

Documentation on variable FF_1FOP in module ida_bytes:

    Forced operand?

Documentation on variable FF_1STRO in module ida_bytes:

    Struct offset?

Documentation on variable FF_1STK in module ida_bytes:

    Stack variable?

Documentation on variable FF_1FLT in module ida_bytes:

    Floating point number?

Documentation on variable FF_1CUST in module ida_bytes:

    Custom representation?

Documentation on variable OPND_OUTER in module ida_bytes:

    outer offset base (combined with operand number). used only in set, get,
    del_offset() functions

Documentation on variable OPND_MASK in module ida_bytes:

    mask for operand number

Documentation on variable OPND_ALL in module ida_bytes:

    all operands

Documentation on variable DT_TYPE in module ida_bytes:

    Mask for DATA typing.

Documentation on variable FF_BYTE in module ida_bytes:

    byte

Documentation on variable FF_WORD in module ida_bytes:

    word

Documentation on variable FF_DWORD in module ida_bytes:

    double word

Documentation on variable FF_QWORD in module ida_bytes:

    quadro word

Documentation on variable FF_TBYTE in module ida_bytes:

    tbyte

Documentation on variable FF_STRLIT in module ida_bytes:

    string literal

Documentation on variable FF_STRUCT in module ida_bytes:

    struct variable

Documentation on variable FF_OWORD in module ida_bytes:

    octaword/xmm word (16 bytes/128 bits)

Documentation on variable FF_FLOAT in module ida_bytes:

    float

Documentation on variable FF_DOUBLE in module ida_bytes:

    double

Documentation on variable FF_PACKREAL in module ida_bytes:

    packed decimal real

Documentation on variable FF_ALIGN in module ida_bytes:

    alignment directive

Documentation on variable FF_CUSTOM in module ida_bytes:

    custom data type

Documentation on variable FF_YWORD in module ida_bytes:

    ymm word (32 bytes/256 bits)

Documentation on variable FF_ZWORD in module ida_bytes:

    zmm word (64 bytes/512 bits)

Documentation on variable ALOPT_IGNHEADS in module ida_bytes:

    don't stop if another data item is encountered. only the byte values will be
    used to determine the string length. if not set, a defined data item or
    instruction will truncate the string

Documentation on variable ALOPT_IGNPRINT in module ida_bytes:

    if set, don't stop at non-printable codepoints, but only at the terminating
    character (or not unicode-mapped character (e.g., 0x8f in CP1252))

Documentation on variable ALOPT_IGNCLT in module ida_bytes:

    if set, don't stop at codepoints that are not part of the current 'culture';
    accept all those that are graphical (this is typically used used by user-
    initiated actions creating string literals.)

Documentation on variable ALOPT_MAX4K in module ida_bytes:

    if string length is more than 4K, return the accumulated length

Documentation on variable ALOPT_ONLYTERM in module ida_bytes:

    only the termination characters can be at the string end. Without this option
    illegal characters also terminate the string.

Documentation on variable STRCONV_ESCAPE in module ida_bytes:

    convert non-printable characters to C escapes (
    , \xNN, \uNNNN)

Documentation on variable STRCONV_REPLCHAR in module ida_bytes:

    convert non-printable characters to the Unicode replacement character (U+FFFD)

Documentation on variable STRCONV_INCLLEN in module ida_bytes:

    for Pascal-style strings, include the prefixing length byte(s) as C-escaped
    sequence

Documentation on variable PSTF_TNORM in module ida_bytes:

    use normal name

Documentation on variable PSTF_TBRIEF in module ida_bytes:

    use brief name (e.g., in the 'Strings' window)

Documentation on variable PSTF_TINLIN in module ida_bytes:

    use 'inline' name (e.g., in the structures comments)

Documentation on variable PSTF_TMASK in module ida_bytes:

    type mask

Documentation on variable PSTF_HOTKEY in module ida_bytes:

    have hotkey markers part of the name

Documentation on variable PSTF_ENC in module ida_bytes:

    if encoding is specified, append it

Documentation on variable PSTF_ONLY_ENC in module ida_bytes:

    generate only the encoding name

Documentation on variable MS_CODE in module ida_bytes:

    Mask for code bits.

Documentation on variable FF_FUNC in module ida_bytes:

    function start?

Documentation on variable FF_IMMD in module ida_bytes:

    Has Immediate value ?

Documentation on variable FF_JUMP in module ida_bytes:

    Has jump table or switch_info?

Documentation on variable data_type_t.props in module ida_bytes:

    properties

Documentation on variable data_type_t.name in module ida_bytes:

    name of the data type. must be unique

Documentation on variable data_type_t.menu_name in module ida_bytes:

    Visible data type name to use in menus if nullptr, no menu item will be created

Documentation on variable data_type_t.hotkey in module ida_bytes:

    Hotkey for the corresponding menu item if nullptr, no hotkey will be associated
    with the menu item

Documentation on variable data_type_t.asm_keyword in module ida_bytes:

    keyword to use for this type in the assembly if nullptr, the data type cannot be
    used in the listing it can still be used in cpuregs window

Documentation on variable data_type_t.value_size in module ida_bytes:

    size of the value in bytes

Documentation on variable DTP_NODUP in module ida_bytes:

    do not use dup construct

Documentation on variable data_format_t.props in module ida_bytes:

    properties (currently 0)

Documentation on variable data_format_t.name in module ida_bytes:

    Format name, must be unique.

Documentation on variable data_format_t.menu_name in module ida_bytes:

    Visible format name to use in menus if nullptr, no menu item will be created

Documentation on variable data_format_t.hotkey in module ida_bytes:

    Hotkey for the corresponding menu item if nullptr, no hotkey will be associated
    with the menu item

Documentation on variable data_format_t.value_size in module ida_bytes:

    size of the value in bytes 0 means any size is ok data formats that are
    registered for standard types (dtid 0) may be called with any value_size
    (instruction operands only)

Documentation on variable data_format_t.text_width in module ida_bytes:

    Usual width of the text representation This value is used to calculate the width
    of the control to display values of this type

Documentation on variable BIN_SEARCH_CASE in module ida_bytes:

    case sensitive

Documentation on variable BIN_SEARCH_NOCASE in module ida_bytes:

    case insensitive

Documentation on variable BIN_SEARCH_NOBREAK in module ida_bytes:

    don't check for Ctrl-Break

Documentation on variable BIN_SEARCH_INITED in module ida_bytes:

    find_byte, find_byter: any initilized value

Documentation on variable BIN_SEARCH_NOSHOW in module ida_bytes:

    don't show search progress or update screen

Documentation on variable BIN_SEARCH_FORWARD in module ida_bytes:

    search forward for bytes

Documentation on variable BIN_SEARCH_BACKWARD in module ida_bytes:

    search backward for bytes

Documentation on variable BIN_SEARCH_BITMASK in module ida_bytes:

    searching using strict bit mask

Documentation on variable hidden_range_t.description in module ida_bytes:

    description to display if the range is collapsed

Documentation on variable hidden_range_t.header in module ida_bytes:

    header lines to display if the range is expanded

Documentation on variable hidden_range_t.footer in module ida_bytes:

    footer lines to display if the range is expanded

Documentation on variable hidden_range_t.visible in module ida_bytes:

    the range state

Documentation on variable hidden_range_t.color in module ida_bytes:

    range color

Documentation on variable dbg_process_start in module ida_dbg:

    @note: This event notification is also an asynchronous function result
           notification for start_process() !

Documentation on variable dbg_process_exit in module ida_dbg:

    @note: This event notification is also an asynchronous function result
           notification for start_process() !

Documentation on variable dbg_process_attach in module ida_dbg:

    @note: This event notification is also an asynchronous function result
           notification for start_process() !

Documentation on variable dbg_process_detach in module ida_dbg:

    @note: This event notification is also an asynchronous function result
           notification for start_process() !

Documentation on variable dbg_suspend_process in module ida_dbg:

    The process is now suspended.
    
    @note: This event notification is also an asynchronous function result
           notification for suspend_process() !

Documentation on variable dbg_bpt in module ida_dbg:

    A user defined breakpoint was reached.

Documentation on variable dbg_trace in module ida_dbg:

    A step occurred (one instruction was executed). This event notification is only
    generated if step tracing is enabled.
    
    @retval 1: do not log this trace event
    @retval 0: log it

Documentation on variable dbg_request_error in module ida_dbg:

    An error occurred during the processing of a request.

Documentation on variable dbg_bpt_changed in module ida_dbg:

    Breakpoint has been changed.

Documentation on variable dbg_started_loading_bpts in module ida_dbg:

    Started loading breakpoint info from idb.

Documentation on variable dbg_finished_loading_bpts in module ida_dbg:

    Finished loading breakpoint info from idb.

Documentation on variable dbg_last in module ida_dbg:

    The last debugger notification code.

Documentation on variable BPTEV_ADDED in module ida_dbg:

    Breakpoint has been added.

Documentation on variable BPTEV_REMOVED in module ida_dbg:

    Breakpoint has been removed.

Documentation on variable BPTEV_CHANGED in module ida_dbg:

    Breakpoint has been modified.

Documentation on variable DSTATE_SUSP in module ida_dbg:

    process is suspended and will not continue

Documentation on variable DSTATE_NOTASK in module ida_dbg:

    no process is currently debugged

Documentation on variable DSTATE_RUN in module ida_dbg:

    process is running

Documentation on variable DBGINV_MEMORY in module ida_dbg:

    invalidate cached memory contents

Documentation on variable DBGINV_MEMCFG in module ida_dbg:

    invalidate cached process segmentation

Documentation on variable DBGINV_REGS in module ida_dbg:

    invalidate cached register values

Documentation on variable DBGINV_ALL in module ida_dbg:

    invalidate everything

Documentation on variable DBGINV_REDRAW in module ida_dbg:

    refresh the screen

Documentation on variable DBGINV_NONE in module ida_dbg:

    invalidate nothing

Documentation on variable BPLT_ABS in module ida_dbg:

    absolute address: ea

Documentation on variable BPLT_REL in module ida_dbg:

    relative address: module_path, offset

Documentation on variable BPLT_SRC in module ida_dbg:

    source level: filename, lineno

Documentation on variable bpt_t.cb in module ida_dbg:

    size of this structure

Documentation on variable bpt_t.loc in module ida_dbg:

    Location.

Documentation on variable bpt_t.pid in module ida_dbg:

    breakpoint process id

Documentation on variable bpt_t.tid in module ida_dbg:

    breakpoint thread id

Documentation on variable bpt_t.ea in module ida_dbg:

    Address, if known. For BPLT_SRC, index into an internal data struct.

Documentation on variable bpt_t.type in module ida_dbg:

    Breakpoint type.

Documentation on variable bpt_t.pass_count in module ida_dbg:

    Number of times the breakpoint is hit before stopping (default is 0: stop
    always)

Documentation on variable bpt_t.flags in module ida_dbg:

    Breakpoint property bits

Documentation on variable bpt_t.props in module ida_dbg:

    Internal breakpoint properties

Documentation on variable bpt_t.size in module ida_dbg:

    Size of the breakpoint (0 for software breakpoints)

Documentation on variable bpt_t.cndidx in module ida_dbg:

    Internal number of the condition (<0-none)

Documentation on variable bpt_t.bptid in module ida_dbg:

    Internal breakpoint id.

Documentation on variable BPT_BRK in module ida_dbg:

    suspend execution upon hit

Documentation on variable BPT_TRACE in module ida_dbg:

    add trace information upon hit

Documentation on variable BPT_UPDMEM in module ida_dbg:

    refresh the memory layout and contents before evaluating bpt condition

Documentation on variable BPT_ENABLED in module ida_dbg:

    enabled?

Documentation on variable BPT_LOWCND in module ida_dbg:

    condition is calculated at low level (on the server side)

Documentation on variable BPT_TRACEON in module ida_dbg:

    enable tracing when the breakpoint is reached

Documentation on variable BPT_TRACE_INSN in module ida_dbg:

    instruction tracing

Documentation on variable BPT_TRACE_FUNC in module ida_dbg:

    function tracing

Documentation on variable BPT_TRACE_BBLK in module ida_dbg:

    basic block tracing

Documentation on variable BPT_TRACE_TYPES in module ida_dbg:

    trace insns, functions, and basic blocks. if any of BPT_TRACE_TYPES bits are set
    but BPT_TRACEON is clear, then turn off tracing for the specified trace types

Documentation on variable BPT_ELANG_SHIFT in module ida_dbg:

    index of the extlang (scripting language) of the condition

Documentation on variable BKPT_BADBPT in module ida_dbg:

    failed to write the bpt to the process memory (at least one location)

Documentation on variable BKPT_LISTBPT in module ida_dbg:

    include in bpt list (user-defined bpt)

Documentation on variable BKPT_TRACE in module ida_dbg:

    trace bpt; should not be deleted when the process gets suspended

Documentation on variable BKPT_ACTIVE in module ida_dbg:

    active?

Documentation on variable BKPT_PARTIAL in module ida_dbg:

    partially active? (some locations were not written yet)

Documentation on variable BKPT_CNDREADY in module ida_dbg:

    condition has been compiled

Documentation on variable BKPT_FAKEPEND in module ida_dbg:

    fake pending bpt: it is inactive but another bpt of the same type is active at
    the same address(es)

Documentation on variable BKPT_PAGE in module ida_dbg:

    written to the process as a page bpt. Available only after writing the bpt to
    the process.

Documentation on variable BPTCK_NONE in module ida_dbg:

    breakpoint does not exist

Documentation on variable BPTCK_NO in module ida_dbg:

    breakpoint is disabled

Documentation on variable BPTCK_YES in module ida_dbg:

    breakpoint is enabled

Documentation on variable BPTCK_ACT in module ida_dbg:

    breakpoint is active (written to the process)

Documentation on variable ST_OVER_DEBUG_SEG in module ida_dbg:

    step tracing will be disabled when IP is in a debugger segment

Documentation on variable ST_OVER_LIB_FUNC in module ida_dbg:

    step tracing will be disabled when IP is in a library function

Documentation on variable ST_ALREADY_LOGGED in module ida_dbg:

    step tracing will be disabled when IP is already logged

Documentation on variable ST_SKIP_LOOPS in module ida_dbg:

    step tracing will try to skip loops already recorded

Documentation on variable ST_OPTIONS_MASK in module ida_dbg:

    mask of available options, to ensure compatibility with newer IDA versions

Documentation on variable IT_LOG_SAME_IP in module ida_dbg:

    specific options for instruction tracing (see set_insn_trace_options())
    
    instruction tracing will log new instructions even when IP doesn't change

Documentation on variable FT_LOG_RET in module ida_dbg:

    specific options for function tracing (see set_func_trace_options())
    
    function tracing will log returning instructions

Documentation on variable BT_LOG_INSTS in module ida_dbg:

    specific options for basic block tracing (see set_bblk_trace_options())
    
    log all instructions in the current basic block

Documentation on variable tev_none in module ida_dbg:

    no event

Documentation on variable tev_insn in module ida_dbg:

    an instruction trace

Documentation on variable tev_call in module ida_dbg:

    a function call trace

Documentation on variable tev_ret in module ida_dbg:

    a function return trace

Documentation on variable tev_bpt in module ida_dbg:

    write, read/write, execution trace

Documentation on variable tev_mem in module ida_dbg:

    memory layout changed

Documentation on variable tev_event in module ida_dbg:

    debug event occurred

Documentation on variable tev_max in module ida_dbg:

    first unused event type

Documentation on variable tev_info_t.type in module ida_dbg:

    trace event type

Documentation on variable tev_info_t.tid in module ida_dbg:

    thread where the event was recorded

Documentation on variable tev_info_t.ea in module ida_dbg:

    address where the event occurred

Documentation on variable DEC_NOTASK in module ida_dbg:

    process does not exist

Documentation on variable DEC_ERROR in module ida_dbg:

    error

Documentation on variable DEC_TIMEOUT in module ida_dbg:

    timeout

Documentation on variable WFNE_ANY in module ida_dbg:

    return the first event (even if it doesn't suspend the process)

Documentation on variable WFNE_SUSP in module ida_dbg:

    wait until the process gets suspended

Documentation on variable WFNE_SILENT in module ida_dbg:

    1: be silent, 0:display modal boxes if necessary

Documentation on variable WFNE_CONT in module ida_dbg:

    continue from the suspended state

Documentation on variable WFNE_NOWAIT in module ida_dbg:

    do not wait for any event, immediately return DEC_TIMEOUT (to be used with
    WFNE_CONT)

Documentation on variable WFNE_USEC in module ida_dbg:

    timeout is specified in microseconds (minimum non-zero timeout is 40000us)

Documentation on variable DOPT_SEGM_MSGS in module ida_dbg:

    log debugger segments modifications

Documentation on variable DOPT_START_BPT in module ida_dbg:

    break on process start

Documentation on variable DOPT_THREAD_MSGS in module ida_dbg:

    log thread starts/exits

Documentation on variable DOPT_THREAD_BPT in module ida_dbg:

    break on thread start/exit

Documentation on variable DOPT_BPT_MSGS in module ida_dbg:

    log breakpoints

Documentation on variable DOPT_LIB_MSGS in module ida_dbg:

    log library loads/unloads

Documentation on variable DOPT_LIB_BPT in module ida_dbg:

    break on library load/unload

Documentation on variable DOPT_INFO_MSGS in module ida_dbg:

    log debugging info events

Documentation on variable DOPT_INFO_BPT in module ida_dbg:

    break on debugging information

Documentation on variable DOPT_REAL_MEMORY in module ida_dbg:

    do not hide breakpoint instructions

Documentation on variable DOPT_REDO_STACK in module ida_dbg:

    reconstruct the stack

Documentation on variable DOPT_ENTRY_BPT in module ida_dbg:

    break on program entry point

Documentation on variable DOPT_EXCDLG in module ida_dbg:

    exception dialogs:

Documentation on variable EXCDLG_NEVER in module ida_dbg:

    never display exception dialogs

Documentation on variable EXCDLG_UNKNOWN in module ida_dbg:

    display for unknown exceptions

Documentation on variable EXCDLG_ALWAYS in module ida_dbg:

    always display

Documentation on variable DOPT_LOAD_DINFO in module ida_dbg:

    automatically load debug files (pdb)

Documentation on variable DOPT_END_BPT in module ida_dbg:

    evaluate event condition on process end

Documentation on variable DOPT_TEMP_HWBPT in module ida_dbg:

    when possible use hardware bpts for temp bpts

Documentation on variable DOPT_FAST_STEP in module ida_dbg:

    prevent debugger memory refreshes when single-stepping

Documentation on variable SRCIT_NONE in module ida_dbg:

    unknown

Documentation on variable SRCIT_MODULE in module ida_dbg:

    module

Documentation on variable SRCIT_FUNC in module ida_dbg:

    function

Documentation on variable SRCIT_STMT in module ida_dbg:

    a statement (if/while/for...)

Documentation on variable SRCIT_EXPR in module ida_dbg:

    an expression (a+b*c)

Documentation on variable SRCIT_STTVAR in module ida_dbg:

    static variable/code

Documentation on variable SRCIT_LOCVAR in module ida_dbg:

    a stack, register, or register-relative local variable or parameter

Documentation on variable direntry_t.idx in module ida_dirtree:

    diridx_t or inode_t

Documentation on variable direntry_t.isdir in module ida_dirtree:

    is 'idx' a diridx_t, or an inode_t

Documentation on variable DTN_FULL_NAME in module ida_dirtree:

    use long form of the entry name. That name is unique.

Documentation on variable DTN_DISPLAY_NAME in module ida_dirtree:

    use short, displayable form of the entry name. for example, 'std::string'
    instead of 'std::basic_string<char, ...>'. Note that more than one "full name"
    can have the same displayable name.

Documentation on variable dirtree_cursor_t.parent in module ida_dirtree:

    the parent directory

Documentation on variable dirtree_cursor_t.rank in module ida_dirtree:

    the index into the parent directory

Documentation on variable IDA_SUBDIR_IDP in module ida_diskio:

    append the processor name as a subdirectory

Documentation on variable IDA_SUBDIR_IDADIR_FIRST in module ida_diskio:

    $IDADIR/subdir will be first, not last

Documentation on variable IDA_SUBDIR_ONLY_EXISTING in module ida_diskio:

    only existing directories will be present

Documentation on variable LINPUT_NONE in module ida_diskio:

    invalid linput

Documentation on variable LINPUT_LOCAL in module ida_diskio:

    local file

Documentation on variable LINPUT_RFILE in module ida_diskio:

    remote file ( debugger_t::open_file, debugger_t::read_file)

Documentation on variable LINPUT_PROCMEM in module ida_diskio:

    debugged process memory (read_dbg_memory())

Documentation on variable LINPUT_GENERIC in module ida_diskio:

    generic linput

Documentation on variable generic_linput_t.filesize in module ida_diskio:

    input file size

Documentation on variable generic_linput_t.blocksize in module ida_diskio:

    preferred block size to work with read/write sizes will be in multiples of this
    number. for example, 4096 is a nice value blocksize 0 means that the filesize is
    unknown. the internal cache will be disabled in this case. also, seeks from the
    file end will fail. blocksize=-1 means error.

Documentation on variable AEF_UTF8 in module ida_entry:

    the name is given in UTF-8 (default)

Documentation on variable AEF_IDBENC in module ida_entry:

    the name is given in the IDB encoding; non-ASCII bytes will be decoded
    accordingly. Specifying AEF_IDBENC also implies AEF_NODUMMY

Documentation on variable AEF_NODUMMY in module ida_entry:

    automatically prepend the name with '_' if it begins with a dummy suffix. See
    also AEF_IDBENC

Documentation on variable DEFMASK in module ida_enum:

    default bitmask

Documentation on variable ENFL_REGEX in module ida_enum:

    apply regular expressions to beautify the name

Documentation on variable MAX_ENUM_SERIAL in module ida_enum:

    Max number of identical constants allowed for one enum type.

Documentation on variable ENUM_MEMBER_ERROR_NAME in module ida_enum:

    already have member with this name (bad name)

Documentation on variable ENUM_MEMBER_ERROR_VALUE in module ida_enum:

    already have 256 members with this value

Documentation on variable ENUM_MEMBER_ERROR_ENUM in module ida_enum:

    bad enum id

Documentation on variable ENUM_MEMBER_ERROR_MASK in module ida_enum:

    bad bmask

Documentation on variable ENUM_MEMBER_ERROR_ILLV in module ida_enum:

    bad bmask and value combination (~bmask & value != 0)

Documentation on variable IDC_LANG_EXT in module ida_expr:

    IDC script extension.

Documentation on variable VARSLICE_SINGLE in module ida_expr:

    return single index (i2 is ignored)

Documentation on variable VREF_LOOP in module ida_expr:

    dereference until we get a non VT_REF

Documentation on variable VREF_ONCE in module ida_expr:

    dereference only once, do not loop

Documentation on variable VREF_COPY in module ida_expr:

    copy the result to the input var (v)

Documentation on variable idc_value_t.vtype in module ida_expr:

    IDC value types

Documentation on variable idc_value_t.num in module ida_expr:

    VT_LONG

Documentation on variable idc_value_t.e in module ida_expr:

    VT_FLOAT

Documentation on variable idc_value_t.funcidx in module ida_expr:

    VT_FUNC

Documentation on variable idc_value_t.pvoid in module ida_expr:

    VT_PVOID

Documentation on variable idc_value_t.i64 in module ida_expr:

    VT_INT64

Documentation on variable idc_value_t.reserve in module ida_expr:

    internal housekeeping: 64-bit qstring is bigger than 12 bytes

Documentation on variable VT_LONG in module ida_expr:

    Integer (see idc_value_t::num)

Documentation on variable VT_FLOAT in module ida_expr:

    Floating point (see idc_value_t::e)

Documentation on variable VT_WILD in module ida_expr:

    Function with arbitrary number of arguments. The actual number of arguments will
    be passed in idc_value_t::num. This value should not be used for idc_value_t.

Documentation on variable VT_OBJ in module ida_expr:

    Object (see idc_value_t::obj)

Documentation on variable VT_FUNC in module ida_expr:

    Function (see idc_value_t::funcidx)

Documentation on variable VT_STR in module ida_expr:

    String (see qstr() and similar functions)

Documentation on variable VT_PVOID in module ida_expr:

    void *

Documentation on variable VT_INT64 in module ida_expr:

    i64

Documentation on variable VT_REF in module ida_expr:

    Reference.

Documentation on variable eExecThrow in module ida_expr:

    See return value of idc_func_t.

Documentation on variable CPL_DEL_MACROS in module ida_expr:

    delete macros at the end of compilation

Documentation on variable CPL_USE_LABELS in module ida_expr:

    allow program labels in the script

Documentation on variable CPL_ONLY_SAFE in module ida_expr:

    allow calls of only thread-safe functions

Documentation on variable EXTFUN_BASE in module ida_expr:

    requires open database.

Documentation on variable EXTFUN_NORET in module ida_expr:

    does not return. the interpreter may clean up its state before calling it.

Documentation on variable EXTFUN_SAFE in module ida_expr:

    thread safe function. may be called from any thread.

Documentation on variable FIXUP_OFF8 in module ida_fixup:

    8-bit offset

Documentation on variable FIXUP_OFF16 in module ida_fixup:

    16-bit offset

Documentation on variable FIXUP_SEG16 in module ida_fixup:

    16-bit base-logical segment base (selector)

Documentation on variable FIXUP_PTR16 in module ida_fixup:

    32-bit long pointer (16-bit base:16-bit offset)

Documentation on variable FIXUP_OFF32 in module ida_fixup:

    32-bit offset

Documentation on variable FIXUP_PTR32 in module ida_fixup:

    48-bit pointer (16-bit base:32-bit offset)

Documentation on variable FIXUP_HI8 in module ida_fixup:

    high 8 bits of 16bit offset

Documentation on variable FIXUP_HI16 in module ida_fixup:

    high 16 bits of 32bit offset

Documentation on variable FIXUP_LOW8 in module ida_fixup:

    low 8 bits of 16bit offset

Documentation on variable FIXUP_LOW16 in module ida_fixup:

    low 16 bits of 32bit offset

Documentation on variable V695_FIXUP_VHIGH in module ida_fixup:

    obsolete

Documentation on variable V695_FIXUP_VLOW in module ida_fixup:

    obsolete

Documentation on variable FIXUP_OFF64 in module ida_fixup:

    64-bit offset

Documentation on variable FIXUP_OFF8S in module ida_fixup:

    8-bit signed offset

Documentation on variable FIXUP_OFF16S in module ida_fixup:

    16-bit signed offset

Documentation on variable FIXUP_OFF32S in module ida_fixup:

    32-bit signed offset

Documentation on variable FIXUP_CUSTOM in module ida_fixup:

    start of the custom types range

Documentation on variable FIXUPF_REL in module ida_fixup:

    fixup is relative to the linear address `base'. Otherwise fixup is relative to
    the start of the segment with `sel' selector.

Documentation on variable FIXUPF_EXTDEF in module ida_fixup:

    target is a location (otherwise - segment). Use this bit if the target is a
    symbol rather than an offset from the beginning of a segment.

Documentation on variable FIXUPF_UNUSED in module ida_fixup:

    fixup is ignored by IDA
    * disallows the kernel to convert operands
    * this fixup is not used during output

Documentation on variable FIXUPF_CREATED in module ida_fixup:

    fixup was not present in the input file

Documentation on variable FIXUPF_LOADER_MASK in module ida_fixup:

    additional flags. The bits from this mask are not stored in the database and can
    be used by the loader at its discretion.

Documentation on variable fixup_data_t.sel in module ida_fixup:

    selector of the target segment. BADSEL means an absolute (zero based) target.
    @see: FIXUPF_REL

Documentation on variable fixup_data_t.off in module ida_fixup:

    target offset
    @note: The target is calculated as `get_base() + off`.

Documentation on variable fixup_data_t.displacement in module ida_fixup:

    displacement (offset from the target)

Documentation on variable STKVAR_VALID_SIZE in module ida_frame:

    x.dtyp contains correct variable type (for insns like 'lea' this bit must be
    off). In general, dr_O references do not allow to determine the variable size

Documentation on variable regvar_t.canon in module ida_frame:

    canonical register name (case-insensitive)

Documentation on variable regvar_t.user in module ida_frame:

    user-defined register name

Documentation on variable regvar_t.cmt in module ida_frame:

    comment to appear near definition

Documentation on variable REGVAR_ERROR_OK in module ida_frame:

    all ok

Documentation on variable REGVAR_ERROR_ARG in module ida_frame:

    function arguments are bad

Documentation on variable REGVAR_ERROR_RANGE in module ida_frame:

    the definition range is bad

Documentation on variable REGVAR_ERROR_NAME in module ida_frame:

    the provided name(s) can't be accepted

Documentation on variable xreflist_entry_t.ea in module ida_frame:

    Location of the insn referencing the stack frame member.

Documentation on variable xreflist_entry_t.opnum in module ida_frame:

    Number of the operand of that instruction.

Documentation on variable xreflist_entry_t.type in module ida_frame:

    The type of xref (cref_t & dref_t)

Documentation on variable func_t.flags in module ida_funcs:

    Function flags

Documentation on variable func_t.frame in module ida_funcs:

    netnode id of frame structure - see frame.hpp

Documentation on variable func_t.frsize in module ida_funcs:

    size of local variables part of frame in bytes. If FUNC_FRAME is set and fpd==0,
    the frame pointer (EBP) is assumed to point to the top of the local variables
    range.

Documentation on variable func_t.frregs in module ida_funcs:

    size of saved registers in frame. This range is immediately above the local
    variables range.

Documentation on variable func_t.argsize in module ida_funcs:

    number of bytes purged from the stack upon returning

Documentation on variable func_t.fpd in module ida_funcs:

    frame pointer delta. (usually 0, i.e. realBP==typicalBP) use update_fpd() to
    modify it.

Documentation on variable func_t.color in module ida_funcs:

    user defined function color

Documentation on variable func_t.pntqty in module ida_funcs:

    number of SP change points

Documentation on variable func_t.points in module ida_funcs:

    array of SP change points. use ...stkpnt...() functions to access this array.

Documentation on variable func_t.regvarqty in module ida_funcs:

    number of register variables (-1-not read in yet) use find_regvar() to read
    register variables

Documentation on variable func_t.regvars in module ida_funcs:

    array of register variables. this array is sorted by: start_ea. use
    ...regvar...() functions to access this array.

Documentation on variable func_t.regargqty in module ida_funcs:

    number of register arguments. During analysis IDA tries to guess the register
    arguments. It stores store the guessing outcome in this field. As soon as it
    determines the final function prototype, regargqty is set to zero.

Documentation on variable func_t.regargs in module ida_funcs:

    unsorted array of register arguments. use ...regarg...() functions to access
    this array. regargs are destroyed when the full function type is determined.

Documentation on variable func_t.tailqty in module ida_funcs:

    number of function tails

Documentation on variable func_t.tails in module ida_funcs:

    array of tails, sorted by ea. use func_tail_iterator_t to access function tails.

Documentation on variable func_t.owner in module ida_funcs:

    the address of the main function possessing this tail

Documentation on variable func_t.refqty in module ida_funcs:

    number of referers

Documentation on variable func_t.referers in module ida_funcs:

    array of referers (function start addresses). use func_parent_iterator_t to
    access the referers.

Documentation on variable FUNC_NORET in module ida_funcs:

    Function doesn't return.

Documentation on variable FUNC_FAR in module ida_funcs:

    Far function.

Documentation on variable FUNC_LIB in module ida_funcs:

    Library function.

Documentation on variable FUNC_STATICDEF in module ida_funcs:

    Static function.

Documentation on variable FUNC_FRAME in module ida_funcs:

    Function uses frame pointer (BP)

Documentation on variable FUNC_USERFAR in module ida_funcs:

    User has specified far-ness of the function

Documentation on variable FUNC_HIDDEN in module ida_funcs:

    A hidden function chunk.

Documentation on variable FUNC_THUNK in module ida_funcs:

    Thunk (jump) function.

Documentation on variable FUNC_BOTTOMBP in module ida_funcs:

    BP points to the bottom of the stack frame.

Documentation on variable FUNC_NORET_PENDING in module ida_funcs:

    Function 'non-return' analysis must be performed. This flag is verified upon
    func_does_return()

Documentation on variable FUNC_SP_READY in module ida_funcs:

    SP-analysis has been performed. If this flag is on, the stack change points
    should not be not modified anymore. Currently this analysis is performed only
    for PC

Documentation on variable FUNC_FUZZY_SP in module ida_funcs:

    Function changes SP in untraceable way, for example: and esp, 0FFFFFFF0h

Documentation on variable FUNC_PROLOG_OK in module ida_funcs:

    Prolog analysis has been performed by last SP-analysis

Documentation on variable FUNC_PURGED_OK in module ida_funcs:

    'argsize' field has been validated. If this bit is clear and 'argsize' is 0,
    then we do not known the real number of bytes removed from the stack. This bit
    is handled by the processor module.

Documentation on variable FUNC_TAIL in module ida_funcs:

    This is a function tail. Other bits must be clear (except FUNC_HIDDEN).

Documentation on variable FUNC_LUMINA in module ida_funcs:

    Function info is provided by Lumina.

Documentation on variable FUNC_OUTLINE in module ida_funcs:

    Outlined code, not a real function.

Documentation on variable MOVE_FUNC_OK in module ida_funcs:

    ok

Documentation on variable MOVE_FUNC_NOCODE in module ida_funcs:

    no instruction at 'newstart'

Documentation on variable MOVE_FUNC_BADSTART in module ida_funcs:

    bad new start address

Documentation on variable MOVE_FUNC_NOFUNC in module ida_funcs:

    no function at 'ea'

Documentation on variable MOVE_FUNC_REFUSED in module ida_funcs:

    a plugin refused the action

Documentation on variable FIND_FUNC_NORMAL in module ida_funcs:

    stop processing if undefined byte is encountered

Documentation on variable FIND_FUNC_DEFINE in module ida_funcs:

    create instruction if undefined byte is encountered

Documentation on variable FIND_FUNC_IGNOREFN in module ida_funcs:

    ignore existing function boundaries. by default the function returns function
    boundaries if ea belongs to a function.

Documentation on variable FIND_FUNC_KEEPBD in module ida_funcs:

    do not modify incoming function boundaries, just create instructions inside the
    boundaries.

Documentation on variable FIND_FUNC_UNDEF in module ida_funcs:

    function has instructions that pass execution flow to unexplored bytes.
    nfn->end_ea will have the address of the unexplored byte.

Documentation on variable FIND_FUNC_OK in module ida_funcs:

    ok, 'nfn' is ready for add_func()

Documentation on variable FIND_FUNC_EXIST in module ida_funcs:

    function exists already. its bounds are returned in 'nfn'.

Documentation on variable IDASGN_OK in module ida_funcs:

    ok

Documentation on variable IDASGN_BADARG in module ida_funcs:

    bad number of signature

Documentation on variable IDASGN_APPLIED in module ida_funcs:

    signature is already applied

Documentation on variable IDASGN_CURRENT in module ida_funcs:

    signature is currently being applied

Documentation on variable IDASGN_PLANNED in module ida_funcs:

    signature is planned to be applied

Documentation on variable LIBFUNC_FOUND in module ida_funcs:

    ok, library function is found

Documentation on variable LIBFUNC_NONE in module ida_funcs:

    no, this is not a library function

Documentation on variable LIBFUNC_DELAY in module ida_funcs:

    no decision because of lack of information

Documentation on variable fcb_normal in module ida_gdl:

    normal block

Documentation on variable fcb_indjump in module ida_gdl:

    block ends with indirect jump

Documentation on variable fcb_ret in module ida_gdl:

    return block

Documentation on variable fcb_cndret in module ida_gdl:

    conditional return block

Documentation on variable fcb_noret in module ida_gdl:

    noreturn block

Documentation on variable fcb_enoret in module ida_gdl:

    external noreturn block (does not belong to the function)

Documentation on variable fcb_extern in module ida_gdl:

    external normal block

Documentation on variable fcb_error in module ida_gdl:

    block passes execution past the function end

Documentation on variable CHART_PRINT_NAMES in module ida_gdl:

    print labels for each block?

Documentation on variable CHART_GEN_DOT in module ida_gdl:

    generate .dot file (file extension is forced to .dot)

Documentation on variable CHART_GEN_GDL in module ida_gdl:

    generate .gdl file (file extension is forced to .gdl)

Documentation on variable CHART_WINGRAPH in module ida_gdl:

    call grapher to display the graph

Documentation on variable CHART_NOLIBFUNCS in module ida_gdl:

    don't include library functions in the graph

Documentation on variable CHART_REFERENCING in module ida_gdl:

    references to the addresses in the list

Documentation on variable CHART_REFERENCED in module ida_gdl:

    references from the addresses in the list

Documentation on variable CHART_RECURSIVE in module ida_gdl:

    analyze added blocks

Documentation on variable CHART_FOLLOW_DIRECTION in module ida_gdl:

    analyze references to added blocks only in the direction of the reference who
    discovered the current block

Documentation on variable CHART_IGNORE_LIB_TO in module ida_gdl:

    ignore references to library functions

Documentation on variable CHART_IGNORE_LIB_FROM in module ida_gdl:

    ignore references from library functions

Documentation on variable CHART_PRINT_DOTS in module ida_gdl:

    print dots if xrefs exist outside of the range recursion depth

Documentation on variable FC_PRINT in module ida_gdl:

    print names (used only by display_flow_chart())

Documentation on variable FC_NOEXT in module ida_gdl:

    do not compute external blocks. Use this to prevent jumps leaving the function
    from appearing in the flow chart. Unless specified, the targets of those
    outgoing jumps will be present in the flow chart under the form of one-
    instruction blocks

Documentation on variable FC_APPND in module ida_gdl:

    multirange flowchart (set by append_to_flowchart)

Documentation on variable FC_CHKBREAK in module ida_gdl:

    build_qflow_chart() may be aborted by user

Documentation on variable FC_CALL_ENDS in module ida_gdl:

    call instructions terminate basic blocks

Documentation on variable FC_NOPREDS in module ida_gdl:

    do not compute predecessor lists

Documentation on variable FC_OUTLINES in module ida_gdl:

    include outlined code (with FUNC_OUTLINE)

Documentation on variable qflow_chart_t.bounds in module ida_gdl:

    overall bounds of the qflow_chart_t instance

Documentation on variable qflow_chart_t.pfn in module ida_gdl:

    the function this instance was built upon

Documentation on variable qflow_chart_t.flags in module ida_gdl:

    flags. See Flow chart flags

Documentation on variable qflow_chart_t.nproper in module ida_gdl:

    number of basic blocks belonging to the specified range

Documentation on variable FlowChart.size in module ida_gdl:

    Number of blocks in the flow chart

Documentation on variable NIF_BG_COLOR in module ida_graph:

    node_info_t::bg_color

Documentation on variable NIF_FRAME_COLOR in module ida_graph:

    node_info_t::frame_color

Documentation on variable NIF_EA in module ida_graph:

    node_info_t::ea

Documentation on variable NIF_TEXT in module ida_graph:

    node_info_t::text

Documentation on variable NIF_FLAGS in module ida_graph:

    node_info_t::flags

Documentation on variable GLICTL_CENTER in module ida_graph:

    the gli should be set/get as center

Documentation on variable node_info_t.bg_color in module ida_graph:

    background color

Documentation on variable node_info_t.frame_color in module ida_graph:

    color of enclosing frame

Documentation on variable node_info_t.flags in module ida_graph:

    flags

Documentation on variable node_info_t.ea in module ida_graph:

    address

Documentation on variable node_info_t.text in module ida_graph:

    node contents

Documentation on variable edge_t.src in module ida_graph:

    source node number

Documentation on variable edge_t.dst in module ida_graph:

    destination node number

Documentation on variable graph_path_visitor_t.path in module ida_graph:

    current path

Documentation on variable graph_path_visitor_t.prune in module ida_graph:

    walk_forward(): prune := true means to stop the current path

Documentation on variable edge_info_t.color in module ida_graph:

    edge color

Documentation on variable edge_info_t.width in module ida_graph:

    edge width

Documentation on variable edge_info_t.layout in module ida_graph:

    describes geometry of edge

Documentation on variable edge_layout_point_t.pidx in module ida_graph:

    index into edge_info_t::layout

Documentation on variable edge_layout_point_t.e in module ida_graph:

    parent edge

Documentation on variable selection_item_t.is_node in module ida_graph:

    represents a selected node?

Documentation on variable selection_item_t.node in module ida_graph:

    node number (is_node = true)

Documentation on variable selection_item_t.elp in module ida_graph:

    edge layout point (is_node = false)

Documentation on variable git_none in module ida_graph:

    nothing

Documentation on variable git_edge in module ida_graph:

    edge (graph_item_t::e, graph_item_t::n. n is farthest edge endpoint)

Documentation on variable git_node in module ida_graph:

    node title (graph_item_t::n)

Documentation on variable git_tool in module ida_graph:

    node title button (graph_item_t::n, graph_item_t::b)

Documentation on variable git_text in module ida_graph:

    node text (graph_item_t::n, graph_item_t::p)

Documentation on variable git_elp in module ida_graph:

    edge layout point (graph_item_t::elp)

Documentation on variable graph_item_t.type in module ida_graph:

    type

Documentation on variable graph_item_t.e in module ida_graph:

    edge source and destination

Documentation on variable graph_item_t.n in module ida_graph:

    node number

Documentation on variable graph_item_t.b in module ida_graph:

    button number

Documentation on variable graph_item_t.p in module ida_graph:

    text coordinates in the node

Documentation on variable graph_item_t.elp in module ida_graph:

    edge layout point

Documentation on variable row_info_t.nodes in module ida_graph:

    list of nodes at the row

Documentation on variable row_info_t.top in module ida_graph:

    top y coord of the row

Documentation on variable row_info_t.bottom in module ida_graph:

    bottom y coord of the row

Documentation on variable abstract_graph_t.title in module ida_graph:

    graph title

Documentation on variable abstract_graph_t.rect_edges_made in module ida_graph:

    have create rectangular edges?

Documentation on variable abstract_graph_t.current_layout in module ida_graph:

    see Proximity view layouts

Documentation on variable abstract_graph_t.circle_center in module ida_graph:

    for layout_circle

Documentation on variable abstract_graph_t.circle_radius in module ida_graph:

    for layout_circle

Documentation on variable abstract_graph_t.callback_ud in module ida_graph:

    user data for callback

Documentation on variable mutable_graph_t.gid in module ida_graph:

    graph id - unique for the database for flowcharts it is equal to the function
    start_ea

Documentation on variable mutable_graph_t.belongs in module ida_graph:

    the subgraph the node belongs to INT_MAX means that the node doesn't exist sign
    bit means collapsed node

Documentation on variable mutable_graph_t.node_flags in module ida_graph:

    node flags

Documentation on variable MTG_GROUP_NODE in module ida_graph:

    is group node?

Documentation on variable MTG_DOT_NODE in module ida_graph:

    is dot node?

Documentation on variable MTG_NON_DISPLAYABLE_NODE in module ida_graph:

    for disassembly graphs - non-displayable nodes have a visible area that is too
    large to generate disassembly lines for without IDA slowing down significantly
    (see MAX_VISIBLE_NODE_AREA)

Documentation on variable grcode_calculating_layout in module ida_graph:

    calculating user-defined graph layout.
    
    @retval 0: not implemented
    @retval 1: graph layout calculated by the plugin

Documentation on variable grcode_layout_calculated in module ida_graph:

    graph layout calculated.
    
    @retval 0: must return 0

Documentation on variable grcode_changed_graph in module ida_graph:

    new graph has been set.
    
    @retval 0: must return 0

Documentation on variable grcode_clicked in module ida_graph:

    graph is being clicked. this callback allows you to ignore some clicks. it
    occurs too early, internal graph variables are not updated yet. current_item1,
    current_item2 point to the same thing. item2 has more information. see also:
    custom_viewer_click_t
    
    @retval 0: ok
    @retval 1: ignore click

Documentation on variable grcode_dblclicked in module ida_graph:

    a graph node has been double clicked.
    
    @retval 0: ok
    @retval 1: ignore click

Documentation on variable grcode_creating_group in module ida_graph:

    a group is being created. this provides an opportunity for the graph to forbid
    creation of the group. Note that groups management is done by the
    mutable_graph_t instance itself: there is no need to modify the graph in this
    callback.
    
    @retval 0: ok
    @retval 1: forbid group creation

Documentation on variable grcode_deleting_group in module ida_graph:

    a group is being deleted. this provides an opportunity for the graph to forbid
    deletion of the group. Note that groups management is done by the
    mutable_graph_t instance itself: there is no need to modify the graph in this
    callback.
    
    @retval 0: ok
    @retval 1: forbid group deletion

Documentation on variable grcode_group_visibility in module ida_graph:

    a group is being collapsed/uncollapsed this provides an opportunity for the
    graph to forbid changing the visibility of the group. Note that groups
    management is done by the mutable_graph_t instance itself: there is no need to
    modify the graph in this callback.
    
    @retval 0: ok
    @retval 1: forbid group modification

Documentation on variable grcode_gotfocus in module ida_graph:

    a graph viewer got focus.
    
    @retval 0: must return 0

Documentation on variable grcode_lostfocus in module ida_graph:

    a graph viewer lost focus.
    
    @retval 0: must return 0

Documentation on variable grcode_user_refresh in module ida_graph:

    refresh user-defined graph nodes and edges This is called when the UI considers
    that it is necessary to recreate the graph layout, and thus has to ensure that
    the 'mutable_graph_t' instance it is using, is up-to-date. For example:
    * at graph creation-time
    * if a refresh_viewer() call was made
    
    @return: success

Documentation on variable grcode_user_text in module ida_graph:

    retrieve text for user-defined graph node. NB: do not use anything calling GDI!
    
    @return: success, result must be filled

Documentation on variable grcode_user_size in module ida_graph:

    calculate node size for user-defined graph.
    
    @retval 0: did not calculate. ida will use node text size
    @retval 1: calculated. ida will add node title to the size

Documentation on variable grcode_user_title in module ida_graph:

    render node title of a user-defined graph.
    
    @retval 0: did not render, ida will fill it with title_bg_color
    @retval 1: rendered node title

Documentation on variable grcode_user_draw in module ida_graph:

    render node of a user-defined graph. NB: draw only on the specified DC and
    nowhere else!
    
    @retval 0: not rendered
    @retval 1: rendered

Documentation on variable grcode_user_hint in module ida_graph:

    retrieve hint for the user-defined graph.
    
    @retval 0: use default hint
    @retval 1: use proposed hint

Documentation on variable grcode_destroyed in module ida_graph:

    graph is being destroyed. Note that this doesn't mean the graph viewer is being
    destroyed; this only means that the graph that is being displayed by it is being
    destroyed, and that, e.g., any possibly cached data should be invalidated (this
    event can happen when, for example, the user decides to group nodes together:
    that operation will effectively create a new graph, that will replace the old
    one.) To be notified when the graph viewer itself is being destroyed, please see
    notification 'view_close', in kernwin.hpp
    
    @retval 0: must return 0

Documentation on variable grcode_create_graph_viewer in module ida_graph:

    use create_graph_viewer()

Documentation on variable grcode_get_graph_viewer in module ida_graph:

    use get_graph_viewer()

Documentation on variable grcode_get_viewer_graph in module ida_graph:

    use get_viewer_graph()

Documentation on variable grcode_create_mutable_graph in module ida_graph:

    use create_mutable_graph()

Documentation on variable grcode_set_viewer_graph in module ida_graph:

    use set_viewer_graph()

Documentation on variable grcode_refresh_viewer in module ida_graph:

    use refresh_viewer()

Documentation on variable grcode_fit_window in module ida_graph:

    use viewer_fit_window()

Documentation on variable grcode_get_curnode in module ida_graph:

    use viewer_get_curnode()

Documentation on variable grcode_center_on in module ida_graph:

    use viewer_center_on()

Documentation on variable grcode_get_selection in module ida_graph:

    use viewer_get_selection()

Documentation on variable grcode_del_custom_layout in module ida_graph:

    use mutable_graph_t::del_custom_layout()

Documentation on variable grcode_set_custom_layout in module ida_graph:

    use mutable_graph_t::set_custom_layout()

Documentation on variable grcode_set_graph_groups in module ida_graph:

    use mutable_graph_t::set_graph_groups()

Documentation on variable grcode_clear in module ida_graph:

    use mutable_graph_t::clear()

Documentation on variable grcode_create_digraph_layout in module ida_graph:

    use mutable_graph_t::create_digraph_layout()

Documentation on variable grcode_create_tree_layout in module ida_graph:

    use abstract_graph_t::create_tree_layout()

Documentation on variable grcode_create_circle_layout in module ida_graph:

    use abstract_graph_t::create_circle_layout()

Documentation on variable grcode_get_node_representative in module ida_graph:

    use mutable_graph_t::get_node_representative()

Documentation on variable grcode_find_subgraph_node in module ida_graph:

    use mutable_graph_t::_find_subgraph_node()

Documentation on variable grcode_create_group in module ida_graph:

    use mutable_graph_t::create_group()

Documentation on variable grcode_get_custom_layout in module ida_graph:

    use mutable_graph_t::get_custom_layout()

Documentation on variable grcode_get_graph_groups in module ida_graph:

    use mutable_graph_t::get_graph_groups()

Documentation on variable grcode_empty in module ida_graph:

    use mutable_graph_t::empty()

Documentation on variable grcode_is_visible_node in module ida_graph:

    use mutable_graph_t::is_visible_node()

Documentation on variable grcode_delete_group in module ida_graph:

    use mutable_graph_t::delete_group()

Documentation on variable grcode_change_group_visibility in module ida_graph:

    use mutable_graph_t::change_group_visibility()

Documentation on variable grcode_set_edge in module ida_graph:

    use mutable_graph_t::set_edge()

Documentation on variable grcode_node_qty in module ida_graph:

    use mutable_graph_t::node_qty()

Documentation on variable grcode_nrect in module ida_graph:

    use mutable_graph_t::nrect()

Documentation on variable grcode_set_titlebar_height in module ida_graph:

    use viewer_set_titlebar_height()

Documentation on variable grcode_create_user_graph_place in module ida_graph:

    use create_user_graph_place()

Documentation on variable grcode_create_disasm_graph1 in module ida_graph:

    use create_disasm_graph(ea_t ea)

Documentation on variable grcode_create_disasm_graph2 in module ida_graph:

    use create_disasm_graph(const rangevec_t &ranges)

Documentation on variable grcode_set_node_info in module ida_graph:

    use viewer_set_node_info()

Documentation on variable grcode_get_node_info in module ida_graph:

    use viewer_get_node_info()

Documentation on variable grcode_del_node_info in module ida_graph:

    use viewer_del_node_info()

Documentation on variable grcode_viewer_create_groups_vec in module ida_graph:

    use viewer_create_groups()

Documentation on variable grcode_viewer_delete_groups_vec in module ida_graph:

    use viewer_delete_groups()

Documentation on variable grcode_viewer_groups_visibility_vec in module ida_graph:

    use viewer_set_groups_visibility()

Documentation on variable grcode_delete_mutable_graph in module ida_graph:

    use delete_mutable_graph()

Documentation on variable grcode_edge_infos_wrapper_copy in module ida_graph:

    use edge_infos_wrapper_t::operator=()

Documentation on variable grcode_edge_infos_wrapper_clear in module ida_graph:

    use edge_infos_wrapper_t::clear()

Documentation on variable grcode_set_gli in module ida_graph:

    use viewer_set_gli()

Documentation on variable grcode_get_gli in module ida_graph:

    use viewer_get_gli()

Documentation on variable MERR_OK in module ida_hexrays:

    ok

Documentation on variable MERR_BLOCK in module ida_hexrays:

    no error, switch to new block

Documentation on variable MERR_INTERR in module ida_hexrays:

    internal error

Documentation on variable MERR_INSN in module ida_hexrays:

    cannot convert to microcode

Documentation on variable MERR_MEM in module ida_hexrays:

    not enough memory

Documentation on variable MERR_BADBLK in module ida_hexrays:

    bad block found

Documentation on variable MERR_BADSP in module ida_hexrays:

    positive sp value has been found

Documentation on variable MERR_PROLOG in module ida_hexrays:

    prolog analysis failed

Documentation on variable MERR_SWITCH in module ida_hexrays:

    wrong switch idiom

Documentation on variable MERR_EXCEPTION in module ida_hexrays:

    exception analysis failed

Documentation on variable MERR_HUGESTACK in module ida_hexrays:

    stack frame is too big

Documentation on variable MERR_LVARS in module ida_hexrays:

    local variable allocation failed

Documentation on variable MERR_BITNESS in module ida_hexrays:

    16-bit functions cannot be decompiled

Documentation on variable MERR_BADCALL in module ida_hexrays:

    could not determine call arguments

Documentation on variable MERR_BADFRAME in module ida_hexrays:

    function frame is wrong

Documentation on variable MERR_UNKTYPE in module ida_hexrays:

    undefined type s (currently unused error code)

Documentation on variable MERR_BADIDB in module ida_hexrays:

    inconsistent database information

Documentation on variable MERR_SIZEOF in module ida_hexrays:

    wrong basic type sizes in compiler settings

Documentation on variable MERR_REDO in module ida_hexrays:

    redecompilation has been requested

Documentation on variable MERR_CANCELED in module ida_hexrays:

    decompilation has been cancelled

Documentation on variable MERR_RECDEPTH in module ida_hexrays:

    max recursion depth reached during lvar allocation

Documentation on variable MERR_OVERLAP in module ida_hexrays:

    variables would overlap: s

Documentation on variable MERR_PARTINIT in module ida_hexrays:

    partially initialized variable s

Documentation on variable MERR_COMPLEX in module ida_hexrays:

    too complex function

Documentation on variable MERR_LICENSE in module ida_hexrays:

    no license available

Documentation on variable MERR_ONLY32 in module ida_hexrays:

    only 32-bit functions can be decompiled for the current database

Documentation on variable MERR_ONLY64 in module ida_hexrays:

    only 64-bit functions can be decompiled for the current database

Documentation on variable MERR_BUSY in module ida_hexrays:

    already decompiling a function

Documentation on variable MERR_FARPTR in module ida_hexrays:

    far memory model is supported only for pc

Documentation on variable MERR_EXTERN in module ida_hexrays:

    special segments cannot be decompiled

Documentation on variable MERR_FUNCSIZE in module ida_hexrays:

    too big function

Documentation on variable MERR_BADRANGES in module ida_hexrays:

    bad input ranges

Documentation on variable MERR_BADARCH in module ida_hexrays:

    current architecture is not supported

Documentation on variable MERR_DSLOT in module ida_hexrays:

    bad instruction in the delay slot

Documentation on variable MERR_STOP in module ida_hexrays:

    no error, stop the analysis

Documentation on variable MERR_LOOP in module ida_hexrays:

    internal code: redo last loop (never reported)

Documentation on variable operand_locator_t.ea in module ida_hexrays:

    address of the original processor instruction

Documentation on variable operand_locator_t.opnum in module ida_hexrays:

    operand number in the instruction

Documentation on variable number_format_t.flags in module ida_hexrays:

    ida flags, which describe number radix, enum, etc

Documentation on variable number_format_t.opnum in module ida_hexrays:

    operand number: 0..UA_MAXOP

Documentation on variable number_format_t.serial in module ida_hexrays:

    for enums: constant serial number

Documentation on variable number_format_t.org_nbytes in module ida_hexrays:

    original number size in bytes

Documentation on variable number_format_t.type_name in module ida_hexrays:

    for stroffs: structure for offsetof()
    for enums: enum name

Documentation on variable NF_FIXED in module ida_hexrays:

    number format has been defined by the user

Documentation on variable NF_NEGDONE in module ida_hexrays:

    temporary internal bit: negation has been performed

Documentation on variable NF_BINVDONE in module ida_hexrays:

    temporary internal bit: inverting bits is done

Documentation on variable NF_NEGATE in module ida_hexrays:

    The user asked to negate the constant.

Documentation on variable NF_BITNOT in module ida_hexrays:

    The user asked to invert bits of the constant.

Documentation on variable NF_VALID in module ida_hexrays:

    internal bit: stroff or enum is valid for enums: this bit is set immediately for
    stroffs: this bit is set at the end of decompilation

Documentation on variable vd_printer_t.hdrlines in module ida_hexrays:

    number of header lines (prototype+typedef+lvars) valid at the end of print
    process

Documentation on variable vc_printer_t.func in module ida_hexrays:

    cfunc_t to generate text for

Documentation on variable qstring_printer_t.with_tags in module ida_hexrays:

    Generate output with color tags.

Documentation on variable qstring_printer_t.s in module ida_hexrays:

    Reference to the output string

Documentation on variable lvar_locator_t.location in module ida_hexrays:

    Variable location.

Documentation on variable lvar_locator_t.defea in module ida_hexrays:

    Definition address. Usually, this is the address of the instruction that
    initializes the variable. In some cases it can be a fictional address.

Documentation on variable lvar_t.name in module ida_hexrays:

    variable name. use mba_t::set_nice_lvar_name() and mba_t::set_user_lvar_name()
    to modify it

Documentation on variable lvar_t.cmt in module ida_hexrays:

    variable comment string

Documentation on variable lvar_t.tif in module ida_hexrays:

    variable type

Documentation on variable lvar_t.width in module ida_hexrays:

    variable size in bytes

Documentation on variable lvar_t.defblk in module ida_hexrays:

    first block defining the variable. 0 for args, -1 if unknown

Documentation on variable lvar_t.divisor in module ida_hexrays:

    max known divisor of the variable

Documentation on variable lvar_saved_info_t.ll in module ida_hexrays:

    Variable locator.

Documentation on variable lvar_saved_info_t.name in module ida_hexrays:

    Name.

Documentation on variable lvar_saved_info_t.type in module ida_hexrays:

    Type.

Documentation on variable lvar_saved_info_t.cmt in module ida_hexrays:

    Comment.

Documentation on variable lvar_saved_info_t.size in module ida_hexrays:

    Type size (if not initialized then -1)

Documentation on variable lvar_saved_info_t.flags in module ida_hexrays:

    saved user lvar info property bits

Documentation on variable LVINF_KEEP in module ida_hexrays:

    preserve saved user settings regardless of vars for example, if a var loses all
    its user-defined attributes or even gets destroyed, keep its lvar_saved_info_t.
    this is used for ephemeral variables that get destroyed by macro recognition.

Documentation on variable LVINF_FORCE in module ida_hexrays:

    force allocation of a new variable. forces the decompiler to create a new
    variable at ll.defea

Documentation on variable LVINF_NOPTR in module ida_hexrays:

    variable type should not be a pointer

Documentation on variable LVINF_NOMAP in module ida_hexrays:

    forbid automatic mapping of the variable

Documentation on variable LVINF_UNUSED in module ida_hexrays:

    unused argument, corresponds to CVAR_UNUSED

Documentation on variable lvar_uservec_t.lvvec in module ida_hexrays:

    User-specified names, types, comments for lvars. Variables without user-
    specified info are not present in this vector.

Documentation on variable lvar_uservec_t.lmaps in module ida_hexrays:

    Local variable mapping (used for merging variables)

Documentation on variable lvar_uservec_t.stkoff_delta in module ida_hexrays:

    Delta to add to IDA stack offset to calculate Hex-Rays stack offsets. Should be
    set by the caller before calling save_user_lvar_settings();

Documentation on variable lvar_uservec_t.ulv_flags in module ida_hexrays:

    Various flags. Possible values are from lvar_uservec_t property bits.

Documentation on variable ULV_PRECISE_DEFEA in module ida_hexrays:

    Use precise defea's for lvar locations.

Documentation on variable MLI_NAME in module ida_hexrays:

    apply lvar name

Documentation on variable MLI_TYPE in module ida_hexrays:

    apply lvar type

Documentation on variable MLI_CMT in module ida_hexrays:

    apply lvar comment

Documentation on variable MLI_SET_FLAGS in module ida_hexrays:

    set LVINF_... bits

Documentation on variable MLI_CLR_FLAGS in module ida_hexrays:

    clear LVINF_... bits

Documentation on variable mop_visitor_t.prune in module ida_hexrays:

    Should skip sub-operands of the current operand? visit_mop() may set
    'prune=true' for that.

Documentation on variable lvar_ref_t.mba in module ida_hexrays:

    Pointer to the parent mba_t object. Since we need to access the 'mba->vars'
    array in order to retrieve the referenced variable, we keep a pointer to mba_t
    here. Note: this means this class and consequently mop_t, minsn_t, mblock_t are
    specific to a mba_t object and cannot migrate between them. fortunately this is
    not something we need to do. second, lvar_ref_t's appear only after MMAT_LVARS.

Documentation on variable lvar_ref_t.off in module ida_hexrays:

    offset from the beginning of the variable

Documentation on variable lvar_ref_t.idx in module ida_hexrays:

    index into mba->vars

Documentation on variable mop_z in module ida_hexrays:

    none

Documentation on variable mop_r in module ida_hexrays:

    register (they exist until MMAT_LVARS)

Documentation on variable mop_n in module ida_hexrays:

    immediate number constant

Documentation on variable mop_str in module ida_hexrays:

    immediate string constant (user representation)

Documentation on variable mop_d in module ida_hexrays:

    result of another instruction

Documentation on variable mop_S in module ida_hexrays:

    local stack variable (they exist until MMAT_LVARS)

Documentation on variable mop_v in module ida_hexrays:

    global variable

Documentation on variable mop_b in module ida_hexrays:

    micro basic block (mblock_t)

Documentation on variable mop_f in module ida_hexrays:

    list of arguments

Documentation on variable mop_l in module ida_hexrays:

    local variable

Documentation on variable mop_h in module ida_hexrays:

    helper function

Documentation on variable mop_c in module ida_hexrays:

    mcases

Documentation on variable mop_fn in module ida_hexrays:

    floating point constant

Documentation on variable mop_p in module ida_hexrays:

    operand pair

Documentation on variable mop_sc in module ida_hexrays:

    scattered

Documentation on variable NOSIZE in module ida_hexrays:

    wrong or unexisting operand size

Documentation on variable stkvar_ref_t.mba in module ida_hexrays:

    Pointer to the parent mba_t object. We need it in order to retrieve the
    referenced stack variable. See notes for lvar_ref_t::mba.

Documentation on variable stkvar_ref_t.off in module ida_hexrays:

    Offset to the stack variable from the bottom of the stack frame. It is called
    'decompiler stkoff' and it is different from IDA stkoff. See a note and a
    picture about 'decompiler stkoff' below.

Documentation on variable scif_t.mba in module ida_hexrays:

    Pointer to the parent mba_t object. Some operations may convert a scattered
    operand into something simpler, (a stack operand, for example). We will need to
    create stkvar_ref_t at that moment, this is why we need this pointer. See notes
    for lvar_ref_t::mba.

Documentation on variable scif_t.name in module ida_hexrays:

    Usually scattered operands are created from a function prototype, which has the
    name information. We preserve it and use it to name the corresponding local
    variable.

Documentation on variable scif_t.type in module ida_hexrays:

    Scattered operands always have type info assigned to them because without it we
    won't be able to manipulte them.

Documentation on variable fnumber_t.fnum in module ida_hexrays:

    Internal representation of the number.

Documentation on variable fnumber_t.nbytes in module ida_hexrays:

    Original size of the constant in bytes.

Documentation on variable SHINS_NUMADDR in module ida_hexrays:

    display definition addresses for numbers

Documentation on variable SHINS_VALNUM in module ida_hexrays:

    display value numbers

Documentation on variable SHINS_SHORT in module ida_hexrays:

    do not display use-def chains and other attrs

Documentation on variable SHINS_LDXEA in module ida_hexrays:

    display address of ldx expressions (not used)

Documentation on variable NO_SIDEFF in module ida_hexrays:

    change operand size but ignore side effects if you decide to keep the changed
    operand, handle_new_size() must be called

Documentation on variable WITH_SIDEFF in module ida_hexrays:

    change operand size and handle side effects

Documentation on variable ONLY_SIDEFF in module ida_hexrays:

    only handle side effects

Documentation on variable ANY_REGSIZE in module ida_hexrays:

    any register size is permitted

Documentation on variable ANY_FPSIZE in module ida_hexrays:

    any size of floating operand is permitted

Documentation on variable mop_t.t in module ida_hexrays:

    Operand type.

Documentation on variable mop_t.oprops in module ida_hexrays:

    Operand properties.

Documentation on variable mop_t.valnum in module ida_hexrays:

    Value number. Zero means unknown. Operands with the same value number are equal.

Documentation on variable mop_t.size in module ida_hexrays:

    Operand size. Usually it is 1,2,4,8 or NOSIZE but for UDTs other sizes are
    permitted

Documentation on variable OPROP_IMPDONE in module ida_hexrays:

    imported operand (a pointer) has been dereferenced

Documentation on variable OPROP_UDT in module ida_hexrays:

    a struct or union

Documentation on variable OPROP_FLOAT in module ida_hexrays:

    possibly floating value

Documentation on variable OPROP_UDEFVAL in module ida_hexrays:

    uses undefined value

Documentation on variable OPROP_LOWADDR in module ida_hexrays:

    a low address offset

Documentation on variable mop_pair_t.lop in module ida_hexrays:

    low operand

Documentation on variable mop_pair_t.hop in module ida_hexrays:

    high operand

Documentation on variable mcallarg_t.ea in module ida_hexrays:

    address where the argument was initialized. BADADDR means unknown.

Documentation on variable mcallarg_t.type in module ida_hexrays:

    formal argument type

Documentation on variable mcallarg_t.name in module ida_hexrays:

    formal argument name

Documentation on variable mcallarg_t.argloc in module ida_hexrays:

    ida argloc

Documentation on variable mcallarg_t.flags in module ida_hexrays:

    FAI_...

Documentation on variable ROLE_UNK in module ida_hexrays:

    unknown function role

Documentation on variable ROLE_EMPTY in module ida_hexrays:

    empty, does not do anything (maybe spoils regs)

Documentation on variable ROLE_MEMSET in module ida_hexrays:

    memset(void *dst, uchar value, size_t count);

Documentation on variable ROLE_MEMSET32 in module ida_hexrays:

    memset32(void *dst, uint32 value, size_t count);

Documentation on variable ROLE_MEMSET64 in module ida_hexrays:

    memset64(void *dst, uint64 value, size_t count);

Documentation on variable ROLE_MEMCPY in module ida_hexrays:

    memcpy(void *dst, const void *src, size_t count);

Documentation on variable ROLE_STRCPY in module ida_hexrays:

    strcpy(char *dst, const char *src);

Documentation on variable ROLE_STRLEN in module ida_hexrays:

    strlen(const char *src);

Documentation on variable ROLE_STRCAT in module ida_hexrays:

    strcat(char *dst, const char *src);

Documentation on variable ROLE_TAIL in module ida_hexrays:

    char *tail(const char *str);

Documentation on variable ROLE_BUG in module ida_hexrays:

    BUG() helper macro: never returns, causes exception.

Documentation on variable ROLE_ALLOCA in module ida_hexrays:

    alloca() function

Documentation on variable ROLE_BSWAP in module ida_hexrays:

    bswap() function (any size)

Documentation on variable ROLE_PRESENT in module ida_hexrays:

    present() function (used in patterns)

Documentation on variable ROLE_CONTAINING_RECORD in module ida_hexrays:

    CONTAINING_RECORD() macro.

Documentation on variable ROLE_FASTFAIL in module ida_hexrays:

    __fastfail()

Documentation on variable ROLE_READFLAGS in module ida_hexrays:

    __readeflags, __readcallersflags

Documentation on variable ROLE_IS_MUL_OK in module ida_hexrays:

    is_mul_ok

Documentation on variable ROLE_SATURATED_MUL in module ida_hexrays:

    saturated_mul

Documentation on variable ROLE_BITTEST in module ida_hexrays:

    [lock] bt

Documentation on variable ROLE_BITTESTANDSET in module ida_hexrays:

    [lock] bts

Documentation on variable ROLE_BITTESTANDRESET in module ida_hexrays:

    [lock] btr

Documentation on variable ROLE_BITTESTANDCOMPLEMENT in module ida_hexrays:

    [lock] btc

Documentation on variable ROLE_VA_ARG in module ida_hexrays:

    va_arg() macro

Documentation on variable ROLE_VA_COPY in module ida_hexrays:

    va_copy() function

Documentation on variable ROLE_VA_START in module ida_hexrays:

    va_start() function

Documentation on variable ROLE_VA_END in module ida_hexrays:

    va_end() function

Documentation on variable ROLE_ROL in module ida_hexrays:

    rotate left

Documentation on variable ROLE_ROR in module ida_hexrays:

    rotate right

Documentation on variable ROLE_CFSUB3 in module ida_hexrays:

    carry flag after subtract with carry

Documentation on variable ROLE_OFSUB3 in module ida_hexrays:

    overflow flag after subtract with carry

Documentation on variable ROLE_ABS in module ida_hexrays:

    integer absolute value

Documentation on variable ROLE_3WAYCMP0 in module ida_hexrays:

    3-way compare helper, returns -1/0/1

Documentation on variable ROLE_3WAYCMP1 in module ida_hexrays:

    3-way compare helper, returns 0/1/2

Documentation on variable ROLE_WMEMCPY in module ida_hexrays:

    wchar_t *wmemcpy(wchar_t *dst, const wchar_t *src, size_t n)

Documentation on variable ROLE_WMEMSET in module ida_hexrays:

    wchar_t *wmemset(wchar_t *dst, wchar_t wc, size_t n)

Documentation on variable ROLE_WCSCPY in module ida_hexrays:

    wchar_t *wcscpy(wchar_t *dst, const wchar_t *src);

Documentation on variable ROLE_WCSLEN in module ida_hexrays:

    size_t wcslen(const wchar_t *s)

Documentation on variable ROLE_WCSCAT in module ida_hexrays:

    wchar_t *wcscat(wchar_t *dst, const wchar_t *src)

Documentation on variable ROLE_SSE_CMP4 in module ida_hexrays:

    e.g. _mm_cmpgt_ss

Documentation on variable ROLE_SSE_CMP8 in module ida_hexrays:

    e.g. _mm_cmpgt_sd

Documentation on variable mcallinfo_t.callee in module ida_hexrays:

    address of the called function, if known

Documentation on variable mcallinfo_t.solid_args in module ida_hexrays:

    number of solid args. there may be variadic args in addtion

Documentation on variable mcallinfo_t.call_spd in module ida_hexrays:

    sp value at call insn

Documentation on variable mcallinfo_t.stkargs_top in module ida_hexrays:

    first offset past stack arguments

Documentation on variable mcallinfo_t.cc in module ida_hexrays:

    calling convention

Documentation on variable mcallinfo_t.args in module ida_hexrays:

    call arguments

Documentation on variable mcallinfo_t.retregs in module ida_hexrays:

    return register(s) (e.g., AX, AX:DX, etc.) this vector is built from return_regs

Documentation on variable mcallinfo_t.return_type in module ida_hexrays:

    type of the returned value

Documentation on variable mcallinfo_t.return_argloc in module ida_hexrays:

    location of the returned value

Documentation on variable mcallinfo_t.return_regs in module ida_hexrays:

    list of values returned by the function

Documentation on variable mcallinfo_t.spoiled in module ida_hexrays:

    list of spoiled locations (includes return_regs)

Documentation on variable mcallinfo_t.pass_regs in module ida_hexrays:

    passthrough registers: registers that depend on input values (subset of spoiled)

Documentation on variable mcallinfo_t.visible_memory in module ida_hexrays:

    what memory is visible to the call?

Documentation on variable mcallinfo_t.dead_regs in module ida_hexrays:

    registers defined by the function but never used. upon propagation we do the
    following:
    * dead_regs += return_regs
    * retregs.clear() since the call is propagated

Documentation on variable mcallinfo_t.flags in module ida_hexrays:

    combination of Call properties... bits

Documentation on variable mcallinfo_t.role in module ida_hexrays:

    function role

Documentation on variable mcallinfo_t.fti_attrs in module ida_hexrays:

    extended function attributes

Documentation on variable FCI_PROP in module ida_hexrays:

    call has been propagated

Documentation on variable FCI_DEAD in module ida_hexrays:

    some return registers were determined dead

Documentation on variable FCI_FINAL in module ida_hexrays:

    call type is final, should not be changed

Documentation on variable FCI_NORET in module ida_hexrays:

    call does not return

Documentation on variable FCI_PURE in module ida_hexrays:

    pure function

Documentation on variable FCI_NOSIDE in module ida_hexrays:

    call does not have side effects

Documentation on variable FCI_SPLOK in module ida_hexrays:

    spoiled/visible_memory lists have been optimized. for some functions we can
    reduce them as soon as information about the arguments becomes available. in
    order not to try optimize them again we use this bit.

Documentation on variable FCI_HASCALL in module ida_hexrays:

    A function is an synthetic helper combined from several instructions and at
    least one of them was a call to a real functions

Documentation on variable FCI_HASFMT in module ida_hexrays:

    A variadic function with recognized printf- or scanf-style format string

Documentation on variable FCI_EXPLOCS in module ida_hexrays:

    all arglocs are specified explicitly

Documentation on variable mcases_t.values in module ida_hexrays:

    expression values for each target

Documentation on variable mcases_t.targets in module ida_hexrays:

    target block numbers

Documentation on variable voff_t.off in module ida_hexrays:

    register number or stack offset

Documentation on variable voff_t.type in module ida_hexrays:

    mop_r - register, mop_S - stack, mop_z - undefined

Documentation on variable vivl_t.size in module ida_hexrays:

    Interval size in bytes.

Documentation on variable chain_t.width in module ida_hexrays:

    size of the value in bytes

Documentation on variable chain_t.varnum in module ida_hexrays:

    allocated variable index (-1 - not allocated yet)

Documentation on variable chain_t.flags in module ida_hexrays:

    combination Chain properties bits

Documentation on variable CHF_INITED in module ida_hexrays:

    is chain initialized? (valid only after lvar allocation)

Documentation on variable CHF_REPLACED in module ida_hexrays:

    chain operands have been replaced?

Documentation on variable CHF_OVER in module ida_hexrays:

    overlapped chain

Documentation on variable CHF_FAKE in module ida_hexrays:

    fake chain created by widen_chains()

Documentation on variable CHF_PASSTHRU in module ida_hexrays:

    pass-thru chain, must use the input variable to the block

Documentation on variable CHF_TERM in module ida_hexrays:

    terminating chain; the variable does not survive across the block

Documentation on variable chain_visitor_t.parent in module ida_hexrays:

    parent of the current chain

Documentation on variable GCA_EMPTY in module ida_hexrays:

    include empty chains

Documentation on variable GCA_SPEC in module ida_hexrays:

    include chains for special registers

Documentation on variable GCA_ALLOC in module ida_hexrays:

    enumerate only allocated chains

Documentation on variable GCA_NALLOC in module ida_hexrays:

    enumerate only non-allocated chains

Documentation on variable GCA_OFIRST in module ida_hexrays:

    consider only chains of the first block

Documentation on variable GCA_OLAST in module ida_hexrays:

    consider only chains of the last block

Documentation on variable minsn_t.opcode in module ida_hexrays:

    instruction opcode

Documentation on variable minsn_t.iprops in module ida_hexrays:

    combination of instruction property bits bits

Documentation on variable minsn_t.next in module ida_hexrays:

    next insn in doubly linked list. check also nexti()

Documentation on variable minsn_t.prev in module ida_hexrays:

    prev insn in doubly linked list. check also previ()

Documentation on variable minsn_t.ea in module ida_hexrays:

    instruction address

Documentation on variable minsn_t.l in module ida_hexrays:

    left operand

Documentation on variable minsn_t.r in module ida_hexrays:

    right operand

Documentation on variable minsn_t.d in module ida_hexrays:

    destination operand

Documentation on variable IPROP_OPTIONAL in module ida_hexrays:

    optional instruction

Documentation on variable IPROP_PERSIST in module ida_hexrays:

    persistent insn; they are not destroyed

Documentation on variable IPROP_WILDMATCH in module ida_hexrays:

    match multiple insns

Documentation on variable IPROP_CLNPOP in module ida_hexrays:

    the purpose of the instruction is to clean stack (e.g. "pop ecx" is often used
    for that)

Documentation on variable IPROP_FPINSN in module ida_hexrays:

    floating point insn

Documentation on variable IPROP_FARCALL in module ida_hexrays:

    call of a far function using push cs/call sequence

Documentation on variable IPROP_TAILCALL in module ida_hexrays:

    tail call

Documentation on variable IPROP_SPLIT in module ida_hexrays:

    the instruction has been split:

Documentation on variable IPROP_SPLIT1 in module ida_hexrays:

    into 1 byte

Documentation on variable IPROP_SPLIT2 in module ida_hexrays:

    into 2 bytes

Documentation on variable IPROP_SPLIT4 in module ida_hexrays:

    into 4 bytes

Documentation on variable IPROP_SPLIT8 in module ida_hexrays:

    into 8 bytes

Documentation on variable IPROP_COMBINED in module ida_hexrays:

    insn has been modified because of a partial reference

Documentation on variable IPROP_EXTSTX in module ida_hexrays:

    this is m_ext propagated into m_stx

Documentation on variable IPROP_IGNLOWSRC in module ida_hexrays:

    low part of the instruction source operand has been created artificially (this
    bit is used only for 'and x, 80...')

Documentation on variable IPROP_INV_JX in module ida_hexrays:

    inverted conditional jump

Documentation on variable IPROP_WAS_NORET in module ida_hexrays:

    was noret icall

Documentation on variable IPROP_MULTI_MOV in module ida_hexrays:

    bits that can be set by plugins:
    
    the minsn was generated as part of insn that moves multiple registers (example:
    STM on ARM may transfer multiple registers)

Documentation on variable IPROP_DONT_PROP in module ida_hexrays:

    may not propagate

Documentation on variable IPROP_DONT_COMB in module ida_hexrays:

    may not combine this instruction with others

Documentation on variable IPROP_MBARRIER in module ida_hexrays:

    this instruction acts as a memory barrier (instructions accessing memory may not
    be reordered past it)

Documentation on variable IPROP_UNMERGED in module ida_hexrays:

    'goto' instruction was transformed info 'call'

Documentation on variable OPTI_ADDREXPRS in module ida_hexrays:

    optimize all address expressions (&x+N; &x-&y)

Documentation on variable OPTI_MINSTKREF in module ida_hexrays:

    may update minstkref

Documentation on variable OPTI_COMBINSNS in module ida_hexrays:

    may combine insns (only for optimize_insn)

Documentation on variable OPTI_NO_LDXOPT in module ida_hexrays:

    the function is called after the propagation attempt, we do not optimize
    low/high(ldx) in this case

Documentation on variable EQ_IGNSIZE in module ida_hexrays:

    ignore source operand sizes

Documentation on variable EQ_IGNCODE in module ida_hexrays:

    ignore instruction opcodes

Documentation on variable EQ_CMPDEST in module ida_hexrays:

    compare instruction destinations

Documentation on variable EQ_OPTINSN in module ida_hexrays:

    optimize mop_d operands

Documentation on variable BLT_NONE in module ida_hexrays:

    unknown block type

Documentation on variable BLT_STOP in module ida_hexrays:

    stops execution regularly (must be the last block)

Documentation on variable BLT_0WAY in module ida_hexrays:

    does not have successors (tail is a noret function)

Documentation on variable BLT_1WAY in module ida_hexrays:

    passes execution to one block (regular or goto block)

Documentation on variable BLT_2WAY in module ida_hexrays:

    passes execution to two blocks (conditional jump)

Documentation on variable BLT_NWAY in module ida_hexrays:

    passes execution to many blocks (switch idiom)

Documentation on variable BLT_XTRN in module ida_hexrays:

    external block (out of function address)

Documentation on variable mblock_t.nextb in module ida_hexrays:

    next block in the doubly linked list

Documentation on variable mblock_t.prevb in module ida_hexrays:

    previous block in the doubly linked list

Documentation on variable mblock_t.flags in module ida_hexrays:

    combination of Basic block properties bits

Documentation on variable mblock_t.start in module ida_hexrays:

    start address

Documentation on variable mblock_t.end in module ida_hexrays:

    end address note: we cannot rely on start/end addresses very much because
    instructions are propagated between blocks

Documentation on variable mblock_t.head in module ida_hexrays:

    pointer to the first instruction of the block

Documentation on variable mblock_t.tail in module ida_hexrays:

    pointer to the last instruction of the block

Documentation on variable mblock_t.mba in module ida_hexrays:

    the parent micro block array

Documentation on variable mblock_t.serial in module ida_hexrays:

    block number

Documentation on variable mblock_t.type in module ida_hexrays:

    block type (BLT_NONE - not computed yet)

Documentation on variable mblock_t.dead_at_start in module ida_hexrays:

    data that is dead at the block entry

Documentation on variable mblock_t.mustbuse in module ida_hexrays:

    data that must be used by the block

Documentation on variable mblock_t.maybuse in module ida_hexrays:

    data that may be used by the block

Documentation on variable mblock_t.mustbdef in module ida_hexrays:

    data that must be defined by the block

Documentation on variable mblock_t.maybdef in module ida_hexrays:

    data that may be defined by the block

Documentation on variable mblock_t.dnu in module ida_hexrays:

    data that is defined but not used in the block

Documentation on variable mblock_t.maxbsp in module ida_hexrays:

    maximal sp value in the block (0...stacksize)

Documentation on variable mblock_t.minbstkref in module ida_hexrays:

    lowest stack location accessible with indirect addressing (offset from the stack
    bottom) initially it is 0 (not computed)

Documentation on variable mblock_t.minbargref in module ida_hexrays:

    the same for arguments

Documentation on variable mblock_t.predset in module ida_hexrays:

    control flow graph: list of our predecessors use npred() and pred() to access it

Documentation on variable mblock_t.succset in module ida_hexrays:

    control flow graph: list of our successors use nsucc() and succ() to access it

Documentation on variable MBL_PRIV in module ida_hexrays:

    private block - no instructions except the specified are accepted (used in
    patterns)

Documentation on variable MBL_NONFAKE in module ida_hexrays:

    regular block

Documentation on variable MBL_FAKE in module ida_hexrays:

    fake block

Documentation on variable MBL_GOTO in module ida_hexrays:

    this block is a goto target

Documentation on variable MBL_TCAL in module ida_hexrays:

    aritifical call block for tail calls

Documentation on variable MBL_PUSH in module ida_hexrays:

    needs "convert push/pop instructions"

Documentation on variable MBL_DMT64 in module ida_hexrays:

    needs "demote 64bits"

Documentation on variable MBL_COMB in module ida_hexrays:

    needs "combine" pass

Documentation on variable MBL_PROP in module ida_hexrays:

    needs 'propagation' pass

Documentation on variable MBL_DEAD in module ida_hexrays:

    needs "eliminate deads" pass

Documentation on variable MBL_LIST in module ida_hexrays:

    use/def lists are ready (not dirty)

Documentation on variable MBL_INCONST in module ida_hexrays:

    inconsistent lists: we are building them

Documentation on variable MBL_CALL in module ida_hexrays:

    call information has been built

Documentation on variable MBL_BACKPROP in module ida_hexrays:

    performed backprop_cc

Documentation on variable MBL_NORET in module ida_hexrays:

    dead end block: doesn't return execution control

Documentation on variable MBL_DSLOT in module ida_hexrays:

    block for delay slot

Documentation on variable MBL_VALRANGES in module ida_hexrays:

    should optimize using value ranges

Documentation on variable MBL_KEEP in module ida_hexrays:

    do not remove even if unreachable

Documentation on variable FD_BACKWARD in module ida_hexrays:

    search direction

Documentation on variable FD_FORWARD in module ida_hexrays:

    search direction

Documentation on variable FD_USE in module ida_hexrays:

    look for use

Documentation on variable FD_DEF in module ida_hexrays:

    look for definition

Documentation on variable FD_DIRTY in module ida_hexrays:

    ignore possible implicit definitions by function calls and indirect memory
    access

Documentation on variable VR_AT_START in module ida_hexrays:

    get value ranges before the instruction or at the block start (if M is nullptr)

Documentation on variable VR_AT_END in module ida_hexrays:

    get value ranges after the instruction or at the block end, just after the last
    instruction (if M is nullptr)

Documentation on variable VR_EXACT in module ida_hexrays:

    find exact match. if not set, the returned valrng size will be >= vivl.size

Documentation on variable WARN_VARARG_REGS in module ida_hexrays:

    0 cannot handle register arguments in vararg function, discarded them

Documentation on variable WARN_ILL_PURGED in module ida_hexrays:

    1 odd caller purged bytes d, correcting

Documentation on variable WARN_ILL_FUNCTYPE in module ida_hexrays:

    2 invalid function type has been ignored

Documentation on variable WARN_VARARG_TCAL in module ida_hexrays:

    3 cannot handle tail call to vararg

Documentation on variable WARN_VARARG_NOSTK in module ida_hexrays:

    4 call vararg without local stack

Documentation on variable WARN_VARARG_MANY in module ida_hexrays:

    5 too many varargs, some ignored

Documentation on variable WARN_ADDR_OUTARGS in module ida_hexrays:

    6 cannot handle address arithmetics in outgoing argument area of stack frame -
    unused

Documentation on variable WARN_DEP_UNK_CALLS in module ida_hexrays:

    7 found interdependent unknown calls

Documentation on variable WARN_ILL_ELLIPSIS in module ida_hexrays:

    8 erroneously detected ellipsis type has been ignored

Documentation on variable WARN_GUESSED_TYPE in module ida_hexrays:

    9 using guessed type s;

Documentation on variable WARN_EXP_LINVAR in module ida_hexrays:

    10 failed to expand a linear variable

Documentation on variable WARN_WIDEN_CHAINS in module ida_hexrays:

    11 failed to widen chains

Documentation on variable WARN_BAD_PURGED in module ida_hexrays:

    12 inconsistent function type and number of purged bytes

Documentation on variable WARN_CBUILD_LOOPS in module ida_hexrays:

    13 too many cbuild loops

Documentation on variable WARN_NO_SAVE_REST in module ida_hexrays:

    14 could not find valid save-restore pair for s

Documentation on variable WARN_ODD_INPUT_REG in module ida_hexrays:

    15 odd input register s

Documentation on variable WARN_ODD_ADDR_USE in module ida_hexrays:

    16 odd use of a variable address

Documentation on variable WARN_MUST_RET_FP in module ida_hexrays:

    17 function return type is incorrect (must be floating point)

Documentation on variable WARN_ILL_FPU_STACK in module ida_hexrays:

    18 inconsistent fpu stack

Documentation on variable WARN_SELFREF_PROP in module ida_hexrays:

    19 self-referencing variable has been detected

Documentation on variable WARN_WOULD_OVERLAP in module ida_hexrays:

    20 variables would overlap: s

Documentation on variable WARN_ARRAY_INARG in module ida_hexrays:

    21 array has been used for an input argument

Documentation on variable WARN_MAX_ARGS in module ida_hexrays:

    22 too many input arguments, some ignored

Documentation on variable WARN_BAD_FIELD_TYPE in module ida_hexrays:

    23 incorrect structure member type for s::s, ignored

Documentation on variable WARN_WRITE_CONST in module ida_hexrays:

    24 write access to const memory at a has been detected

Documentation on variable WARN_BAD_RETVAR in module ida_hexrays:

    25 wrong return variable

Documentation on variable WARN_FRAG_LVAR in module ida_hexrays:

    26 fragmented variable at s may be wrong

Documentation on variable WARN_HUGE_STKOFF in module ida_hexrays:

    27 exceedingly huge offset into the stack frame

Documentation on variable WARN_UNINITED_REG in module ida_hexrays:

    28 reference to an uninitialized register has been removed: s

Documentation on variable WARN_FIXED_MACRO in module ida_hexrays:

    29 fixed broken macro-insn

Documentation on variable WARN_WRONG_VA_OFF in module ida_hexrays:

    30 wrong offset of va_list variable

Documentation on variable WARN_CR_NOFIELD in module ida_hexrays:

    31 CONTAINING_RECORD: no field 's' in struct 's' at d

Documentation on variable WARN_CR_BADOFF in module ida_hexrays:

    32 CONTAINING_RECORD: too small offset d for struct 's'

Documentation on variable WARN_BAD_STROFF in module ida_hexrays:

    33 user specified stroff has not been processed: s

Documentation on variable WARN_BAD_VARSIZE in module ida_hexrays:

    34 inconsistent variable size for 's'

Documentation on variable WARN_UNSUPP_REG in module ida_hexrays:

    35 unsupported processor register 's'

Documentation on variable WARN_UNALIGNED_ARG in module ida_hexrays:

    36 unaligned function argument 's'

Documentation on variable WARN_BAD_STD_TYPE in module ida_hexrays:

    37 corrupted or unexisting local type 's'

Documentation on variable WARN_BAD_CALL_SP in module ida_hexrays:

    38 bad sp value at call

Documentation on variable WARN_MISSED_SWITCH in module ida_hexrays:

    39 wrong markup of switch jump, skipped it

Documentation on variable WARN_BAD_SP in module ida_hexrays:

    40 positive sp value a has been found

Documentation on variable WARN_BAD_STKPNT in module ida_hexrays:

    41 wrong sp change point

Documentation on variable WARN_UNDEF_LVAR in module ida_hexrays:

    42 variable 's' is possibly undefined

Documentation on variable WARN_JUMPOUT in module ida_hexrays:

    43 control flows out of bounds

Documentation on variable WARN_BAD_VALRNG in module ida_hexrays:

    44 values range analysis failed

Documentation on variable WARN_BAD_SHADOW in module ida_hexrays:

    45 ignored the value written to the shadow area of the succeeding call

Documentation on variable WARN_OPT_VALRNG in module ida_hexrays:

    46 conditional instruction was optimized away because s

Documentation on variable WARN_RET_LOCREF in module ida_hexrays:

    47 returning address of temporary local variable 's'

Documentation on variable WARN_BAD_MAPDST in module ida_hexrays:

    48 too short map destination 's' for variable 's'

Documentation on variable WARN_BAD_INSN in module ida_hexrays:

    49 bad instruction

Documentation on variable WARN_ODD_ABI in module ida_hexrays:

    50 encountered odd instruction for the current ABI

Documentation on variable WARN_UNBALANCED_STACK in module ida_hexrays:

    51 unbalanced stack, ignored a potential tail call

Documentation on variable WARN_OPT_VALRNG2 in module ida_hexrays:

    52 mask 0xX is shortened because s <= 0xX"

Documentation on variable WARN_OPT_VALRNG3 in module ida_hexrays:

    53 masking with 0XX was optimized away because s <= 0xX

Documentation on variable WARN_OPT_USELESS_JCND in module ida_hexrays:

    54 simplified comparisons for 's': s became s

Documentation on variable WARN_MAX in module ida_hexrays:

    may be used in notes as a placeholder when the warning id is not available

Documentation on variable hexwarn_t.ea in module ida_hexrays:

    Address where the warning occurred.

Documentation on variable hexwarn_t.id in module ida_hexrays:

    Warning id.

Documentation on variable hexwarn_t.text in module ida_hexrays:

    Fully formatted text of the warning.

Documentation on variable MMAT_ZERO in module ida_hexrays:

    microcode does not exist

Documentation on variable MMAT_GENERATED in module ida_hexrays:

    generated microcode

Documentation on variable MMAT_PREOPTIMIZED in module ida_hexrays:

    preoptimized pass is complete

Documentation on variable MMAT_LOCOPT in module ida_hexrays:

    local optimization of each basic block is complete. control flow graph is ready
    too.

Documentation on variable MMAT_CALLS in module ida_hexrays:

    detected call arguments

Documentation on variable MMAT_GLBOPT1 in module ida_hexrays:

    performed the first pass of global optimization

Documentation on variable MMAT_GLBOPT2 in module ida_hexrays:

    most global optimization passes are done

Documentation on variable MMAT_GLBOPT3 in module ida_hexrays:

    completed all global optimization. microcode is fixed now.

Documentation on variable MMAT_LVARS in module ida_hexrays:

    allocated local variables

Documentation on variable MMIDX_GLBLOW in module ida_hexrays:

    global memory: low part

Documentation on variable MMIDX_GLBHIGH in module ida_hexrays:

    global memory: high part

Documentation on variable mba_ranges_t.pfn in module ida_hexrays:

    function to decompile. if not null, then function mode.

Documentation on variable mba_ranges_t.ranges in module ida_hexrays:

    snippet mode: ranges to decompile. function mode: list of outlined ranges

Documentation on variable mba_t.qty in module ida_hexrays:

    number of basic blocks

Documentation on variable mba_t.npurged in module ida_hexrays:

    -1 - unknown

Documentation on variable mba_t.cc in module ida_hexrays:

    calling convention

Documentation on variable mba_t.tmpstk_size in module ida_hexrays:

    size of the temporary stack part (which dynamically changes with push/pops)

Documentation on variable mba_t.frsize in module ida_hexrays:

    size of local stkvars range in the stack frame

Documentation on variable mba_t.frregs in module ida_hexrays:

    size of saved registers range in the stack frame

Documentation on variable mba_t.fpd in module ida_hexrays:

    frame pointer delta

Documentation on variable mba_t.pfn_flags in module ida_hexrays:

    copy of func_t::flags

Documentation on variable mba_t.retsize in module ida_hexrays:

    size of return address in the stack frame

Documentation on variable mba_t.shadow_args in module ida_hexrays:

    size of shadow argument area

Documentation on variable mba_t.fullsize in module ida_hexrays:

    Full stack size including incoming args.

Documentation on variable mba_t.stacksize in module ida_hexrays:

    The maximal size of the function stack including bytes allocated for outgoing
    call arguments (up to retaddr)

Documentation on variable mba_t.inargoff in module ida_hexrays:

    offset of the first stack argument; after fix_scattered_movs() INARGOFF may be
    less than STACKSIZE

Documentation on variable mba_t.minstkref in module ida_hexrays:

    The lowest stack location whose address was taken.

Documentation on variable mba_t.minstkref_ea in module ida_hexrays:

    address with lowest minstkref (for debugging)

Documentation on variable mba_t.minargref in module ida_hexrays:

    The lowest stack argument location whose address was taken This location and
    locations above it can be aliased It controls locations >= inargoff-shadow_args

Documentation on variable mba_t.spd_adjust in module ida_hexrays:

    If sp>0, the max positive sp value.

Documentation on variable mba_t.aliased_vars in module ida_hexrays:

    Aliased stkvar locations.

Documentation on variable mba_t.aliased_args in module ida_hexrays:

    Aliased stkarg locations.

Documentation on variable mba_t.gotoff_stkvars in module ida_hexrays:

    stkvars that hold .got offsets. considered to be unaliasable

Documentation on variable mba_t.aliased_memory in module ida_hexrays:

    aliased_memory+restricted_memory=ALLMEM

Documentation on variable mba_t.nodel_memory in module ida_hexrays:

    global dead elimination may not delete references to this area

Documentation on variable mba_t.consumed_argregs in module ida_hexrays:

    registers converted into stack arguments, should not be used as arguments

Documentation on variable mba_t.maturity in module ida_hexrays:

    current maturity level

Documentation on variable mba_t.reqmat in module ida_hexrays:

    required maturity level

Documentation on variable mba_t.final_type in module ida_hexrays:

    is the function type final? (specified by the user)

Documentation on variable mba_t.idb_type in module ida_hexrays:

    function type as retrieved from the database

Documentation on variable mba_t.idb_spoiled in module ida_hexrays:

    MBA_SPLINFO && final_type: info in ida format.

Documentation on variable mba_t.spoiled_list in module ida_hexrays:

    MBA_SPLINFO && !final_type: info in vd format.

Documentation on variable mba_t.fti_flags in module ida_hexrays:

    FTI_... constants for the current function.

Documentation on variable mba_t.deprecated_idb_node in module ida_hexrays:

    netnode with additional decompiler info. deprecated, do not use it anymore. it
    may get stale after undo.

Documentation on variable mba_t.label in module ida_hexrays:

    name of the function or pattern (colored)

Documentation on variable mba_t.vars in module ida_hexrays:

    local variables

Documentation on variable mba_t.argidx in module ida_hexrays:

    input arguments (indexes into 'vars')

Documentation on variable mba_t.retvaridx in module ida_hexrays:

    index of variable holding the return value -1 means none

Documentation on variable mba_t.error_ea in module ida_hexrays:

    during microcode generation holds ins.ea

Documentation on variable mba_t.blocks in module ida_hexrays:

    double linked list of blocks

Documentation on variable mba_t.natural in module ida_hexrays:

    natural order of blocks

Documentation on variable mba_t.std_ivls in module ida_hexrays:

    we treat memory as consisting of 6 parts see memreg_index_t

Documentation on variable MBA_PRCDEFS in module ida_hexrays:

    use precise defeas for chain-allocated lvars

Documentation on variable MBA_NOFUNC in module ida_hexrays:

    function is not present, addresses might be wrong

Documentation on variable MBA_PATTERN in module ida_hexrays:

    microcode pattern, callinfo is present

Documentation on variable MBA_LOADED in module ida_hexrays:

    loaded gdl, no instructions (debugging)

Documentation on variable MBA_RETFP in module ida_hexrays:

    function returns floating point value

Documentation on variable MBA_SPLINFO in module ida_hexrays:

    (final_type ? idb_spoiled : spoiled_regs) is valid

Documentation on variable MBA_PASSREGS in module ida_hexrays:

    has mcallinfo_t::pass_regs

Documentation on variable MBA_THUNK in module ida_hexrays:

    thunk function

Documentation on variable MBA_CMNSTK in module ida_hexrays:

    stkvars+stkargs should be considered as one area

Documentation on variable MBA_PREOPT in module ida_hexrays:

    preoptimization stage complete

Documentation on variable MBA_CMBBLK in module ida_hexrays:

    request to combine blocks

Documentation on variable MBA_ASRTOK in module ida_hexrays:

    assertions have been generated

Documentation on variable MBA_CALLS in module ida_hexrays:

    callinfo has been built

Documentation on variable MBA_ASRPROP in module ida_hexrays:

    assertion have been propagated

Documentation on variable MBA_SAVRST in module ida_hexrays:

    save-restore analysis has been performed

Documentation on variable MBA_RETREF in module ida_hexrays:

    return type has been refined

Documentation on variable MBA_GLBOPT in module ida_hexrays:

    microcode has been optimized globally

Documentation on variable MBA_LVARS0 in module ida_hexrays:

    lvar pre-allocation has been performed

Documentation on variable MBA_LVARS1 in module ida_hexrays:

    lvar real allocation has been performed

Documentation on variable MBA_DELPAIRS in module ida_hexrays:

    pairs have been deleted once

Documentation on variable MBA_CHVARS in module ida_hexrays:

    can verify chain varnums

Documentation on variable MBA_SHORT in module ida_hexrays:

    use short display

Documentation on variable MBA_COLGDL in module ida_hexrays:

    display graph after each reduction

Documentation on variable MBA_INSGDL in module ida_hexrays:

    display instruction in graphs

Documentation on variable MBA_NICE in module ida_hexrays:

    apply transformations to c code

Documentation on variable MBA_REFINE in module ida_hexrays:

    may refine return value size

Documentation on variable MBA_WINGR32 in module ida_hexrays:

    use wingraph32

Documentation on variable MBA_NUMADDR in module ida_hexrays:

    display definition addresses for numbers

Documentation on variable MBA_VALNUM in module ida_hexrays:

    display value numbers

Documentation on variable MBA2_LVARNAMES_OK in module ida_hexrays:

    may verify lvar_names?

Documentation on variable MBA2_LVARS_RENAMED in module ida_hexrays:

    accept empty names now?

Documentation on variable MBA2_OVER_CHAINS in module ida_hexrays:

    has overlapped chains?

Documentation on variable MBA2_VALRNG_DONE in module ida_hexrays:

    calculated valranges?

Documentation on variable MBA2_IS_CTR in module ida_hexrays:

    is constructor?

Documentation on variable MBA2_IS_DTR in module ida_hexrays:

    is destructor?

Documentation on variable MBA2_ARGIDX_OK in module ida_hexrays:

    may verify input argument list?

Documentation on variable MBA2_NO_DUP_CALLS in module ida_hexrays:

    forbid multiple calls with the same ea

Documentation on variable MBA2_NO_DUP_LVARS in module ida_hexrays:

    forbid multiple lvars with the same ea

Documentation on variable MBA2_UNDEF_RETVAR in module ida_hexrays:

    return value is undefined

Documentation on variable MBA2_ARGIDX_SORTED in module ida_hexrays:

    args finally sorted according to ABI (e.g. reverse stkarg order in Borland)

Documentation on variable MBA2_CODE16_BIT in module ida_hexrays:

    the code16 bit removed

Documentation on variable MBA2_STACK_RETVAL in module ida_hexrays:

    the return value is on the stack

Documentation on variable MBA2_HAS_OUTLINES in module ida_hexrays:

    calls to outlined code have been inlined

Documentation on variable MBA2_NO_FRAME in module ida_hexrays:

    do not use function frame info (only snippet mode)

Documentation on variable MBA2_DONT_VERIFY in module ida_hexrays:

    Do not verify microcode. This flag is recomended to be set only when debugging
    decompiler plugins

Documentation on variable NALT_VD in module ida_hexrays:

    this index is not used by ida

Documentation on variable LOCOPT_ALL in module ida_hexrays:

    redo optimization for all blocks. if this bit is not set, only dirty blocks will
    be optimized

Documentation on variable LOCOPT_REFINE in module ida_hexrays:

    refine return type, ok to fail

Documentation on variable LOCOPT_REFINE2 in module ida_hexrays:

    refine return type, try harder

Documentation on variable ACFL_LOCOPT in module ida_hexrays:

    perform local propagation (requires ACFL_BLKOPT)

Documentation on variable ACFL_BLKOPT in module ida_hexrays:

    perform interblock transformations

Documentation on variable ACFL_GLBPROP in module ida_hexrays:

    perform global propagation

Documentation on variable ACFL_GLBDEL in module ida_hexrays:

    perform dead code eliminition

Documentation on variable ACFL_GUESS in module ida_hexrays:

    may guess calling conventions

Documentation on variable CPBLK_FAST in module ida_hexrays:

    do not update minbstkref and minbargref

Documentation on variable CPBLK_MINREF in module ida_hexrays:

    update minbstkref and minbargref

Documentation on variable CPBLK_OPTJMP in module ida_hexrays:

    del the jump insn at the end of the block if it becomes useless

Documentation on variable GC_REGS_AND_STKVARS in module ida_hexrays:

    registers and stkvars (restricted memory only)

Documentation on variable GC_ASR in module ida_hexrays:

    all the above and assertions

Documentation on variable GC_XDSU in module ida_hexrays:

    only registers calculated with FULL_XDSU

Documentation on variable GC_END in module ida_hexrays:

    number of chain types

Documentation on variable GC_DIRTY_ALL in module ida_hexrays:

    bitmask to represent all chains

Documentation on variable OPF_REUSE in module ida_hexrays:

    reuse existing window

Documentation on variable OPF_NEW_WINDOW in module ida_hexrays:

    open new window

Documentation on variable OPF_REUSE_ACTIVE in module ida_hexrays:

    reuse existing window, only if the currently active widget is a pseudocode view

Documentation on variable OPF_NO_WAIT in module ida_hexrays:

    do not display waitbox if decompilation happens

Documentation on variable VDRUN_NEWFILE in module ida_hexrays:

    Create a new file or overwrite existing file.

Documentation on variable VDRUN_APPEND in module ida_hexrays:

    Create a new file or append to existing file.

Documentation on variable VDRUN_ONLYNEW in module ida_hexrays:

    Fail if output file already exists.

Documentation on variable VDRUN_SILENT in module ida_hexrays:

    Silent decompilation.

Documentation on variable VDRUN_SENDIDB in module ida_hexrays:

    Send problematic databases to hex-rays.com.

Documentation on variable VDRUN_MAYSTOP in module ida_hexrays:

    The user can cancel decompilation.

Documentation on variable VDRUN_CMDLINE in module ida_hexrays:

    Called from ida's command line.

Documentation on variable VDRUN_STATS in module ida_hexrays:

    Print statistics into vd_stats.txt.

Documentation on variable VDRUN_LUMINA in module ida_hexrays:

    Use lumina server.

Documentation on variable hexrays_failure_t.code in module ida_hexrays:

    Microcode error codes

Documentation on variable hexrays_failure_t.errea in module ida_hexrays:

    associated address

Documentation on variable hexrays_failure_t.str in module ida_hexrays:

    string information

Documentation on variable gco_info_t.name in module ida_hexrays:

    register or stkvar name

Documentation on variable gco_info_t.stkoff in module ida_hexrays:

    if stkvar, stack offset

Documentation on variable gco_info_t.regnum in module ida_hexrays:

    if register, the register id

Documentation on variable gco_info_t.size in module ida_hexrays:

    operand size

Documentation on variable GCO_STK in module ida_hexrays:

    a stack variable

Documentation on variable GCO_REG in module ida_hexrays:

    is register? otherwise a stack variable

Documentation on variable GCO_USE in module ida_hexrays:

    is source operand?

Documentation on variable GCO_DEF in module ida_hexrays:

    is destination operand?

Documentation on variable cot_comma in module ida_hexrays:

    x, y

Documentation on variable cot_asg in module ida_hexrays:

    x = y

Documentation on variable cot_asgbor in module ida_hexrays:

    x |= y

Documentation on variable cot_asgxor in module ida_hexrays:

    x ^= y

Documentation on variable cot_asgband in module ida_hexrays:

    x &= y

Documentation on variable cot_asgadd in module ida_hexrays:

    x += y

Documentation on variable cot_asgsub in module ida_hexrays:

    x -= y

Documentation on variable cot_asgmul in module ida_hexrays:

    x *= y

Documentation on variable cot_asgsshr in module ida_hexrays:

    x >>= y signed

Documentation on variable cot_asgushr in module ida_hexrays:

    x >>= y unsigned

Documentation on variable cot_asgshl in module ida_hexrays:

    x <<= y

Documentation on variable cot_asgsdiv in module ida_hexrays:

    x /= y signed

Documentation on variable cot_asgudiv in module ida_hexrays:

    x /= y unsigned

Documentation on variable cot_asgsmod in module ida_hexrays:

    x %= y signed

Documentation on variable cot_asgumod in module ida_hexrays:

    x %= y unsigned

Documentation on variable cot_tern in module ida_hexrays:

    x ? y : z

Documentation on variable cot_lor in module ida_hexrays:

    x || y

Documentation on variable cot_land in module ida_hexrays:

    x && y

Documentation on variable cot_bor in module ida_hexrays:

    x | y

Documentation on variable cot_xor in module ida_hexrays:

    x ^ y

Documentation on variable cot_band in module ida_hexrays:

    x & y

Documentation on variable cot_eq in module ida_hexrays:

    x == y int or fpu (see EXFL_FPOP)

Documentation on variable cot_ne in module ida_hexrays:

    x != y int or fpu (see EXFL_FPOP)

Documentation on variable cot_sge in module ida_hexrays:

    x >= y signed or fpu (see EXFL_FPOP)

Documentation on variable cot_uge in module ida_hexrays:

    x >= y unsigned

Documentation on variable cot_sle in module ida_hexrays:

    x <= y signed or fpu (see EXFL_FPOP)

Documentation on variable cot_ule in module ida_hexrays:

    x <= y unsigned

Documentation on variable cot_sgt in module ida_hexrays:

    x > y signed or fpu (see EXFL_FPOP)

Documentation on variable cot_ugt in module ida_hexrays:

    x > y unsigned

Documentation on variable cot_slt in module ida_hexrays:

    x < y signed or fpu (see EXFL_FPOP)

Documentation on variable cot_ult in module ida_hexrays:

    x < y unsigned

Documentation on variable cot_sshr in module ida_hexrays:

    x >> y signed

Documentation on variable cot_ushr in module ida_hexrays:

    x >> y unsigned

Documentation on variable cot_shl in module ida_hexrays:

    x << y

Documentation on variable cot_add in module ida_hexrays:

    x + y

Documentation on variable cot_sub in module ida_hexrays:

    x - y

Documentation on variable cot_mul in module ida_hexrays:

    x * y

Documentation on variable cot_sdiv in module ida_hexrays:

    x / y signed

Documentation on variable cot_udiv in module ida_hexrays:

    x / y unsigned

Documentation on variable cot_smod in module ida_hexrays:

    x % y signed

Documentation on variable cot_umod in module ida_hexrays:

    x % y unsigned

Documentation on variable cot_fadd in module ida_hexrays:

    x + y fp

Documentation on variable cot_fsub in module ida_hexrays:

    x - y fp

Documentation on variable cot_fmul in module ida_hexrays:

    x * y fp

Documentation on variable cot_fdiv in module ida_hexrays:

    x / y fp

Documentation on variable cot_fneg in module ida_hexrays:

    -x fp

Documentation on variable cot_neg in module ida_hexrays:

    -x

Documentation on variable cot_cast in module ida_hexrays:

    (type)x

Documentation on variable cot_lnot in module ida_hexrays:

    !x

Documentation on variable cot_bnot in module ida_hexrays:

    ~x

Documentation on variable cot_ptr in module ida_hexrays:

    *x, access size in 'ptrsize'

Documentation on variable cot_ref in module ida_hexrays:

    &x

Documentation on variable cot_postinc in module ida_hexrays:

    x++

Documentation on variable cot_postdec in module ida_hexrays:

    x-

Documentation on variable cot_preinc in module ida_hexrays:

    ++x

Documentation on variable cot_predec in module ida_hexrays:

    -x

Documentation on variable cot_call in module ida_hexrays:

    x(...)

Documentation on variable cot_idx in module ida_hexrays:

    x[y]

Documentation on variable cot_memref in module ida_hexrays:

    x.m

Documentation on variable cot_memptr in module ida_hexrays:

    x->m, access size in 'ptrsize'

Documentation on variable cot_num in module ida_hexrays:

    n

Documentation on variable cot_fnum in module ida_hexrays:

    fpc

Documentation on variable cot_str in module ida_hexrays:

    string constant (user representation)

Documentation on variable cot_obj in module ida_hexrays:

    obj_ea

Documentation on variable cot_var in module ida_hexrays:

    v

Documentation on variable cot_insn in module ida_hexrays:

    instruction in expression, internal representation only

Documentation on variable cot_sizeof in module ida_hexrays:

    sizeof(x)

Documentation on variable cot_helper in module ida_hexrays:

    arbitrary name

Documentation on variable cot_type in module ida_hexrays:

    arbitrary type

Documentation on variable cit_empty in module ida_hexrays:

    instruction types start here

Documentation on variable cit_block in module ida_hexrays:

    block-statement: { ... }

Documentation on variable cit_expr in module ida_hexrays:

    expression-statement: expr;

Documentation on variable cit_if in module ida_hexrays:

    if-statement

Documentation on variable cit_for in module ida_hexrays:

    for-statement

Documentation on variable cit_while in module ida_hexrays:

    while-statement

Documentation on variable cit_do in module ida_hexrays:

    do-statement

Documentation on variable cit_switch in module ida_hexrays:

    switch-statement

Documentation on variable cit_break in module ida_hexrays:

    break-statement

Documentation on variable cit_continue in module ida_hexrays:

    continue-statement

Documentation on variable cit_return in module ida_hexrays:

    return-statement

Documentation on variable cit_goto in module ida_hexrays:

    goto-statement

Documentation on variable cit_asm in module ida_hexrays:

    asm-statement

Documentation on variable cnumber_t._value in module ida_hexrays:

    its value

Documentation on variable cnumber_t.nf in module ida_hexrays:

    how to represent it

Documentation on variable var_ref_t.mba in module ida_hexrays:

    pointer to the underlying micro array

Documentation on variable var_ref_t.idx in module ida_hexrays:

    index into lvars_t

Documentation on variable ctree_visitor_t.cv_flags in module ida_hexrays:

    Ctree visitor property bits

Documentation on variable ctree_visitor_t.parents in module ida_hexrays:

    Vector of parents of the current item.

Documentation on variable CV_FAST in module ida_hexrays:

    do not maintain parent information

Documentation on variable CV_PRUNE in module ida_hexrays:

    this bit is set by visit...() to prune the walk

Documentation on variable CV_PARENTS in module ida_hexrays:

    maintain parent information

Documentation on variable CV_POST in module ida_hexrays:

    call the leave...() functions

Documentation on variable CV_RESTART in module ida_hexrays:

    restart enumeration at the top expr (apply_to_exprs)

Documentation on variable CV_INSNS in module ida_hexrays:

    visit only statements, prune all expressions do not use before the final ctree
    maturity because expressions may contain statements at intermediate stages (see
    cot_insn). Otherwise you risk missing statements embedded into expressions.

Documentation on variable cfunc_parentee_t.func in module ida_hexrays:

    Pointer to current function.

Documentation on variable CMAT_ZERO in module ida_hexrays:

    does not exist

Documentation on variable CMAT_BUILT in module ida_hexrays:

    just generated

Documentation on variable CMAT_TRANS1 in module ida_hexrays:

    applied first wave of transformations

Documentation on variable CMAT_NICE in module ida_hexrays:

    nicefied expressions

Documentation on variable CMAT_TRANS2 in module ida_hexrays:

    applied second wave of transformations

Documentation on variable CMAT_CPA in module ida_hexrays:

    corrected pointer arithmetic

Documentation on variable CMAT_TRANS3 in module ida_hexrays:

    applied third wave of transformations

Documentation on variable CMAT_CASTED in module ida_hexrays:

    added necessary casts

Documentation on variable CMAT_FINAL in module ida_hexrays:

    ready-to-use

Documentation on variable ITP_EMPTY in module ida_hexrays:

    nothing

Documentation on variable ITP_ARG1 in module ida_hexrays:

    , (64 entries are reserved for 64 call arguments)

Documentation on variable ITP_ASM in module ida_hexrays:

    __asm-line

Documentation on variable ITP_ELSE in module ida_hexrays:

    else-line

Documentation on variable ITP_DO in module ida_hexrays:

    do-line

Documentation on variable ITP_SEMI in module ida_hexrays:

    semicolon

Documentation on variable ITP_CURLY1 in module ida_hexrays:

    {

Documentation on variable ITP_CURLY2 in module ida_hexrays:

    }

Documentation on variable ITP_BRACE2 in module ida_hexrays:

    )

Documentation on variable ITP_COLON in module ida_hexrays:

    : (label)

Documentation on variable ITP_BLOCK1 in module ida_hexrays:

    opening block comment. this comment is printed before the item (other comments
    are indented and printed after the item)

Documentation on variable ITP_BLOCK2 in module ida_hexrays:

    closing block comment.

Documentation on variable ITP_CASE in module ida_hexrays:

    bit for switch cases

Documentation on variable ITP_SIGN in module ida_hexrays:

    if this bit is set too, then we have a negative case value

Documentation on variable RETRIEVE_ONCE in module ida_hexrays:

    Retrieve comment if it has not been used yet.

Documentation on variable RETRIEVE_ALWAYS in module ida_hexrays:

    Retrieve comment even if it has been used.

Documentation on variable citem_cmt_t.used in module ida_hexrays:

    the comment has been retrieved?

Documentation on variable citem_locator_t.ea in module ida_hexrays:

    citem address

Documentation on variable citem_locator_t.op in module ida_hexrays:

    citem operation

Documentation on variable citem_t.ea in module ida_hexrays:

    address that corresponds to the item. may be BADADDR

Documentation on variable citem_t.label_num in module ida_hexrays:

    label number. -1 means no label. items of the expression types (cot_...) should
    not have labels at the final maturity level, but at the intermediate levels any
    ctree item may have a label. Labels must be unique. Usually they correspond to
    the basic block numbers.

Documentation on variable citem_t.index in module ida_hexrays:

    an index in cfunc_t::treeitems. meaningful only after print_func()

Documentation on variable citem_t.op in module ida_hexrays:

    item type

Documentation on variable cexpr_t.type in module ida_hexrays:

    expression type. must be carefully maintained

Documentation on variable cexpr_t.exflags in module ida_hexrays:

    Expression attributes

Documentation on variable cexpr_t.v in module ida_hexrays:

    used for cot_var

Documentation on variable cexpr_t.n in module ida_hexrays:

    used for cot_num

Documentation on variable cexpr_t.fpc in module ida_hexrays:

    used for cot_fnum

Documentation on variable cexpr_t.x in module ida_hexrays:

    the first operand of the expression

Documentation on variable cexpr_t.y in module ida_hexrays:

    the second operand of the expression

Documentation on variable cexpr_t.z in module ida_hexrays:

    the third operand of the expression

Documentation on variable cexpr_t.a in module ida_hexrays:

    argument list (used for cot_call)

Documentation on variable cexpr_t.insn in module ida_hexrays:

    an embedded statement, they are prohibited at the final maturity stage
    (CMAT_FINAL)

Documentation on variable cexpr_t.m in module ida_hexrays:

    member offset (used for cot_memptr, cot_memref) for unions, the member number

Documentation on variable cexpr_t.ptrsize in module ida_hexrays:

    memory access size (used for cot_ptr, cot_memptr)

Documentation on variable cexpr_t.obj_ea in module ida_hexrays:

    used for cot_obj

Documentation on variable cexpr_t.refwidth in module ida_hexrays:

    how many bytes are accessed? (-1: none)

Documentation on variable cexpr_t.helper in module ida_hexrays:

    helper name (used for cot_helper)

Documentation on variable cexpr_t.string in module ida_hexrays:

    utf8 string constant, user representation (used for cot_str)

Documentation on variable EXFL_CPADONE in module ida_hexrays:

    pointer arithmetic correction done

Documentation on variable EXFL_LVALUE in module ida_hexrays:

    expression is lvalue even if it doesn't look like it

Documentation on variable EXFL_FPOP in module ida_hexrays:

    floating point operation

Documentation on variable EXFL_ALONE in module ida_hexrays:

    standalone helper

Documentation on variable EXFL_CSTR in module ida_hexrays:

    string literal

Documentation on variable EXFL_PARTIAL in module ida_hexrays:

    type of the expression is considered partial

Documentation on variable EXFL_UNDEF in module ida_hexrays:

    expression uses undefined value

Documentation on variable EXFL_JUMPOUT in module ida_hexrays:

    jump out-of-function

Documentation on variable EXFL_VFTABLE in module ida_hexrays:

    is ptr to vftable (used for cot_memptr, cot_memref)

Documentation on variable EXFL_ALL in module ida_hexrays:

    all currently defined bits

Documentation on variable ceinsn_t.expr in module ida_hexrays:

    Expression of the statement.

Documentation on variable CALC_CURLY_BRACES in module ida_hexrays:

    print curly braces if necessary

Documentation on variable NO_CURLY_BRACES in module ida_hexrays:

    don't print curly braces

Documentation on variable USE_CURLY_BRACES in module ida_hexrays:

    print curly braces without any checks

Documentation on variable cif_t.ithen in module ida_hexrays:

    Then-branch of the if-statement.

Documentation on variable cif_t.ielse in module ida_hexrays:

    Else-branch of the if-statement. May be nullptr.

Documentation on variable cfor_t.init in module ida_hexrays:

    Initialization expression.

Documentation on variable cfor_t.step in module ida_hexrays:

    Step expression.

Documentation on variable cgoto_t.label_num in module ida_hexrays:

    Target label number.

Documentation on variable cinsn_t.cblock in module ida_hexrays:

    details of block-statement

Documentation on variable cinsn_t.cexpr in module ida_hexrays:

    details of expression-statement

Documentation on variable cinsn_t.cif in module ida_hexrays:

    details of if-statement

Documentation on variable cinsn_t.cfor in module ida_hexrays:

    details of for-statement

Documentation on variable cinsn_t.cwhile in module ida_hexrays:

    details of while-statement

Documentation on variable cinsn_t.cdo in module ida_hexrays:

    details of do-statement

Documentation on variable cinsn_t.cswitch in module ida_hexrays:

    details of switch-statement

Documentation on variable cinsn_t.creturn in module ida_hexrays:

    details of return-statement

Documentation on variable cinsn_t.cgoto in module ida_hexrays:

    details of goto-statement

Documentation on variable cinsn_t.casm in module ida_hexrays:

    details of asm-statement

Documentation on variable carg_t.is_vararg in module ida_hexrays:

    is a vararg (matches ...)

Documentation on variable carg_t.formal_type in module ida_hexrays:

    formal parameter type (if known)

Documentation on variable carglist_t.functype in module ida_hexrays:

    function object type

Documentation on variable carglist_t.flags in module ida_hexrays:

    call flags

Documentation on variable CFL_FINAL in module ida_hexrays:

    call type is final, should not be changed

Documentation on variable CFL_HELPER in module ida_hexrays:

    created from a decompiler helper function

Documentation on variable CFL_NORET in module ida_hexrays:

    call does not return

Documentation on variable ccase_t.values in module ida_hexrays:

    List of case values. if empty, then 'default' case

Documentation on variable cswitch_t.mvnf in module ida_hexrays:

    Maximal switch value and number format.

Documentation on variable cswitch_t.cases in module ida_hexrays:

    Switch cases: values and instructions.

Documentation on variable ANCHOR_CITEM in module ida_hexrays:

    c-tree item

Documentation on variable ANCHOR_LVAR in module ida_hexrays:

    declaration of local variable

Documentation on variable ANCHOR_ITP in module ida_hexrays:

    item type preciser

Documentation on variable ANCHOR_BLKCMT in module ida_hexrays:

    block comment (for ctree items)

Documentation on variable VDI_NONE in module ida_hexrays:

    undefined

Documentation on variable VDI_EXPR in module ida_hexrays:

    c-tree item

Documentation on variable VDI_LVAR in module ida_hexrays:

    declaration of local variable

Documentation on variable VDI_FUNC in module ida_hexrays:

    the function itself (the very first line with the function prototype)

Documentation on variable VDI_TAIL in module ida_hexrays:

    cursor is at (beyond) the line end (commentable line)

Documentation on variable ctree_item_t.citype in module ida_hexrays:

    Item type.

Documentation on variable GLN_CURRENT in module ida_hexrays:

    get label of the current item

Documentation on variable GLN_GOTO_TARGET in module ida_hexrays:

    get goto target

Documentation on variable GLN_ALL in module ida_hexrays:

    get both

Documentation on variable FORBID_UNUSED_LABELS in module ida_hexrays:

    Unused labels cause interr.

Documentation on variable ALLOW_UNUSED_LABELS in module ida_hexrays:

    Unused labels are permitted.

Documentation on variable cfunc_t.entry_ea in module ida_hexrays:

    function entry address

Documentation on variable cfunc_t.mba in module ida_hexrays:

    underlying microcode

Documentation on variable cfunc_t.body in module ida_hexrays:

    function body, must be a block

Documentation on variable cfunc_t.argidx in module ida_hexrays:

    list of arguments (indexes into vars)

Documentation on variable cfunc_t.maturity in module ida_hexrays:

    maturity level

Documentation on variable cfunc_t.user_labels in module ida_hexrays:

    user-defined labels.

Documentation on variable cfunc_t.user_cmts in module ida_hexrays:

    user-defined comments.

Documentation on variable cfunc_t.numforms in module ida_hexrays:

    user-defined number formats.

Documentation on variable cfunc_t.user_iflags in module ida_hexrays:

    user-defined item flags ctree item iflags bits

Documentation on variable cfunc_t.user_unions in module ida_hexrays:

    user-defined union field selections.

Documentation on variable cfunc_t.refcnt in module ida_hexrays:

    reference count to this object. use cfuncptr_t

Documentation on variable cfunc_t.statebits in module ida_hexrays:

    current cfunc_t state. see cfunc state bits

Documentation on variable cfunc_t.hdrlines in module ida_hexrays:

    number of lines in the declaration area

Documentation on variable cfunc_t.treeitems in module ida_hexrays:

    vector of ctree items

Documentation on variable CIT_COLLAPSED in module ida_hexrays:

    display ctree item in collapsed form

Documentation on variable CFS_BOUNDS in module ida_hexrays:

    'eamap' and 'boundaries' are ready

Documentation on variable CFS_TEXT in module ida_hexrays:

    'sv' is ready (and hdrlines)

Documentation on variable CFS_LVARS_HIDDEN in module ida_hexrays:

    local variable definitions are collapsed

Documentation on variable CFS_LOCKED in module ida_hexrays:

    cfunc is temporarily locked

Documentation on variable DECOMP_NO_WAIT in module ida_hexrays:

    do not display waitbox

Documentation on variable DECOMP_NO_CACHE in module ida_hexrays:

    do not use decompilation cache

Documentation on variable DECOMP_NO_FRAME in module ida_hexrays:

    do not use function frame info (only snippet mode)

Documentation on variable DECOMP_WARNINGS in module ida_hexrays:

    display warnings in the output window

Documentation on variable DECOMP_ALL_BLKS in module ida_hexrays:

    generate microcode for unreachable blocks

Documentation on variable DECOMP_NO_HIDE in module ida_hexrays:

    do not close display waitbox. see close_hexrays_waitboxes()

Documentation on variable DECOMP_NO_XREFS in module ida_hexrays:

    do not update global xrefs cache

Documentation on variable hxe_flowchart in module ida_hexrays:

    Flowchart has been generated.

Documentation on variable hxe_stkpnts in module ida_hexrays:

    SP change points have been calculated.

Documentation on variable hxe_prolog in module ida_hexrays:

    Prolog analysis has been finished.

Documentation on variable hxe_microcode in module ida_hexrays:

    Microcode has been generated.

Documentation on variable hxe_preoptimized in module ida_hexrays:

    Microcode has been preoptimized.

Documentation on variable hxe_locopt in module ida_hexrays:

    Basic block level optimization has been finished.

Documentation on variable hxe_prealloc in module ida_hexrays:

    Local variables: preallocation step begins.

Documentation on variable hxe_glbopt in module ida_hexrays:

    Global optimization has been finished. If microcode is modified, MERR_LOOP must
    be returned. It will cause a complete restart of the optimization.

Documentation on variable hxe_structural in module ida_hexrays:

    Structural analysis has been finished.

Documentation on variable hxe_maturity in module ida_hexrays:

    Ctree maturity level is being changed.

Documentation on variable hxe_interr in module ida_hexrays:

    Internal error has occurred.

Documentation on variable hxe_combine in module ida_hexrays:

    Trying to combine instructions of basic block.

Documentation on variable hxe_print_func in module ida_hexrays:

    Printing ctree and generating text.

Documentation on variable hxe_func_printed in module ida_hexrays:

    Function text has been generated. Plugins may modify the text in cfunc_t::sv.
    The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store
    pointers to ctree items.

Documentation on variable hxe_resolve_stkaddrs in module ida_hexrays:

    The optimizer is about to resolve stack addresses.

Documentation on variable hxe_build_callinfo in module ida_hexrays:

    Analyzing a call instruction.

Documentation on variable hxe_open_pseudocode in module ida_hexrays:

    New pseudocode view has been opened.

Documentation on variable hxe_switch_pseudocode in module ida_hexrays:

    Existing pseudocode view has been reloaded with a new function. Its text has not
    been refreshed yet, only cfunc and mba pointers are ready.

Documentation on variable hxe_refresh_pseudocode in module ida_hexrays:

    Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is
    forbidden in this event.

Documentation on variable hxe_close_pseudocode in module ida_hexrays:

    Pseudocode view is being closed.

Documentation on variable hxe_keyboard in module ida_hexrays:

    Keyboard has been hit.

Documentation on variable hxe_right_click in module ida_hexrays:

    Mouse right click. Use hxe_populating_popup instead, in case you want to add
    items in the popup menu.

Documentation on variable hxe_double_click in module ida_hexrays:

    Mouse double click.

Documentation on variable hxe_curpos in module ida_hexrays:

    Current cursor position has been changed. (for example, by left-clicking or
    using keyboard)

Documentation on variable hxe_create_hint in module ida_hexrays:

    Create a hint for the current item.
    @see: ui_get_custom_viewer_hint
    
    @retval 0: continue collecting hints with other subscribers
    @retval 1: stop collecting hints

Documentation on variable hxe_text_ready in module ida_hexrays:

    Decompiled text is ready.

Documentation on variable hxe_populating_popup in module ida_hexrays:

    Populating popup menu. We can add menu items now.

Documentation on variable lxe_lvar_name_changed in module ida_hexrays:

    Local variable got renamed.

Documentation on variable lxe_lvar_type_changed in module ida_hexrays:

    Local variable type got changed.

Documentation on variable lxe_lvar_cmt_changed in module ida_hexrays:

    Local variable comment got changed.

Documentation on variable lxe_lvar_mapping_changed in module ida_hexrays:

    Local variable mapping got changed.

Documentation on variable hxe_cmt_changed in module ida_hexrays:

    Comment got changed.

Documentation on variable USE_KEYBOARD in module ida_hexrays:

    Keyboard.

Documentation on variable USE_MOUSE in module ida_hexrays:

    Mouse.

Documentation on variable ctext_position_t.lnnum in module ida_hexrays:

    Line number.

Documentation on variable ctext_position_t.x in module ida_hexrays:

    x coordinate of the cursor within the window

Documentation on variable ctext_position_t.y in module ida_hexrays:

    y coordinate of the cursor within the window

Documentation on variable history_item_t.ea in module ida_hexrays:

    The entry address of the decompiled function.

Documentation on variable history_item_t.end in module ida_hexrays:

    BADADDR-decompile function; otherwise end of the range.

Documentation on variable vdui_t.flags in module ida_hexrays:

    Properties of pseudocode window

Documentation on variable vdui_t.view_idx in module ida_hexrays:

    pseudocode window index (0..)

Documentation on variable vdui_t.ct in module ida_hexrays:

    pseudocode view

Documentation on variable vdui_t.mba in module ida_hexrays:

    pointer to underlying microcode

Documentation on variable vdui_t.cfunc in module ida_hexrays:

    pointer to function object

Documentation on variable vdui_t.last_code in module ida_hexrays:

    result of the last user action. See Microcode error codes

Documentation on variable vdui_t.cpos in module ida_hexrays:

    Current ctext position.

Documentation on variable vdui_t.head in module ida_hexrays:

    First ctree item on the current line (for block comments)

Documentation on variable vdui_t.item in module ida_hexrays:

    Current ctree item.

Documentation on variable vdui_t.tail in module ida_hexrays:

    Tail ctree item on the current line (for indented comments)

Documentation on variable CMT_NONE in module ida_hexrays:

    No comment is possible.

Documentation on variable CMT_TAIL in module ida_hexrays:

    Indented comment.

Documentation on variable CMT_BLOCK1 in module ida_hexrays:

    Anterioir block comment.

Documentation on variable CMT_BLOCK2 in module ida_hexrays:

    Posterior block comment.

Documentation on variable CMT_LVAR in module ida_hexrays:

    Local variable comment.

Documentation on variable CMT_FUNC in module ida_hexrays:

    Function comment.

Documentation on variable CMT_ALL in module ida_hexrays:

    All comments.

Documentation on variable VDUI_VISIBLE in module ida_hexrays:

    is visible?

Documentation on variable VDUI_VALID in module ida_hexrays:

    is valid?

Documentation on variable ui_stroff_op_t.text in module ida_hexrays:

    any text for the column "Operand" of widget

Documentation on variable ui_stroff_op_t.offset in module ida_hexrays:

    operand offset, will be used when calculating the UDT path

Documentation on variable AF_FINAL in module ida_ida:

    Final pass of analysis.

Documentation on variable f_EXE_old in module ida_ida:

    MS DOS EXE File.

Documentation on variable f_COM_old in module ida_ida:

    MS DOS COM File.

Documentation on variable f_BIN in module ida_ida:

    Binary File.

Documentation on variable f_DRV in module ida_ida:

    MS DOS Driver.

Documentation on variable f_WIN in module ida_ida:

    New Executable (NE)

Documentation on variable f_HEX in module ida_ida:

    Intel Hex Object File.

Documentation on variable f_MEX in module ida_ida:

    MOS Technology Hex Object File.

Documentation on variable f_LX in module ida_ida:

    Linear Executable (LX)

Documentation on variable f_LE in module ida_ida:

    Linear Executable (LE)

Documentation on variable f_NLM in module ida_ida:

    Netware Loadable Module (NLM)

Documentation on variable f_COFF in module ida_ida:

    Common Object File Format (COFF)

Documentation on variable f_PE in module ida_ida:

    Portable Executable (PE)

Documentation on variable f_OMF in module ida_ida:

    Object Module Format.

Documentation on variable f_SREC in module ida_ida:

    Motorola SREC (S-record)

Documentation on variable f_ZIP in module ida_ida:

    ZIP file (this file is never loaded to IDA database)

Documentation on variable f_OMFLIB in module ida_ida:

    Library of OMF Modules.

Documentation on variable f_AR in module ida_ida:

    ar library

Documentation on variable f_LOADER in module ida_ida:

    file is loaded using LOADER DLL

Documentation on variable f_ELF in module ida_ida:

    Executable and Linkable Format (ELF)

Documentation on variable f_W32RUN in module ida_ida:

    Watcom DOS32 Extender (W32RUN)

Documentation on variable f_AOUT in module ida_ida:

    Linux a.out (AOUT)

Documentation on variable f_PRC in module ida_ida:

    PalmPilot program file.

Documentation on variable f_EXE in module ida_ida:

    MS DOS EXE File.

Documentation on variable f_COM in module ida_ida:

    MS DOS COM File.

Documentation on variable f_AIXAR in module ida_ida:

    AIX ar library.

Documentation on variable f_MACHO in module ida_ida:

    Mac OS X Mach-O.

Documentation on variable f_PSXOBJ in module ida_ida:

    Sony Playstation PSX object file.

Documentation on variable compiler_info_t.id in module ida_ida:

    compiler id (see Compiler IDs)

Documentation on variable compiler_info_t.cm in module ida_ida:

    memory model and calling convention (see CM)

Documentation on variable compiler_info_t.size_i in module ida_ida:

    sizeof(int)

Documentation on variable compiler_info_t.size_b in module ida_ida:

    sizeof(bool)

Documentation on variable compiler_info_t.size_e in module ida_ida:

    sizeof(enum)

Documentation on variable compiler_info_t.defalign in module ida_ida:

    default alignment for structures

Documentation on variable compiler_info_t.size_s in module ida_ida:

    short

Documentation on variable compiler_info_t.size_l in module ida_ida:

    long

Documentation on variable compiler_info_t.size_ll in module ida_ida:

    longlong

Documentation on variable compiler_info_t.size_ldbl in module ida_ida:

    longdouble (if different from processor_t::tbyte_size)

Documentation on variable STT_CUR in module ida_ida:

    use current storage type (may be used only as a function argument)

Documentation on variable STT_VA in module ida_ida:

    regular storage: virtual arrays, an explicit flag for each byte

Documentation on variable STT_MM in module ida_ida:

    memory map: sparse storage. useful for huge objects

Documentation on variable STT_DBG in module ida_ida:

    memory map: temporary debugger storage. used internally

Documentation on variable IDAINFO_TAG_SIZE in module ida_ida:

    The database parameters. This structure is kept in the ida database. It contains
    the essential parameters for the current program

Documentation on variable idainfo.tag in module ida_ida:

    'IDA'

Documentation on variable idainfo.version in module ida_ida:

    Version of database.

Documentation on variable idainfo.procname in module ida_ida:

    Name of the current processor (with \0)

Documentation on variable idainfo.s_genflags in module ida_ida:

    General idainfo flags

Documentation on variable idainfo.database_change_count in module ida_ida:

    incremented after each byte and regular segment modifications

Documentation on variable idainfo.filetype in module ida_ida:

    The input file type.

Documentation on variable idainfo.ostype in module ida_ida:

    OS type the program is for bit definitions in libfuncs.hpp

Documentation on variable idainfo.apptype in module ida_ida:

    Application type bit definitions in libfuncs.hpp

Documentation on variable idainfo.asmtype in module ida_ida:

    target assembler number

Documentation on variable idainfo.specsegs in module ida_ida:

    What format do special segments use? 0-unspecified, 4-entries are 4 bytes, 8-
    entries are 8 bytes.

Documentation on variable idainfo.af in module ida_ida:

    Analysis flags

Documentation on variable idainfo.af2 in module ida_ida:

    Analysis flags 2

Documentation on variable idainfo.baseaddr in module ida_ida:

    remaining 29 bits are reserved
    
    base address of the program (paragraphs)

Documentation on variable idainfo.start_ss in module ida_ida:

    selector of the initial stack segment

Documentation on variable idainfo.start_cs in module ida_ida:

    selector of the segment with the main entry point

Documentation on variable idainfo.start_ip in module ida_ida:

    IP register value at the start of program execution

Documentation on variable idainfo.start_ea in module ida_ida:

    Linear address of program entry point.

Documentation on variable idainfo.start_sp in module ida_ida:

    SP register value at the start of program execution

Documentation on variable idainfo.main in module ida_ida:

    address of main()

Documentation on variable idainfo.min_ea in module ida_ida:

    current limits of program

Documentation on variable idainfo.max_ea in module ida_ida:

    maxEA is excluded

Documentation on variable idainfo.omin_ea in module ida_ida:

    original minEA (is set after loading the input file)

Documentation on variable idainfo.omax_ea in module ida_ida:

    original maxEA (is set after loading the input file)

Documentation on variable idainfo.lowoff in module ida_ida:

    Low limit for offsets (used in calculation of 'void' operands)

Documentation on variable idainfo.highoff in module ida_ida:

    High limit for offsets (used in calculation of 'void' operands)

Documentation on variable idainfo.maxref in module ida_ida:

    Max tail for references.

Documentation on variable idainfo.xrefnum in module ida_ida:

    CROSS REFERENCES.
    
    Number of references to generate in the disassembly listing 0 - xrefs won't be
    generated at all

Documentation on variable idainfo.type_xrefnum in module ida_ida:

    Number of references to generate in the struct & enum windows 0 - xrefs won't be
    generated at all

Documentation on variable idainfo.refcmtnum in module ida_ida:

    Number of comment lines to generate for refs to string literals or demangled
    names 0 - such comments won't be generated at all

Documentation on variable idainfo.s_xrefflag in module ida_ida:

    Xref options

Documentation on variable idainfo.max_autoname_len in module ida_ida:

    NAMES.
    
    max autogenerated name length (without zero byte)

Documentation on variable idainfo.nametype in module ida_ida:

    Dummy names representation types

Documentation on variable idainfo.short_demnames in module ida_ida:

    short form of demangled names

Documentation on variable idainfo.long_demnames in module ida_ida:

    long form of demangled names see demangle.h for definitions

Documentation on variable idainfo.demnames in module ida_ida:

    Demangled name flags

Documentation on variable idainfo.listnames in module ida_ida:

    Name list options

Documentation on variable idainfo.indent in module ida_ida:

    DISASSEMBLY LISTING DETAILS.
    
    Indentation for instructions

Documentation on variable idainfo.cmt_indent in module ida_ida:

    Indentation for comments.

Documentation on variable idainfo.margin in module ida_ida:

    max length of data lines

Documentation on variable idainfo.lenxref in module ida_ida:

    max length of line with xrefs

Documentation on variable idainfo.outflags in module ida_ida:

    output flags

Documentation on variable idainfo.s_cmtflg in module ida_ida:

    Comment options

Documentation on variable idainfo.s_limiter in module ida_ida:

    Delimiter options

Documentation on variable idainfo.bin_prefix_size in module ida_ida:

    Number of instruction bytes (opcodes) to show in line prefix.

Documentation on variable idainfo.s_prefflag in module ida_ida:

    Line prefix options

Documentation on variable idainfo.strlit_flags in module ida_ida:

    STRING LITERALS.
    
    string literal flags

Documentation on variable idainfo.strlit_break in module ida_ida:

    string literal line break symbol

Documentation on variable idainfo.strlit_zeroes in module ida_ida:

    leading zeroes

Documentation on variable idainfo.strtype in module ida_ida:

    current ascii string type see nalt.hpp for string types

Documentation on variable idainfo.strlit_pref in module ida_ida:

    prefix for string literal names

Documentation on variable idainfo.strlit_sernum in module ida_ida:

    serial number

Documentation on variable idainfo.datatypes in module ida_ida:

    data types allowed in data carousel

Documentation on variable idainfo.cc in module ida_ida:

    COMPILER.
    
    Target compiler

Documentation on variable idainfo.abibits in module ida_ida:

    ABI features. Depends on info returned by get_abi_name() Processor modules may
    modify them in set_compiler

Documentation on variable idainfo.appcall_options in module ida_ida:

    appcall options, see idd.hpp

Documentation on variable idainfo.lflags in module ida_ida:

    Misc. database flags

Documentation on variable INFFL_AUTO in module ida_ida:

    Autoanalysis is enabled?

Documentation on variable INFFL_ALLASM in module ida_ida:

    may use constructs not supported by the target assembler

Documentation on variable INFFL_LOADIDC in module ida_ida:

    loading an idc file that contains database info

Documentation on variable INFFL_NOUSER in module ida_ida:

    do not store user info in the database

Documentation on variable INFFL_READONLY in module ida_ida:

    (internal) temporary interdiction to modify the database

Documentation on variable INFFL_CHKOPS in module ida_ida:

    check manual operands? (unused)

Documentation on variable INFFL_NMOPS in module ida_ida:

    allow non-matched operands? (unused)

Documentation on variable INFFL_GRAPH_VIEW in module ida_ida:

    currently using graph options ( text_options_t::graph)

Documentation on variable LFLG_PC_FPP in module ida_ida:

    decode floating point processor instructions?

Documentation on variable LFLG_PC_FLAT in module ida_ida:

    32-bit program (or higher)?

Documentation on variable LFLG_64BIT in module ida_ida:

    64-bit program?

Documentation on variable LFLG_IS_DLL in module ida_ida:

    Is dynamic library?

Documentation on variable LFLG_FLAT_OFF32 in module ida_ida:

    treat REF_OFF32 as 32-bit offset for 16bit segments (otherwise try SEG16:OFF16)

Documentation on variable LFLG_MSF in module ida_ida:

    Byte order: is MSB first?

Documentation on variable LFLG_WIDE_HBF in module ida_ida:

    Bit order of wide bytes: high byte first? (wide bytes: processor_t::dnbits > 8)

Documentation on variable LFLG_DBG_NOPATH in module ida_ida:

    do not store input full path in debugger process options

Documentation on variable LFLG_SNAPSHOT in module ida_ida:

    memory snapshot was taken?

Documentation on variable LFLG_PACK in module ida_ida:

    pack the database?

Documentation on variable LFLG_COMPRESS in module ida_ida:

    compress the database?

Documentation on variable LFLG_KERNMODE in module ida_ida:

    is kernel mode binary?

Documentation on variable IDB_UNPACKED in module ida_ida:

    leave database components unpacked

Documentation on variable IDB_PACKED in module ida_ida:

    pack database components into .idb

Documentation on variable IDB_COMPRESSED in module ida_ida:

    compress & pack database components

Documentation on variable AF_CODE in module ida_ida:

    Trace execution flow.

Documentation on variable AF_MARKCODE in module ida_ida:

    Mark typical code sequences as code.

Documentation on variable AF_JUMPTBL in module ida_ida:

    Locate and create jump tables.

Documentation on variable AF_PURDAT in module ida_ida:

    Control flow to data segment is ignored.

Documentation on variable AF_USED in module ida_ida:

    Analyze and create all xrefs.

Documentation on variable AF_UNK in module ida_ida:

    Delete instructions with no xrefs.

Documentation on variable AF_PROCPTR in module ida_ida:

    Create function if data xref data->code32 exists.

Documentation on variable AF_PROC in module ida_ida:

    Create functions if call is present.

Documentation on variable AF_FTAIL in module ida_ida:

    Create function tails.

Documentation on variable AF_LVAR in module ida_ida:

    Create stack variables.

Documentation on variable AF_STKARG in module ida_ida:

    Propagate stack argument information.

Documentation on variable AF_REGARG in module ida_ida:

    Propagate register argument information.

Documentation on variable AF_TRACE in module ida_ida:

    Trace stack pointer.

Documentation on variable AF_VERSP in module ida_ida:

    Perform full SP-analysis. ( processor_t::verify_sp)

Documentation on variable AF_ANORET in module ida_ida:

    Perform 'no-return' analysis.

Documentation on variable AF_MEMFUNC in module ida_ida:

    Try to guess member function types.

Documentation on variable AF_TRFUNC in module ida_ida:

    Truncate functions upon code deletion.

Documentation on variable AF_STRLIT in module ida_ida:

    Create string literal if data xref exists.

Documentation on variable AF_CHKUNI in module ida_ida:

    Check for unicode strings.

Documentation on variable AF_FIXUP in module ida_ida:

    Create offsets and segments using fixup info.

Documentation on variable AF_DREFOFF in module ida_ida:

    Create offset if data xref to seg32 exists.

Documentation on variable AF_IMMOFF in module ida_ida:

    Convert 32bit instruction operand to offset.

Documentation on variable AF_DATOFF in module ida_ida:

    Automatically convert data to offsets.

Documentation on variable AF_FLIRT in module ida_ida:

    Use flirt signatures.

Documentation on variable AF_SIGCMT in module ida_ida:

    Append a signature name comment for recognized anonymous library functions.

Documentation on variable AF_SIGMLT in module ida_ida:

    Allow recognition of several copies of the same function.

Documentation on variable AF_HFLIRT in module ida_ida:

    Automatically hide library functions.

Documentation on variable AF_JFUNC in module ida_ida:

    Rename jump functions as j_...

Documentation on variable AF_NULLSUB in module ida_ida:

    Rename empty functions as nullsub_...

Documentation on variable AF_DODATA in module ida_ida:

    Coagulate data segs at the final pass.

Documentation on variable AF_DOCODE in module ida_ida:

    Coagulate code segs at the final pass.

Documentation on variable AF2_DOEH in module ida_ida:

    Handle EH information.

Documentation on variable AF2_DORTTI in module ida_ida:

    Handle RTTI information.

Documentation on variable AF2_MACRO in module ida_ida:

    Try to combine several instructions into a macro instruction

Documentation on variable SW_SEGXRF in module ida_ida:

    show segments in xrefs?

Documentation on variable SW_XRFMRK in module ida_ida:

    show xref type marks?

Documentation on variable SW_XRFFNC in module ida_ida:

    show function offsets?

Documentation on variable SW_XRFVAL in module ida_ida:

    show xref values? (otherwise-"...")

Documentation on variable DEMNAM_MASK in module ida_ida:

    mask for name form

Documentation on variable DEMNAM_CMNT in module ida_ida:

    display demangled names as comments

Documentation on variable DEMNAM_NAME in module ida_ida:

    display demangled names as regular names

Documentation on variable DEMNAM_NONE in module ida_ida:

    don't display demangled names

Documentation on variable DEMNAM_GCC3 in module ida_ida:

    assume gcc3 names (valid for gnu compiler)

Documentation on variable DEMNAM_FIRST in module ida_ida:

    override type info

Documentation on variable LN_NORMAL in module ida_ida:

    include normal names

Documentation on variable LN_PUBLIC in module ida_ida:

    include public names

Documentation on variable LN_AUTO in module ida_ida:

    include autogenerated names

Documentation on variable LN_WEAK in module ida_ida:

    include weak names

Documentation on variable OFLG_SHOW_VOID in module ida_ida:

    Display void marks?

Documentation on variable OFLG_SHOW_AUTO in module ida_ida:

    Display autoanalysis indicator?

Documentation on variable OFLG_GEN_NULL in module ida_ida:

    Generate empty lines?

Documentation on variable OFLG_SHOW_PREF in module ida_ida:

    Show line prefixes?

Documentation on variable OFLG_PREF_SEG in module ida_ida:

    line prefixes with segment name?

Documentation on variable OFLG_LZERO in module ida_ida:

    generate leading zeroes in numbers

Documentation on variable OFLG_GEN_ORG in module ida_ida:

    Generate 'org' directives?

Documentation on variable OFLG_GEN_ASSUME in module ida_ida:

    Generate 'assume' directives?

Documentation on variable OFLG_GEN_TRYBLKS in module ida_ida:

    Generate try/catch directives?

Documentation on variable SCF_RPTCMT in module ida_ida:

    show repeatable comments?

Documentation on variable SCF_ALLCMT in module ida_ida:

    comment all lines?

Documentation on variable SCF_NOCMT in module ida_ida:

    no comments at all

Documentation on variable SCF_LINNUM in module ida_ida:

    show source line numbers

Documentation on variable SCF_TESTMODE in module ida_ida:

    testida.idc is running

Documentation on variable SCF_SHHID_ITEM in module ida_ida:

    show hidden instructions

Documentation on variable SCF_SHHID_FUNC in module ida_ida:

    show hidden functions

Documentation on variable SCF_SHHID_SEGM in module ida_ida:

    show hidden segments

Documentation on variable LMT_THIN in module ida_ida:

    thin borders

Documentation on variable LMT_THICK in module ida_ida:

    thick borders

Documentation on variable LMT_EMPTY in module ida_ida:

    empty lines at the end of basic blocks

Documentation on variable PREF_SEGADR in module ida_ida:

    show segment addresses?

Documentation on variable PREF_FNCOFF in module ida_ida:

    show function offsets?

Documentation on variable PREF_STACK in module ida_ida:

    show stack pointer?

Documentation on variable PREF_PFXTRUNC in module ida_ida:

    truncate instruction bytes if they would need more than 1 line

Documentation on variable STRF_GEN in module ida_ida:

    generate names?

Documentation on variable STRF_AUTO in module ida_ida:

    names have 'autogenerated' bit?

Documentation on variable STRF_SERIAL in module ida_ida:

    generate serial names?

Documentation on variable STRF_UNICODE in module ida_ida:

    unicode strings are present?

Documentation on variable STRF_COMMENT in module ida_ida:

    generate auto comment for string references?

Documentation on variable STRF_SAVECASE in module ida_ida:

    preserve case of strings for identifiers

Documentation on variable ABI_8ALIGN4 in module ida_ida:

    4 byte alignment for 8byte scalars (__int64/double) inside structures?

Documentation on variable ABI_PACK_STKARGS in module ida_ida:

    do not align stack arguments to stack slots

Documentation on variable ABI_BIGARG_ALIGN in module ida_ida:

    use natural type alignment for argument if the alignment exceeds native word
    size. (e.g. __int64 argument should be 8byte aligned on some 32bit platforms)

Documentation on variable ABI_STACK_LDBL in module ida_ida:

    long double arguments are passed on stack

Documentation on variable ABI_STACK_VARARGS in module ida_ida:

    varargs are always passed on stack (even when there are free registers)

Documentation on variable ABI_HARD_FLOAT in module ida_ida:

    use the floating-point register set

Documentation on variable ABI_SET_BY_USER in module ida_ida:

    compiler/abi were set by user flag and require SETCOMP_BY_USER flag to be
    changed

Documentation on variable ABI_GCC_LAYOUT in module ida_ida:

    use gcc layout for udts (used for mingw)

Documentation on variable ABI_MAP_STKARGS in module ida_ida:

    register arguments are mapped to stack area (and consume stack slots)

Documentation on variable ABI_HUGEARG_ALIGN in module ida_ida:

    use natural type alignment for an argument even if its alignment exceeds double
    native word size (the default is to use double word max). e.g. if this bit is
    set, __int128 has 16-byte alignment. this bit is not used by ida yet

Documentation on variable INF_FILE_FORMAT_NAME in module ida_ida:

    file format name for loader modules

Documentation on variable INF_GROUPS in module ida_ida:

    segment group information (see init_groups())

Documentation on variable INF_H_PATH in module ida_ida:

    C header path.

Documentation on variable INF_C_MACROS in module ida_ida:

    C predefined macros.

Documentation on variable INF_INCLUDE in module ida_ida:

    assembler include file name

Documentation on variable INF_DUALOP_GRAPH in module ida_ida:

    Graph text representation options.

Documentation on variable INF_DUALOP_TEXT in module ida_ida:

    Text text representation options.

Documentation on variable INF_MD5 in module ida_ida:

    MD5 of the input file.

Documentation on variable INF_IDA_VERSION in module ida_ida:

    version of ida which created the database

Documentation on variable INF_STR_ENCODINGS in module ida_ida:

    a list of encodings for the program strings

Documentation on variable INF_DBG_BINPATHS in module ida_ida:

    unused (20 indexes)

Documentation on variable INF_SHA256 in module ida_ida:

    SHA256 of the input file.

Documentation on variable INF_ABINAME in module ida_ida:

    ABI name (processor specific)

Documentation on variable INF_ARCHIVE_PATH in module ida_ida:

    archive file path

Documentation on variable INF_PROBLEMS in module ida_ida:

    problem lists

Documentation on variable INF_SELECTORS in module ida_ida:

    2..63 are for selector_t blob (see init_selectors())

Documentation on variable INF_NOTEPAD in module ida_ida:

    notepad blob, occupies 1000 indexes (1MB of text)

Documentation on variable INF_SRCDBG_PATHS in module ida_ida:

    source debug paths, occupies 20 indexes

Documentation on variable INF_SRCDBG_UNDESIRED in module ida_ida:

    user-closed source files, occupies 20 indexes

Documentation on variable INF_INITIAL_VERSION in module ida_ida:

    initial version of database

Documentation on variable INF_CTIME in module ida_ida:

    database creation timestamp

Documentation on variable INF_ELAPSED in module ida_ida:

    seconds database stayed open

Documentation on variable INF_NOPENS in module ida_ida:

    how many times the database is opened

Documentation on variable INF_CRC32 in module ida_ida:

    input file crc32

Documentation on variable INF_IMAGEBASE in module ida_ida:

    image base

Documentation on variable INF_IDSNODE in module ida_ida:

    ids modnode id (for import_module)

Documentation on variable INF_FSIZE in module ida_ida:

    input file size

Documentation on variable INF_OUTFILEENC in module ida_ida:

    output file encoding index

Documentation on variable UA_MAXOP in module ida_ida:

    max number of operands allowed for an instruction

Documentation on variable idbattr_info_t.name in module ida_ida:

    human-readable name

Documentation on variable idbattr_info_t.offset in module ida_ida:

    field position: offset within a structure (IDI_STRUCFLD) altval or supval index
    (IDI_NODEVAL) hashval name (IDI_NODEVAL+IDI_HASH)

Documentation on variable idbattr_info_t.width in module ida_ida:

    field width in bytes

Documentation on variable idbattr_info_t.bitmask in module ida_ida:

    mask for bitfields (0-not bitfield)

Documentation on variable idbattr_info_t.tag in module ida_ida:

    tag of node value (if IDI_NODEVAL is set)

Documentation on variable idbattr_info_t.vmap in module ida_ida:

    array value=>name (terminated by empty element)

Documentation on variable idbattr_info_t.individual_node in module ida_ida:

    individual node name (nullptr - use default)

Documentation on variable idbattr_info_t.maxsize in module ida_ida:

    max bytes reserved for storage in netnode

Documentation on variable IDI_STRUCFLD in module ida_ida:

    structure field (opposite to IDI_NODEVAL)

Documentation on variable IDI_SCALAR in module ida_ida:

    scalar value (default)

Documentation on variable IDI_CSTR in module ida_ida:

    string

Documentation on variable IDI_QSTRING in module ida_ida:

    qstring

Documentation on variable IDI_BYTEARRAY in module ida_ida:

    byte array: binary representation

Documentation on variable IDI_EA_HEX in module ida_ida:

    default representation: hex or "BADADDR"

Documentation on variable IDI_DEC in module ida_ida:

    show as decimal

Documentation on variable IDI_HEX in module ida_ida:

    show as hexadecimal

Documentation on variable IDI_INC in module ida_ida:

    stored value is incremented (scalars only)

Documentation on variable IDI_MAP_VAL in module ida_ida:

    apply ea2node() to value

Documentation on variable IDI_HASH in module ida_ida:

    hashed node field, hash name in offset

Documentation on variable IDI_HLPSTRUC in module ida_ida:

    call helper for pointer to structure

Documentation on variable IDI_READONLY in module ida_ida:

    read-only field (cannot be modified)

Documentation on variable IDI_BITMAP in module ida_ida:

    bitmap field: interpret bitmask as bit number

Documentation on variable IDI_ONOFF in module ida_ida:

    show boolean as on/off (not true/false)

Documentation on variable IDI_NOMERGE in module ida_ida:

    field should not be merged as part of INF

Documentation on variable PY_ICID_INT64 in module ida_idaapi:

    int64 object

Documentation on variable PY_ICID_BYREF in module ida_idaapi:

    byref object

Documentation on variable PY_ICID_OPAQUE in module ida_idaapi:

    opaque object

Documentation on variable ST_OVER_DEBUG_SEG in module ida_idaapi:

    step tracing will be disabled when IP is in a debugger segment

Documentation on variable ST_OVER_LIB_FUNC in module ida_idaapi:

    step tracing will be disabled when IP is in a library function

Documentation on variable py_clinked_object_t.clink in module ida_idaapi:

    Returns the C link as a PyObject

Documentation on variable py_clinked_object_t.clink_ptr in module ida_idaapi:

    Returns the C link pointer as a number

Documentation on variable NW_OPENIDB in module ida_idaapi:

    Notify when the database is opened. Its callback is of the form: def notify_when_callback(nw_code, is_old_database)

Documentation on variable NW_CLOSEIDB in module ida_idaapi:

    Notify when the database is closed. Its callback is of the form: def notify_when_callback(nw_code)

Documentation on variable NW_INITIDA in module ida_idaapi:

    Notify when the IDA starts. Its callback is of the form: def notify_when_callback(nw_code)

Documentation on variable NW_TERMIDA in module ida_idaapi:

    Notify when the IDA terminates. Its callback is of the form: def notify_when_callback(nw_code)

Documentation on variable NW_REMOVE in module ida_idaapi:

    Use this flag with other flags to uninstall a notifywhen callback

Documentation on variable IDD_INTERFACE_VERSION in module ida_idd:

    The IDD interface version number.

Documentation on variable NO_THREAD in module ida_idd:

    No thread. in PROCESS_STARTED this value can be used to specify that the main
    thread has not been created. It will be initialized later by a THREAD_STARTED
    event.

Documentation on variable process_info_t.pid in module ida_idd:

    process id

Documentation on variable process_info_t.name in module ida_idd:

    process name

Documentation on variable debapp_attrs_t.cbsize in module ida_idd:

    control field: size of this structure

Documentation on variable debapp_attrs_t.addrsize in module ida_idd:

    address size of the process. Since 64-bit debuggers usually can debug 32-bit
    applications, we cannot rely on sizeof(ea_t) to detect the current address size.
    The following variable should be used instead. It is initialized with 8 for
    64-bit debuggers but they should adjust it as soon as they learn that a 32-bit
    application is being debugged. For 32-bit debuggers it is initialized with 4.

Documentation on variable debapp_attrs_t.platform in module ida_idd:

    platform name process is running/debugging under. (is used as a key value in
    exceptions.cfg)

Documentation on variable register_info_t.name in module ida_idd:

    Register name.

Documentation on variable register_info_t.flags in module ida_idd:

    Register info attribute flags

Documentation on variable register_info_t.register_class in module ida_idd:

    segment, mmx, etc.

Documentation on variable register_info_t.dtype in module ida_idd:

    Register size (see Operand value types)

Documentation on variable register_info_t.bit_strings in module ida_idd:

    strings corresponding to each bit of the register. (nullptr = no bit, same name
    = multi-bits mask)

Documentation on variable register_info_t.default_bit_strings_mask in module ida_idd:

    mask of default bits

Documentation on variable REGISTER_READONLY in module ida_idd:

    the user can't modify the current value of this register

Documentation on variable REGISTER_IP in module ida_idd:

    instruction pointer

Documentation on variable REGISTER_SP in module ida_idd:

    stack pointer

Documentation on variable REGISTER_FP in module ida_idd:

    frame pointer

Documentation on variable REGISTER_ADDRESS in module ida_idd:

    may contain an address

Documentation on variable REGISTER_CS in module ida_idd:

    code segment

Documentation on variable REGISTER_SS in module ida_idd:

    stack segment

Documentation on variable REGISTER_NOLF in module ida_idd:

    displays this register without returning to the next line, allowing the next
    register to be displayed to its right (on the same line)

Documentation on variable REGISTER_CUSTFMT in module ida_idd:

    register should be displayed using a custom data format. the format name is in
    bit_strings[0]; the corresponding regval_t will use bytevec_t

Documentation on variable memory_info_t.name in module ida_idd:

    Memory range name.

Documentation on variable memory_info_t.sclass in module ida_idd:

    Memory range class name.

Documentation on variable memory_info_t.sbase in module ida_idd:

    Segment base (meaningful only for segmented architectures, e.g. 16-bit x86) The
    base is specified in paragraphs (i.e. shifted to the right by 4)

Documentation on variable memory_info_t.bitness in module ida_idd:

    Number of bits in segment addresses (0-16bit, 1-32bit, 2-64bit)

Documentation on variable memory_info_t.perm in module ida_idd:

    Memory range permissions (0-no information): see segment.hpp.

Documentation on variable scattered_segm_t.name in module ida_idd:

    name of the segment

Documentation on variable NO_EVENT in module ida_idd:

    Not an interesting event. This event can be used if the debugger module needs to
    return an event but there are no valid events.

Documentation on variable PROCESS_STARTED in module ida_idd:

    New process has been started.

Documentation on variable PROCESS_EXITED in module ida_idd:

    Process has been stopped.

Documentation on variable THREAD_STARTED in module ida_idd:

    New thread has been started.

Documentation on variable THREAD_EXITED in module ida_idd:

    Thread has been stopped.

Documentation on variable BREAKPOINT in module ida_idd:

    Breakpoint has been reached. IDA will complain about unknown breakpoints, they
    should be reported as exceptions.

Documentation on variable STEP in module ida_idd:

    One instruction has been executed. Spurious events of this kind are silently
    ignored by IDA.

Documentation on variable EXCEPTION in module ida_idd:

    Exception.

Documentation on variable LIB_LOADED in module ida_idd:

    New library has been loaded.

Documentation on variable LIB_UNLOADED in module ida_idd:

    Library has been unloaded.

Documentation on variable INFORMATION in module ida_idd:

    User-defined information. This event can be used to return empty information
    This will cause IDA to call get_debug_event() immediately once more.

Documentation on variable PROCESS_ATTACHED in module ida_idd:

    Successfully attached to running process.

Documentation on variable PROCESS_DETACHED in module ida_idd:

    Successfully detached from process.

Documentation on variable PROCESS_SUSPENDED in module ida_idd:

    Process has been suspended. This event can be used by the debugger module to
    signal if the process spontaneously gets suspended (not because of an exception,
    breakpoint, or single step). IDA will silently switch to the 'suspended process'
    mode without displaying any messages.

Documentation on variable TRACE_FULL in module ida_idd:

    The trace buffer of the tracer module is full and IDA needs to read it before
    continuing

Documentation on variable modinfo_t.name in module ida_idd:

    full name of the module

Documentation on variable modinfo_t.base in module ida_idd:

    module base address. if unknown pass BADADDR

Documentation on variable modinfo_t.size in module ida_idd:

    module size. if unknown pass 0

Documentation on variable modinfo_t.rebase_to in module ida_idd:

    if not BADADDR, then rebase the program to the specified address

Documentation on variable bptaddr_t.hea in module ida_idd:

    Possible address referenced by hardware breakpoints.

Documentation on variable bptaddr_t.kea in module ida_idd:

    Address of the triggered bpt from the kernel's point of view. (for some systems
    with special memory mappings, the triggered ea might be different from event
    ea). Use to BADADDR for flat memory model.

Documentation on variable excinfo_t.code in module ida_idd:

    Exception code.

Documentation on variable excinfo_t.can_cont in module ida_idd:

    Execution of the process can continue after this exception?

Documentation on variable excinfo_t.ea in module ida_idd:

    Possible address referenced by the exception.

Documentation on variable excinfo_t.info in module ida_idd:

    Exception message.

Documentation on variable debug_event_t.pid in module ida_idd:

    Process where the event occurred.

Documentation on variable debug_event_t.tid in module ida_idd:

    Thread where the event occurred.

Documentation on variable debug_event_t.ea in module ida_idd:

    Address where the event occurred.

Documentation on variable debug_event_t.handled in module ida_idd:

    Is event handled by the debugger?. (from the system's point of view) Meaningful
    for EXCEPTION events

Documentation on variable exception_info_t.code in module ida_idd:

    exception code

Documentation on variable exception_info_t.flags in module ida_idd:

    Exception info flags

Documentation on variable exception_info_t.name in module ida_idd:

    Exception standard name.

Documentation on variable exception_info_t.desc in module ida_idd:

    Long message used to display info about the exception.

Documentation on variable BPT_WRITE in module ida_idd:

    Write access.

Documentation on variable BPT_READ in module ida_idd:

    Read access.

Documentation on variable BPT_RDWR in module ida_idd:

    Read/write access.

Documentation on variable BPT_SOFT in module ida_idd:

    Software breakpoint.

Documentation on variable BPT_EXEC in module ida_idd:

    Execute instruction.

Documentation on variable BPT_DEFAULT in module ida_idd:

    Choose bpt type automatically.

Documentation on variable EXC_BREAK in module ida_idd:

    break on the exception

Documentation on variable EXC_HANDLE in module ida_idd:

    should be handled by the debugger?

Documentation on variable EXC_MSG in module ida_idd:

    instead of a warning, log the exception to the output window

Documentation on variable EXC_SILENT in module ida_idd:

    do not warn or log to the output window

Documentation on variable regval_t.rvtype in module ida_idd:

    one of Register value types

Documentation on variable regval_t.ival in module ida_idd:

    8: integer value

Documentation on variable regval_t.fval in module ida_idd:

    12: floating point value in the internal representation (see ieee.h)

Documentation on variable RVT_INT in module ida_idd:

    integer

Documentation on variable RVT_FLOAT in module ida_idd:

    floating point

Documentation on variable RVT_UNAVAILABLE in module ida_idd:

    unavailable; other values mean custom data type

Documentation on variable call_stack_info_t.callea in module ida_idd:

    the address of the call instruction. for the 0th frame this is usually just the
    current value of EIP.

Documentation on variable call_stack_info_t.funcea in module ida_idd:

    the address of the called function

Documentation on variable call_stack_info_t.fp in module ida_idd:

    the value of the frame pointer of the called function

Documentation on variable call_stack_info_t.funcok in module ida_idd:

    is the function present?

Documentation on variable thread_name_t.tid in module ida_idd:

    thread

Documentation on variable thread_name_t.name in module ida_idd:

    new thread name

Documentation on variable RESMOD_NONE in module ida_idd:

    no stepping, run freely

Documentation on variable RESMOD_INTO in module ida_idd:

    step into call (the most typical single stepping)

Documentation on variable RESMOD_OVER in module ida_idd:

    step over call

Documentation on variable RESMOD_OUT in module ida_idd:

    step out of the current function (run until return)

Documentation on variable RESMOD_SRCINTO in module ida_idd:

    until control reaches a different source line

Documentation on variable RESMOD_SRCOVER in module ida_idd:

    next source line in the current stack frame

Documentation on variable RESMOD_SRCOUT in module ida_idd:

    next source line in the previous stack frame

Documentation on variable RESMOD_USER in module ida_idd:

    step out to the user code

Documentation on variable RESMOD_HANDLE in module ida_idd:

    step into the exception handler

Documentation on variable DRC_EVENTS in module ida_idd:

    success, there are pending events

Documentation on variable DRC_CRC in module ida_idd:

    success, but the input file crc does not match

Documentation on variable DRC_OK in module ida_idd:

    success

Documentation on variable DRC_NONE in module ida_idd:

    reaction to the event not implemented

Documentation on variable DRC_FAILED in module ida_idd:

    failed or false

Documentation on variable DRC_NETERR in module ida_idd:

    network error

Documentation on variable DRC_NOFILE in module ida_idd:

    file not found

Documentation on variable DRC_IDBSEG in module ida_idd:

    use idb segmentation

Documentation on variable DRC_NOPROC in module ida_idd:

    the process does not exist anymore

Documentation on variable DRC_NOCHG in module ida_idd:

    no changes

Documentation on variable DRC_ERROR in module ida_idd:

    unclassified error, may be complemented by errbuf

Documentation on variable NO_PROCESS in module ida_idd:

    No process.

Documentation on variable Appcall_callable__.timeout in module ida_idd:

    An Appcall instance can change its timeout value with this attribute

Documentation on variable Appcall_callable__.options in module ida_idd:

    Sets the Appcall options locally to this Appcall instance

Documentation on variable Appcall_callable__.ea in module ida_idd:

    Returns or sets the EA associated with this object

Documentation on variable Appcall_callable__.tif in module ida_idd:

    Returns the tinfo_t object

Documentation on variable Appcall_callable__.size in module ida_idd:

    Returns the size of the type

Documentation on variable Appcall_callable__.type in module ida_idd:

    Returns the typestring

Documentation on variable Appcall_callable__.fields in module ida_idd:

    Returns the field names

Documentation on variable Appcall__.APPCALL_MANUAL in module ida_idd:

    Only set up the appcall, do not run it.
    you should call CleanupAppcall() when finished

Documentation on variable Appcall__.APPCALL_DEBEV in module ida_idd:

    Return debug event information
    If this bit is set, exceptions during appcall
    will generate idc exceptions with full
    information about the exception

Documentation on variable Appcall__.APPCALL_TIMEOUT in module ida_idd:

    Appcall with timeout
    The timeout value in milliseconds is specified
    in the high 2 bytes of the 'options' argument:
    If timed out, errbuf will contain "timeout".

Documentation on variable Appcall__.Consts in module ida_idd:

    Use Appcall.Consts.CONST_NAME to access constants

Documentation on variable IDP_INTERFACE_VERSION in module ida_idp:

    The interface version number.
    @note: see also IDA_SDK_VERSION from pro.h

Documentation on variable CF_STOP in module ida_idp:

    Instruction doesn't pass execution to the next instruction

Documentation on variable CF_CALL in module ida_idp:

    CALL instruction (should make a procedure here)

Documentation on variable CF_CHG1 in module ida_idp:

    The instruction modifies the first operand.

Documentation on variable CF_CHG2 in module ida_idp:

    The instruction modifies the second operand.

Documentation on variable CF_CHG3 in module ida_idp:

    The instruction modifies the third operand.

Documentation on variable CF_CHG4 in module ida_idp:

    The instruction modifies 4 operand.

Documentation on variable CF_CHG5 in module ida_idp:

    The instruction modifies 5 operand.

Documentation on variable CF_CHG6 in module ida_idp:

    The instruction modifies 6 operand.

Documentation on variable CF_USE1 in module ida_idp:

    The instruction uses value of the first operand.

Documentation on variable CF_USE2 in module ida_idp:

    The instruction uses value of the second operand.

Documentation on variable CF_USE3 in module ida_idp:

    The instruction uses value of the third operand.

Documentation on variable CF_USE4 in module ida_idp:

    The instruction uses value of the 4 operand.

Documentation on variable CF_USE5 in module ida_idp:

    The instruction uses value of the 5 operand.

Documentation on variable CF_USE6 in module ida_idp:

    The instruction uses value of the 6 operand.

Documentation on variable CF_JUMP in module ida_idp:

    The instruction passes execution using indirect jump or call (thus needs
    additional analysis)

Documentation on variable CF_SHFT in module ida_idp:

    Bit-shift instruction (shl,shr...)

Documentation on variable CF_HLL in module ida_idp:

    Instruction may be present in a high level language function

Documentation on variable CF_CHG7 in module ida_idp:

    The instruction modifies the 7th operand.

Documentation on variable CF_CHG8 in module ida_idp:

    The instruction modifies the 8th operand.

Documentation on variable CF_USE7 in module ida_idp:

    The instruction uses value of the 7th operand.

Documentation on variable CF_USE8 in module ida_idp:

    The instruction uses value of the 8th operand.

Documentation on variable asm_t.flag in module ida_idp:

    Assembler feature bits

Documentation on variable asm_t.uflag in module ida_idp:

    user defined flags (local only for IDP) you may define and use your own bits

Documentation on variable asm_t.name in module ida_idp:

    Assembler name (displayed in menus)

Documentation on variable asm_t.help in module ida_idp:

    Help screen number, 0 - no help.

Documentation on variable asm_t.header in module ida_idp:

    array of automatically generated header lines they appear at the start of
    disassembled text

Documentation on variable asm_t.origin in module ida_idp:

    org directive

Documentation on variable asm_t.end in module ida_idp:

    end directive

Documentation on variable asm_t.cmnt in module ida_idp:

    comment string (see also cmnt2)

Documentation on variable asm_t.ascsep in module ida_idp:

    string literal delimiter

Documentation on variable asm_t.accsep in module ida_idp:

    char constant delimiter

Documentation on variable asm_t.esccodes in module ida_idp:

    special chars that cannot appear as is in string and char literals

Documentation on variable asm_t.a_ascii in module ida_idp:

    string literal directive

Documentation on variable asm_t.a_byte in module ida_idp:

    byte directive

Documentation on variable asm_t.a_word in module ida_idp:

    word directive

Documentation on variable asm_t.a_dword in module ida_idp:

    nullptr if not allowed

Documentation on variable asm_t.a_qword in module ida_idp:

    nullptr if not allowed

Documentation on variable asm_t.a_oword in module ida_idp:

    nullptr if not allowed

Documentation on variable asm_t.a_float in module ida_idp:

    float; 4bytes; nullptr if not allowed

Documentation on variable asm_t.a_double in module ida_idp:

    double; 8bytes; nullptr if not allowed

Documentation on variable asm_t.a_tbyte in module ida_idp:

    long double; nullptr if not allowed

Documentation on variable asm_t.a_packreal in module ida_idp:

    packed decimal real nullptr if not allowed

Documentation on variable asm_t.a_dups in module ida_idp:

    array keyword. the following sequences may appear:
    * #h header
    * #d size
    * #v value
    * #s(b,w,l,q,f,d,o) size specifiers for byte,word, dword,qword,
    float,double,oword

Documentation on variable asm_t.a_bss in module ida_idp:

    uninitialized data directive should include 's' for the size of data

Documentation on variable asm_t.a_equ in module ida_idp:

    'equ' Used if AS_UNEQU is set

Documentation on variable asm_t.a_seg in module ida_idp:

    'seg ' prefix (example: push seg seg001)

Documentation on variable asm_t.a_curip in module ida_idp:

    current IP (instruction pointer) symbol in assembler

Documentation on variable asm_t.a_public in module ida_idp:

    "public" name keyword. nullptr-use default, ""-do not generate

Documentation on variable asm_t.a_weak in module ida_idp:

    "weak" name keyword. nullptr-use default, ""-do not generate

Documentation on variable asm_t.a_extrn in module ida_idp:

    "extern" name keyword

Documentation on variable asm_t.a_comdef in module ida_idp:

    "comm" (communal variable)

Documentation on variable asm_t.a_align in module ida_idp:

    "align" keyword

Documentation on variable asm_t.lbrace in module ida_idp:

    left brace used in complex expressions

Documentation on variable asm_t.rbrace in module ida_idp:

    right brace used in complex expressions

Documentation on variable asm_t.a_mod in module ida_idp:

    % mod assembler time operation

Documentation on variable asm_t.a_band in module ida_idp:

    & bit and assembler time operation

Documentation on variable asm_t.a_bor in module ida_idp:

    | bit or assembler time operation

Documentation on variable asm_t.a_xor in module ida_idp:

    ^ bit xor assembler time operation

Documentation on variable asm_t.a_bnot in module ida_idp:

    ~ bit not assembler time operation

Documentation on variable asm_t.a_shl in module ida_idp:

    << shift left assembler time operation

Documentation on variable asm_t.a_shr in module ida_idp:

    >> shift right assembler time operation

Documentation on variable asm_t.a_sizeof_fmt in module ida_idp:

    size of type (format string)

Documentation on variable asm_t.flag2 in module ida_idp:

    Secondary assembler feature bits

Documentation on variable asm_t.cmnt2 in module ida_idp:

    comment close string (usually nullptr) this is used to denote a string which
    closes comments, for example, if the comments are represented with (* ... *)
    then cmnt = "(*" and cmnt2 = "*)"

Documentation on variable asm_t.low8 in module ida_idp:

    low8 operation, should contain s for the operand

Documentation on variable asm_t.high8 in module ida_idp:

    high8

Documentation on variable asm_t.low16 in module ida_idp:

    low16

Documentation on variable asm_t.high16 in module ida_idp:

    high16

Documentation on variable asm_t.a_include_fmt in module ida_idp:

    the include directive (format string)

Documentation on variable asm_t.a_vstruc_fmt in module ida_idp:

    if a named item is a structure and displayed in the verbose (multiline) form
    then display the name as printf(a_strucname_fmt, typename) (for asms with type
    checking, e.g. tasm ideal)

Documentation on variable asm_t.a_rva in module ida_idp:

    'rva' keyword for image based offsets (see REFINFO_RVAOFF)

Documentation on variable asm_t.a_yword in module ida_idp:

    32-byte (256-bit) data; nullptr if not allowed requires AS2_YWORD

Documentation on variable asm_t.a_zword in module ida_idp:

    64-byte (512-bit) data; nullptr if not allowed requires AS2_ZWORD

Documentation on variable AS_OFFST in module ida_idp:

    offsets are 'offset xxx' ?

Documentation on variable AS_COLON in module ida_idp:

    create colons after data names ?

Documentation on variable AS_UDATA in module ida_idp:

    can use '?' in data directives

Documentation on variable AS_2CHRE in module ida_idp:

    double char constants are: "xy

Documentation on variable AS_NCHRE in module ida_idp:

    char constants are: 'x

Documentation on variable AS_N2CHR in module ida_idp:

    can't have 2 byte char consts

Documentation on variable AS_1TEXT in module ida_idp:

    1 text per line, no bytes

Documentation on variable AS_NHIAS in module ida_idp:

    no characters with high bit

Documentation on variable AS_NCMAS in module ida_idp:

    no commas in ascii directives

Documentation on variable AS_HEXFM in module ida_idp:

    mask - hex number format

Documentation on variable ASH_HEXF0 in module ida_idp:

    34h

Documentation on variable ASH_HEXF1 in module ida_idp:

    h'34

Documentation on variable ASH_HEXF2 in module ida_idp:

    34

Documentation on variable ASH_HEXF3 in module ida_idp:

    0x34

Documentation on variable ASH_HEXF4 in module ida_idp:

    $34

Documentation on variable ASH_HEXF5 in module ida_idp:

    <^R > (radix)

Documentation on variable AS_DECFM in module ida_idp:

    mask - decimal number format

Documentation on variable ASD_DECF0 in module ida_idp:

    34

Documentation on variable ASD_DECF1 in module ida_idp:

    #34

Documentation on variable ASD_DECF2 in module ida_idp:

    34.

Documentation on variable ASD_DECF3 in module ida_idp:

    .34

Documentation on variable AS_OCTFM in module ida_idp:

    mask - octal number format

Documentation on variable ASO_OCTF0 in module ida_idp:

    123o

Documentation on variable ASO_OCTF1 in module ida_idp:

    0123

Documentation on variable ASO_OCTF2 in module ida_idp:

    123

Documentation on variable ASO_OCTF3 in module ida_idp:

    @123

Documentation on variable ASO_OCTF4 in module ida_idp:

    o'123

Documentation on variable ASO_OCTF5 in module ida_idp:

    123q

Documentation on variable ASO_OCTF6 in module ida_idp:

    ~123

Documentation on variable ASO_OCTF7 in module ida_idp:

    q'123

Documentation on variable AS_BINFM in module ida_idp:

    mask - binary number format

Documentation on variable ASB_BINF0 in module ida_idp:

    010101b

Documentation on variable ASB_BINF1 in module ida_idp:

    ^B010101

Documentation on variable ASB_BINF2 in module ida_idp:

    %010101

Documentation on variable ASB_BINF3 in module ida_idp:

    0b1010101

Documentation on variable ASB_BINF4 in module ida_idp:

    b'1010101

Documentation on variable ASB_BINF5 in module ida_idp:

    b'1010101'

Documentation on variable AS_UNEQU in module ida_idp:

    replace undefined data items with EQU (for ANTA's A80)

Documentation on variable AS_ONEDUP in module ida_idp:

    One array definition per line.

Documentation on variable AS_NOXRF in module ida_idp:

    Disable xrefs during the output file generation.

Documentation on variable AS_XTRNTYPE in module ida_idp:

    Assembler understands type of extern symbols as ":type" suffix.

Documentation on variable AS_RELSUP in module ida_idp:

    Checkarg: 'and','or','xor' operations with addresses are possible.

Documentation on variable AS_LALIGN in module ida_idp:

    Labels at "align" keyword are supported.

Documentation on variable AS_NOCODECLN in module ida_idp:

    don't create colons after code names

Documentation on variable AS_NOSPACE in module ida_idp:

    No spaces in expressions.

Documentation on variable AS_ALIGN2 in module ida_idp:

    .align directive expects an exponent rather than a power of 2 (.align 5 means to
    align at 32byte boundary)

Documentation on variable AS_ASCIIC in module ida_idp:

    ascii directive accepts C-like escape sequences (\n,\x01 and similar)

Documentation on variable AS_ASCIIZ in module ida_idp:

    ascii directive inserts implicit zero byte at the end

Documentation on variable AS2_BRACE in module ida_idp:

    Use braces for all expressions.

Documentation on variable AS2_STRINV in module ida_idp:

    Invert meaning of idainfo::wide_high_byte_first for text strings (for processors
    with bytes bigger than 8 bits)

Documentation on variable AS2_BYTE1CHAR in module ida_idp:

    One symbol per processor byte. Meaningful only for wide byte processors

Documentation on variable AS2_IDEALDSCR in module ida_idp:

    Description of struc/union is in the 'reverse' form (keyword before name), the
    same as in borland tasm ideal

Documentation on variable AS2_TERSESTR in module ida_idp:

    'terse' structure initialization form; NAME<fld,fld,...> is supported

Documentation on variable AS2_COLONSUF in module ida_idp:

    addresses may have ":xx" suffix; this suffix must be ignored when extracting the
    address under the cursor

Documentation on variable AS2_YWORD in module ida_idp:

    a_yword field is present and valid

Documentation on variable AS2_ZWORD in module ida_idp:

    a_zword field is present and valid

Documentation on variable HKCB_GLOBAL in module ida_idp:

    is global event listener? if true, the listener will survive database closing
    and opening. it will stay in the memory until explicitly unhooked. otherwise the
    kernel will delete it as soon as the owner is unloaded. should be used only with
    PLUGIN_FIX plugins.

Documentation on variable PLFM_386 in module ida_idp:

    Intel 80x86.

Documentation on variable PLFM_Z80 in module ida_idp:

    8085, Z80

Documentation on variable PLFM_I860 in module ida_idp:

    Intel 860.

Documentation on variable PLFM_8051 in module ida_idp:

    8051

Documentation on variable PLFM_TMS in module ida_idp:

    Texas Instruments TMS320C5x.

Documentation on variable PLFM_6502 in module ida_idp:

    6502

Documentation on variable PLFM_PDP in module ida_idp:

    PDP11.

Documentation on variable PLFM_68K in module ida_idp:

    Motorola 680x0.

Documentation on variable PLFM_JAVA in module ida_idp:

    Java.

Documentation on variable PLFM_6800 in module ida_idp:

    Motorola 68xx.

Documentation on variable PLFM_ST7 in module ida_idp:

    SGS-Thomson ST7.

Documentation on variable PLFM_MC6812 in module ida_idp:

    Motorola 68HC12.

Documentation on variable PLFM_MIPS in module ida_idp:

    MIPS.

Documentation on variable PLFM_ARM in module ida_idp:

    Advanced RISC Machines.

Documentation on variable PLFM_TMSC6 in module ida_idp:

    Texas Instruments TMS320C6x.

Documentation on variable PLFM_PPC in module ida_idp:

    PowerPC.

Documentation on variable PLFM_80196 in module ida_idp:

    Intel 80196.

Documentation on variable PLFM_Z8 in module ida_idp:

    Z8.

Documentation on variable PLFM_SH in module ida_idp:

    Renesas (formerly Hitachi) SuperH.

Documentation on variable PLFM_NET in module ida_idp:

    Microsoft Visual Studio.Net.

Documentation on variable PLFM_AVR in module ida_idp:

    Atmel 8-bit RISC processor(s)

Documentation on variable PLFM_H8 in module ida_idp:

    Hitachi H8/300, H8/2000.

Documentation on variable PLFM_PIC in module ida_idp:

    Microchip's PIC.

Documentation on variable PLFM_SPARC in module ida_idp:

    SPARC.

Documentation on variable PLFM_ALPHA in module ida_idp:

    DEC Alpha.

Documentation on variable PLFM_HPPA in module ida_idp:

    Hewlett-Packard PA-RISC.

Documentation on variable PLFM_H8500 in module ida_idp:

    Hitachi H8/500.

Documentation on variable PLFM_TRICORE in module ida_idp:

    Tasking Tricore.

Documentation on variable PLFM_DSP56K in module ida_idp:

    Motorola DSP5600x.

Documentation on variable PLFM_C166 in module ida_idp:

    Siemens C166 family.

Documentation on variable PLFM_ST20 in module ida_idp:

    SGS-Thomson ST20.

Documentation on variable PLFM_IA64 in module ida_idp:

    Intel Itanium IA64.

Documentation on variable PLFM_I960 in module ida_idp:

    Intel 960.

Documentation on variable PLFM_F2MC in module ida_idp:

    Fujistu F2MC-16.

Documentation on variable PLFM_TMS320C54 in module ida_idp:

    Texas Instruments TMS320C54xx.

Documentation on variable PLFM_TMS320C55 in module ida_idp:

    Texas Instruments TMS320C55xx.

Documentation on variable PLFM_TRIMEDIA in module ida_idp:

    Trimedia.

Documentation on variable PLFM_M32R in module ida_idp:

    Mitsubishi 32bit RISC.

Documentation on variable PLFM_NEC_78K0 in module ida_idp:

    NEC 78K0.

Documentation on variable PLFM_NEC_78K0S in module ida_idp:

    NEC 78K0S.

Documentation on variable PLFM_M740 in module ida_idp:

    Mitsubishi 8bit.

Documentation on variable PLFM_M7700 in module ida_idp:

    Mitsubishi 16bit.

Documentation on variable PLFM_ST9 in module ida_idp:

    ST9+.

Documentation on variable PLFM_FR in module ida_idp:

    Fujitsu FR Family.

Documentation on variable PLFM_MC6816 in module ida_idp:

    Motorola 68HC16.

Documentation on variable PLFM_M7900 in module ida_idp:

    Mitsubishi 7900.

Documentation on variable PLFM_TMS320C3 in module ida_idp:

    Texas Instruments TMS320C3.

Documentation on variable PLFM_KR1878 in module ida_idp:

    Angstrem KR1878.

Documentation on variable PLFM_AD218X in module ida_idp:

    Analog Devices ADSP 218X.

Documentation on variable PLFM_OAKDSP in module ida_idp:

    Atmel OAK DSP.

Documentation on variable PLFM_TLCS900 in module ida_idp:

    Toshiba TLCS-900.

Documentation on variable PLFM_C39 in module ida_idp:

    Rockwell C39.

Documentation on variable PLFM_CR16 in module ida_idp:

    NSC CR16.

Documentation on variable PLFM_MN102L00 in module ida_idp:

    Panasonic MN10200.

Documentation on variable PLFM_TMS320C1X in module ida_idp:

    Texas Instruments TMS320C1x.

Documentation on variable PLFM_NEC_V850X in module ida_idp:

    NEC V850 and V850ES/E1/E2.

Documentation on variable PLFM_SCR_ADPT in module ida_idp:

    Processor module adapter for processor modules written in scripting languages.

Documentation on variable PLFM_EBC in module ida_idp:

    EFI Bytecode.

Documentation on variable PLFM_MSP430 in module ida_idp:

    Texas Instruments MSP430.

Documentation on variable PLFM_SPU in module ida_idp:

    Cell Broadband Engine Synergistic Processor Unit.

Documentation on variable PLFM_DALVIK in module ida_idp:

    Android Dalvik Virtual Machine.

Documentation on variable PLFM_65C816 in module ida_idp:

    65802/65816

Documentation on variable PLFM_M16C in module ida_idp:

    Renesas M16C.

Documentation on variable PLFM_ARC in module ida_idp:

    Argonaut RISC Core.

Documentation on variable PLFM_UNSP in module ida_idp:

    SunPlus unSP.

Documentation on variable PLFM_TMS320C28 in module ida_idp:

    Texas Instruments TMS320C28x.

Documentation on variable PLFM_DSP96K in module ida_idp:

    Motorola DSP96000.

Documentation on variable PLFM_SPC700 in module ida_idp:

    Sony SPC700.

Documentation on variable PLFM_AD2106X in module ida_idp:

    Analog Devices ADSP 2106X.

Documentation on variable PLFM_PIC16 in module ida_idp:

    Microchip's 16-bit PIC.

Documentation on variable PLFM_S390 in module ida_idp:

    IBM's S390.

Documentation on variable PLFM_XTENSA in module ida_idp:

    Tensilica Xtensa.

Documentation on variable PLFM_RISCV in module ida_idp:

    RISC-V.

Documentation on variable PLFM_RL78 in module ida_idp:

    Renesas RL78.

Documentation on variable PLFM_RX in module ida_idp:

    Renesas RX.

Documentation on variable PR_SEGS in module ida_idp:

    has segment registers?

Documentation on variable PR_USE32 in module ida_idp:

    supports 32-bit addressing?

Documentation on variable PR_DEFSEG32 in module ida_idp:

    segments are 32-bit by default

Documentation on variable PR_RNAMESOK in module ida_idp:

    allow user register names for location names

Documentation on variable PR_ADJSEGS in module ida_idp:

    IDA may adjust segments' starting/ending addresses.

Documentation on variable PR_DEFNUM in module ida_idp:

    mask - default number representation

Documentation on variable PRN_HEX in module ida_idp:

    hex

Documentation on variable PRN_OCT in module ida_idp:

    octal

Documentation on variable PRN_DEC in module ida_idp:

    decimal

Documentation on variable PRN_BIN in module ida_idp:

    binary

Documentation on variable PR_WORD_INS in module ida_idp:

    instruction codes are grouped 2bytes in binary line prefix

Documentation on variable PR_NOCHANGE in module ida_idp:

    The user can't change segments and code/data attributes (display only)

Documentation on variable PR_ASSEMBLE in module ida_idp:

    Module has a built-in assembler and will react to ev_assemble.

Documentation on variable PR_ALIGN in module ida_idp:

    All data items should be aligned properly.

Documentation on variable PR_TYPEINFO in module ida_idp:

    the processor module fully supports type information callbacks; without full
    support, function argument locations and other things will probably be wrong.

Documentation on variable PR_USE64 in module ida_idp:

    supports 64-bit addressing?

Documentation on variable PR_SGROTHER in module ida_idp:

    the segment registers don't contain the segment selectors.

Documentation on variable PR_STACK_UP in module ida_idp:

    the stack grows up

Documentation on variable PR_BINMEM in module ida_idp:

    the processor module provides correct segmentation for binary files (i.e. it
    creates additional segments). The kernel will not ask the user to specify the
    RAM/ROM sizes

Documentation on variable PR_SEGTRANS in module ida_idp:

    the processor module supports the segment translation feature (meaning it
    calculates the code addresses using the map_code_ea() function)

Documentation on variable PR_CHK_XREF in module ida_idp:

    don't allow near xrefs between segments with different bases

Documentation on variable PR_NO_SEGMOVE in module ida_idp:

    the processor module doesn't support move_segm() (i.e. the user can't move
    segments)

Documentation on variable PR_USE_ARG_TYPES in module ida_idp:

    use processor_t::use_arg_types callback

Documentation on variable PR_SCALE_STKVARS in module ida_idp:

    use processor_t::get_stkvar_scale callback

Documentation on variable PR_DELAYED in module ida_idp:

    has delayed jumps and calls. If this flag is set,
    processor_t::is_basic_block_end, processor_t::delay_slot_insn should be
    implemented

Documentation on variable PR_ALIGN_INSN in module ida_idp:

    allow ida to create alignment instructions arbitrarily. Since these instructions
    might lead to other wrong instructions and spoil the listing, IDA does not
    create them by default anymore

Documentation on variable PR_PURGING in module ida_idp:

    there are calling conventions which may purge bytes from the stack

Documentation on variable PR_CNDINSNS in module ida_idp:

    has conditional instructions

Documentation on variable PR_USE_TBYTE in module ida_idp:

    BTMT_SPECFLT means _TBYTE type

Documentation on variable PR_DEFSEG64 in module ida_idp:

    segments are 64-bit by default

Documentation on variable PR_OUTER in module ida_idp:

    has outer operands (currently only mc68k)

Documentation on variable PR2_MAPPINGS in module ida_idp:

    the processor module uses memory mapping

Documentation on variable PR2_IDP_OPTS in module ida_idp:

    the module has processor-specific configuration options

Documentation on variable PR2_REALCVT in module ida_idp:

    the module has a custom 'ev_realcvt' implementation (otherwise IEEE-754 format
    is assumed)

Documentation on variable PR2_CODE16_BIT in module ida_idp:

    low bit of code addresses has special meaning e.g. ARM Thumb, MIPS16

Documentation on variable PR2_MACRO in module ida_idp:

    processor supports macro instructions

Documentation on variable PR2_USE_CALCREL in module ida_idp:

    (Lumina) the module supports calcrel info

Documentation on variable PR2_REL_BITS in module ida_idp:

    (Lumina) calcrel info has bits granularity, not bytes - construction flag only

Documentation on variable PR2_FORCE_16BIT in module ida_idp:

    use 16-bit basic types despite of 32-bit segments (used by c166)

Documentation on variable OP_FP_BASED in module ida_idp:

    operand is FP based

Documentation on variable OP_SP_BASED in module ida_idp:

    operand is SP based

Documentation on variable OP_SP_ADD in module ida_idp:

    operand value is added to the pointer

Documentation on variable OP_SP_SUB in module ida_idp:

    operand value is subtracted from the pointer

Documentation on variable CUSTOM_INSN_ITYPE in module ida_idp:

    Custom instruction codes defined by processor extension plugins must be greater
    than or equal to this

Documentation on variable REG_SPOIL in module ida_idp:

    processor_t::use_regarg_type uses this bit in the return value to indicate that
    the register value has been spoiled

Documentation on variable reg_info_t.reg in module ida_idp:

    register number

Documentation on variable reg_info_t.size in module ida_idp:

    register size

Documentation on variable reg_access_t.regnum in module ida_idp:

    register number (only entire registers)

Documentation on variable reg_access_t.range in module ida_idp:

    bitrange inside the register

Documentation on variable reg_access_t.opnum in module ida_idp:

    operand number

Documentation on variable SETPROC_IDB in module ida_idp:

    set processor type for old idb

Documentation on variable SETPROC_LOADER in module ida_idp:

    set processor type for new idb; if the user has specified a compatible
    processor, return success without changing it. if failure, call loader_failure()

Documentation on variable SETPROC_LOADER_NON_FATAL in module ida_idp:

    the same as SETPROC_LOADER but non-fatal failures.

Documentation on variable SETPROC_USER in module ida_idp:

    set user-specified processor used for -p and manual processor change at later
    time

Documentation on variable FPV_BADARG in module ida_ieee:

    wrong value of max_exp

Documentation on variable FPV_NORM in module ida_ieee:

    regular value

Documentation on variable FPV_NAN in module ida_ieee:

    NaN.

Documentation on variable FPV_PINF in module ida_ieee:

    positive infinity

Documentation on variable FPV_NINF in module ida_ieee:

    negative infinity

Documentation on variable REAL_ERROR_OK in module ida_ieee:

    no error

Documentation on variable REAL_ERROR_FPOVER in module ida_ieee:

    floating overflow or underflow

Documentation on variable REAL_ERROR_INTOVER in module ida_ieee:

    eetol*: integer overflow

Documentation on variable IEEE_EXONE in module ida_ieee:

    The exponent of 1.0.

Documentation on variable E_SPECIAL_EXP in module ida_ieee:

    Exponent in fpvalue_t for NaN and Inf.

Documentation on variable mbox_internal in module ida_kernwin:

    internal error

Documentation on variable chtype_generic in module ida_kernwin:

    the generic choose() function

Documentation on variable chtype_idasgn in module ida_kernwin:

    see choose_idasgn()

Documentation on variable chtype_entry in module ida_kernwin:

    see choose_entry()

Documentation on variable chtype_name in module ida_kernwin:

    see choose_name()

Documentation on variable chtype_stkvar_xref in module ida_kernwin:

    see choose_stkvar_xref()

Documentation on variable chtype_xref in module ida_kernwin:

    see choose_xref()

Documentation on variable chtype_enum in module ida_kernwin:

    see choose_enum()

Documentation on variable chtype_enum_by_value in module ida_kernwin:

    Deprecated. See chtype_enum_by_value_and_size.

Documentation on variable chtype_func in module ida_kernwin:

    see choose_func()

Documentation on variable chtype_segm in module ida_kernwin:

    see choose_segm()

Documentation on variable chtype_struc in module ida_kernwin:

    see choose_struc()

Documentation on variable chtype_strpath in module ida_kernwin:

    see choose_struc_path()

Documentation on variable chtype_idatil in module ida_kernwin:

    see choose_til()

Documentation on variable chtype_enum_by_value_and_size in module ida_kernwin:

    see choose_enum_by_value()

Documentation on variable chtype_srcp in module ida_kernwin:

    see choose_srcp()

Documentation on variable TCCRT_INVALID in module ida_kernwin:

    invalid

Documentation on variable TCCRT_FLAT in module ida_kernwin:

    flat view

Documentation on variable TCCRT_GRAPH in module ida_kernwin:

    graph view

Documentation on variable TCCRT_PROXIMITY in module ida_kernwin:

    proximity view

Documentation on variable TCCPT_INVALID in module ida_kernwin:

    invalid

Documentation on variable TCCPT_PLACE in module ida_kernwin:

    place_t

Documentation on variable TCCPT_SIMPLELINE_PLACE in module ida_kernwin:

    simpleline_place_t

Documentation on variable TCCPT_IDAPLACE in module ida_kernwin:

    idaplace_t

Documentation on variable TCCPT_ENUMPLACE in module ida_kernwin:

    enumplace_t

Documentation on variable TCCPT_STRUCTPLACE in module ida_kernwin:

    structplace_t

Documentation on variable VME_UNKNOWN in module ida_kernwin:

    unknown mouse button

Documentation on variable VME_LEFT_BUTTON in module ida_kernwin:

    left mouse button

Documentation on variable VME_RIGHT_BUTTON in module ida_kernwin:

    right mouse button

Documentation on variable VME_MID_BUTTON in module ida_kernwin:

    middle mouse button

Documentation on variable SETMENU_INS in module ida_kernwin:

    add menu item before the specified path (default)

Documentation on variable SETMENU_APP in module ida_kernwin:

    add menu item after the specified path

Documentation on variable SETMENU_FIRST in module ida_kernwin:

    add item to the beginning of menu

Documentation on variable SETMENU_ENSURE_SEP in module ida_kernwin:

    make sure there is a separator before the action

Documentation on variable CREATETB_ADV in module ida_kernwin:

    toolbar is for 'advanced mode' only

Documentation on variable HIF_IDENTIFIER in module ida_kernwin:

    text is an identifier (i.e., when searching for the current highlight,
    SEARCH_IDENT will be used)

Documentation on variable HIF_REGISTER in module ida_kernwin:

    text represents a register (aliases/subregisters will be highlit as well)

Documentation on variable HIF_LOCKED in module ida_kernwin:

    locked; clicking/moving the cursor around doesn't change the highlight

Documentation on variable HIF_NOCASE in module ida_kernwin:

    case insensitive

Documentation on variable HIF_USE_SLOT in module ida_kernwin:

    use the given number, or just use the "floating" highlight

Documentation on variable HIF_SLOT_SHIFT in module ida_kernwin:

    position of the 3 top bits specifying which highlight to use

Documentation on variable HIF_SLOT_0 in module ida_kernwin:

    operate on slot 0

Documentation on variable HIF_SLOT_1 in module ida_kernwin:

    operate on slot 1

Documentation on variable HIF_SLOT_2 in module ida_kernwin:

    operate on slot 2

Documentation on variable HIF_SLOT_3 in module ida_kernwin:

    operate on slot 3

Documentation on variable HIF_SLOT_4 in module ida_kernwin:

    operate on slot 4

Documentation on variable HIF_SLOT_5 in module ida_kernwin:

    operate on slot 5

Documentation on variable HIF_SLOT_6 in module ida_kernwin:

    operate on slot 6

Documentation on variable HIF_SLOT_7 in module ida_kernwin:

    operate on slot 7

Documentation on variable CDVF_NOLINES in module ida_kernwin:

    don't show line numbers

Documentation on variable CDVF_LINEICONS in module ida_kernwin:

    icons can be drawn over the line control

Documentation on variable CDVF_STATUSBAR in module ida_kernwin:

    keep the status bar in the custom viewer

Documentation on variable IDCHK_OK in module ida_kernwin:

    ok

Documentation on variable IDCHK_ARG in module ida_kernwin:

    bad argument(s)

Documentation on variable IDCHK_KEY in module ida_kernwin:

    bad hotkey name

Documentation on variable IDCHK_MAX in module ida_kernwin:

    too many IDC hotkeys

Documentation on variable WCLS_SAVE in module ida_kernwin:

    save state in desktop config

Documentation on variable WCLS_NO_CONTEXT in module ida_kernwin:

    don't change the current context (useful for toolbars)

Documentation on variable WCLS_DONT_SAVE_SIZE in module ida_kernwin:

    don't save size of the window

Documentation on variable WCLS_DELETE_LATER in module ida_kernwin:

    assign the deletion of the widget to the UI loop ///<

Documentation on variable DP_LEFT in module ida_kernwin:

    Dock src_form to the left of dest_form.

Documentation on variable DP_TOP in module ida_kernwin:

    Dock src_form above dest_form.

Documentation on variable DP_RIGHT in module ida_kernwin:

    Dock src_form to the right of dest_form.

Documentation on variable DP_BOTTOM in module ida_kernwin:

    Dock src_form below dest_form.

Documentation on variable DP_INSIDE in module ida_kernwin:

    Create a new tab bar with both src_form and dest_form.

Documentation on variable DP_TAB in module ida_kernwin:

    Place src_form into a tab next to dest_form, if dest_form is in a tab bar
    (otherwise the same as DP_INSIDE)

Documentation on variable DP_BEFORE in module ida_kernwin:

    Place src_form before dst_form in the tab bar instead of after; used with
    DP_INSIDE or DP_TAB.

Documentation on variable DP_FLOATING in module ida_kernwin:

    Make src_form floating.

Documentation on variable DP_SZHINT in module ida_kernwin:

    When floating or in a splitter (i.e., not tabbed), use the widget's size hint to
    determine the best geometry (Qt only)

Documentation on variable SVF_COPY_LINES in module ida_kernwin:

    keep a local copy of '*lines'

Documentation on variable SVF_LINES_BYPTR in module ida_kernwin:

    remember the 'lines' ptr. do not make a copy of '*lines'

Documentation on variable CVNF_LAZY in module ida_kernwin:

    try and move the cursor to a line displaying the place_t if possible. This might
    disregard the Y position in case of success

Documentation on variable CVNF_JUMP in module ida_kernwin:

    push the current position in this viewer's lochist_t before going to the new
    location

Documentation on variable CVNF_ACT in module ida_kernwin:

    activate (i.e., switch to) the viewer. Activation is performed before the new
    lochist_entry_t instance is actually copied to the viewer's lochist_t
    (otherwise, if the viewer was invisible its on_location_changed() handler
    wouldn't be called.)

Documentation on variable WOPN_RESTORE in module ida_kernwin:

    if the widget was the only widget in a floating area the last time it was
    closed, it will be restored as floating, with the same position+size as before

Documentation on variable WOPN_PERSIST in module ida_kernwin:

    widget will remain available when starting or stopping debugger sessions

Documentation on variable WOPN_CLOSED_BY_ESC in module ida_kernwin:

    override idagui.cfg:CLOSED_BY_ESC: esc will close

Documentation on variable WOPN_NOT_CLOSED_BY_ESC in module ida_kernwin:

    override idagui.cfg:CLOSED_BY_ESC: esc will not close

Documentation on variable WOPN_DP_LEFT in module ida_kernwin:

    Dock widget to the left of dest_ctrl.

Documentation on variable WOPN_DP_TOP in module ida_kernwin:

    Dock widget above dest_ctrl.

Documentation on variable WOPN_DP_RIGHT in module ida_kernwin:

    Dock widget to the right of dest_ctrl.

Documentation on variable WOPN_DP_BOTTOM in module ida_kernwin:

    Dock widget below dest_ctrl.

Documentation on variable WOPN_DP_INSIDE in module ida_kernwin:

    Create a new tab bar with both widget and dest_ctrl.

Documentation on variable WOPN_DP_TAB in module ida_kernwin:

    Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar
    (otherwise the same as WOPN_DP_INSIDE)

Documentation on variable WOPN_DP_BEFORE in module ida_kernwin:

    Place widget before dst_form in the tab bar instead of after; used with
    WOPN_DP_INSIDE and WOPN_DP_TAB

Documentation on variable WOPN_DP_FLOATING in module ida_kernwin:

    Make widget floating.

Documentation on variable WOPN_DP_SZHINT in module ida_kernwin:

    when floating or in a splitter (i.e., not tabbed), use the widget's size hint to
    determine the best geometry (Qt only)

Documentation on variable RENADDR_IDA in module ida_kernwin:

    dialog for "IDA View"

Documentation on variable RENADDR_HR in module ida_kernwin:

    dialog for "Pseudocode"; additional flags:
    * 0x01 Library function
    * 0x02 Mark as decompiled

Documentation on variable place_t.lnnum in module ida_kernwin:

    Number of line within the current object.

Documentation on variable simpleline_t.line in module ida_kernwin:

    line text

Documentation on variable simpleline_t.color in module ida_kernwin:

    line prefix color

Documentation on variable simpleline_t.bgcolor in module ida_kernwin:

    line background color

Documentation on variable simpleline_place_t.n in module ida_kernwin:

    line number

Documentation on variable idaplace_t.ea in module ida_kernwin:

    address

Documentation on variable enumplace_t.idx in module ida_kernwin:

    enum serial number

Documentation on variable enumplace_t.bmask in module ida_kernwin:

    enum member bitmask

Documentation on variable enumplace_t.value in module ida_kernwin:

    enum member value

Documentation on variable enumplace_t.serial in module ida_kernwin:

    enum member serial number

Documentation on variable structplace_t.idx in module ida_kernwin:

    struct serial number

Documentation on variable structplace_t.offset in module ida_kernwin:

    offset within struct

Documentation on variable PCF_EA_CAPABLE in module ida_kernwin:

    toea() implementation returns meaningful data

Documentation on variable PCF_MAKEPLACE_ALLOCATES in module ida_kernwin:

    makeplace() returns a freshly allocated (i.e., non-static) instance. All new
    code should pass that flag to register_place_class(), and the corresponding
    makeplace() class implementation should return new instances.

Documentation on variable twinpos_t.at in module ida_kernwin:

    location in view

Documentation on variable twinpos_t.x in module ida_kernwin:

    cursor x

Documentation on variable twinline_t.at in module ida_kernwin:

    location in view

Documentation on variable twinline_t.line in module ida_kernwin:

    line contents

Documentation on variable twinline_t.prefix_color in module ida_kernwin:

    line prefix color

Documentation on variable twinline_t.bg_color in module ida_kernwin:

    line background color

Documentation on variable twinline_t.is_default in module ida_kernwin:

    is this the default line of the current location?

Documentation on variable lines_rendering_input_t.sections_lines in module ida_kernwin:

    references to the lines that are used for rendering

Documentation on variable lines_rendering_input_t.sync_group in module ida_kernwin:

    the 'synced' group 'widget' (see ui_get_lines_rendering_info) belongs to, or
    nullptr

Documentation on variable CK_TRACE in module ida_kernwin:

    traced address

Documentation on variable CK_TRACE_OVL in module ida_kernwin:

    overlay trace address

Documentation on variable CK_EXTRA1 in module ida_kernwin:

    extra background overlay #1

Documentation on variable CK_EXTRA2 in module ida_kernwin:

    extra background overlay #2

Documentation on variable CK_EXTRA3 in module ida_kernwin:

    extra background overlay #3

Documentation on variable CK_EXTRA4 in module ida_kernwin:

    extra background overlay #4

Documentation on variable CK_EXTRA5 in module ida_kernwin:

    extra background overlay #5

Documentation on variable CK_EXTRA6 in module ida_kernwin:

    extra background overlay #6

Documentation on variable CK_EXTRA7 in module ida_kernwin:

    extra background overlay #7

Documentation on variable CK_EXTRA8 in module ida_kernwin:

    extra background overlay #8

Documentation on variable CK_EXTRA9 in module ida_kernwin:

    extra background overlay #9

Documentation on variable CK_EXTRA10 in module ida_kernwin:

    extra background overlay #10

Documentation on variable CK_EXTRA11 in module ida_kernwin:

    extra background overlay #11

Documentation on variable CK_EXTRA12 in module ida_kernwin:

    extra background overlay #12

Documentation on variable CK_EXTRA13 in module ida_kernwin:

    extra background overlay #13

Documentation on variable CK_EXTRA14 in module ida_kernwin:

    extra background overlay #14

Documentation on variable CK_EXTRA15 in module ida_kernwin:

    extra background overlay #15

Documentation on variable CK_EXTRA16 in module ida_kernwin:

    extra background overlay #16

Documentation on variable LROEF_FULL_LINE in module ida_kernwin:

    full line background

Documentation on variable LROEF_CPS_RANGE in module ida_kernwin:

    background for range of chars

Documentation on variable line_rendering_output_entry_t.flags in module ida_kernwin:

    line_rendering_output_entry_t flags

Documentation on variable line_rendering_output_entry_t.cpx in module ida_kernwin:

    number of char to start from, valid if LROEF_CPS_RANGE

Documentation on variable line_rendering_output_entry_t.nchars in module ida_kernwin:

    chars count, valid if LROEF_CPS_RANGE

Documentation on variable BWN_UNKNOWN in module ida_kernwin:

    unknown window

Documentation on variable BWN_EXPORTS in module ida_kernwin:

    exports

Documentation on variable BWN_IMPORTS in module ida_kernwin:

    imports

Documentation on variable BWN_NAMES in module ida_kernwin:

    names

Documentation on variable BWN_FUNCS in module ida_kernwin:

    functions

Documentation on variable BWN_STRINGS in module ida_kernwin:

    strings

Documentation on variable BWN_SEGS in module ida_kernwin:

    segments

Documentation on variable BWN_SEGREGS in module ida_kernwin:

    segment registers

Documentation on variable BWN_SELS in module ida_kernwin:

    selectors

Documentation on variable BWN_SIGNS in module ida_kernwin:

    signatures

Documentation on variable BWN_TILS in module ida_kernwin:

    type libraries

Documentation on variable BWN_LOCTYPS in module ida_kernwin:

    local types

Documentation on variable BWN_CALLS in module ida_kernwin:

    function calls

Documentation on variable BWN_PROBS in module ida_kernwin:

    problems

Documentation on variable BWN_BPTS in module ida_kernwin:

    breakpoints

Documentation on variable BWN_THREADS in module ida_kernwin:

    threads

Documentation on variable BWN_MODULES in module ida_kernwin:

    modules

Documentation on variable BWN_TRACE in module ida_kernwin:

    tracing view

Documentation on variable BWN_CALL_STACK in module ida_kernwin:

    call stack

Documentation on variable BWN_XREFS in module ida_kernwin:

    xrefs

Documentation on variable BWN_SEARCH in module ida_kernwin:

    search results

Documentation on variable BWN_FRAME in module ida_kernwin:

    function frame

Documentation on variable BWN_NAVBAND in module ida_kernwin:

    navigation band

Documentation on variable BWN_ENUMS in module ida_kernwin:

    enumerations

Documentation on variable BWN_STRUCTS in module ida_kernwin:

    structures

Documentation on variable BWN_DISASM in module ida_kernwin:

    disassembly views

Documentation on variable BWN_DUMP in module ida_kernwin:

    hex dumps

Documentation on variable BWN_NOTEPAD in module ida_kernwin:

    notepad

Documentation on variable BWN_OUTPUT in module ida_kernwin:

    the text area, in the output window

Documentation on variable BWN_CLI in module ida_kernwin:

    the command-line, in the output window

Documentation on variable BWN_WATCH in module ida_kernwin:

    the 'watches' debugger window

Documentation on variable BWN_LOCALS in module ida_kernwin:

    the 'locals' debugger window

Documentation on variable BWN_STKVIEW in module ida_kernwin:

    the 'Stack view' debugger window

Documentation on variable BWN_CHOOSER in module ida_kernwin:

    a non-builtin chooser

Documentation on variable BWN_SHORTCUTCSR in module ida_kernwin:

    the shortcuts chooser (Qt version only)

Documentation on variable BWN_SHORTCUTWIN in module ida_kernwin:

    the shortcuts window (Qt version only)

Documentation on variable BWN_CPUREGS in module ida_kernwin:

    one of the 'General registers', 'FPU register', ... debugger windows

Documentation on variable BWN_SO_STRUCTS in module ida_kernwin:

    the 'Structure offsets' dialog's 'Structures and Unions' panel

Documentation on variable BWN_SO_OFFSETS in module ida_kernwin:

    the 'Structure offsets' dialog's offset panel

Documentation on variable BWN_CMDPALCSR in module ida_kernwin:

    the command palette chooser (Qt version only)

Documentation on variable BWN_CMDPALWIN in module ida_kernwin:

    the command palette window (Qt version only)

Documentation on variable BWN_SNIPPETS in module ida_kernwin:

    the 'Execute script' window

Documentation on variable BWN_CUSTVIEW in module ida_kernwin:

    custom viewers

Documentation on variable BWN_ADDRWATCH in module ida_kernwin:

    the 'Watch List' window

Documentation on variable BWN_PSEUDOCODE in module ida_kernwin:

    hexrays decompiler views

Documentation on variable BWN_CALLS_CALLERS in module ida_kernwin:

    function calls, callers

Documentation on variable BWN_CALLS_CALLEES in module ida_kernwin:

    function calls, callees

Documentation on variable BWN_MDVIEWCSR in module ida_kernwin:

    lumina metadata view chooser

Documentation on variable BWN_DISASM_ARROWS in module ida_kernwin:

    disassembly arrows widget

Documentation on variable BWN_CV_LINE_INFOS in module ida_kernwin:

    custom viewers' lineinfo widget

Documentation on variable BWN_SRCPTHMAP_CSR in module ida_kernwin:

    "Source paths..."'s path mappings chooser

Documentation on variable BWN_SRCPTHUND_CSR in module ida_kernwin:

    "Source paths..."'s undesired paths chooser

Documentation on variable BWN_UNDOHIST in module ida_kernwin:

    Undo history.

Documentation on variable BWN_SNIPPETS_CSR in module ida_kernwin:

    the list of snippets in the 'Execute script' window

Documentation on variable BWN_SCRIPTS_CSR in module ida_kernwin:

    the "Recent scripts" chooser

Documentation on variable BWN_BOOKMARKS in module ida_kernwin:

    a persistent 'Bookmarks' widget

Documentation on variable BWN_STACK in module ida_kernwin:

    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

Documentation on variable BWN_DISASMS in module ida_kernwin:

    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

Documentation on variable BWN_DUMPS in module ida_kernwin:

    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

Documentation on variable BWN_SEARCHS in module ida_kernwin:

    Alias. Some BWN_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

Documentation on variable IWID_EXPORTS in module ida_kernwin:

    exports (0)

Documentation on variable IWID_IMPORTS in module ida_kernwin:

    imports (1)

Documentation on variable IWID_NAMES in module ida_kernwin:

    names (2)

Documentation on variable IWID_FUNCS in module ida_kernwin:

    functions (3)

Documentation on variable IWID_STRINGS in module ida_kernwin:

    strings (4)

Documentation on variable IWID_SEGS in module ida_kernwin:

    segments (5)

Documentation on variable IWID_SEGREGS in module ida_kernwin:

    segment registers (6)

Documentation on variable IWID_SELS in module ida_kernwin:

    selectors (7)

Documentation on variable IWID_SIGNS in module ida_kernwin:

    signatures (8)

Documentation on variable IWID_TILS in module ida_kernwin:

    type libraries (9)

Documentation on variable IWID_LOCTYPS in module ida_kernwin:

    local types (10)

Documentation on variable IWID_CALLS in module ida_kernwin:

    function calls (11)

Documentation on variable IWID_PROBS in module ida_kernwin:

    problems (12)

Documentation on variable IWID_BPTS in module ida_kernwin:

    breakpoints (13)

Documentation on variable IWID_THREADS in module ida_kernwin:

    threads (14)

Documentation on variable IWID_MODULES in module ida_kernwin:

    modules (15)

Documentation on variable IWID_TRACE in module ida_kernwin:

    tracing view (16)

Documentation on variable IWID_CALL_STACK in module ida_kernwin:

    call stack (17)

Documentation on variable IWID_XREFS in module ida_kernwin:

    xrefs (18)

Documentation on variable IWID_SEARCH in module ida_kernwin:

    search results (19)

Documentation on variable IWID_FRAME in module ida_kernwin:

    function frame (25)

Documentation on variable IWID_NAVBAND in module ida_kernwin:

    navigation band (26)

Documentation on variable IWID_ENUMS in module ida_kernwin:

    enumerations (27)

Documentation on variable IWID_STRUCTS in module ida_kernwin:

    structures (28)

Documentation on variable IWID_DISASM in module ida_kernwin:

    disassembly views (29)

Documentation on variable IWID_DUMP in module ida_kernwin:

    hex dumps (30)

Documentation on variable IWID_NOTEPAD in module ida_kernwin:

    notepad (31)

Documentation on variable IWID_OUTPUT in module ida_kernwin:

    output (32)

Documentation on variable IWID_CLI in module ida_kernwin:

    input line (33)

Documentation on variable IWID_WATCH in module ida_kernwin:

    watches (34)

Documentation on variable IWID_LOCALS in module ida_kernwin:

    locals (35)

Documentation on variable IWID_STKVIEW in module ida_kernwin:

    stack view (36)

Documentation on variable IWID_CHOOSER in module ida_kernwin:

    chooser (37)

Documentation on variable IWID_SHORTCUTCSR in module ida_kernwin:

    shortcuts chooser (38)

Documentation on variable IWID_SHORTCUTWIN in module ida_kernwin:

    shortcuts window (39)

Documentation on variable IWID_CPUREGS in module ida_kernwin:

    registers (40)

Documentation on variable IWID_SO_STRUCTS in module ida_kernwin:

    stroff (41)

Documentation on variable IWID_SO_OFFSETS in module ida_kernwin:

    stroff (42)

Documentation on variable IWID_CMDPALCSR in module ida_kernwin:

    command palette (43)

Documentation on variable IWID_CMDPALWIN in module ida_kernwin:

    command palette (44)

Documentation on variable IWID_SNIPPETS in module ida_kernwin:

    snippets (45)

Documentation on variable IWID_CUSTVIEW in module ida_kernwin:

    custom viewers (46)

Documentation on variable IWID_ADDRWATCH in module ida_kernwin:

    address watches (47)

Documentation on variable IWID_PSEUDOCODE in module ida_kernwin:

    decompiler (48)

Documentation on variable IWID_CALLS_CALLERS in module ida_kernwin:

    funcalls, callers (49)

Documentation on variable IWID_CALLS_CALLEES in module ida_kernwin:

    funcalls, callees (50)

Documentation on variable IWID_MDVIEWCSR in module ida_kernwin:

    lumina md view (51)

Documentation on variable IWID_DISASM_ARROWS in module ida_kernwin:

    arrows widget (52)

Documentation on variable IWID_CV_LINE_INFOS in module ida_kernwin:

    lineinfo widget (53)

Documentation on variable IWID_SRCPTHMAP_CSR in module ida_kernwin:

    mappings chooser (54)

Documentation on variable IWID_SRCPTHUND_CSR in module ida_kernwin:

    undesired chooser (55)

Documentation on variable IWID_UNDOHIST in module ida_kernwin:

    Undo history (56)

Documentation on variable IWID_SNIPPETS_CSR in module ida_kernwin:

    snippets chooser (57)

Documentation on variable IWID_SCRIPTS_CSR in module ida_kernwin:

    recent scripts (58)

Documentation on variable IWID_BOOKMARKS in module ida_kernwin:

    bookmarks list (59)

Documentation on variable IWID_ALL in module ida_kernwin:

    mask

Documentation on variable IWID_STACK in module ida_kernwin:

    Alias. Some IWID_* were confusing, and thus have been renamed. This is to ensure
    bw-compat.

Documentation on variable AST_ENABLE_ALWAYS in module ida_kernwin:

    enable action and do not call action_handler_t::update() anymore

Documentation on variable AST_ENABLE_FOR_IDB in module ida_kernwin:

    enable action for the current idb. call action_handler_t::update() when a
    database is opened/closed

Documentation on variable AST_ENABLE_FOR_WIDGET in module ida_kernwin:

    enable action for the current widget. call action_handler_t::update() when a
    widget gets/loses focus

Documentation on variable AST_ENABLE in module ida_kernwin:

    enable action - call action_handler_t::update() when anything changes

Documentation on variable AST_DISABLE_ALWAYS in module ida_kernwin:

    disable action and do not call action_handler_t::action() anymore

Documentation on variable AST_DISABLE_FOR_IDB in module ida_kernwin:

    analog of AST_ENABLE_FOR_IDB

Documentation on variable AST_DISABLE_FOR_WIDGET in module ida_kernwin:

    analog of AST_ENABLE_FOR_WIDGET

Documentation on variable AST_DISABLE in module ida_kernwin:

    analog of AST_ENABLE

Documentation on variable CH_MODAL in module ida_kernwin:

    Modal chooser.

Documentation on variable CH_KEEP in module ida_kernwin:

    The chooser instance's lifecycle is not tied to the lifecycle of the widget
    showing its contents. Closing the widget will not destroy the chooser structure.
    This allows for, e.g., static global chooser instances that don't need to be
    allocated on the heap. Also stack-allocated chooser instances must set this bit.

Documentation on variable CH_MULTI in module ida_kernwin:

    The chooser will allow multi-selection (only for GUI choosers). This bit is set
    when using the chooser_multi_t structure.

Documentation on variable CH_MULTI_EDIT in module ida_kernwin:

    Obsolete.

Documentation on variable CH_NOBTNS in module ida_kernwin:

    do not display ok/cancel/help/search buttons. Meaningful only for gui modal
    windows because non-modal windows do not have any buttons anyway. Text mode does
    not have them neither.

Documentation on variable CH_ATTRS in module ida_kernwin:

    generate ui_get_chooser_item_attrs (gui only)

Documentation on variable CH_NOIDB in module ida_kernwin:

    use the chooser before opening the database

Documentation on variable CH_FORCE_DEFAULT in module ida_kernwin:

    if a non-modal chooser was already open, change selection to the default one

Documentation on variable CH_CAN_INS in module ida_kernwin:

    allow to insert new items

Documentation on variable CH_CAN_DEL in module ida_kernwin:

    allow to delete existing item(s)

Documentation on variable CH_CAN_EDIT in module ida_kernwin:

    allow to edit existing item(s)

Documentation on variable CH_CAN_REFRESH in module ida_kernwin:

    allow to refresh chooser

Documentation on variable CH_QFLT in module ida_kernwin:

    open with quick filter enabled and focused

Documentation on variable CH_QFTYP_DEFAULT in module ida_kernwin:

    set quick filtering type to the possible existing default for this chooser

Documentation on variable CH_QFTYP_NORMAL in module ida_kernwin:

    normal (i.e., lexicographical) quick filter type

Documentation on variable CH_QFTYP_WHOLE_WORDS in module ida_kernwin:

    whole words quick filter type

Documentation on variable CH_QFTYP_REGEX in module ida_kernwin:

    regex quick filter type

Documentation on variable CH_QFTYP_FUZZY in module ida_kernwin:

    fuzzy search quick filter type

Documentation on variable CH_NO_STATUS_BAR in module ida_kernwin:

    don't show a status bar

Documentation on variable CH_RESTORE in module ida_kernwin:

    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version
    only)

Documentation on variable CH_RENAME_IS_EDIT in module ida_kernwin:

    triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit()
    callback for the corresponding row.

Documentation on variable CH_BUILTIN_MASK in module ida_kernwin:

    Mask for builtin chooser numbers. Plugins should not use them.

Documentation on variable CH_HAS_DIRTREE in module ida_kernwin:

    The chooser can provide a dirtree_t, meaning a tree-like structure can be
    provided to the user (instead of a flat table)

Documentation on variable CH_TM_NO_TREE in module ida_kernwin:

    chooser will show up in no-tree mode

Documentation on variable CH_TM_FOLDERS_ONLY in module ida_kernwin:

    chooser will show in folders-only mode

Documentation on variable CH_TM_FULL_TREE in module ida_kernwin:

    chooser will show in no-tree mode

Documentation on variable CH_HAS_DIFF in module ida_kernwin:

    The chooser can be used in a diffing/merging workflow.

Documentation on variable CH_NO_SORT in module ida_kernwin:

    The chooser will not have sorting abilities.

Documentation on variable CH_NO_FILTER in module ida_kernwin:

    The chooser will not have filtering abilities.

Documentation on variable CH_NON_PERSISTED_TREE in module ida_kernwin:

    the chooser tree is not persisted (it is not loaded on startup and is not saved
    on exit)

Documentation on variable CHCOL_PLAIN in module ida_kernwin:

    plain string

Documentation on variable CHCOL_PATH in module ida_kernwin:

    file path

Documentation on variable CHCOL_HEX in module ida_kernwin:

    hexadecimal number

Documentation on variable CHCOL_DEC in module ida_kernwin:

    decimal number

Documentation on variable CHCOL_EA in module ida_kernwin:

    address

Documentation on variable CHCOL_FNAME in module ida_kernwin:

    function name

Documentation on variable CHCOL_FORMAT in module ida_kernwin:

    column format mask

Documentation on variable CHCOL_DEFHIDDEN in module ida_kernwin:

    column should be hidden by default

Documentation on variable CHCOL_DRAGHINT in module ida_kernwin:

    the column number that will be used to build hints for the dragging undo label.
    This should be provided for at most one column for any given chooser.

Documentation on variable CHCOL_INODENAME in module ida_kernwin:

    if CH_HAS_DIRTREE has been specified, this instructs the chooser that this
    column shows the inode name. This should be provided for at most one column for
    any given chooser.

Documentation on variable CHITEM_BOLD in module ida_kernwin:

    display the item in bold

Documentation on variable CHITEM_ITALIC in module ida_kernwin:

    display the item in italic

Documentation on variable CHITEM_UNDER in module ida_kernwin:

    underline the item

Documentation on variable CHITEM_STRIKE in module ida_kernwin:

    strikeout the item

Documentation on variable CHITEM_GRAY in module ida_kernwin:

    gray out the item

Documentation on variable CHOOSER_NOMAINMENU in module ida_kernwin:

    do not display main menu

Documentation on variable CHOOSER_NOSTATUSBAR in module ida_kernwin:

    do not display status bar (obsolete. Use CH_NO_STATUS_BAR instead)

Documentation on variable chooser_item_attrs_t.flags in module ida_kernwin:

    Chooser item property bits

Documentation on variable chooser_item_attrs_t.color in module ida_kernwin:

    item color

Documentation on variable chooser_stdact_desc_t.version in module ida_kernwin:

    to support the backward compatibility

Documentation on variable chooser_stdact_desc_t.label in module ida_kernwin:

    see action_desc_t

Documentation on variable chooser_base_t.x0 in module ida_kernwin:

    screen position, Functions: generic list choosers

Documentation on variable chooser_base_t.width in module ida_kernwin:

    (in chars)

Documentation on variable chooser_base_t.height in module ida_kernwin:

    (in chars)

Documentation on variable chooser_base_t.title in module ida_kernwin:

    menu title (includes ptr to help). May have chooser title prefixes (see "Chooser
     title" above).

Documentation on variable chooser_base_t.columns in module ida_kernwin:

    number of columns

Documentation on variable chooser_base_t.widths in module ida_kernwin:

    column widths
    * low 16 bits of each value hold the column width
    * high 16 bits are flags (see Chooser column flags)

Documentation on variable chooser_base_t.header in module ida_kernwin:

    header line; contains the tooltips, and column name for each of 'columns'
    columns. When tooltips need to be provided, the syntax should be:
    "#tooltip#column-name". (Otherwise, the syntax is simply "column-name".)

Documentation on variable chooser_base_t.icon in module ida_kernwin:

    default icon

Documentation on variable chooser_base_t.popup_names in module ida_kernwin:

    array of custom labels of the standard actions. Used to replace labels for these
    actions.
    An empty name means that the default name will be used.
    @note: Availability of these actions is determined by the CH_CAN_... flags. The
           label, icon and other action attributes can be overwritten in the action
           description returned by get_stdact_descs()

Documentation on variable chooser_base_t.deflt_col in module ida_kernwin:

    Column that will have focus.

Documentation on variable CVH_KEYDOWN in module ida_kernwin:

    see custom_viewer_keydown_t

Documentation on variable CVH_POPUP in module ida_kernwin:

    see custom_viewer_popup_t

Documentation on variable CVH_DBLCLICK in module ida_kernwin:

    see custom_viewer_dblclick_t

Documentation on variable CVH_CURPOS in module ida_kernwin:

    see custom_viewer_curpos_t

Documentation on variable CVH_CLOSE in module ida_kernwin:

    see custom_viewer_close_t

Documentation on variable CVH_CLICK in module ida_kernwin:

    see custom_viewer_click_t

Documentation on variable CVH_QT_AWARE in module ida_kernwin:

    see set_custom_viewer_qt_aware()

Documentation on variable CVH_HELP in module ida_kernwin:

    see custom_viewer_help_t

Documentation on variable CVH_MOUSEMOVE in module ida_kernwin:

    see custom_viewer_mouse_moved_t

Documentation on variable CDVH_USERDATA in module ida_kernwin:

    see set_code_viewer_user_data()

Documentation on variable CDVH_SRCVIEW in module ida_kernwin:

    see set_code_viewer_is_source()

Documentation on variable CDVH_LINES_CLICK in module ida_kernwin:

    see code_viewer_lines_click_t

Documentation on variable CDVH_LINES_DBLCLICK in module ida_kernwin:

    see code_viewer_lines_click_t

Documentation on variable CDVH_LINES_POPUP in module ida_kernwin:

    see code_viewer_lines_click_t

Documentation on variable CDVH_LINES_DRAWICON in module ida_kernwin:

    see code_viewer_lines_icon_t

Documentation on variable CDVH_LINES_LINENUM in module ida_kernwin:

    see code_viewer_lines_linenum_t

Documentation on variable CDVH_LINES_ICONMARGIN in module ida_kernwin:

    see set_code_viewer_lines_icon_margin()

Documentation on variable CDVH_LINES_RADIX in module ida_kernwin:

    see set_code_viewer_lines_radix()

Documentation on variable CDVH_LINES_ALIGNMENT in module ida_kernwin:

    see set_code_viewer_lines_alignment()

Documentation on variable VES_SHIFT in module ida_kernwin:

    state & 1 => Shift is pressed
    state & 2 => Alt is pressed
    state & 4 => Ctrl is pressed
    state & 8 => Mouse left button is pressed
    state & 16 => Mouse right button is pressed
    state & 32 => Mouse middle button is pressed
    state & 128 => Meta is pressed (OSX only)

Documentation on variable msg_activated in module ida_kernwin:

    The message window is activated.

Documentation on variable msg_deactivated in module ida_kernwin:

    The message window is deactivated.

Documentation on variable msg_click in module ida_kernwin:

    Click event.
    
    @retval 1: handled
    @retval 0: not handled (invoke default handler)

Documentation on variable msg_dblclick in module ida_kernwin:

    Double click event.
    
    @retval 1: handled
    @retval 0: not handled (invoke default handler)

Documentation on variable msg_closed in module ida_kernwin:

    View closed.

Documentation on variable msg_keydown in module ida_kernwin:

    Key down event.
    
    @retval 1: handled
    @retval 0: not handled (invoke default handler)

Documentation on variable renderer_pos_info_t.node in module ida_kernwin:

    the node, or -1 if the current renderer is not a graph renderer.

Documentation on variable renderer_pos_info_t.cx in module ida_kernwin:

    the X coords of the character in the current line. When in graph mode: X coords
    of the character in 'node'.
    When in flat mode: X coords of the character in the line, w/o
    taking scrolling into consideration.

Documentation on variable renderer_pos_info_t.cy in module ida_kernwin:

    the Y coords of the character. When in graph mode: Y coords of the character in
    'node'.
    When in flat mode: Line number, starting from the top.

Documentation on variable renderer_pos_info_t.sx in module ida_kernwin:

    the number of chars that are scrolled (flat mode only)

Documentation on variable view_mouse_event_location_t.ea in module ida_kernwin:

    flat view (rtype == TCCRT_FLAT)

Documentation on variable view_mouse_event_location_t.item in module ida_kernwin:

    graph views (rtype != TCCRT_FLAT). nullptr if mouse is not currently over an
    item.

Documentation on variable view_mouse_event_t.rtype in module ida_kernwin:

    type of renderer that received the event

Documentation on variable view_mouse_event_t.x in module ida_kernwin:

    screen x coordinate

Documentation on variable view_mouse_event_t.y in module ida_kernwin:

    screen y coordinate

Documentation on variable view_mouse_event_t.location in module ida_kernwin:

    location where event was generated

Documentation on variable view_mouse_event_t.state in module ida_kernwin:

    contains information about what buttons are CURRENTLY pressed on the keyboard
    and mouse. view_mouse_event_t instances created in functions like
    mouseReleaseEvent() won't contain any information about the mouse, because it
    has been released.

Documentation on variable view_mouse_event_t.button in module ida_kernwin:

    represents which mouse button was responsible for generating the event. This
    field does not care about the current state of the mouse.

Documentation on variable view_mouse_event_t.renderer_pos in module ida_kernwin:

    position where event was generated, relative to the renderer

Documentation on variable view_activated in module ida_kernwin:

    A view is activated

Documentation on variable view_deactivated in module ida_kernwin:

    A view is deactivated

Documentation on variable view_keydown in module ida_kernwin:

    Key down event

Documentation on variable view_click in module ida_kernwin:

    Click event

Documentation on variable view_dblclick in module ida_kernwin:

    Double click event

Documentation on variable view_curpos in module ida_kernwin:

    Cursor position changed

Documentation on variable view_created in module ida_kernwin:

    A view is being created.

Documentation on variable view_close in module ida_kernwin:

    View closed

Documentation on variable view_switched in module ida_kernwin:

    A view's renderer has changed.

Documentation on variable view_mouse_over in module ida_kernwin:

    The user moved the mouse over (or out of) a node or an edge. This is only
    relevant in a graph view.

Documentation on variable view_loc_changed in module ida_kernwin:

    The location for the view has changed (can be either the place_t, the
    renderer_info_t, or both.)

Documentation on variable view_mouse_moved in module ida_kernwin:

    The mouse moved on the view

Documentation on variable input_event_t.cb in module ida_kernwin:

    size marker

Documentation on variable input_event_t.kind in module ida_kernwin:

    the kind of event

Documentation on variable input_event_t.modifiers in module ida_kernwin:

    current keyboard (and mouse) modifiers

Documentation on variable input_event_t.target in module ida_kernwin:

    the target widget

Documentation on variable input_event_t.source in module ida_kernwin:

    the source event, should it be required for detailed inform (e.g., a QEvent in
    the GUI version of IDA)

Documentation on variable MFF_FAST in module ida_kernwin:

    execute code as soon as possible
    this mode is ok call ui related functions
    that do not query the database.

Documentation on variable MFF_READ in module ida_kernwin:

    execute code only when ida is idle and it is safe to query the database.
    this mode is recommended only for code that does not modify the database.
    (nb: ida may be in the middle of executing another user request, for example it may be waiting for him to enter values into a modal dialog box)

Documentation on variable MFF_WRITE in module ida_kernwin:

    execute code only when ida is idle and it is safe to modify the database. in particular, this flag will suspend execution if there is
    a modal dialog box on the screen this mode can be used to call any ida api function. MFF_WRITE implies MFF_READ

Documentation on variable MFF_NOWAIT in module ida_kernwin:

    Do not wait for the request to be executed.
    he caller should ensure that the request is not
    destroyed until the execution completes.
    if not, the request will be ignored.
    the return code of execute_sync() is meaningless
    in this case.
    This flag can be used to delay the code execution
    until the next UI loop run even from the main thread

Documentation on variable UIJMP_ACTIVATE in module ida_kernwin:

    activate the new window

Documentation on variable UIJMP_DONTPUSH in module ida_kernwin:

    do not remember the current address in the navigation history

Documentation on variable UIJMP_ANYVIEW in module ida_kernwin:

    jump in any ea_t-capable view

Documentation on variable UIJMP_IDAVIEW in module ida_kernwin:

    jump in idaview

Documentation on variable UIJMP_IDAVIEW_NEW in module ida_kernwin:

    jump in new idaview

Documentation on variable action_ctx_base_cur_sel_t.to in module ida_kernwin:

    end of selection

Documentation on variable action_ctx_base_t.widget_type in module ida_kernwin:

    type of current widget

Documentation on variable action_ctx_base_t.widget_title in module ida_kernwin:

    title of current widget

Documentation on variable action_ctx_base_t.chooser_selection in module ida_kernwin:

    current chooser selection (0-based)

Documentation on variable action_ctx_base_t.action in module ida_kernwin:

    action name

Documentation on variable action_ctx_base_t.cur_flags in module ida_kernwin:

    Current address information. see Action context property bits.

Documentation on variable action_ctx_base_t.cur_ea in module ida_kernwin:

    the current EA of the position in the view

Documentation on variable action_ctx_base_t.cur_value in module ida_kernwin:

    the possible address, or value the cursor is positioned on

Documentation on variable action_ctx_base_t.cur_func in module ida_kernwin:

    the current function

Documentation on variable action_ctx_base_t.cur_fchunk in module ida_kernwin:

    the current function chunk

Documentation on variable action_ctx_base_t.cur_struc in module ida_kernwin:

    the current structure

Documentation on variable action_ctx_base_t.cur_strmem in module ida_kernwin:

    the current structure member

Documentation on variable action_ctx_base_t.cur_enum in module ida_kernwin:

    the current enum

Documentation on variable action_ctx_base_t.cur_seg in module ida_kernwin:

    the current segment

Documentation on variable action_ctx_base_t.cur_sel in module ida_kernwin:

    the currently selected range. also see ACF_HAS_SELECTION

Documentation on variable action_ctx_base_t.regname in module ida_kernwin:

    register name (if widget_type == BWN_CPUREGS and context menu opened on
    register)

Documentation on variable action_ctx_base_t.focus in module ida_kernwin:

    The focused widget in case it is not the 'form' itself (e.g., the 'quick filter'
    input in choosers.)

Documentation on variable action_ctx_base_t.graph_selection in module ida_kernwin:

    the current graph selection (if in a graph view)

Documentation on variable action_ctx_base_t.dirtree_selection in module ida_kernwin:

    the current dirtree_t selection (if applicable)

Documentation on variable action_ctx_base_t.source in module ida_kernwin:

    the underlying chooser_base_t (if 'widget' is a chooser widget)

Documentation on variable ACF_HAS_SELECTION in module ida_kernwin:

    there is currently a valid selection

Documentation on variable ACF_XTRN_EA in module ida_kernwin:

    cur_ea is in 'externs' segment

Documentation on variable ACF_HAS_FIELD_DIRTREE_SELECTION in module ida_kernwin:

    'cur_enum_member' and 'dirtree_selection' fields are present

Documentation on variable ACF_HAS_SOURCE in module ida_kernwin:

    'source' field is present

Documentation on variable AHF_VERSION in module ida_kernwin:

    action handler version (used by action_handler_t::flags)

Documentation on variable AHF_VERSION_MASK in module ida_kernwin:

    mask for action_handler_t::flags

Documentation on variable action_desc_t.cb in module ida_kernwin:

    size of this structure

Documentation on variable action_desc_t.name in module ida_kernwin:

    the internal name of the action; must be unique. a way to reduce possible
    conflicts is to prefix it with some specific prefix. E.g., "myplugin:doSthg".

Documentation on variable action_desc_t.label in module ida_kernwin:

    the label of the action, possibly with an accelerator key definition (e.g.,
    "~J~ump to operand")

Documentation on variable action_desc_t.owner in module ida_kernwin:

    either the plugin_t, or plugmod_t responsible for registering the action. Can be
    nullptr Please see ACTION_DESC_LITERAL_PLUGMOD

Documentation on variable action_desc_t.shortcut in module ida_kernwin:

    an optional shortcut definition. E.g., "Ctrl+Enter"

Documentation on variable action_desc_t.tooltip in module ida_kernwin:

    an optional tooltip for the action

Documentation on variable action_desc_t.icon in module ida_kernwin:

    an optional icon ID to use

Documentation on variable action_desc_t.flags in module ida_kernwin:

    See Action flags.

Documentation on variable ADF_OWN_HANDLER in module ida_kernwin:

    handler is owned by the action; it'll be destroyed when the action is
    unregistered. Use DYNACTION_DESC_LITERAL to set this bit.

Documentation on variable ADF_NO_UNDO in module ida_kernwin:

    the action does not create an undo point. useful for actions that do not modify
    the database.

Documentation on variable ADF_OT_MASK in module ida_kernwin:

    Owner type mask.

Documentation on variable ADF_OT_PLUGIN in module ida_kernwin:

    Owner is a plugin_t.

Documentation on variable ADF_OT_PLUGMOD in module ida_kernwin:

    Owner is a plugmod_t.

Documentation on variable ADF_OT_PROCMOD in module ida_kernwin:

    Owner is a procmod_t.

Documentation on variable ADF_GLOBAL in module ida_kernwin:

    Register the action globally, so that it's available even if no IDB is present

Documentation on variable ADF_NO_HIGHLIGHT in module ida_kernwin:

    After activating, do not update the highlight according to what's under the
    cursor (listings only.)

Documentation on variable ADF_CHECKABLE in module ida_kernwin:

    action is checkable

Documentation on variable ADF_CHECKED in module ida_kernwin:

    starts in a checked state (requires ADF_CHECKABLE)

Documentation on variable AA_NONE in module ida_kernwin:

    no effect

Documentation on variable AA_LABEL in module ida_kernwin:

    see update_action_label()

Documentation on variable AA_SHORTCUT in module ida_kernwin:

    see update_action_shortcut()

Documentation on variable AA_TOOLTIP in module ida_kernwin:

    see update_action_tooltip()

Documentation on variable AA_ICON in module ida_kernwin:

    see update_action_icon()

Documentation on variable AA_STATE in module ida_kernwin:

    see update_action_state()

Documentation on variable AA_CHECKABLE in module ida_kernwin:

    see update_action_checkable()

Documentation on variable AA_CHECKED in module ida_kernwin:

    see update_action_checked()

Documentation on variable AA_VISIBILITY in module ida_kernwin:

    see update_action_visibility()

Documentation on variable ASKBTN_YES in module ida_kernwin:

    Yes button.

Documentation on variable ASKBTN_NO in module ida_kernwin:

    No button.

Documentation on variable ASKBTN_CANCEL in module ida_kernwin:

    Cancel button.

Documentation on variable ASKBTN_BTN1 in module ida_kernwin:

    First (Yes) button.

Documentation on variable ASKBTN_BTN2 in module ida_kernwin:

    Second (No) button.

Documentation on variable ASKBTN_BTN3 in module ida_kernwin:

    Third (Cancel) button.

Documentation on variable HIST_SEG in module ida_kernwin:

    segment names

Documentation on variable HIST_CMT in module ida_kernwin:

    comments

Documentation on variable HIST_SRCH in module ida_kernwin:

    search substrings

Documentation on variable HIST_IDENT in module ida_kernwin:

    names

Documentation on variable HIST_FILE in module ida_kernwin:

    file names

Documentation on variable HIST_TYPE in module ida_kernwin:

    type declarations

Documentation on variable HIST_CMD in module ida_kernwin:

    commands

Documentation on variable HIST_DIR in module ida_kernwin:

    directory names (text version only)

Documentation on variable CLNL_RTRIM in module ida_kernwin:

    Remove trailing space characters.

Documentation on variable CLNL_LTRIM in module ida_kernwin:

    Remove leading space characters.

Documentation on variable CLNL_FINDCMT in module ida_kernwin:

    Search for the comment symbol everywhere in the line, not only at the beginning.

Documentation on variable Choose.CH_MODAL in module ida_kernwin:

    Modal chooser

Documentation on variable Choose.CH_MULTI in module ida_kernwin:

    Allow multi selection.
    Refer the description of the OnInsertLine(), OnDeleteLine(),
    OnEditLine(), OnSelectLine(), OnRefresh(), OnSelectionChange() to
    see a difference between single and multi selection callbacks.

Documentation on variable Choose.CH_NOIDB in module ida_kernwin:

    use the chooser even without an open database, same as x0=-2

Documentation on variable Choose.CH_FORCE_DEFAULT in module ida_kernwin:

    If a non-modal chooser was already open, change selection to the given
    default one

Documentation on variable Choose.CH_CAN_INS in module ida_kernwin:

    allow to insert new items

Documentation on variable Choose.CH_CAN_DEL in module ida_kernwin:

    allow to delete existing item(s)

Documentation on variable Choose.CH_CAN_EDIT in module ida_kernwin:

    allow to edit existing item(s)

Documentation on variable Choose.CH_CAN_REFRESH in module ida_kernwin:

    allow to refresh chooser

Documentation on variable Choose.CH_QFLT in module ida_kernwin:

    open with quick filter enabled and focused

Documentation on variable Choose.CH_NO_STATUS_BAR in module ida_kernwin:

    don't show a status bar

Documentation on variable Choose.CH_RESTORE in module ida_kernwin:

    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)

Documentation on variable Choose.CH_RENAME_IS_EDIT in module ida_kernwin:

    triggering a 'edit/rename' (i.e., F2 shortcut) on a cell,
    should call the edit() callback for the corresponding row.

Documentation on variable Choose.NO_SELECTION in module ida_kernwin:

    there is no selected item

Documentation on variable Choose.EMPTY_CHOOSER in module ida_kernwin:

    the chooser is initialized

Documentation on variable Choose.ALREADY_EXISTS in module ida_kernwin:

    the non-modal chooser with the same data is already open

Documentation on variable Choose.NO_ATTR in module ida_kernwin:

    some mandatory attribute is missing

Documentation on variable textctrl_info_t.TXTF_AUTOINDENT in module ida_kernwin:

    Auto-indent on new line

Documentation on variable textctrl_info_t.TXTF_ACCEPTTABS in module ida_kernwin:

    Tab key inserts 'tabsize' spaces

Documentation on variable textctrl_info_t.TXTF_READONLY in module ida_kernwin:

    Text cannot be edited (but can be selected and copied)

Documentation on variable textctrl_info_t.TXTF_SELECTED in module ida_kernwin:

    Shows the field with its text selected

Documentation on variable textctrl_info_t.TXTF_MODIFIED in module ida_kernwin:

    Gets/sets the modified status

Documentation on variable textctrl_info_t.TXTF_FIXEDFONT in module ida_kernwin:

    The control uses IDA's fixed font

Documentation on variable textctrl_info_t.value in module ida_kernwin:

    Alias for the text property

Documentation on variable textctrl_info_t.text in module ida_kernwin:

    in, out: text control value

Documentation on variable textctrl_info_t.flags in module ida_kernwin:

    Text control property bits

Documentation on variable textctrl_info_t.tabsize in module ida_kernwin:

    how many spaces a single tab will indent

Documentation on variable Form.FT_ASCII in module ida_kernwin:

    Ascii string - char *

Documentation on variable Form.FT_SEG in module ida_kernwin:

    Segment - sel_t *

Documentation on variable Form.FT_HEX in module ida_kernwin:

    Hex number - uval_t *

Documentation on variable Form.FT_SHEX in module ida_kernwin:

    Signed hex number - sval_t *

Documentation on variable Form.FT_COLOR in module ida_kernwin:

    Color button - bgcolor_t *

Documentation on variable Form.FT_ADDR in module ida_kernwin:

    Address - ea_t *

Documentation on variable Form.FT_UINT64 in module ida_kernwin:

    default base uint64 - uint64

Documentation on variable Form.FT_INT64 in module ida_kernwin:

    default base int64 - int64

Documentation on variable Form.FT_RAWHEX in module ida_kernwin:

    Hex number, no 0x prefix - uval_t *

Documentation on variable Form.FT_FILE in module ida_kernwin:

    File browse - char * at least QMAXPATH

Documentation on variable Form.FT_DEC in module ida_kernwin:

    Decimal number - sval_t *

Documentation on variable Form.FT_OCT in module ida_kernwin:

    Octal number, C notation - sval_t *

Documentation on variable Form.FT_BIN in module ida_kernwin:

    Binary number, 0b prefix - sval_t *

Documentation on variable Form.FT_CHAR in module ida_kernwin:

    Char value -- sval_t *

Documentation on variable Form.FT_IDENT in module ida_kernwin:

    Identifier - char * at least MAXNAMELEN

Documentation on variable Form.FT_BUTTON in module ida_kernwin:

    Button - def handler(code)

Documentation on variable Form.FT_DIR in module ida_kernwin:

    Path to directory - char * at least QMAXPATH

Documentation on variable Form.FT_TYPE in module ida_kernwin:

    Type declaration - char * at least MAXSTR

Documentation on variable Form._FT_USHORT in module ida_kernwin:

    Unsigned short

Documentation on variable Form.FT_FORMCHG in module ida_kernwin:

    Form change callback - formchgcb_t

Documentation on variable Form.FT_ECHOOSER in module ida_kernwin:

    Embedded chooser - idaapi.Choose

Documentation on variable Form.FT_MULTI_LINE_TEXT in module ida_kernwin:

    Multi text control - textctrl_info_t

Documentation on variable Form.FT_DROPDOWN_LIST in module ida_kernwin:

    Dropdown list control - Form.DropdownControl

Documentation on variable Form.FT_HTML_LABEL in module ida_kernwin:

    HTML label to display (only for GUI version, and for dynamic labels; no input)

Documentation on variable Form.NumericArgument.StringArgument.Control.LabelControl.StringLabel.NumericLabel.GroupItemControl.ChkGroupItemControl.checked in module ida_kernwin:

    Get/Sets checkbox item check status

Documentation on variable Form.NumericArgument.StringArgument.Control.LabelControl.StringLabel.NumericLabel.GroupItemControl.ChkGroupItemControl.RadGroupItemControl.selected in module ida_kernwin:

    Get/Sets radiobox item selection status

Documentation on variable Form.NumericArgument.StringArgument.Control.LabelControl.StringLabel.NumericLabel.GroupItemControl.ChkGroupItemControl.RadGroupItemControl.GroupControl.ChkGroupControl.ItemClass in module ida_kernwin:

    Group control item factory class instance
    We need this because later we won't be treating ChkGroupControl or RadGroupControl
    individually, instead we will be working with GroupControl in general.

Documentation on variable Form.NumericArgument.StringArgument.Control.LabelControl.StringLabel.NumericLabel.GroupItemControl.ChkGroupItemControl.RadGroupItemControl.GroupControl.ChkGroupControl.RadGroupControl.InputControl.NumericInput.ColorInput.StringInput.FileInput.DirInput.ButtonInput.FormChangeCb.EmbeddedChooserControl.value in module ida_kernwin:

    Returns the embedded chooser instance

Documentation on variable Form.NumericArgument.StringArgument.Control.LabelControl.StringLabel.NumericLabel.GroupItemControl.ChkGroupItemControl.RadGroupItemControl.GroupControl.ChkGroupControl.RadGroupControl.InputControl.NumericInput.ColorInput.StringInput.FileInput.DirInput.ButtonInput.FormChangeCb.EmbeddedChooserControl.selection in module ida_kernwin:

    Returns the selection

Documentation on variable Form.NumericArgument.StringArgument.Control.LabelControl.StringLabel.NumericLabel.GroupItemControl.ChkGroupItemControl.RadGroupItemControl.GroupControl.ChkGroupControl.RadGroupControl.InputControl.NumericInput.ColorInput.StringInput.FileInput.DirInput.ButtonInput.FormChangeCb.EmbeddedChooserControl.DropdownListControl.selval in module ida_kernwin:

    Read/write the selection value.
    The value is used as an item index in readonly mode or text value in editable mode
    This value can be used only after the form has been closed.

Documentation on variable PluginForm.WOPN_RESTORE in module ida_kernwin:

    if the widget is the only widget in a floating area when
    it is closed, remember that area's geometry. The next
    time that widget is created as floating (i.e., WOPN_DP_FLOATING)
    its geometry will be restored (e.g., "Execute script"

Documentation on variable PluginForm.WOPN_PERSIST in module ida_kernwin:

    form will persist until explicitly closed with Close()

Documentation on variable PluginForm.WOPN_DP_LEFT in module ida_kernwin:

    Dock widget to the left of dest_ctrl

Documentation on variable PluginForm.WOPN_DP_TOP in module ida_kernwin:

    Dock widget above dest_ctrl

Documentation on variable PluginForm.WOPN_DP_RIGHT in module ida_kernwin:

    Dock widget to the right of dest_ctrl

Documentation on variable PluginForm.WOPN_DP_BOTTOM in module ida_kernwin:

    Dock widget below dest_ctrl

Documentation on variable PluginForm.WOPN_DP_INSIDE in module ida_kernwin:

    Create a new tab bar with both widget and dest_ctrl

Documentation on variable PluginForm.WOPN_DP_TAB in module ida_kernwin:

    Place widget into a tab next to dest_ctrl,
    if dest_ctrl is in a tab bar
    (otherwise the same as #WOPN_DP_INSIDE)

Documentation on variable PluginForm.WOPN_DP_BEFORE in module ida_kernwin:

    place widget before dst_form in the tab bar instead of after
    used with #WOPN_DP_INSIDE and #WOPN_DP_TAB

Documentation on variable PluginForm.WOPN_DP_FLOATING in module ida_kernwin:

    When floating or in a splitter (i.e., not tabbed),
    use the widget's size hint to determine the best
    geometry (Qt only)

Documentation on variable PluginForm.WOPN_DP_SZHINT in module ida_kernwin:

    Make widget floating

Documentation on variable PluginForm.WCLS_SAVE in module ida_kernwin:

    Save state in desktop config

Documentation on variable PluginForm.WCLS_NO_CONTEXT in module ida_kernwin:

    Don't change the current context (useful for toolbars)

Documentation on variable PluginForm.WCLS_DONT_SAVE_SIZE in module ida_kernwin:

    Don't save size of the window

Documentation on variable PluginForm.WCLS_DELETE_LATER in module ida_kernwin:

    This flag should be used when Close() is called from an event handler

Documentation on variable COLOR_ON in module ida_lines:

    Escape character (ON). Followed by a color code (color_t).

Documentation on variable COLOR_OFF in module ida_lines:

    Escape character (OFF). Followed by a color code (color_t).

Documentation on variable COLOR_ESC in module ida_lines:

    Escape character (Quote next character). This is needed to output '\1' and '\2'
    characters.

Documentation on variable COLOR_INV in module ida_lines:

    Escape character (Inverse foreground and background colors). This escape
    character has no corresponding COLOR_OFF. Its action continues until the next
    COLOR_INV or end of line.

Documentation on variable SCOLOR_ON in module ida_lines:

    Escape character (ON)

Documentation on variable SCOLOR_OFF in module ida_lines:

    Escape character (OFF)

Documentation on variable SCOLOR_ESC in module ida_lines:

    Escape character (Quote next character)

Documentation on variable SCOLOR_INV in module ida_lines:

    Escape character (Inverse colors)

Documentation on variable SCOLOR_DEFAULT in module ida_lines:

    Default.

Documentation on variable SCOLOR_REGCMT in module ida_lines:

    Regular comment.

Documentation on variable SCOLOR_RPTCMT in module ida_lines:

    Repeatable comment (defined not here)

Documentation on variable SCOLOR_AUTOCMT in module ida_lines:

    Automatic comment.

Documentation on variable SCOLOR_INSN in module ida_lines:

    Instruction.

Documentation on variable SCOLOR_DATNAME in module ida_lines:

    Dummy Data Name.

Documentation on variable SCOLOR_DNAME in module ida_lines:

    Regular Data Name.

Documentation on variable SCOLOR_DEMNAME in module ida_lines:

    Demangled Name.

Documentation on variable SCOLOR_SYMBOL in module ida_lines:

    Punctuation.

Documentation on variable SCOLOR_CHAR in module ida_lines:

    Char constant in instruction.

Documentation on variable SCOLOR_STRING in module ida_lines:

    String constant in instruction.

Documentation on variable SCOLOR_NUMBER in module ida_lines:

    Numeric constant in instruction.

Documentation on variable SCOLOR_VOIDOP in module ida_lines:

    Void operand.

Documentation on variable SCOLOR_CREF in module ida_lines:

    Code reference.

Documentation on variable SCOLOR_DREF in module ida_lines:

    Data reference.

Documentation on variable SCOLOR_CREFTAIL in module ida_lines:

    Code reference to tail byte.

Documentation on variable SCOLOR_DREFTAIL in module ida_lines:

    Data reference to tail byte.

Documentation on variable SCOLOR_ERROR in module ida_lines:

    Error or problem.

Documentation on variable SCOLOR_PREFIX in module ida_lines:

    Line prefix.

Documentation on variable SCOLOR_BINPREF in module ida_lines:

    Binary line prefix bytes.

Documentation on variable SCOLOR_EXTRA in module ida_lines:

    Extra line.

Documentation on variable SCOLOR_ALTOP in module ida_lines:

    Alternative operand.

Documentation on variable SCOLOR_HIDNAME in module ida_lines:

    Hidden name.

Documentation on variable SCOLOR_LIBNAME in module ida_lines:

    Library function name.

Documentation on variable SCOLOR_LOCNAME in module ida_lines:

    Local variable name.

Documentation on variable SCOLOR_CODNAME in module ida_lines:

    Dummy code name.

Documentation on variable SCOLOR_ASMDIR in module ida_lines:

    Assembler directive.

Documentation on variable SCOLOR_MACRO in module ida_lines:

    Macro.

Documentation on variable SCOLOR_DSTR in module ida_lines:

    String constant in data directive.

Documentation on variable SCOLOR_DCHAR in module ida_lines:

    Char constant in data directive.

Documentation on variable SCOLOR_DNUM in module ida_lines:

    Numeric constant in data directive.

Documentation on variable SCOLOR_KEYWORD in module ida_lines:

    Keywords.

Documentation on variable SCOLOR_REG in module ida_lines:

    Register name.

Documentation on variable SCOLOR_IMPNAME in module ida_lines:

    Imported name.

Documentation on variable SCOLOR_SEGNAME in module ida_lines:

    Segment name.

Documentation on variable SCOLOR_UNKNAME in module ida_lines:

    Dummy unknown name.

Documentation on variable SCOLOR_CNAME in module ida_lines:

    Regular code name.

Documentation on variable SCOLOR_UNAME in module ida_lines:

    Regular unknown name.

Documentation on variable SCOLOR_COLLAPSED in module ida_lines:

    Collapsed line.

Documentation on variable SCOLOR_ADDR in module ida_lines:

    Hidden address mark.

Documentation on variable COLOR_SELECTED in module ida_lines:

    Selected.

Documentation on variable COLOR_LIBFUNC in module ida_lines:

    Library function.

Documentation on variable COLOR_REGFUNC in module ida_lines:

    Regular function.

Documentation on variable COLOR_CODE in module ida_lines:

    Single instruction.

Documentation on variable COLOR_DATA in module ida_lines:

    Data bytes.

Documentation on variable COLOR_UNKNOWN in module ida_lines:

    Unexplored byte.

Documentation on variable COLOR_EXTERN in module ida_lines:

    External name definition segment.

Documentation on variable COLOR_CURITEM in module ida_lines:

    Current item.

Documentation on variable COLOR_CURLINE in module ida_lines:

    Current line.

Documentation on variable COLOR_HIDLINE in module ida_lines:

    Hidden line.

Documentation on variable COLOR_LUMFUNC in module ida_lines:

    Lumina function.

Documentation on variable COLOR_BG_MAX in module ida_lines:

    Max color number.

Documentation on variable COLOR_DEFAULT in module ida_lines:

    Default.

Documentation on variable COLOR_REGCMT in module ida_lines:

    Regular comment.

Documentation on variable COLOR_RPTCMT in module ida_lines:

    Repeatable comment (comment defined somewhere else)

Documentation on variable COLOR_AUTOCMT in module ida_lines:

    Automatic comment.

Documentation on variable COLOR_INSN in module ida_lines:

    Instruction.

Documentation on variable COLOR_DATNAME in module ida_lines:

    Dummy Data Name.

Documentation on variable COLOR_DNAME in module ida_lines:

    Regular Data Name.

Documentation on variable COLOR_DEMNAME in module ida_lines:

    Demangled Name.

Documentation on variable COLOR_SYMBOL in module ida_lines:

    Punctuation.

Documentation on variable COLOR_CHAR in module ida_lines:

    Char constant in instruction.

Documentation on variable COLOR_STRING in module ida_lines:

    String constant in instruction.

Documentation on variable COLOR_NUMBER in module ida_lines:

    Numeric constant in instruction.

Documentation on variable COLOR_VOIDOP in module ida_lines:

    Void operand.

Documentation on variable COLOR_CREF in module ida_lines:

    Code reference.

Documentation on variable COLOR_DREF in module ida_lines:

    Data reference.

Documentation on variable COLOR_CREFTAIL in module ida_lines:

    Code reference to tail byte.

Documentation on variable COLOR_DREFTAIL in module ida_lines:

    Data reference to tail byte.

Documentation on variable COLOR_ERROR in module ida_lines:

    Error or problem.

Documentation on variable COLOR_PREFIX in module ida_lines:

    Line prefix.

Documentation on variable COLOR_BINPREF in module ida_lines:

    Binary line prefix bytes.

Documentation on variable COLOR_EXTRA in module ida_lines:

    Extra line.

Documentation on variable COLOR_ALTOP in module ida_lines:

    Alternative operand.

Documentation on variable COLOR_HIDNAME in module ida_lines:

    Hidden name.

Documentation on variable COLOR_LIBNAME in module ida_lines:

    Library function name.

Documentation on variable COLOR_LOCNAME in module ida_lines:

    Local variable name.

Documentation on variable COLOR_CODNAME in module ida_lines:

    Dummy code name.

Documentation on variable COLOR_ASMDIR in module ida_lines:

    Assembler directive.

Documentation on variable COLOR_MACRO in module ida_lines:

    Macro.

Documentation on variable COLOR_DSTR in module ida_lines:

    String constant in data directive.

Documentation on variable COLOR_DCHAR in module ida_lines:

    Char constant in data directive.

Documentation on variable COLOR_DNUM in module ida_lines:

    Numeric constant in data directive.

Documentation on variable COLOR_KEYWORD in module ida_lines:

    Keywords.

Documentation on variable COLOR_REG in module ida_lines:

    Register name.

Documentation on variable COLOR_IMPNAME in module ida_lines:

    Imported name.

Documentation on variable COLOR_SEGNAME in module ida_lines:

    Segment name.

Documentation on variable COLOR_UNKNAME in module ida_lines:

    Dummy unknown name.

Documentation on variable COLOR_CNAME in module ida_lines:

    Regular code name.

Documentation on variable COLOR_UNAME in module ida_lines:

    Regular unknown name.

Documentation on variable COLOR_COLLAPSED in module ida_lines:

    Collapsed line.

Documentation on variable COLOR_FG_MAX in module ida_lines:

    Max color number.

Documentation on variable COLOR_ADDR in module ida_lines:

    hidden address marks. the address is represented as 8digit hex number: 01234567.
    it doesn't have COLOR_OFF pair. NB: for 64-bit IDA, the address is 16digit.

Documentation on variable COLOR_OPND1 in module ida_lines:

    Instruction operand 1.

Documentation on variable COLOR_OPND2 in module ida_lines:

    Instruction operand 2.

Documentation on variable COLOR_OPND3 in module ida_lines:

    Instruction operand 3.

Documentation on variable COLOR_OPND4 in module ida_lines:

    Instruction operand 4.

Documentation on variable COLOR_OPND5 in module ida_lines:

    Instruction operand 5.

Documentation on variable COLOR_OPND6 in module ida_lines:

    Instruction operand 6.

Documentation on variable COLOR_OPND7 in module ida_lines:

    Instruction operand 7.

Documentation on variable COLOR_OPND8 in module ida_lines:

    Instruction operand 8.

Documentation on variable COLOR_RESERVED1 in module ida_lines:

    This tag is reserved for internal IDA use.

Documentation on variable COLOR_LUMINA in module ida_lines:

    Lumina-related, only for the navigation band.

Documentation on variable COLOR_ADDR_SIZE in module ida_lines:

    Size of a tagged address (see COLOR_ADDR)

Documentation on variable loader_t.version in module ida_loader:

    api version, should be IDP_INTERFACE_VERSION

Documentation on variable loader_t.flags in module ida_loader:

    Loader flags

Documentation on variable LDRF_RELOAD in module ida_loader:

    loader recognizes NEF_RELOAD flag

Documentation on variable LDRF_REQ_PROC in module ida_loader:

    Requires a processor to be set. if this bit is not set, load_file() must call
    set_processor_type(..., SETPROC_LOADER)

Documentation on variable ACCEPT_ARCHIVE in module ida_loader:

    Specify that a file format is served by archive loader See loader_t::accept_file

Documentation on variable ACCEPT_CONTINUE in module ida_loader:

    Specify that the function must be called another time See loader_t::accept_file

Documentation on variable ACCEPT_FIRST in module ida_loader:

    Specify that a file format should be place first in "load file" dialog box. See
    loader_t::accept_file

Documentation on variable NEF_SEGS in module ida_loader:

    Create segments.

Documentation on variable NEF_RSCS in module ida_loader:

    Load resources.

Documentation on variable NEF_NAME in module ida_loader:

    Rename entries.

Documentation on variable NEF_MAN in module ida_loader:

    Manual load.

Documentation on variable NEF_FILL in module ida_loader:

    Fill segment gaps.

Documentation on variable NEF_IMPS in module ida_loader:

    Create import segment.

Documentation on variable NEF_FIRST in module ida_loader:

    This is the first file loaded into the database.

Documentation on variable NEF_CODE in module ida_loader:

    for load_binary_file(): load as a code segment

Documentation on variable NEF_RELOAD in module ida_loader:

    reload the file at the same place:
    * don't create segments
    * don't create fixup info
    * don't import segments
    * etc.
    
    Load only the bytes into the base. A loader should have the LDRF_RELOAD bit set.

Documentation on variable NEF_FLAT in module ida_loader:

    Autocreate FLAT group (PE)

Documentation on variable NEF_MINI in module ida_loader:

    Create mini database (do not copy segment bytes from the input file; use only
    the file header metadata)

Documentation on variable NEF_LOPT in module ida_loader:

    Display additional loader options dialog.

Documentation on variable NEF_LALL in module ida_loader:

    Load all segments without questions.

Documentation on variable OFILE_MAP in module ida_loader:

    MAP file.

Documentation on variable OFILE_EXE in module ida_loader:

    Executable file.

Documentation on variable OFILE_IDC in module ida_loader:

    IDC file.

Documentation on variable OFILE_LST in module ida_loader:

    Disassembly listing.

Documentation on variable OFILE_ASM in module ida_loader:

    Assembly.

Documentation on variable OFILE_DIF in module ida_loader:

    Difference.

Documentation on variable GENFLG_ASMTYPE in module ida_loader:

    OFILE_ASM,OFILE_LST: gen information about types too

Documentation on variable GENFLG_GENHTML in module ida_loader:

    OFILE_ASM,OFILE_LST: generate html (ui_genfile_callback will be used)

Documentation on variable GENFLG_ASMINC in module ida_loader:

    OFILE_ASM,OFILE_LST: gen information only about types

Documentation on variable FILEREG_PATCHABLE in module ida_loader:

    means that the input file may be patched (i.e. no compression, no iterated data,
    etc)

Documentation on variable FILEREG_NOTPATCHABLE in module ida_loader:

    the data is kept in some encoded form in the file.

Documentation on variable PLUGIN_DLL in module ida_loader:

    Pattern to find plugin files.

Documentation on variable idp_name_t.lname in module ida_loader:

    long processor name

Documentation on variable idp_name_t.sname in module ida_loader:

    short processor name

Documentation on variable idp_name_t.hidden in module ida_loader:

    is hidden

Documentation on variable idp_desc_t.path in module ida_loader:

    module file name

Documentation on variable idp_desc_t.mtime in module ida_loader:

    time of last modification

Documentation on variable idp_desc_t.family in module ida_loader:

    processor's family

Documentation on variable idp_desc_t.names in module ida_loader:

    processor names

Documentation on variable idp_desc_t.is_script in module ida_loader:

    the processor module is a script

Documentation on variable idp_desc_t.checked in module ida_loader:

    internal, for cache management

Documentation on variable plugin_info_t.next in module ida_loader:

    next plugin information

Documentation on variable plugin_info_t.path in module ida_loader:

    full path to the plugin

Documentation on variable plugin_info_t.org_name in module ida_loader:

    original short name of the plugin

Documentation on variable plugin_info_t.name in module ida_loader:

    short name of the plugin it will appear in the menu

Documentation on variable plugin_info_t.org_hotkey in module ida_loader:

    original hotkey to run the plugin

Documentation on variable plugin_info_t.hotkey in module ida_loader:

    current hotkey to run the plugin

Documentation on variable plugin_info_t.arg in module ida_loader:

    argument used to call the plugin

Documentation on variable plugin_info_t.entry in module ida_loader:

    pointer to the plugin if it is already loaded

Documentation on variable plugin_info_t.flags in module ida_loader:

    a copy of plugin_t::flags

Documentation on variable plugin_info_t.comment in module ida_loader:

    a copy of plugin_t::comment

Documentation on variable MAX_DATABASE_DESCRIPTION in module ida_loader:

    Maximum database snapshot description length.

Documentation on variable snapshot_t.id in module ida_loader:

    snapshot ID. This value is computed using qgettimeofday()

Documentation on variable snapshot_t.flags in module ida_loader:

    Snapshot flags

Documentation on variable snapshot_t.desc in module ida_loader:

    snapshot description

Documentation on variable snapshot_t.filename in module ida_loader:

    snapshot file name

Documentation on variable snapshot_t.children in module ida_loader:

    snapshot children

Documentation on variable SSF_AUTOMATIC in module ida_loader:

    automatic snapshot

Documentation on variable SSUF_DESC in module ida_loader:

    Update the description.

Documentation on variable SSUF_PATH in module ida_loader:

    Update the path.

Documentation on variable SSUF_FLAGS in module ida_loader:

    Update the flags.

Documentation on variable DBFL_KILL in module ida_loader:

    delete unpacked database

Documentation on variable DBFL_COMP in module ida_loader:

    collect garbage

Documentation on variable DBFL_BAK in module ida_loader:

    create backup file (if !DBFL_KILL)

Documentation on variable DBFL_TEMP in module ida_loader:

    temporary database

Documentation on variable PATH_TYPE_CMD in module ida_loader:

    full path to the file specified in the command line

Documentation on variable PATH_TYPE_IDB in module ida_loader:

    full path of IDB file

Documentation on variable PATH_TYPE_ID0 in module ida_loader:

    full path of ID0 file

Documentation on variable MERGE_KIND_NETNODE in module ida_merge:

    netnode (no merging, to be used in idbunits)

Documentation on variable MERGE_KIND_AUTOQ in module ida_merge:

    auto queues

Documentation on variable MERGE_KIND_INF in module ida_merge:

    merge the inf variable (global settings)

Documentation on variable MERGE_KIND_ENCODINGS in module ida_merge:

    merge encodings

Documentation on variable MERGE_KIND_ENCODINGS2 in module ida_merge:

    merge default encodings

Documentation on variable MERGE_KIND_SCRIPTS2 in module ida_merge:

    merge scripts common info

Documentation on variable MERGE_KIND_SCRIPTS in module ida_merge:

    merge scripts

Documentation on variable MERGE_KIND_CUSTDATA in module ida_merge:

    merge custom data type and formats

Documentation on variable MERGE_KIND_ENUMS in module ida_merge:

    merge enums

Documentation on variable MERGE_KIND_STRUCTS in module ida_merge:

    merge structs (globally: add/delete structs entirely)

Documentation on variable MERGE_KIND_TILS in module ida_merge:

    merge type libraries

Documentation on variable MERGE_KIND_TINFO in module ida_merge:

    merge tinfo

Documentation on variable MERGE_KIND_STRMEM in module ida_merge:

    merge struct members

Documentation on variable MERGE_KIND_UDTMEM in module ida_merge:

    merge UDT members (local types)

Documentation on variable MERGE_KIND_GHSTRCMT in module ida_merge:

    merge ghost structure comment

Documentation on variable MERGE_KIND_STRMEMCMT in module ida_merge:

    merge member comments for ghost struc

Documentation on variable MERGE_KIND_SELECTORS in module ida_merge:

    merge selectors

Documentation on variable MERGE_KIND_STT in module ida_merge:

    merge flag storage types

Documentation on variable MERGE_KIND_SEGMENTS in module ida_merge:

    merge segments

Documentation on variable MERGE_KIND_SEGGRPS in module ida_merge:

    merge segment groups

Documentation on variable MERGE_KIND_SEGREGS in module ida_merge:

    merge segment registers

Documentation on variable MERGE_KIND_ORPHANS in module ida_merge:

    merge orphan bytes

Documentation on variable MERGE_KIND_BYTEVAL in module ida_merge:

    merge byte values

Documentation on variable MERGE_KIND_FIXUPS in module ida_merge:

    merge fixups

Documentation on variable MERGE_KIND_MAPPING in module ida_merge:

    merge manual memory mapping

Documentation on variable MERGE_KIND_EXPORTS in module ida_merge:

    merge exports

Documentation on variable MERGE_KIND_IMPORTS in module ida_merge:

    merge imports

Documentation on variable MERGE_KIND_PATCHES in module ida_merge:

    merge patched bytes

Documentation on variable MERGE_KIND_FLAGS in module ida_merge:

    merge flags_t

Documentation on variable MERGE_KIND_EXTRACMT in module ida_merge:

    merge extra next or prev lines

Documentation on variable MERGE_KIND_AFLAGS_EA in module ida_merge:

    merge aflags for mapped EA

Documentation on variable MERGE_KIND_IGNOREMICRO in module ida_merge:

    IM ("$ ignore micro") flags.

Documentation on variable MERGE_KIND_HIDDENRANGES in module ida_merge:

    merge hidden ranges

Documentation on variable MERGE_KIND_SOURCEFILES in module ida_merge:

    merge source files ranges

Documentation on variable MERGE_KIND_FUNC in module ida_merge:

    merge func info

Documentation on variable MERGE_KIND_FRAMEMGR in module ida_merge:

    merge frames (globally: add/delete frames entirely)

Documentation on variable MERGE_KIND_FRAME in module ida_merge:

    merge function frame info (frame members)

Documentation on variable MERGE_KIND_STKPNTS in module ida_merge:

    merge SP change points

Documentation on variable MERGE_KIND_FLOWS in module ida_merge:

    merge flows

Documentation on variable MERGE_KIND_CREFS in module ida_merge:

    merge crefs

Documentation on variable MERGE_KIND_DREFS in module ida_merge:

    merge drefs

Documentation on variable MERGE_KIND_BPTS in module ida_merge:

    merge breakpoints

Documentation on variable MERGE_KIND_WATCHPOINTS in module ida_merge:

    merge watchpoints

Documentation on variable MERGE_KIND_BOOKMARKS in module ida_merge:

    merge bookmarks

Documentation on variable MERGE_KIND_TRYBLKS in module ida_merge:

    merge try blocks

Documentation on variable MERGE_KIND_DIRTREE in module ida_merge:

    merge std dirtrees

Documentation on variable MERGE_KIND_VFTABLES in module ida_merge:

    merge vftables

Documentation on variable MERGE_KIND_SIGNATURES in module ida_merge:

    signatures

Documentation on variable MERGE_KIND_PROBLEMS in module ida_merge:

    problems

Documentation on variable MERGE_KIND_UI in module ida_merge:

    UI.

Documentation on variable MERGE_KIND_NOTEPAD in module ida_merge:

    notepad

Documentation on variable MERGE_KIND_LOADER in module ida_merge:

    loader data

Documentation on variable MERGE_KIND_DEBUGGER in module ida_merge:

    debugger data

Documentation on variable MERGE_KIND_DBG_MEMREGS in module ida_merge:

    manual memory regions (debugger)

Documentation on variable MERGE_KIND_LAST in module ida_merge:

    last predefined merge handler type. please note that there can be more merge
    handler types, registered by plugins and processor modules.

Documentation on variable MERGE_KIND_END in module ida_merge:

    insert to the end of handler list, valid for
    merge_handler_params_t::insert_after

Documentation on variable merge_data_t.dbctx_ids in module ida_merge:

    local, remote, base ids

Documentation on variable merge_data_t.nbases in module ida_merge:

    number of database participating in merge process, maybe 2 or 3

Documentation on variable merge_data_t.ev_handlers in module ida_merge:

    event handlers

Documentation on variable merge_handler_params_t.kind in module ida_merge:

    merge handler kind merge_kind_t

Documentation on variable merge_handler_params_t.insert_after in module ida_merge:

    desired position inside 'handlers' merge_kind_t

Documentation on variable MH_LISTEN in module ida_merge:

    merge handler will receive merge events

Documentation on variable MH_TERSE in module ida_merge:

    do not display equal lines in the merge results table

Documentation on variable MH_UI_NODETAILS in module ida_merge:

    ida will not show the diffpos details

Documentation on variable MH_UI_COMPLEX in module ida_merge:

    diffpos details won't be displayed in the diffpos chooser

Documentation on variable MH_UI_DP_NOLINEDIFF in module ida_merge:

    Detail pane: do not show differences inside the line.

Documentation on variable MH_UI_DP_SHORTNAME in module ida_merge:

    Detail pane: use the first part of a complex diffpos name as the tree node name.

Documentation on variable MH_UI_INDENT in module ida_merge:

    preserve indent for diffpos name in diffpos chooser

Documentation on variable MH_UI_SPLITNAME in module ida_merge:

    ida will split the diffpos name by 7-bit ASCII char to create chooser columns

Documentation on variable MH_UI_CHAR_MASK in module ida_merge:

    7-bit ASCII split character

Documentation on variable MH_UI_COMMANAME in module ida_merge:

    ida will split the diffpos name by ',' to create chooser columns

Documentation on variable MH_UI_COLONNAME in module ida_merge:

    ida will split the diffpos name by ':' to create chooser columns

Documentation on variable moddata_diff_helper_t.module_name in module ida_merge:

    will be used as a prefix for field desc

Documentation on variable moddata_diff_helper_t.netnode_name in module ida_merge:

    name of netnode with module data attributes

Documentation on variable moddata_diff_helper_t.fields in module ida_merge:

    module data attribute descriptions

Documentation on variable moddata_diff_helper_t.nfields in module ida_merge:

    number of descriptions

Documentation on variable moddata_diff_helper_t.additional_mh_flags in module ida_merge:

    additional merge handler flags

Documentation on variable NDS_IS_BOOL in module ida_merge:

    boolean value

Documentation on variable NDS_IS_EA in module ida_merge:

    EA value.

Documentation on variable NDS_IS_RELATIVE in module ida_merge:

    value is relative to index (stored as delta)

Documentation on variable NDS_IS_STR in module ida_merge:

    string value

Documentation on variable NDS_SUPVAL in module ida_merge:

    stored as netnode supvals (not scalar)

Documentation on variable NDS_BLOB in module ida_merge:

    stored as netnode blobs

Documentation on variable NDS_EV_RANGE in module ida_merge:

    enable default handling of mev_modified_ranges, mev_deleting_segm

Documentation on variable NDS_EV_FUNC in module ida_merge:

    enable default handling of mev_added_func/mev_deleting_func

Documentation on variable NDS_MAP_IDX in module ida_merge:

    apply ea2node() to index (==NETMAP_IDX)

Documentation on variable NDS_MAP_VAL in module ida_merge:

    apply ea2node() to value. Along with NDS_INC it gives effect of NETMAP_VAL,
    examples: altval_ea : NDS_MAP_IDX charval : NDS_VAL8 charval_ea:
    NDS_MAP_IDX|NDS_VAL8 eaget : NDS_MAP_IDX|NDS_MAP_VAL|NDS_INC

Documentation on variable NDS_VAL8 in module ida_merge:

    use 8-bit values (==NETMAP_V8)

Documentation on variable NDS_INC in module ida_merge:

    stored value is incremented (scalars only)

Documentation on variable merge_node_info_t.name in module ida_merge:

    name of the array (label)

Documentation on variable merge_node_info_t.tag in module ida_merge:

    a tag used to access values in the netnode

Documentation on variable merge_node_info_t.nds_flags in module ida_merge:

    node value attributes (a combination of nds_flags_t)

Documentation on variable NALT_SWITCH in module ida_nalt:

    switch idiom address (used at jump targets)

Documentation on variable NALT_STRUCT in module ida_nalt:

    struct id

Documentation on variable NALT_AFLAGS in module ida_nalt:

    additional flags for an item

Documentation on variable NALT_LINNUM in module ida_nalt:

    source line number

Documentation on variable NALT_ABSBASE in module ida_nalt:

    absolute segment location

Documentation on variable NALT_ENUM0 in module ida_nalt:

    enum id for the first operand

Documentation on variable NALT_ENUM1 in module ida_nalt:

    enum id for the second operand

Documentation on variable NALT_PURGE in module ida_nalt:

    number of bytes purged from the stack when a function is called indirectly

Documentation on variable NALT_STRTYPE in module ida_nalt:

    type of string item

Documentation on variable NALT_ALIGN in module ida_nalt:

    alignment value if the item is FF_ALIGN (should by equal to power of 2)

Documentation on variable NALT_COLOR in module ida_nalt:

    instruction/data background color

Documentation on variable NSUP_CMT in module ida_nalt:

    regular comment

Documentation on variable NSUP_REPCMT in module ida_nalt:

    repeatable comment

Documentation on variable NSUP_FOP1 in module ida_nalt:

    forced operand 1

Documentation on variable NSUP_FOP2 in module ida_nalt:

    forced operand 2

Documentation on variable NSUP_JINFO in module ida_nalt:

    jump table info

Documentation on variable NSUP_ARRAY in module ida_nalt:

    array parameters

Documentation on variable NSUP_FOP3 in module ida_nalt:

    forced operand 3

Documentation on variable NSUP_SWITCH in module ida_nalt:

    switch information

Documentation on variable NSUP_REF0 in module ida_nalt:

    complex reference information for operand 1

Documentation on variable NSUP_REF1 in module ida_nalt:

    complex reference information for operand 2

Documentation on variable NSUP_REF2 in module ida_nalt:

    complex reference information for operand 3

Documentation on variable NSUP_OREF0 in module ida_nalt:

    outer complex reference information for operand 1

Documentation on variable NSUP_OREF1 in module ida_nalt:

    outer complex reference information for operand 2

Documentation on variable NSUP_OREF2 in module ida_nalt:

    outer complex reference information for operand 3

Documentation on variable NSUP_SEGTRANS in module ida_nalt:

    segment translations

Documentation on variable NSUP_FOP4 in module ida_nalt:

    forced operand 4

Documentation on variable NSUP_FOP5 in module ida_nalt:

    forced operand 5

Documentation on variable NSUP_FOP6 in module ida_nalt:

    forced operand 6

Documentation on variable NSUP_REF3 in module ida_nalt:

    complex reference information for operand 4

Documentation on variable NSUP_REF4 in module ida_nalt:

    complex reference information for operand 5

Documentation on variable NSUP_REF5 in module ida_nalt:

    complex reference information for operand 6

Documentation on variable NSUP_OREF3 in module ida_nalt:

    outer complex reference information for operand 4

Documentation on variable NSUP_OREF4 in module ida_nalt:

    outer complex reference information for operand 5

Documentation on variable NSUP_OREF5 in module ida_nalt:

    outer complex reference information for operand 6

Documentation on variable NSUP_XREFPOS in module ida_nalt:

    saved xref address and type in the xrefs window

Documentation on variable NSUP_CUSTDT in module ida_nalt:

    custom data type id

Documentation on variable NSUP_ARGEAS in module ida_nalt:

    instructions that initialize call arguments

Documentation on variable NSUP_FOP7 in module ida_nalt:

    forced operand 7

Documentation on variable NSUP_FOP8 in module ida_nalt:

    forced operand 8

Documentation on variable NSUP_REF6 in module ida_nalt:

    complex reference information for operand 7

Documentation on variable NSUP_REF7 in module ida_nalt:

    complex reference information for operand 8

Documentation on variable NSUP_OREF6 in module ida_nalt:

    outer complex reference information for operand 7

Documentation on variable NSUP_OREF7 in module ida_nalt:

    outer complex reference information for operand 8

Documentation on variable NSUP_POINTS in module ida_nalt:

    SP change points blob (see funcs.cpp). values NSUP_POINTS..NSUP_POINTS+0x1000
    are reserved

Documentation on variable NSUP_MANUAL in module ida_nalt:

    manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are reserved

Documentation on variable NSUP_TYPEINFO in module ida_nalt:

    type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are reserved

Documentation on variable NSUP_REGVAR in module ida_nalt:

    register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are reserved

Documentation on variable NSUP_LLABEL in module ida_nalt:

    local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved

Documentation on variable NSUP_REGARG in module ida_nalt:

    register argument type/name descriptions values NSUP_REGARG..NSUP_REGARG+0x1000
    are reserved

Documentation on variable NSUP_FTAILS in module ida_nalt:

    function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000 are
    reserved

Documentation on variable NSUP_GROUP in module ida_nalt:

    graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are reserved

Documentation on variable NSUP_OPTYPES in module ida_nalt:

    operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000 are
    reserved

Documentation on variable NSUP_ORIGFMD in module ida_nalt:

    function metadata before lumina information was applied values
    NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved

Documentation on variable NALT_CREF_TO in module ida_nalt:

    code xref to, idx: target address

Documentation on variable NALT_CREF_FROM in module ida_nalt:

    code xref from, idx: source address

Documentation on variable NALT_DREF_TO in module ida_nalt:

    data xref to, idx: target address

Documentation on variable NALT_DREF_FROM in module ida_nalt:

    data xref from, idx: source address

Documentation on variable NSUP_GR_INFO in module ida_nalt:

    group node info: color, ea, text

Documentation on variable NALT_GR_LAYX in module ida_nalt:

    group layout ptrs, hash: md5 of 'belongs'

Documentation on variable NSUP_GR_LAYT in module ida_nalt:

    group layouts, idx: layout pointer

Documentation on variable PATCH_TAG in module ida_nalt:

    Patch netnode tag.

Documentation on variable AFL_LINNUM in module ida_nalt:

    has line number info

Documentation on variable AFL_USERSP in module ida_nalt:

    user-defined SP value

Documentation on variable AFL_PUBNAM in module ida_nalt:

    name is public (inter-file linkage)

Documentation on variable AFL_WEAKNAM in module ida_nalt:

    name is weak

Documentation on variable AFL_HIDDEN in module ida_nalt:

    the item is hidden completely

Documentation on variable AFL_MANUAL in module ida_nalt:

    the instruction/data is specified by the user

Documentation on variable AFL_NOBRD in module ida_nalt:

    the code/data border is hidden

Documentation on variable AFL_ZSTROFF in module ida_nalt:

    display struct field name at 0 offset when displaying an offset. example:
    offset somestruct.field_0  if this flag is clear, then
    offset somestruct

Documentation on variable AFL_BNOT0 in module ida_nalt:

    the 1st operand is bitwise negated

Documentation on variable AFL_BNOT1 in module ida_nalt:

    the 2nd operand is bitwise negated

Documentation on variable AFL_LIB in module ida_nalt:

    item from the standard library. low level flag, is used to set FUNC_LIB of
    func_t

Documentation on variable AFL_TI in module ida_nalt:

    has typeinfo? (NSUP_TYPEINFO); used only for addresses, not for member_t

Documentation on variable AFL_TI0 in module ida_nalt:

    has typeinfo for operand 0? (NSUP_OPTYPES)

Documentation on variable AFL_TI1 in module ida_nalt:

    has typeinfo for operand 1? (NSUP_OPTYPES+1)

Documentation on variable AFL_LNAME in module ida_nalt:

    has local name too (FF_NAME should be set)

Documentation on variable AFL_TILCMT in module ida_nalt:

    has type comment? (such a comment may be changed by IDA)

Documentation on variable AFL_LZERO0 in module ida_nalt:

    toggle leading zeroes for the 1st operand

Documentation on variable AFL_LZERO1 in module ida_nalt:

    toggle leading zeroes for the 2nd operand

Documentation on variable AFL_COLORED in module ida_nalt:

    has user defined instruction color?

Documentation on variable AFL_TERSESTR in module ida_nalt:

    terse structure variable display?

Documentation on variable AFL_NORET in module ida_nalt:

    for imported function pointers: doesn't return. this flag can also be used for
    any instruction which halts or finishes the program execution

Documentation on variable AFL_FIXEDSPD in module ida_nalt:

    sp delta value is fixed by analysis. should not be modified by modules

Documentation on variable AFL_ALIGNFLOW in module ida_nalt:

    the previous insn was created for alignment purposes only

Documentation on variable AFL_USERTI in module ida_nalt:

    the type information is definitive. (comes from the user or type library) if not
    set see AFL_TYPE_GUESSED

Documentation on variable AFL_RETFP in module ida_nalt:

    function returns a floating point value

Documentation on variable AFL_USEMODSP in module ida_nalt:

    insn modifes SP and uses the modified value; example: pop [rsp+N]

Documentation on variable AFL_NOTCODE in module ida_nalt:

    autoanalysis should not create code here

Documentation on variable AFL_NOTPROC in module ida_nalt:

    autoanalysis should not create proc here

Documentation on variable AFL_TYPE_GUESSED in module ida_nalt:

    who guessed the type information?

Documentation on variable AFL_IDA_GUESSED in module ida_nalt:

    the type is guessed by IDA

Documentation on variable AFL_HR_GUESSED_FUNC in module ida_nalt:

    the function type is guessed by the decompiler

Documentation on variable AFL_HR_GUESSED_DATA in module ida_nalt:

    the data type is guessed by the decompiler

Documentation on variable AFL_HR_DETERMINED in module ida_nalt:

    the type is definitely guessed by the decompiler

Documentation on variable STRTYPE_TERMCHR in module ida_nalt:

    C-style string.
    
    < Character-terminated string. The termination characters are kept in the next
    bytes of string type.

Documentation on variable STRTYPE_C in module ida_nalt:

    Zero-terminated 16bit chars.

Documentation on variable STRTYPE_C_16 in module ida_nalt:

    Zero-terminated 32bit chars.

Documentation on variable STRTYPE_C_32 in module ida_nalt:

    Pascal-style, one-byte length prefix.

Documentation on variable STRTYPE_PASCAL in module ida_nalt:

    Pascal-style, 16bit chars, one-byte length prefix.

Documentation on variable STRTYPE_PASCAL_16 in module ida_nalt:

    Pascal-style, two-byte length prefix.

Documentation on variable STRTYPE_LEN2 in module ida_nalt:

    Pascal-style, 16bit chars, two-byte length prefix.

Documentation on variable STRTYPE_LEN2_16 in module ida_nalt:

    Pascal-style, four-byte length prefix.

Documentation on variable STRTYPE_LEN4 in module ida_nalt:

    Pascal-style, 16bit chars, four-byte length prefix.

Documentation on variable STRENC_DEFAULT in module ida_nalt:

    use default encoding for this type (see get_default_encoding_idx())

Documentation on variable STRENC_NONE in module ida_nalt:

    force no-conversion encoding

Documentation on variable array_parameters_t.lineitems in module ida_nalt:

    number of items on a line

Documentation on variable array_parameters_t.alignment in module ida_nalt:

    -1 - don't align. 0 - align automatically. else item width

Documentation on variable AP_ALLOWDUPS in module ida_nalt:

    use 'dup' construct

Documentation on variable AP_SIGNED in module ida_nalt:

    treats numbers as signed

Documentation on variable AP_INDEX in module ida_nalt:

    display array element indexes as comments

Documentation on variable AP_ARRAY in module ida_nalt:

    create as array (this flag is not stored in database)

Documentation on variable AP_IDXBASEMASK in module ida_nalt:

    mask for number base of the indexes

Documentation on variable AP_IDXDEC in module ida_nalt:

    display indexes in decimal

Documentation on variable AP_IDXHEX in module ida_nalt:

    display indexes in hex

Documentation on variable AP_IDXOCT in module ida_nalt:

    display indexes in octal

Documentation on variable AP_IDXBIN in module ida_nalt:

    display indexes in binary

Documentation on variable switch_info_t.flags in module ida_nalt:

    Switch info flags

Documentation on variable switch_info_t.ncases in module ida_nalt:

    number of cases (excluding default)

Documentation on variable switch_info_t.jumps in module ida_nalt:

    jump table start address

Documentation on variable switch_info_t.values in module ida_nalt:

    values table address (if SWI_SPARSE is set)

Documentation on variable switch_info_t.lowcase in module ida_nalt:

    the lowest value in cases

Documentation on variable switch_info_t.defjump in module ida_nalt:

    default jump address (BADADDR if no default case)

Documentation on variable switch_info_t.startea in module ida_nalt:

    start of the switch idiom

Documentation on variable switch_info_t.jcases in module ida_nalt:

    number of entries in the jump table (SWI_INDIRECT)

Documentation on variable switch_info_t.elbase in module ida_nalt:

    element base

Documentation on variable switch_info_t.regnum in module ida_nalt:

    the switch expression as a value of the REGNUM register before the instruction
    at EXPR_EA. -1 means 'unknown'

Documentation on variable switch_info_t.regdtype in module ida_nalt:

    size of the switch expression register as dtype

Documentation on variable switch_info_t.custom in module ida_nalt:

    information for custom tables (filled and used by modules)

Documentation on variable switch_info_t.expr_ea in module ida_nalt:

    the address before that the switch expression is in REGNUM. If BADADDR, then the
    first insn marked as IM_SWITCH after STARTEA is used.

Documentation on variable switch_info_t.marks in module ida_nalt:

    the insns marked as IM_SWITCH. They used to delete the switch.

Documentation on variable SWI_SPARSE in module ida_nalt:

    sparse switch (value table present), otherwise lowcase present

Documentation on variable SWI_V32 in module ida_nalt:

    32-bit values in table

Documentation on variable SWI_J32 in module ida_nalt:

    32-bit jump offsets

Documentation on variable SWI_VSPLIT in module ida_nalt:

    value table is split (only for 32-bit values)

Documentation on variable SWI_USER in module ida_nalt:

    user specified switch (starting from version 2)

Documentation on variable SWI_DEF_IN_TBL in module ida_nalt:

    default case is an entry in the jump table. This flag is applicable in 2 cases:
    * The sparse indirect switch (i.e. a switch with a values table) {jump table
    size} == {value table size} + 1. The default case entry is the last one in the
    table (or the first one in the case of an inversed jump table).
    * The switch with insns in the jump table. The default case entry is before the
    first entry of the table.
    See also the find_defjump_from_table() helper function.

Documentation on variable SWI_JMP_INV in module ida_nalt:

    jumptable is inversed. (last entry is for first entry in values table)

Documentation on variable SWI_SHIFT_MASK in module ida_nalt:

    use formula (element<<shift) + elbase to find jump targets

Documentation on variable SWI_ELBASE in module ida_nalt:

    elbase is present (otherwise the base of the switch segment will be used)

Documentation on variable SWI_JSIZE in module ida_nalt:

    jump offset expansion bit

Documentation on variable SWI_VSIZE in module ida_nalt:

    value table element size expansion bit

Documentation on variable SWI_SEPARATE in module ida_nalt:

    create an array of individual elements (otherwise separate items)

Documentation on variable SWI_SIGNED in module ida_nalt:

    jump table entries are signed

Documentation on variable SWI_CUSTOM in module ida_nalt:

    custom jump table. processor_t::create_switch_xrefs will be called to create
    code xrefs for the table. Custom jump table must be created by the module (see
    also SWI_STDTBL)

Documentation on variable SWI_INDIRECT in module ida_nalt:

    value table elements are used as indexes into the jump table (for sparse
    switches)

Documentation on variable SWI_SUBTRACT in module ida_nalt:

    table values are subtracted from the elbase instead of being added

Documentation on variable SWI_HXNOLOWCASE in module ida_nalt:

    lowcase value should not be used by the decompiler (internal flag)

Documentation on variable SWI_STDTBL in module ida_nalt:

    custom jump table with standard table formatting. ATM IDA doesn't use SWI_CUSTOM
    for switches with standard table formatting. So this flag can be considered as
    obsolete.

Documentation on variable SWI_DEFRET in module ida_nalt:

    return in the default case (defjump==BADADDR)

Documentation on variable SWI_SELFREL in module ida_nalt:

    jump address is relative to the element not to ELBASE

Documentation on variable SWI_JMPINSN in module ida_nalt:

    jump table entries are insns. For such entries SHIFT has a different meaning. It
    denotes the number of insns in the entry. For example, 0 - the entry contains
    the jump to the case, 1 - the entry contains one insn like a 'mov' and jump to
    the end of case, and so on.

Documentation on variable SWI_VERSION in module ida_nalt:

    the structure contains the VERSION member

Documentation on variable custom_data_type_ids_t.dtid in module ida_nalt:

    data type id

Documentation on variable custom_data_type_ids_t.fids in module ida_nalt:

    data format ids

Documentation on variable refinfo_t.target in module ida_nalt:

    reference target (BADADDR-none)

Documentation on variable refinfo_t.base in module ida_nalt:

    base of reference (may be BADADDR)

Documentation on variable refinfo_t.tdelta in module ida_nalt:

    offset from the target

Documentation on variable refinfo_t.flags in module ida_nalt:

    Reference info flags

Documentation on variable V695_REF_OFF8 in module ida_nalt:

    reserved

Documentation on variable REF_OFF16 in module ida_nalt:

    16bit full offset

Documentation on variable REF_OFF32 in module ida_nalt:

    32bit full offset

Documentation on variable REF_LOW8 in module ida_nalt:

    low 8bits of 16bit offset

Documentation on variable REF_LOW16 in module ida_nalt:

    low 16bits of 32bit offset

Documentation on variable REF_HIGH8 in module ida_nalt:

    high 8bits of 16bit offset

Documentation on variable REF_HIGH16 in module ida_nalt:

    high 16bits of 32bit offset

Documentation on variable V695_REF_VHIGH in module ida_nalt:

    obsolete

Documentation on variable V695_REF_VLOW in module ida_nalt:

    obsolete

Documentation on variable REF_OFF64 in module ida_nalt:

    64bit full offset

Documentation on variable REF_OFF8 in module ida_nalt:

    8bit full offset

Documentation on variable REFINFO_TYPE in module ida_nalt:

    reference type (reftype_t), or custom reference ID if REFINFO_CUSTOM set

Documentation on variable REFINFO_RVAOFF in module ida_nalt:

    based reference (rva); refinfo_t::base will be forced to get_imagebase(); such a
    reference is displayed with the asm_t::a_rva keyword

Documentation on variable REFINFO_PASTEND in module ida_nalt:

    reference past an item; it may point to an nonexistent address; do not destroy
    alignment dirs

Documentation on variable REFINFO_CUSTOM in module ida_nalt:

    a custom reference. see custom_refinfo_handler_t. the id of the custom refinfo
    is stored under the REFINFO_TYPE mask.

Documentation on variable REFINFO_NOBASE in module ida_nalt:

    don't create the base xref; implies that the base can be any value. nb: base
    xrefs are created only if the offset base points to the middle of a segment

Documentation on variable REFINFO_SUBTRACT in module ida_nalt:

    the reference value is subtracted from the base value instead of (as usual)
    being added to it

Documentation on variable REFINFO_SIGNEDOP in module ida_nalt:

    the operand value is sign-extended (only supported for REF_OFF8/16/32/64)

Documentation on variable REFINFO_NO_ZEROS in module ida_nalt:

    an opval of 0 will be considered invalid

Documentation on variable REFINFO_NO_ONES in module ida_nalt:

    an opval of ~0 will be considered invalid

Documentation on variable MAXSTRUCPATH in module ida_nalt:

    maximal inclusion depth of unions

Documentation on variable opinfo_t.ri in module ida_nalt:

    for offset members

Documentation on variable opinfo_t.tid in module ida_nalt:

    for struct, etc. members

Documentation on variable opinfo_t.path in module ida_nalt:

    for stroff

Documentation on variable opinfo_t.strtype in module ida_nalt:

    for strings (String type codes)

Documentation on variable opinfo_t.ec in module ida_nalt:

    for enums

Documentation on variable opinfo_t.cd in module ida_nalt:

    for custom data

Documentation on variable RIDX_FILE_FORMAT_NAME in module ida_nalt:

    file format name for loader modules

Documentation on variable RIDX_SELECTORS in module ida_nalt:

    2..63 are for selector_t blob (see init_selectors())

Documentation on variable RIDX_GROUPS in module ida_nalt:

    segment group information (see init_groups())

Documentation on variable RIDX_H_PATH in module ida_nalt:

    C header path.

Documentation on variable RIDX_C_MACROS in module ida_nalt:

    C predefined macros.

Documentation on variable RIDX_SMALL_IDC_OLD in module ida_nalt:

    Instant IDC statements (obsolete)

Documentation on variable RIDX_NOTEPAD in module ida_nalt:

    notepad blob, occupies 1000 indexes (1MB of text)

Documentation on variable RIDX_INCLUDE in module ida_nalt:

    assembler include file name

Documentation on variable RIDX_SMALL_IDC in module ida_nalt:

    Instant IDC statements, blob.

Documentation on variable RIDX_DUALOP_GRAPH in module ida_nalt:

    Graph text representation options.

Documentation on variable RIDX_DUALOP_TEXT in module ida_nalt:

    Text text representation options.

Documentation on variable RIDX_MD5 in module ida_nalt:

    MD5 of the input file.

Documentation on variable RIDX_IDA_VERSION in module ida_nalt:

    version of ida which created the database

Documentation on variable RIDX_STR_ENCODINGS in module ida_nalt:

    a list of encodings for the program strings

Documentation on variable RIDX_SRCDBG_PATHS in module ida_nalt:

    source debug paths, occupies 20 indexes

Documentation on variable RIDX_DBG_BINPATHS in module ida_nalt:

    unused (20 indexes)

Documentation on variable RIDX_SHA256 in module ida_nalt:

    SHA256 of the input file.

Documentation on variable RIDX_ABINAME in module ida_nalt:

    ABI name (processor specific)

Documentation on variable RIDX_ARCHIVE_PATH in module ida_nalt:

    archive file path

Documentation on variable RIDX_PROBLEMS in module ida_nalt:

    problem lists

Documentation on variable RIDX_SRCDBG_UNDESIRED in module ida_nalt:

    user-closed source files, occupies 20 indexes

Documentation on variable MAXNAMELEN in module ida_name:

    Maximum length of a name in IDA (with the trailing zero)

Documentation on variable FUNC_IMPORT_PREFIX in module ida_name:

    Name prefix used by IDA for the imported functions.

Documentation on variable SN_CHECK in module ida_name:

    Fail if the name contains invalid characters.

Documentation on variable SN_NOCHECK in module ida_name:

    Replace invalid characters silently. If this bit is set, all invalid chars (not
    in NameChars or MangleChars) will be replaced by '_' List of valid characters is
    defined in ida.cfg

Documentation on variable SN_PUBLIC in module ida_name:

    if set, make name public

Documentation on variable SN_NON_PUBLIC in module ida_name:

    if set, make name non-public

Documentation on variable SN_WEAK in module ida_name:

    if set, make name weak

Documentation on variable SN_NON_WEAK in module ida_name:

    if set, make name non-weak

Documentation on variable SN_AUTO in module ida_name:

    if set, make name autogenerated

Documentation on variable SN_NON_AUTO in module ida_name:

    if set, make name non-autogenerated

Documentation on variable SN_NOLIST in module ida_name:

    if set, exclude name from the list. if not set, then include the name into the
    list (however, if other bits are set, the name might be immediately excluded
    from the list).

Documentation on variable SN_NOWARN in module ida_name:

    don't display a warning if failed

Documentation on variable SN_LOCAL in module ida_name:

    create local name. a function should exist. local names can't be public or weak.
    also they are not included into the list of names they can't have dummy
    prefixes.

Documentation on variable SN_IDBENC in module ida_name:

    the name is given in the IDB encoding; non-ASCII bytes will be decoded
    accordingly. Specifying SN_IDBENC also implies SN_NODUMMY

Documentation on variable SN_FORCE in module ida_name:

    if the specified name is already present in the database, try variations with a
    numerical suffix like "_123"

Documentation on variable SN_NODUMMY in module ida_name:

    automatically prepend the name with '_' if it begins with a dummy suffix such as
    'sub_'. See also SN_IDBENC

Documentation on variable SN_DELTAIL in module ida_name:

    if name cannot be set because of a tail byte, delete the hindering item

Documentation on variable NT_NONE in module ida_name:

    name doesn't exist or has no value

Documentation on variable NT_BYTE in module ida_name:

    name is byte name (regular name)

Documentation on variable NT_LOCAL in module ida_name:

    name is local label

Documentation on variable NT_STKVAR in module ida_name:

    name is stack variable name

Documentation on variable NT_ENUM in module ida_name:

    name is symbolic constant

Documentation on variable NT_ABS in module ida_name:

    name is absolute symbol (SEG_ABSSYM)

Documentation on variable NT_SEG in module ida_name:

    name is segment or segment register name

Documentation on variable NT_STROFF in module ida_name:

    name is structure member

Documentation on variable NT_BMASK in module ida_name:

    name is a bit group mask name

Documentation on variable NT_REGVAR in module ida_name:

    name is a renamed register (*value is idx into pfn->regvars)

Documentation on variable GN_VISIBLE in module ida_name:

    replace forbidden characters by SUBSTCHAR

Documentation on variable GN_COLORED in module ida_name:

    return colored name

Documentation on variable GN_DEMANGLED in module ida_name:

    return demangled name

Documentation on variable GN_STRICT in module ida_name:

    fail if cannot demangle

Documentation on variable GN_SHORT in module ida_name:

    use short form of demangled name

Documentation on variable GN_LONG in module ida_name:

    use long form of demangled name

Documentation on variable GN_LOCAL in module ida_name:

    try to get local name first; if failed, get global

Documentation on variable GN_ISRET in module ida_name:

    for dummy names: use retloc

Documentation on variable GN_NOT_ISRET in module ida_name:

    for dummy names: do not use retloc

Documentation on variable GN_NOT_DUMMY in module ida_name:

    do not return a dummy name

Documentation on variable GETN_APPZERO in module ida_name:

    meaningful only if the name refers to a structure. append a struct field name if
    the field offset is zero?

Documentation on variable GETN_NOFIXUP in module ida_name:

    ignore the fixup information when producing the name

Documentation on variable GETN_NODUMMY in module ida_name:

    do not create a new dummy name but pretend it exists

Documentation on variable GNCN_NOSEG in module ida_name:

    ignore the segment prefix when producing the name

Documentation on variable GNCN_NOCOLOR in module ida_name:

    generate an uncolored name

Documentation on variable GNCN_NOLABEL in module ida_name:

    don't generate labels

Documentation on variable GNCN_NOFUNC in module ida_name:

    don't generate funcname+... expressions

Documentation on variable GNCN_SEG_FUNC in module ida_name:

    generate both segment and function names (default is to omit segment name if a
    function name is present)

Documentation on variable GNCN_SEGNUM in module ida_name:

    segment part is displayed as a hex number

Documentation on variable GNCN_REQFUNC in module ida_name:

    return 0 if the address does not belong to a function

Documentation on variable GNCN_REQNAME in module ida_name:

    return 0 if the address can only be represented as a hex number

Documentation on variable GNCN_NODBGNM in module ida_name:

    don't use debug names

Documentation on variable GNCN_PREFDBG in module ida_name:

    if using debug names, prefer debug names over function names

Documentation on variable DEBNAME_EXACT in module ida_name:

    find a name at exactly the specified address

Documentation on variable DEBNAME_LOWER in module ida_name:

    find a name with the address >= the specified address

Documentation on variable DEBNAME_UPPER in module ida_name:

    find a name with the address > the specified address

Documentation on variable DEBNAME_NICE in module ida_name:

    find a name with the address <= the specified address

Documentation on variable BADNODE in module ida_netnode:

    A number to represent a bad netnode reference.

Documentation on variable MAXNAMESIZE in module ida_netnode:

    Maximum length of a netnode name. WILL BE REMOVED IN THE FUTURE.

Documentation on variable MAX_NODENAME_SIZE in module ida_netnode:

    Maximum length of a name. We permit names up to 32KB-1 bytes.

Documentation on variable MAXSPECSIZE in module ida_netnode:

    Maximum length of strings or objects stored in a supval array element.

Documentation on variable atag in module ida_netnode:

    Array of altvals.

Documentation on variable stag in module ida_netnode:

    Array of supvals.

Documentation on variable htag in module ida_netnode:

    Array of hashvals.

Documentation on variable vtag in module ida_netnode:

    Value of netnode.

Documentation on variable ntag in module ida_netnode:

    Name of netnode.

Documentation on variable ltag in module ida_netnode:

    Links between netnodes.

Documentation on variable IDA_SDK_VERSION in module ida_pro:

    IDA SDK v8.1.

Documentation on variable MAXSTR in module ida_pro:

    maximum string size

Documentation on variable __MF__ in module ida_pro:

    byte sex of our platform (Most significant byte First). 0: little endian (Intel
    80x86). 1: big endian (PowerPC).

Documentation on variable qrefcnt_obj_t.refcnt in module ida_pro:

    counter

Documentation on variable IDBDEC_ESCAPE in module ida_pro:

    convert non-printable characters to C escapes (
    , \xNN, \uNNNN)

Documentation on variable CP_UTF16 in module ida_pro:

    UTF-16 codepage.

Documentation on variable SUBSTCHAR in module ida_pro:

    default char, used if a char cannot be represented in a codepage

Documentation on variable channel_redir_t.fd in module ida_pro:

    channel number

Documentation on variable channel_redir_t.file in module ida_pro:

    file name to redirect to/from. if empty, the channel must be closed.

Documentation on variable channel_redir_t.flags in module ida_pro:

    i/o redirection flags

Documentation on variable channel_redir_t.start in module ida_pro:

    begin of the redirection string in the command line

Documentation on variable channel_redir_t.length in module ida_pro:

    length of the redirection string in the command line

Documentation on variable IOREDIR_INPUT in module ida_pro:

    input redirection

Documentation on variable IOREDIR_OUTPUT in module ida_pro:

    output redirection

Documentation on variable IOREDIR_APPEND in module ida_pro:

    append, do not overwrite the output file

Documentation on variable IOREDIR_QUOTED in module ida_pro:

    the file name was quoted

Documentation on variable instant_dbgopts_t.debmod in module ida_pro:

    name of debugger module

Documentation on variable instant_dbgopts_t.env in module ida_pro:

    config variables for debmod. example: DEFAULT_CPU=13;MAXPACKETSIZE=-1

Documentation on variable instant_dbgopts_t.host in module ida_pro:

    remote hostname (if remote debugging)

Documentation on variable instant_dbgopts_t.port in module ida_pro:

    port number for the remote debugger server

Documentation on variable instant_dbgopts_t.pid in module ida_pro:

    process to attach to (-1: ask the user)

Documentation on variable instant_dbgopts_t.event_id in module ida_pro:

    event to trigger upon attaching

Documentation on variable instant_dbgopts_t.attach in module ida_pro:

    should attach to a process?

Documentation on variable _qstrvec_t.size in module ida_pro:

    Returns the count of elements

Documentation on variable PR_NOBASE in module ida_problems:

    Can't find offset base.

Documentation on variable PR_NONAME in module ida_problems:

    Can't find name.

Documentation on variable PR_NOFOP in module ida_problems:

    Can't find forced op (not used anymore)

Documentation on variable PR_NOCMT in module ida_problems:

    Can't find comment (not used anymore)

Documentation on variable PR_NOXREFS in module ida_problems:

    Can't find references.

Documentation on variable PR_JUMP in module ida_problems:

    Jump by table !!!! ignored.

Documentation on variable PR_DISASM in module ida_problems:

    Can't disasm.

Documentation on variable PR_HEAD in module ida_problems:

    Already head.

Documentation on variable PR_ILLADDR in module ida_problems:

    Exec flows beyond limits.

Documentation on variable PR_MANYLINES in module ida_problems:

    Too many lines.

Documentation on variable PR_BADSTACK in module ida_problems:

    Failed to trace the value of the stack pointer.

Documentation on variable PR_ATTN in module ida_problems:

    Attention! Probably erroneous situation.

Documentation on variable PR_FINAL in module ida_problems:

    Decision to convert to instruction/data is made by IDA.

Documentation on variable PR_ROLLED in module ida_problems:

    The decision made by IDA was wrong and rolled back.

Documentation on variable PR_COLLISION in module ida_problems:

    FLAIR collision: the function with the given name already exists.

Documentation on variable PR_DECIMP in module ida_problems:

    FLAIR match indecision: the patterns matched, but not the function(s) being
    referenced.

Documentation on variable PR_END in module ida_problems:

    Number of problem types.

Documentation on variable range_t.start_ea in module ida_range:

    start_ea included

Documentation on variable range_t.end_ea in module ida_range:

    end_ea excluded

Documentation on variable RANGE_KIND_FUNC in module ida_range:

    func_t

Documentation on variable RANGE_KIND_SEGMENT in module ida_range:

    segment_t

Documentation on variable RANGE_KIND_HIDDEN_RANGE in module ida_range:

    hidden_range_t

Documentation on variable ROOT_KEY_NAME in module ida_registry:

    Default key used to store IDA settings in registry (Windows version).
    @note: this name is automatically prepended to all key names passed to functions
           in this file.

Documentation on variable reg_unknown in module ida_registry:

    unknown

Documentation on variable reg_sz in module ida_registry:

    utf8 string

Documentation on variable reg_binary in module ida_registry:

    binary data

Documentation on variable reg_dword in module ida_registry:

    32-bit number

Documentation on variable SEARCH_UP in module ida_search:

    search towards lower addresses

Documentation on variable SEARCH_DOWN in module ida_search:

    search towards higher addresses

Documentation on variable SEARCH_NEXT in module ida_search:

    skip the starting address when searching. this bit is useful only for search(),
    bin_search2(), find_reg_access(). find_.. functions skip the starting address
    automatically.

Documentation on variable SEARCH_CASE in module ida_search:

    case-sensitive search (case-insensitive otherwise)

Documentation on variable SEARCH_REGEX in module ida_search:

    regular expressions in search string (supported only for the text search)

Documentation on variable SEARCH_NOBRK in module ida_search:

    do not test if the user clicked cancel to interrupt the search

Documentation on variable SEARCH_NOSHOW in module ida_search:

    do not display the search progress/refresh screen

Documentation on variable SEARCH_IDENT in module ida_search:

    search for an identifier (text search). it means that the characters before and
    after the match cannot be is_visible_char().

Documentation on variable SEARCH_BRK in module ida_search:

    return BADADDR if the search was cancelled.

Documentation on variable SREG_NUM in module ida_segment:

    Maximum number of segment registers is 16 (see segregs.hpp)

Documentation on variable segment_t.name in module ida_segment:

    use get/set_segm_name() functions

Documentation on variable segment_t.sclass in module ida_segment:

    use get/set_segm_class() functions

Documentation on variable segment_t.orgbase in module ida_segment:

    this field is IDP dependent. you may keep your information about the segment
    here

Documentation on variable segment_t.align in module ida_segment:

    Segment alignment codes

Documentation on variable segment_t.comb in module ida_segment:

    Segment combination codes

Documentation on variable segment_t.perm in module ida_segment:

    Segment permissions (0 means no information)

Documentation on variable segment_t.bitness in module ida_segment:

    Number of bits in the segment addressing
    * 0: 16 bits
    * 1: 32 bits
    * 2: 64 bits

Documentation on variable segment_t.flags in module ida_segment:

    Segment flags

Documentation on variable segment_t.sel in module ida_segment:

    segment selector - should be unique. You can't change this field after creating
    the segment. Exception: 16bit OMF files may have several segments with the same
    selector, but this is not good (no way to denote a segment exactly) so it should
    be fixed in the future.

Documentation on variable segment_t.defsr in module ida_segment:

    default segment register values. first element of this array keeps information
    about value of processor_t::reg_first_sreg

Documentation on variable segment_t.type in module ida_segment:

    segment type (see Segment types). The kernel treats different segment types
    differently. Segments marked with '*' contain no instructions or data and are
    not declared as 'segments' in the disassembly.

Documentation on variable segment_t.color in module ida_segment:

    the segment color

Documentation on variable saAbs in module ida_segment:

    Absolute segment.

Documentation on variable saRelByte in module ida_segment:

    Relocatable, byte aligned.

Documentation on variable saRelWord in module ida_segment:

    Relocatable, word (2-byte) aligned.

Documentation on variable saRelPara in module ida_segment:

    Relocatable, paragraph (16-byte) aligned.

Documentation on variable saRelPage in module ida_segment:

    Relocatable, aligned on 256-byte boundary.

Documentation on variable saRelDble in module ida_segment:

    Relocatable, aligned on a double word (4-byte) boundary.

Documentation on variable saRel4K in module ida_segment:

    This value is used by the PharLap OMF for page (4K) alignment. It is not
    supported by LINK.

Documentation on variable saGroup in module ida_segment:

    Segment group.

Documentation on variable saRel32Bytes in module ida_segment:

    32 bytes

Documentation on variable saRel64Bytes in module ida_segment:

    64 bytes

Documentation on variable saRelQword in module ida_segment:

    8 bytes

Documentation on variable saRel128Bytes in module ida_segment:

    128 bytes

Documentation on variable saRel512Bytes in module ida_segment:

    512 bytes

Documentation on variable saRel1024Bytes in module ida_segment:

    1024 bytes

Documentation on variable saRel2048Bytes in module ida_segment:

    2048 bytes

Documentation on variable scPriv in module ida_segment:

    Private. Do not combine with any other program segment.

Documentation on variable scGroup in module ida_segment:

    Segment group.

Documentation on variable scPub in module ida_segment:

    Public. Combine by appending at an offset that meets the alignment requirement.

Documentation on variable scPub2 in module ida_segment:

    As defined by Microsoft, same as C=2 (public).

Documentation on variable scStack in module ida_segment:

    Stack. Combine as for C=2. This combine type forces byte alignment.

Documentation on variable scCommon in module ida_segment:

    Common. Combine by overlay using maximum size.

Documentation on variable scPub3 in module ida_segment:

    As defined by Microsoft, same as C=2 (public).

Documentation on variable SEGPERM_EXEC in module ida_segment:

    Execute.

Documentation on variable SEGPERM_WRITE in module ida_segment:

    Write.

Documentation on variable SEGPERM_READ in module ida_segment:

    Read.

Documentation on variable SFL_COMORG in module ida_segment:

    IDP dependent field (IBM PC: if set, ORG directive is not commented out)

Documentation on variable SFL_OBOK in module ida_segment:

    Orgbase is present? (IDP dependent field)

Documentation on variable SFL_HIDDEN in module ida_segment:

    Is the segment hidden?

Documentation on variable SFL_DEBUG in module ida_segment:

    Is the segment created for the debugger?. Such segments are temporary and do not
    have permanent flags.

Documentation on variable SFL_LOADER in module ida_segment:

    Is the segment created by the loader?

Documentation on variable SFL_HIDETYPE in module ida_segment:

    Hide segment type (do not print it in the listing)

Documentation on variable SFL_HEADER in module ida_segment:

    Header segment (do not create offsets to it in the disassembly)

Documentation on variable SEG_NORM in module ida_segment:

    unknown type, no assumptions

Documentation on variable SEG_XTRN in module ida_segment:

    * segment with 'extern' definitions. no instructions are allowed

Documentation on variable SEG_CODE in module ida_segment:

    code segment

Documentation on variable SEG_DATA in module ida_segment:

    data segment

Documentation on variable SEG_GRP in module ida_segment:

    * group of segments

Documentation on variable SEG_NULL in module ida_segment:

    zero-length segment

Documentation on variable SEG_UNDF in module ida_segment:

    undefined segment type (not used)

Documentation on variable SEG_BSS in module ida_segment:

    uninitialized segment

Documentation on variable SEG_ABSSYM in module ida_segment:

    * segment with definitions of absolute symbols

Documentation on variable SEG_COMM in module ida_segment:

    * segment with communal definitions

Documentation on variable SEG_IMEM in module ida_segment:

    internal processor memory & sfr (8051)

Documentation on variable ADDSEG_NOSREG in module ida_segment:

    set all default segment register values to BADSEL (undefine all default segment
    registers)

Documentation on variable ADDSEG_OR_DIE in module ida_segment:

    qexit() if can't add a segment

Documentation on variable ADDSEG_NOTRUNC in module ida_segment:

    don't truncate the new segment at the beginning of the next segment if they
    overlap. destroy/truncate old segments instead.

Documentation on variable ADDSEG_QUIET in module ida_segment:

    silent mode, no "Adding segment..." in the messages window

Documentation on variable ADDSEG_FILLGAP in module ida_segment:

    fill gap between new segment and previous one. i.e. if such a gap exists, and
    this gap is less than 64K, then fill the gap by extending the previous segment
    and adding .align directive to it. This way we avoid gaps between segments. too
    many gaps lead to a virtual array failure. it cannot hold more than ~1000 gaps.

Documentation on variable ADDSEG_SPARSE in module ida_segment:

    use sparse storage method for the new ranges of the created segment. please note
    that the ranges that were already enabled before creating the segment will not
    change their storage type.

Documentation on variable ADDSEG_NOAA in module ida_segment:

    do not mark new segment for auto-analysis

Documentation on variable ADDSEG_IDBENC in module ida_segment:

    'name' and 'sclass' are given in the IDB encoding; non-ASCII bytes will be
    decoded accordingly

Documentation on variable SEGMOD_KILL in module ida_segment:

    disable addresses if segment gets shrinked or deleted

Documentation on variable SEGMOD_KEEP in module ida_segment:

    keep information (code & data, etc)

Documentation on variable SEGMOD_SILENT in module ida_segment:

    be silent

Documentation on variable SEGMOD_KEEP0 in module ida_segment:

    flag for internal use, don't set

Documentation on variable SEGMOD_KEEPSEL in module ida_segment:

    do not try to delete unused selector

Documentation on variable SEGMOD_NOMOVE in module ida_segment:

    don't move info from the start of segment to the new start address (for
    set_segm_start())

Documentation on variable SEGMOD_SPARSE in module ida_segment:

    use sparse storage if extending the segment (for set_segm_start(),
    set_segm_end())

Documentation on variable MSF_SILENT in module ida_segment:

    don't display a "please wait" box on the screen

Documentation on variable MSF_NOFIX in module ida_segment:

    don't call the loader to fix relocations

Documentation on variable MSF_LDKEEP in module ida_segment:

    keep the loader in the memory (optimization)

Documentation on variable MSF_FIXONCE in module ida_segment:

    call loader only once with the special calling method. valid for
    rebase_program(). see loader_t::move_segm.

Documentation on variable MSF_PRIORITY in module ida_segment:

    loader segments will overwrite any existing debugger segments when moved. valid
    for move_segm()

Documentation on variable MSF_NETNODES in module ida_segment:

    move netnodes instead of changing inf.netdelta (this is slower); valid for
    rebase_program()

Documentation on variable MOVE_SEGM_OK in module ida_segment:

    all ok

Documentation on variable MOVE_SEGM_PARAM in module ida_segment:

    The specified segment does not exist.

Documentation on variable MOVE_SEGM_ROOM in module ida_segment:

    Not enough free room at the target address.

Documentation on variable MOVE_SEGM_IDP in module ida_segment:

    IDP module forbids moving the segment.

Documentation on variable MOVE_SEGM_CHUNK in module ida_segment:

    Too many chunks are defined, can't move.

Documentation on variable MOVE_SEGM_LOADER in module ida_segment:

    The segment has been moved but the loader complained.

Documentation on variable MOVE_SEGM_ODD in module ida_segment:

    Cannot move segments by an odd number of bytes.

Documentation on variable MOVE_SEGM_ORPHAN in module ida_segment:

    Orphan bytes hinder segment movement.

Documentation on variable MOVE_SEGM_DEBUG in module ida_segment:

    Debugger segments cannot be moved.

Documentation on variable MOVE_SEGM_SOURCEFILES in module ida_segment:

    Source files ranges of addresses hinder segment movement.

Documentation on variable MOVE_SEGM_MAPPING in module ida_segment:

    Memory mapping ranges of addresses hinder segment movement.

Documentation on variable MOVE_SEGM_INVAL in module ida_segment:

    Invalid argument (delta/target does not fit the address space)

Documentation on variable CSS_OK in module ida_segment:

    ok

Documentation on variable CSS_NODBG in module ida_segment:

    debugger is not running

Documentation on variable CSS_NORANGE in module ida_segment:

    could not find corresponding memory range

Documentation on variable CSS_NOMEM in module ida_segment:

    not enough memory (might be because the segment is too big)

Documentation on variable CSS_BREAK in module ida_segment:

    memory reading process stopped by user

Documentation on variable MAX_GROUPS in module ida_segment:

    max number of segment groups

Documentation on variable MAX_SEGM_TRANSLATIONS in module ida_segment:

    max number of segment translations

Documentation on variable sreg_range_t.val in module ida_segregs:

    segment register value

Documentation on variable sreg_range_t.tag in module ida_segregs:

    Segment register range tags

Documentation on variable SR_inherit in module ida_segregs:

    the value is inherited from the previous range

Documentation on variable SR_user in module ida_segregs:

    the value is specified by the user

Documentation on variable SR_auto in module ida_segregs:

    the value is determined by IDA

Documentation on variable SR_autostart in module ida_segregs:

    used as SR_auto for segment starting address

Documentation on variable SRCLANG_C in module ida_srclang:

    C.

Documentation on variable SRCLANG_CPP in module ida_srclang:

    C++.

Documentation on variable SRCLANG_OBJC in module ida_srclang:

    Objective-C.

Documentation on variable SRCLANG_SWIFT in module ida_srclang:

    Swift (not supported yet)

Documentation on variable SRCLANG_GO in module ida_srclang:

    Golang (not supported yet)

Documentation on variable STRUC_SEPARATOR in module ida_struct:

    structname.fieldname

Documentation on variable member_t.id in module ida_struct:

    name(), cmt, rptcmt

Documentation on variable member_t.soff in module ida_struct:

    start offset (for unions - number of the member 0..n)

Documentation on variable member_t.eoff in module ida_struct:

    end offset

Documentation on variable member_t.flag in module ida_struct:

    type+representation bits

Documentation on variable member_t.props in module ida_struct:

    Struct member properties

Documentation on variable MF_OK in module ida_struct:

    is the member ok? (always yes)

Documentation on variable MF_UNIMEM in module ida_struct:

    is a member of a union?

Documentation on variable MF_HASUNI in module ida_struct:

    has members of type "union"?

Documentation on variable MF_BYTIL in module ida_struct:

    the member was created due to the type system

Documentation on variable MF_HASTI in module ida_struct:

    has type information?

Documentation on variable MF_BASECLASS in module ida_struct:

    a special member representing base class

Documentation on variable MF_DTOR in module ida_struct:

    a special member representing destructor

Documentation on variable MF_DUPNAME in module ida_struct:

    duplicate name resolved with _N suffix (N==soff)

Documentation on variable struc_t.id in module ida_struct:

    struct id

Documentation on variable struc_t.memqty in module ida_struct:

    number of members

Documentation on variable struc_t.members in module ida_struct:

    only defined members are stored here. there may be gaps between members.

Documentation on variable struc_t.age in module ida_struct:

    not used

Documentation on variable struc_t.props in module ida_struct:

    Structure properties

Documentation on variable struc_t.ordinal in module ida_struct:

    corresponding local type ordinal number

Documentation on variable SF_VAR in module ida_struct:

    is variable size structure (varstruct)? a variable size structure is one with
    the zero size last member. if the last member is a varstruct, then the current
    structure is a varstruct too.

Documentation on variable SF_UNION in module ida_struct:

    is a union? varunions are prohibited!

Documentation on variable SF_HASUNI in module ida_struct:

    has members of type "union"?

Documentation on variable SF_NOLIST in module ida_struct:

    don't include in the chooser list

Documentation on variable SF_TYPLIB in module ida_struct:

    the structure comes from type library

Documentation on variable SF_HIDDEN in module ida_struct:

    the structure is collapsed

Documentation on variable SF_FRAME in module ida_struct:

    the structure is a function frame

Documentation on variable SF_ALIGN in module ida_struct:

    alignment (shift amount: 0..31)

Documentation on variable SF_GHOST in module ida_struct:

    ghost copy of a local type

Documentation on variable STRNFL_REGEX in module ida_struct:

    apply regular expressions to beautify the name

Documentation on variable STRUC_ERROR_MEMBER_OK in module ida_struct:

    success

Documentation on variable STRUC_ERROR_MEMBER_NAME in module ida_struct:

    already has member with this name (bad name)

Documentation on variable STRUC_ERROR_MEMBER_OFFSET in module ida_struct:

    already has member at this offset

Documentation on variable STRUC_ERROR_MEMBER_SIZE in module ida_struct:

    bad number of bytes or bad sizeof(type)

Documentation on variable STRUC_ERROR_MEMBER_TINFO in module ida_struct:

    bad typeid parameter

Documentation on variable STRUC_ERROR_MEMBER_STRUCT in module ida_struct:

    bad struct id (the 1st argument)

Documentation on variable STRUC_ERROR_MEMBER_UNIVAR in module ida_struct:

    unions can't have variable sized members

Documentation on variable STRUC_ERROR_MEMBER_VARLAST in module ida_struct:

    variable sized member should be the last member in the structure

Documentation on variable STRUC_ERROR_MEMBER_NESTED in module ida_struct:

    recursive structure nesting is forbidden

Documentation on variable SMT_BADARG in module ida_struct:

    bad parameters

Documentation on variable SMT_NOCOMPAT in module ida_struct:

    the new type is not compatible with the old type

Documentation on variable SMT_WORSE in module ida_struct:

    the new type is worse than the old type

Documentation on variable SMT_SIZE in module ida_struct:

    the new type is incompatible with the member size

Documentation on variable SMT_ARRAY in module ida_struct:

    arrays are forbidden as function arguments

Documentation on variable SMT_OVERLAP in module ida_struct:

    member would overlap with members that cannot be deleted

Documentation on variable SMT_FAILED in module ida_struct:

    failed to set new member type

Documentation on variable SMT_KEEP in module ida_struct:

    no need to change the member type, the old type is better

Documentation on variable SET_MEMTI_MAY_DESTROY in module ida_struct:

    may destroy other members

Documentation on variable SET_MEMTI_COMPATIBLE in module ida_struct:

    new type must be compatible with the old

Documentation on variable SET_MEMTI_FUNCARG in module ida_struct:

    mptr is function argument (cannot create arrays)

Documentation on variable SET_MEMTI_BYTIL in module ida_struct:

    new type was created by the type subsystem

Documentation on variable SET_MEMTI_USERTI in module ida_struct:

    user-specified type

Documentation on variable TBERR_OK in module ida_tryblks:

    ok

Documentation on variable TBERR_START in module ida_tryblks:

    bad start address

Documentation on variable TBERR_END in module ida_tryblks:

    bad end address

Documentation on variable TBERR_ORDER in module ida_tryblks:

    bad address order

Documentation on variable TBERR_EMPTY in module ida_tryblks:

    empty try block

Documentation on variable TBERR_KIND in module ida_tryblks:

    illegal try block kind

Documentation on variable TBERR_NO_CATCHES in module ida_tryblks:

    no catch blocks at all

Documentation on variable TBERR_INTERSECT in module ida_tryblks:

    range would intersect inner tryblk

Documentation on variable RESERVED_BYTE in module ida_typeinf:

    multifunctional purpose

Documentation on variable TAH_BYTE in module ida_typeinf:

    type attribute header byte

Documentation on variable FAH_BYTE in module ida_typeinf:

    function argument attribute header byte

Documentation on variable TAH_HASATTRS in module ida_typeinf:

    has extended attributes

Documentation on variable TAFLD_METHOD in module ida_typeinf:

    denotes a udt member function

Documentation on variable TAH_ALL in module ida_typeinf:

    all defined bits

Documentation on variable type_attr_t.key in module ida_typeinf:

    one symbol keys are reserved to be used by the kernel the ones starting with an
    underscore are reserved too

Documentation on variable type_attr_t.value in module ida_typeinf:

    attribute bytes

Documentation on variable TYPE_BASE_MASK in module ida_typeinf:

    the low 4 bits define the basic type

Documentation on variable TYPE_FLAGS_MASK in module ida_typeinf:

    type flags - they have different meaning depending on the basic type

Documentation on variable TYPE_MODIF_MASK in module ida_typeinf:

    modifiers.
    * for BT_ARRAY see Derived type: array
    * BT_VOID can have them ONLY in 'void *'

Documentation on variable TYPE_FULL_MASK in module ida_typeinf:

    basic type with type flags

Documentation on variable BT_UNK in module ida_typeinf:

    unknown

Documentation on variable BT_VOID in module ida_typeinf:

    void

Documentation on variable BTMT_SIZE0 in module ida_typeinf:

    BT_VOID - normal void; BT_UNK - don't use

Documentation on variable BTMT_SIZE12 in module ida_typeinf:

    size = 1 byte if BT_VOID; 2 if BT_UNK

Documentation on variable BTMT_SIZE48 in module ida_typeinf:

    size = 4 bytes if BT_VOID; 8 if BT_UNK

Documentation on variable BTMT_SIZE128 in module ida_typeinf:

    size = 16 bytes if BT_VOID; unknown if BT_UNK (IN struct alignment - see below)

Documentation on variable BT_INT8 in module ida_typeinf:

    __int8

Documentation on variable BT_INT16 in module ida_typeinf:

    __int16

Documentation on variable BT_INT32 in module ida_typeinf:

    __int32

Documentation on variable BT_INT64 in module ida_typeinf:

    __int64

Documentation on variable BT_INT128 in module ida_typeinf:

    __int128 (for alpha & future use)

Documentation on variable BT_INT in module ida_typeinf:

    natural int. (size provided by idp module)

Documentation on variable BTMT_UNKSIGN in module ida_typeinf:

    unknown signedness

Documentation on variable BTMT_SIGNED in module ida_typeinf:

    signed

Documentation on variable BTMT_USIGNED in module ida_typeinf:

    unsigned

Documentation on variable BTMT_CHAR in module ida_typeinf:

    specify char or segment register
    * BT_INT8 - char
    * BT_INT - segment register
    * other BT_INT... - don't use

Documentation on variable BT_BOOL in module ida_typeinf:

    bool

Documentation on variable BTMT_DEFBOOL in module ida_typeinf:

    size is model specific or unknown(?)

Documentation on variable BTMT_BOOL1 in module ida_typeinf:

    size 1byte

Documentation on variable BTMT_BOOL2 in module ida_typeinf:

    size 2bytes - !inf_is_64bit()

Documentation on variable BTMT_BOOL8 in module ida_typeinf:

    size 8bytes - inf_is_64bit()

Documentation on variable BTMT_BOOL4 in module ida_typeinf:

    size 4bytes

Documentation on variable BT_FLOAT in module ida_typeinf:

    float

Documentation on variable BTMT_FLOAT in module ida_typeinf:

    float (4 bytes)

Documentation on variable BTMT_DOUBLE in module ida_typeinf:

    double (8 bytes)

Documentation on variable BTMT_LNGDBL in module ida_typeinf:

    long double (compiler specific)

Documentation on variable BTMT_SPECFLT in module ida_typeinf:

    float (variable size). if processor_t::use_tbyte() then use
    processor_t::tbyte_size, otherwise 2 bytes

Documentation on variable _BT_LAST_BASIC in module ida_typeinf:

    the last basic type, all basic types may be followed by [tah-typeattrs]

Documentation on variable BT_PTR in module ida_typeinf:

    pointer. has the following format: [db sizeof(ptr)]; [tah-typeattrs]; type_t...

Documentation on variable BTMT_DEFPTR in module ida_typeinf:

    default for model

Documentation on variable BTMT_NEAR in module ida_typeinf:

    near

Documentation on variable BTMT_FAR in module ida_typeinf:

    far

Documentation on variable BTMT_CLOSURE in module ida_typeinf:

    closure.
    * if ptr to BT_FUNC - __closure. in this case next byte MUST be RESERVED_BYTE,
    and after it BT_FUNC
    * else the next byte contains sizeof(ptr) allowed values are 1 - ph.max_ptr_size
    * if value is bigger than ph.max_ptr_size, based_ptr_name_and_size() is called
    to find out the typeinfo

Documentation on variable BT_ARRAY in module ida_typeinf:

    array

Documentation on variable BTMT_NONBASED in module ida_typeinf:

    if set
    array base==0
    format: dt num_elem; [tah-typeattrs]; type_t...
    if num_elem==0 then the array size is unknown
    else
    format: da num_elem, base; [tah-typeattrs]; type_t...
    used only for serialization

Documentation on variable BTMT_ARRESERV in module ida_typeinf:

    reserved bit

Documentation on variable BT_FUNC in module ida_typeinf:

    function. format:
    optional: CM_CC_SPOILED | num_of_spoiled_regs
                    if num_of_spoiled_reg == BFA_FUNC_MARKER:
                      ::bfa_byte
                      if (bfa_byte & BFA_FUNC_EXT_FORMAT) != 0
                       ::fti_bits (only low bits: FTI_SPOILED,...,FTI_VIRTUAL)
                       num_of_spoiled_reg times: spoiled reg info (see
    extract_spoiledreg)
                      else
                        bfa_byte is function attribute byte (see Function attribute
    byte...)
                    else:
                      num_of_spoiled_reg times: spoiled reg info (see
    extract_spoiledreg)
          cm_t ... calling convention and memory model
          [tah-typeattrs];
          type_t ... return type;
          [serialized argloc_t of returned value (if CM_CC_SPECIAL{PE} && !return
    void);
          if !CM_CC_VOIDARG:
            dt N (N=number of parameters)
            if ( N == 0 )
            if CM_CC_ELLIPSIS or CM_CC_SPECIALE
                func(...)
              else
                parameters are unknown
            else
              N records:
                type_t ... (i.e. type of each parameter)
                [serialized argloc_t (if CM_CC_SPECIAL{PE})] (i.e. place of each
    parameter)
                [FAH_BYTE + de( funcarg_t::flags )]

Documentation on variable BTMT_DEFCALL in module ida_typeinf:

    call method - default for model or unknown

Documentation on variable BTMT_NEARCALL in module ida_typeinf:

    function returns by retn

Documentation on variable BTMT_FARCALL in module ida_typeinf:

    function returns by retf

Documentation on variable BTMT_INTCALL in module ida_typeinf:

    function returns by iret in this case cc MUST be 'unknown'

Documentation on variable BT_COMPLEX in module ida_typeinf:

    struct/union/enum/typedef. format:
    [dt N (N=field count) if !BTMT_TYPEDEF]
           if N == 0:
             p_string name (unnamed types have names "anon_...")
             [sdacl-typeattrs];
           else, for struct & union:
             if N == 0x7FFE   // Support for high (i.e., > 4095) members count
               N = deserialize_de()
             ALPOW = N & 0x7
             MCNT = N >> 3
             if MCNT == 0
               empty struct
             if ALPOW == 0
               ALIGN = get_default_align()
             else
               ALIGN = (1 << (ALPOW - 1))
             [sdacl-typeattrs];
           else, for enums:
             if N == 0x7FFE   // Support for high enum entries count.
               N = deserialize_de()
             [tah-typeattrs];

Documentation on variable BTMT_TYPEDEF in module ida_typeinf:

    named reference always p_string name

Documentation on variable BT_BITFIELD in module ida_typeinf:

    bitfield (only in struct) ['bitmasked' enum see below] next byte is dt ((size in
    bits << 1) | (unsigned ? 1 : 0))

Documentation on variable BTMT_BFLDI8 in module ida_typeinf:

    __int8

Documentation on variable BTMT_BFLDI16 in module ida_typeinf:

    __int16

Documentation on variable BTMT_BFLDI32 in module ida_typeinf:

    __int32

Documentation on variable BTMT_BFLDI64 in module ida_typeinf:

    __int64

Documentation on variable BT_RESERVED in module ida_typeinf:

    RESERVED.

Documentation on variable BTM_CONST in module ida_typeinf:

    const

Documentation on variable BTM_VOLATILE in module ida_typeinf:

    volatile

Documentation on variable BTE_SIZE_MASK in module ida_typeinf:

    storage size.
    * if == 0 then inf_get_cc_size_e()
    * else 1 << (n -1) = 1,2,4...64

Documentation on variable BTE_RESERVED in module ida_typeinf:

    must be 0, in order to distinguish from a tah-byte

Documentation on variable BTE_BITFIELD in module ida_typeinf:

    'subarrays'. In this case ANY record has the following format:
    * 'de' mask (has name)
    * 'dt' cnt
    * cnt records of 'de' values (cnt CAN be 0)
    @note: delta for ALL subsegment is ONE

Documentation on variable BTE_OUT_MASK in module ida_typeinf:

    output style mask

Documentation on variable BTE_HEX in module ida_typeinf:

    hex

Documentation on variable BTE_CHAR in module ida_typeinf:

    char or hex

Documentation on variable BTE_SDEC in module ida_typeinf:

    signed decimal

Documentation on variable BTE_UDEC in module ida_typeinf:

    unsigned decimal

Documentation on variable BTE_ALWAYS in module ida_typeinf:

    this bit MUST be present

Documentation on variable BT_SEGREG in module ida_typeinf:

    segment register

Documentation on variable BT_UNK_BYTE in module ida_typeinf:

    1 byte

Documentation on variable BT_UNK_WORD in module ida_typeinf:

    2 bytes

Documentation on variable BT_UNK_DWORD in module ida_typeinf:

    4 bytes

Documentation on variable BT_UNK_QWORD in module ida_typeinf:

    8 bytes

Documentation on variable BT_UNK_OWORD in module ida_typeinf:

    16 bytes

Documentation on variable BT_UNKNOWN in module ida_typeinf:

    unknown size - for parameters

Documentation on variable BTF_BYTE in module ida_typeinf:

    byte

Documentation on variable BTF_UNK in module ida_typeinf:

    unknown

Documentation on variable BTF_VOID in module ida_typeinf:

    void

Documentation on variable BTF_INT8 in module ida_typeinf:

    signed byte

Documentation on variable BTF_CHAR in module ida_typeinf:

    signed char

Documentation on variable BTF_UCHAR in module ida_typeinf:

    unsigned char

Documentation on variable BTF_UINT8 in module ida_typeinf:

    unsigned byte

Documentation on variable BTF_INT16 in module ida_typeinf:

    signed short

Documentation on variable BTF_UINT16 in module ida_typeinf:

    unsigned short

Documentation on variable BTF_INT32 in module ida_typeinf:

    signed int

Documentation on variable BTF_UINT32 in module ida_typeinf:

    unsigned int

Documentation on variable BTF_INT64 in module ida_typeinf:

    signed long

Documentation on variable BTF_UINT64 in module ida_typeinf:

    unsigned long

Documentation on variable BTF_INT128 in module ida_typeinf:

    signed 128-bit value

Documentation on variable BTF_UINT128 in module ida_typeinf:

    unsigned 128-bit value

Documentation on variable BTF_INT in module ida_typeinf:

    int, unknown signedness

Documentation on variable BTF_UINT in module ida_typeinf:

    unsigned int

Documentation on variable BTF_SINT in module ida_typeinf:

    singed int

Documentation on variable BTF_BOOL in module ida_typeinf:

    boolean

Documentation on variable BTF_FLOAT in module ida_typeinf:

    float

Documentation on variable BTF_DOUBLE in module ida_typeinf:

    double

Documentation on variable BTF_LDOUBLE in module ida_typeinf:

    long double

Documentation on variable BTF_TBYTE in module ida_typeinf:

    see BTMT_SPECFLT

Documentation on variable BTF_STRUCT in module ida_typeinf:

    struct

Documentation on variable BTF_UNION in module ida_typeinf:

    union

Documentation on variable BTF_ENUM in module ida_typeinf:

    enum

Documentation on variable BTF_TYPEDEF in module ida_typeinf:

    typedef

Documentation on variable til_t.name in module ida_typeinf:

    short file name (without path and extension)

Documentation on variable til_t.desc in module ida_typeinf:

    human readable til description

Documentation on variable til_t.nbases in module ida_typeinf:

    number of base tils

Documentation on variable til_t.flags in module ida_typeinf:

    Type info library property bits

Documentation on variable til_t.cc in module ida_typeinf:

    information about the target compiler

Documentation on variable til_t.nrefs in module ida_typeinf:

    number of references to the til

Documentation on variable til_t.nstreams in module ida_typeinf:

    number of extra streams

Documentation on variable til_t.streams in module ida_typeinf:

    symbol stream storage

Documentation on variable no_sign in module ida_typeinf:

    no sign, or unknown

Documentation on variable type_signed in module ida_typeinf:

    signed type

Documentation on variable type_unsigned in module ida_typeinf:

    unsigned type

Documentation on variable TIL_ZIP in module ida_typeinf:

    pack buckets using zip

Documentation on variable TIL_MAC in module ida_typeinf:

    til has macro table

Documentation on variable TIL_ESI in module ida_typeinf:

    extended sizeof info (short, long, longlong)

Documentation on variable TIL_UNI in module ida_typeinf:

    universal til for any compiler

Documentation on variable TIL_ORD in module ida_typeinf:

    type ordinal numbers are present

Documentation on variable TIL_ALI in module ida_typeinf:

    type aliases are present (this bit is used only on the disk)

Documentation on variable TIL_MOD in module ida_typeinf:

    til has been modified, should be saved

Documentation on variable TIL_STM in module ida_typeinf:

    til has extra streams

Documentation on variable TIL_SLD in module ida_typeinf:

    sizeof(long double)

Documentation on variable TIL_ADD_FAILED in module ida_typeinf:

    see errbuf

Documentation on variable TIL_ADD_OK in module ida_typeinf:

    some tils were added

Documentation on variable TIL_ADD_ALREADY in module ida_typeinf:

    the base til was already added

Documentation on variable rrel_t.off in module ida_typeinf:

    displacement from the address pointed by the register

Documentation on variable rrel_t.reg in module ida_typeinf:

    register index (into ph.reg_names)

Documentation on variable CM_UNKNOWN in module ida_typeinf:

    unknown

Documentation on variable CM_N8_F16 in module ida_typeinf:

    if sizeof(int)<=2: near 1 byte, far 2 bytes

Documentation on variable CM_N64 in module ida_typeinf:

    if sizeof(int)>2: near 8 bytes, far 8 bytes

Documentation on variable CM_N16_F32 in module ida_typeinf:

    near 2 bytes, far 4 bytes

Documentation on variable CM_N32_F48 in module ida_typeinf:

    near 4 bytes, far 6 bytes

Documentation on variable CM_CC_INVALID in module ida_typeinf:

    this value is invalid

Documentation on variable CM_CC_UNKNOWN in module ida_typeinf:

    unknown calling convention

Documentation on variable CM_CC_VOIDARG in module ida_typeinf:

    function without arguments if has other cc and argnum == 0, represent as f() -
    unknown list

Documentation on variable CM_CC_CDECL in module ida_typeinf:

    stack

Documentation on variable CM_CC_ELLIPSIS in module ida_typeinf:

    cdecl + ellipsis

Documentation on variable CM_CC_STDCALL in module ida_typeinf:

    stack, purged

Documentation on variable CM_CC_PASCAL in module ida_typeinf:

    stack, purged, reverse order of args

Documentation on variable CM_CC_FASTCALL in module ida_typeinf:

    stack, purged (x86), first args are in regs (compiler-dependent)

Documentation on variable CM_CC_THISCALL in module ida_typeinf:

    stack, purged (x86), first arg is in reg (compiler-dependent)

Documentation on variable CM_CC_MANUAL in module ida_typeinf:

    special case for compiler specific (not used)

Documentation on variable CM_CC_SPOILED in module ida_typeinf:

    This is NOT a cc! Mark of __spoil record the low nibble is count and after n
    {spoilreg_t} present real cm_t byte. if n == BFA_FUNC_MARKER, the next byte is
    the function attribute byte.

Documentation on variable CM_CC_SPECIALE in module ida_typeinf:

    CM_CC_SPECIAL with ellipsis

Documentation on variable CM_CC_SPECIALP in module ida_typeinf:

    Equal to CM_CC_SPECIAL, but with purged stack.

Documentation on variable BFA_NORET in module ida_typeinf:

    __noreturn

Documentation on variable BFA_PURE in module ida_typeinf:

    __pure

Documentation on variable BFA_HIGH in module ida_typeinf:

    high level prototype (with possibly hidden args)

Documentation on variable BFA_STATIC in module ida_typeinf:

    static

Documentation on variable BFA_VIRTUAL in module ida_typeinf:

    virtual

Documentation on variable BFA_FUNC_MARKER in module ida_typeinf:

    This is NOT a cc! (used internally as a marker)

Documentation on variable BFA_FUNC_EXT_FORMAT in module ida_typeinf:

    This is NOT a real attribute (used internally as marker for extended format)

Documentation on variable ALOC_NONE in module ida_typeinf:

    none

Documentation on variable ALOC_STACK in module ida_typeinf:

    stack offset

Documentation on variable ALOC_DIST in module ida_typeinf:

    distributed (scattered)

Documentation on variable ALOC_REG1 in module ida_typeinf:

    one register (and offset within it)

Documentation on variable ALOC_REG2 in module ida_typeinf:

    register pair

Documentation on variable ALOC_RREL in module ida_typeinf:

    register relative

Documentation on variable ALOC_STATIC in module ida_typeinf:

    global address

Documentation on variable ALOC_CUSTOM in module ida_typeinf:

    custom argloc (7 or higher)

Documentation on variable argpart_t.off in module ida_typeinf:

    offset from the beginning of the argument

Documentation on variable argpart_t.size in module ida_typeinf:

    the number of bytes

Documentation on variable PRALOC_VERIFY in module ida_typeinf:

    interr if illegal argloc

Documentation on variable PRALOC_STKOFF in module ida_typeinf:

    print stack offsets

Documentation on variable ARGREGS_GP_ONLY in module ida_typeinf:

    GP registers used for all arguments.

Documentation on variable ARGREGS_INDEPENDENT in module ida_typeinf:

    FP/GP registers used separately (like gcc64)

Documentation on variable ARGREGS_BY_SLOTS in module ida_typeinf:

    fixed FP/GP register per each slot (like vc64)

Documentation on variable ARGREGS_FP_CONSUME_GP in module ida_typeinf:

    FP register also consumes one or more GP regs but not vice versa (aix ppc ABI)

Documentation on variable ARGREGS_MIPS_O32 in module ida_typeinf:

    MIPS ABI o32.

Documentation on variable callregs_t.policy in module ida_typeinf:

    argument policy

Documentation on variable callregs_t.nregs in module ida_typeinf:

    max number of registers that can be used in a call

Documentation on variable callregs_t.gpregs in module ida_typeinf:

    array of gp registers

Documentation on variable callregs_t.fpregs in module ida_typeinf:

    array of fp registers

Documentation on variable SETCOMP_OVERRIDE in module ida_typeinf:

    may override old compiler info

Documentation on variable SETCOMP_ONLY_ID in module ida_typeinf:

    cc has only 'id' field; the rest will be set to defaults corresponding to the
    program bitness

Documentation on variable SETCOMP_ONLY_ABI in module ida_typeinf:

    ignore cc field complete, use only abiname

Documentation on variable SETCOMP_BY_USER in module ida_typeinf:

    invoked by user, cannot be replaced by module/loader

Documentation on variable MAX_FUNC_ARGS in module ida_typeinf:

    max number of function arguments

Documentation on variable sc_unk in module ida_typeinf:

    unknown

Documentation on variable sc_type in module ida_typeinf:

    typedef

Documentation on variable sc_ext in module ida_typeinf:

    extern

Documentation on variable sc_stat in module ida_typeinf:

    static

Documentation on variable sc_reg in module ida_typeinf:

    register

Documentation on variable sc_auto in module ida_typeinf:

    auto

Documentation on variable sc_friend in module ida_typeinf:

    friend

Documentation on variable sc_virt in module ida_typeinf:

    virtual

Documentation on variable HTI_CPP in module ida_typeinf:

    C++ mode (not implemented)

Documentation on variable HTI_TST in module ida_typeinf:

    test mode: discard the result

Documentation on variable HTI_FIL in module ida_typeinf:

    "input" is file name, otherwise "input" contains a C declaration

Documentation on variable HTI_MAC in module ida_typeinf:

    define macros from the base tils

Documentation on variable HTI_NWR in module ida_typeinf:

    no warning messages

Documentation on variable HTI_NER in module ida_typeinf:

    ignore all errors but display them

Documentation on variable HTI_DCL in module ida_typeinf:

    don't complain about redeclarations

Documentation on variable HTI_NDC in module ida_typeinf:

    don't decorate names

Documentation on variable HTI_PAK in module ida_typeinf:

    explicit structure pack value (#pragma pack)

Documentation on variable HTI_PAK_SHIFT in module ida_typeinf:

    shift for HTI_PAK. This field should be used if you want to remember an explicit
    pack value for each structure/union type. See HTI_PAK... definitions

Documentation on variable HTI_PAKDEF in module ida_typeinf:

    default pack value

Documentation on variable HTI_PAK1 in module ida_typeinf:

    #pragma pack(1)

Documentation on variable HTI_PAK2 in module ida_typeinf:

    #pragma pack(2)

Documentation on variable HTI_PAK4 in module ida_typeinf:

    #pragma pack(4)

Documentation on variable HTI_PAK8 in module ida_typeinf:

    #pragma pack(8)

Documentation on variable HTI_PAK16 in module ida_typeinf:

    #pragma pack(16)

Documentation on variable HTI_HIGH in module ida_typeinf:

    assume high level prototypes (with hidden args, etc)

Documentation on variable HTI_LOWER in module ida_typeinf:

    lower the function prototypes

Documentation on variable HTI_RAWARGS in module ida_typeinf:

    leave argument names unchanged (do not remove underscores)

Documentation on variable PT_SIL in module ida_typeinf:

    silent, no messages

Documentation on variable PT_NDC in module ida_typeinf:

    don't decorate names

Documentation on variable PT_TYP in module ida_typeinf:

    return declared type information

Documentation on variable PT_VAR in module ida_typeinf:

    return declared object information

Documentation on variable PT_PACKMASK in module ida_typeinf:

    mask for pack alignment values

Documentation on variable PT_HIGH in module ida_typeinf:

    assume high level prototypes (with hidden args, etc)

Documentation on variable PT_LOWER in module ida_typeinf:

    lower the function prototypes

Documentation on variable PT_REPLACE in module ida_typeinf:

    replace the old type (used in idc)

Documentation on variable PT_RAWARGS in module ida_typeinf:

    leave argument names unchanged (do not remove underscores)

Documentation on variable PRTYPE_1LINE in module ida_typeinf:

    print to one line

Documentation on variable PRTYPE_MULTI in module ida_typeinf:

    print to many lines

Documentation on variable PRTYPE_TYPE in module ida_typeinf:

    print type declaration (not variable declaration)

Documentation on variable PRTYPE_PRAGMA in module ida_typeinf:

    print pragmas for alignment

Documentation on variable PRTYPE_SEMI in module ida_typeinf:

    append ; to the end

Documentation on variable PRTYPE_CPP in module ida_typeinf:

    use c++ name (only for print_type())

Documentation on variable PRTYPE_NOREGEX in module ida_typeinf:

    do not apply regular expressions to beautify name

Documentation on variable PRTYPE_COLORED in module ida_typeinf:

    add color tag COLOR_SYMBOL for any parentheses, commas and colons

Documentation on variable NTF_TYPE in module ida_typeinf:

    type name

Documentation on variable NTF_SYMU in module ida_typeinf:

    symbol, name is unmangled ('func')

Documentation on variable NTF_SYMM in module ida_typeinf:

    symbol, name is mangled ('_func'); only one of NTF_TYPE and NTF_SYMU, NTF_SYMM
    can be used

Documentation on variable NTF_NOBASE in module ida_typeinf:

    don't inspect base tils (for get_named_type)

Documentation on variable NTF_REPLACE in module ida_typeinf:

    replace original type (for set_named_type)

Documentation on variable NTF_UMANGLED in module ida_typeinf:

    name is unmangled (don't use this flag)

Documentation on variable NTF_NOCUR in module ida_typeinf:

    don't inspect current til file (for get_named_type)

Documentation on variable NTF_64BIT in module ida_typeinf:

    value is 64bit

Documentation on variable NTF_FIXNAME in module ida_typeinf:

    force-validate the name of the type when setting (set_named_type,
    set_numbered_type only)

Documentation on variable NTF_IDBENC in module ida_typeinf:

    the name is given in the IDB encoding; non-ASCII bytes will be decoded
    accordingly (set_named_type, set_numbered_type only)

Documentation on variable NTF_CHKSYNC in module ida_typeinf:

    check that synchronization to IDB passed OK (set_numbered_type, set_named_type)

Documentation on variable TERR_OK in module ida_typeinf:

    ok

Documentation on variable TERR_SAVE in module ida_typeinf:

    failed to save

Documentation on variable TERR_SERIALIZE in module ida_typeinf:

    failed to serialize

Documentation on variable TERR_WRONGNAME in module ida_typeinf:

    name is not acceptable

Documentation on variable TERR_BADSYNC in module ida_typeinf:

    failed to synchronize with IDB

Documentation on variable IMPTYPE_VERBOSE in module ida_typeinf:

    more verbose output (dialog boxes may appear)

Documentation on variable IMPTYPE_OVERRIDE in module ida_typeinf:

    override existing type

Documentation on variable IMPTYPE_LOCAL in module ida_typeinf:

    the type is local, the struct/enum won't be marked as til type. there is no need
    to specify this bit if til==idati, the kernel will set it automatically

Documentation on variable ADDTIL_DEFAULT in module ida_typeinf:

    default behavior

Documentation on variable ADDTIL_INCOMP in module ida_typeinf:

    load incompatible tils

Documentation on variable ADDTIL_SILENT in module ida_typeinf:

    do not ask any questions

Documentation on variable ADDTIL_FAILED in module ida_typeinf:

    something bad, the warning is displayed

Documentation on variable ADDTIL_OK in module ida_typeinf:

    ok, til is loaded

Documentation on variable ADDTIL_COMP in module ida_typeinf:

    ok, but til is not compatible with the current compiler

Documentation on variable ADDTIL_ABORTED in module ida_typeinf:

    til was not loaded (incompatible til rejected by user)

Documentation on variable TINFO_GUESSED in module ida_typeinf:

    this is a guessed type

Documentation on variable TINFO_DEFINITE in module ida_typeinf:

    this is a definite type

Documentation on variable TINFO_DELAYFUNC in module ida_typeinf:

    if type is a function and no function exists at ea, schedule its creation and
    argument renaming to auto-analysis, otherwise try to create it immediately

Documentation on variable TINFO_STRICT in module ida_typeinf:

    never convert given type to another one before applying

Documentation on variable GUESS_FUNC_FAILED in module ida_typeinf:

    couldn't guess the function type

Documentation on variable GUESS_FUNC_TRIVIAL in module ida_typeinf:

    the function type doesn't have interesting info

Documentation on variable GUESS_FUNC_OK in module ida_typeinf:

    ok, some non-trivial information is gathered

Documentation on variable STI_PCHAR in module ida_typeinf:

    char *

Documentation on variable STI_PUCHAR in module ida_typeinf:

    uint8 *

Documentation on variable STI_PCCHAR in module ida_typeinf:

    const char *

Documentation on variable STI_PCUCHAR in module ida_typeinf:

    const uint8 *

Documentation on variable STI_PBYTE in module ida_typeinf:

    _BYTE *

Documentation on variable STI_PINT in module ida_typeinf:

    int *

Documentation on variable STI_PUINT in module ida_typeinf:

    unsigned int *

Documentation on variable STI_PVOID in module ida_typeinf:

    void *

Documentation on variable STI_PPVOID in module ida_typeinf:

    void **

Documentation on variable STI_PCVOID in module ida_typeinf:

    const void *

Documentation on variable STI_ACHAR in module ida_typeinf:

    char[]

Documentation on variable STI_AUCHAR in module ida_typeinf:

    uint8[]

Documentation on variable STI_ACCHAR in module ida_typeinf:

    const char[]

Documentation on variable STI_ACUCHAR in module ida_typeinf:

    const uint8[]

Documentation on variable STI_FPURGING in module ida_typeinf:

    void __userpurge(int)

Documentation on variable STI_FDELOP in module ida_typeinf:

    void __cdecl(void *)

Documentation on variable STI_MSGSEND in module ida_typeinf:

    void *(void *, const char *, ...)

Documentation on variable STI_AEABI_LCMP in module ida_typeinf:

    int __fastcall(int64 x, int64 y)

Documentation on variable STI_AEABI_ULCMP in module ida_typeinf:

    int __fastcall(uint64 x, uint64 y)

Documentation on variable STI_DONT_USE in module ida_typeinf:

    unused stock type id; should not be used

Documentation on variable STI_SIZE_T in module ida_typeinf:

    size_t

Documentation on variable STI_SSIZE_T in module ida_typeinf:

    ssize_t

Documentation on variable STI_AEABI_MEMCPY in module ida_typeinf:

    void __fastcall(void *, const void *, size_t)

Documentation on variable STI_AEABI_MEMSET in module ida_typeinf:

    void __fastcall(void *, size_t, int)

Documentation on variable STI_AEABI_MEMCLR in module ida_typeinf:

    void __fastcall(void *, size_t)

Documentation on variable STI_RTC_CHECK_2 in module ida_typeinf:

    int16 __fastcall(int16 x)

Documentation on variable STI_RTC_CHECK_4 in module ida_typeinf:

    int32 __fastcall(int32 x)

Documentation on variable STI_RTC_CHECK_8 in module ida_typeinf:

    int64 __fastcall(int64 x)

Documentation on variable STI_COMPLEX64 in module ida_typeinf:

    struct complex64_t { float real, imag; }

Documentation on variable STI_COMPLEX128 in module ida_typeinf:

    struct complex128_t { double real, imag; }

Documentation on variable GTD_CALC_LAYOUT in module ida_typeinf:

    calculate udt layout

Documentation on variable GTD_NO_LAYOUT in module ida_typeinf:

    don't calculate udt layout please note that udt layout may have been calculated
    earlier

Documentation on variable GTD_DEL_BITFLDS in module ida_typeinf:

    delete udt bitfields

Documentation on variable GTD_CALC_ARGLOCS in module ida_typeinf:

    calculate func arg locations

Documentation on variable GTD_NO_ARGLOCS in module ida_typeinf:

    don't calculate func arg locations please note that the locations may have been
    calculated earlier

Documentation on variable GTS_NESTED in module ida_typeinf:

    nested type (embedded into a udt)

Documentation on variable GTS_BASECLASS in module ida_typeinf:

    is baseclass of a udt

Documentation on variable SUDT_SORT in module ida_typeinf:

    fields are not sorted by offset, sort them first

Documentation on variable SUDT_ALIGN in module ida_typeinf:

    recalculate field alignments, struct packing, etc to match the offsets and size
    info

Documentation on variable SUDT_GAPS in module ida_typeinf:

    allow to fill gaps with additional members (_BYTE[])

Documentation on variable SUDT_UNEX in module ida_typeinf:

    references to nonexistent member types are acceptable; in this case it is better
    to set the corresponding udt_member_t::fda field to the type alignment. If this
    field is not set, ida will try to guess the alignment.

Documentation on variable SUDT_FAST in module ida_typeinf:

    serialize without verifying offsets and alignments

Documentation on variable SUDT_CONST in module ida_typeinf:

    only for serialize_udt: make type const

Documentation on variable SUDT_VOLATILE in module ida_typeinf:

    only for serialize_udt: make type volatile

Documentation on variable COMP_UNK in module ida_typeinf:

    Unknown.

Documentation on variable COMP_MS in module ida_typeinf:

    Visual C++.

Documentation on variable COMP_BC in module ida_typeinf:

    Borland C++.

Documentation on variable COMP_WATCOM in module ida_typeinf:

    Watcom C++.

Documentation on variable COMP_GNU in module ida_typeinf:

    GNU C++.

Documentation on variable COMP_VISAGE in module ida_typeinf:

    Visual Age C++.

Documentation on variable COMP_BP in module ida_typeinf:

    Delphi.

Documentation on variable COMP_UNSURE in module ida_typeinf:

    uncertain compiler id

Documentation on variable BADSIZE in module ida_typeinf:

    bad type size

Documentation on variable BADORD in module ida_typeinf:

    invalid type ordinal

Documentation on variable FIRST_NONTRIVIAL_TYPID in module ida_typeinf:

    Denotes the first bit describing a nontrivial type.

Documentation on variable TYPID_ISREF in module ida_typeinf:

    Identifies that a type that is a typeref.

Documentation on variable TYPID_SHIFT in module ida_typeinf:

    First type detail bit.

Documentation on variable STRMEM_OFFSET in module ida_typeinf:

    get member by offset
    * in: udm->offset - is a member offset in bits

Documentation on variable STRMEM_INDEX in module ida_typeinf:

    get member by number
    * in: udm->offset - is a member number

Documentation on variable STRMEM_AUTO in module ida_typeinf:

    get member by offset if struct, or get member by index if union
    * nb: union: index is stored in the udm->offset field!
    * nb: struct: offset is in bytes (not in bits)!

Documentation on variable STRMEM_NAME in module ida_typeinf:

    get member by name
    * in: udm->name - the desired member name.

Documentation on variable STRMEM_TYPE in module ida_typeinf:

    get member by type.
    * in: udm->type - the desired member type. member types are compared with
    tinfo_t::equals_to()

Documentation on variable STRMEM_SIZE in module ida_typeinf:

    get member by size.
    * in: udm->size - the desired member size.

Documentation on variable STRMEM_MINS in module ida_typeinf:

    get smallest member by size.

Documentation on variable STRMEM_MAXS in module ida_typeinf:

    get biggest member by size.

Documentation on variable STRMEM_VFTABLE in module ida_typeinf:

    can be combined with STRMEM_OFFSET, STRMEM_AUTO get vftable instead of the base
    class

Documentation on variable STRMEM_SKIP_EMPTY in module ida_typeinf:

    can be combined with STRMEM_OFFSET, STRMEM_AUTO skip empty members (i.e. having
    zero size) only last empty member can be returned

Documentation on variable STRMEM_CASTABLE_TO in module ida_typeinf:

    can be combined with STRMEM_TYPE: member type must be castable to the specified
    type

Documentation on variable STRMEM_ANON in module ida_typeinf:

    can be combined with STRMEM_NAME: look inside anonymous members too.

Documentation on variable TCMP_EQUAL in module ida_typeinf:

    are types equal?

Documentation on variable TCMP_IGNMODS in module ida_typeinf:

    ignore const/volatile modifiers

Documentation on variable TCMP_AUTOCAST in module ida_typeinf:

    can t1 be cast into t2 automatically?

Documentation on variable TCMP_MANCAST in module ida_typeinf:

    can t1 be cast into t2 manually?

Documentation on variable TCMP_CALL in module ida_typeinf:

    can t1 be called with t2 type?

Documentation on variable TCMP_DELPTR in module ida_typeinf:

    remove pointer from types before comparing

Documentation on variable TCMP_DECL in module ida_typeinf:

    compare declarations without resolving them

Documentation on variable TCMP_ANYBASE in module ida_typeinf:

    accept any base class when casting

Documentation on variable TCMP_SKIPTHIS in module ida_typeinf:

    skip the first function argument in comparison

Documentation on variable simd_info_t.name in module ida_typeinf:

    name of SIMD type (nullptr-undefined)

Documentation on variable simd_info_t.tif in module ida_typeinf:

    SIMD type (empty-undefined)

Documentation on variable simd_info_t.size in module ida_typeinf:

    SIMD type size in bytes (0-undefined)

Documentation on variable simd_info_t.memtype in module ida_typeinf:

    member type BTF_INT8/16/32/64/128, BTF_UINT8/16/32/64/128 BTF_INT - integrals of
    any size/sign BTF_FLOAT, BTF_DOUBLE BTF_TBYTE - floatings of any size BTF_UNION
    - union of integral and floating types BTF_UNK - undefined

Documentation on variable ptr_type_data_t.obj_type in module ida_typeinf:

    pointed object type

Documentation on variable ptr_type_data_t.closure in module ida_typeinf:

    cannot have both closure and based_ptr_size

Documentation on variable ptr_type_data_t.taptr_bits in module ida_typeinf:

    TAH bits.

Documentation on variable ptr_type_data_t.parent in module ida_typeinf:

    Parent struct.

Documentation on variable ptr_type_data_t.delta in module ida_typeinf:

    Offset from the beginning of the parent struct.

Documentation on variable array_type_data_t.elem_type in module ida_typeinf:

    element type

Documentation on variable array_type_data_t.base in module ida_typeinf:

    array base

Documentation on variable array_type_data_t.nelems in module ida_typeinf:

    number of elements

Documentation on variable funcarg_t.argloc in module ida_typeinf:

    argument location

Documentation on variable funcarg_t.name in module ida_typeinf:

    argument name (may be empty)

Documentation on variable funcarg_t.cmt in module ida_typeinf:

    argument comment (may be empty)

Documentation on variable funcarg_t.type in module ida_typeinf:

    argument type

Documentation on variable funcarg_t.flags in module ida_typeinf:

    Function argument property bits

Documentation on variable FAI_HIDDEN in module ida_typeinf:

    hidden argument

Documentation on variable FAI_RETPTR in module ida_typeinf:

    pointer to return value. implies hidden

Documentation on variable FAI_STRUCT in module ida_typeinf:

    was initially a structure

Documentation on variable FAI_ARRAY in module ida_typeinf:

    was initially an array; see "__org_typedef" or "__org_arrdim" type attributes to
    determine the original type

Documentation on variable FAI_UNUSED in module ida_typeinf:

    argument is not used by the function

Documentation on variable TA_ORG_TYPEDEF in module ida_typeinf:

    the original typedef name (simple string)

Documentation on variable TA_ORG_ARRDIM in module ida_typeinf:

    the original array dimension (pack_dd)

Documentation on variable TA_FORMAT in module ida_typeinf:

    info about the 'format' argument. 3 times pack_dd: format_functype_t, argument
    number of 'format', argument number of '...'

Documentation on variable func_type_data_t.flags in module ida_typeinf:

    Function type data property bits

Documentation on variable func_type_data_t.rettype in module ida_typeinf:

    return type

Documentation on variable func_type_data_t.retloc in module ida_typeinf:

    return location

Documentation on variable func_type_data_t.stkargs in module ida_typeinf:

    size of stack arguments (not used in build_func_type)

Documentation on variable func_type_data_t.spoiled in module ida_typeinf:

    spoiled register information. if spoiled register info is present, it overrides
    the standard spoil info (eax, edx, ecx for x86)

Documentation on variable func_type_data_t.cc in module ida_typeinf:

    calling convention

Documentation on variable FTI_SPOILED in module ida_typeinf:

    information about spoiled registers is present

Documentation on variable FTI_NORET in module ida_typeinf:

    noreturn

Documentation on variable FTI_PURE in module ida_typeinf:

    __pure

Documentation on variable FTI_HIGH in module ida_typeinf:

    high level prototype (with possibly hidden args)

Documentation on variable FTI_STATIC in module ida_typeinf:

    static

Documentation on variable FTI_VIRTUAL in module ida_typeinf:

    virtual

Documentation on variable FTI_CALLTYPE in module ida_typeinf:

    mask for FTI_*CALL

Documentation on variable FTI_DEFCALL in module ida_typeinf:

    default call

Documentation on variable FTI_NEARCALL in module ida_typeinf:

    near call

Documentation on variable FTI_FARCALL in module ida_typeinf:

    far call

Documentation on variable FTI_INTCALL in module ida_typeinf:

    interrupt call

Documentation on variable FTI_ARGLOCS in module ida_typeinf:

    info about argument locations has been calculated (stkargs and retloc too)

Documentation on variable FTI_EXPLOCS in module ida_typeinf:

    all arglocs are specified explicitly

Documentation on variable FTI_CONST in module ida_typeinf:

    const member function

Documentation on variable FTI_CTOR in module ida_typeinf:

    constructor

Documentation on variable FTI_DTOR in module ida_typeinf:

    destructor

Documentation on variable FTI_ALL in module ida_typeinf:

    all defined bits

Documentation on variable CC_CDECL_OK in module ida_typeinf:

    can use __cdecl calling convention?

Documentation on variable CC_ALLOW_ARGPERM in module ida_typeinf:

    disregard argument order?

Documentation on variable CC_ALLOW_REGHOLES in module ida_typeinf:

    allow holes in register argument list?

Documentation on variable CC_HAS_ELLIPSIS in module ida_typeinf:

    function has a variable list of arguments?

Documentation on variable CC_GOLANG_OK in module ida_typeinf:

    can use __golang calling convention

Documentation on variable stkarg_area_info_t.stkarg_offset in module ida_typeinf:

    Offset from the SP to the first stack argument (can include linkage area)
    examples: pc: 0, hppa: -0x34, ppc aix: 0x18

Documentation on variable stkarg_area_info_t.shadow_size in module ida_typeinf:

    Size of the shadow area. explanations at:
    \link{https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-
    in-x64-assembly} examples: x64 Visual Studio C++: 0x20, x64 gcc: 0, ppc aix:
    0x20

Documentation on variable stkarg_area_info_t.linkage_area in module ida_typeinf:

    Size of the linkage area. explanations at: \link{https://www.ibm.com/docs/en/xl-
    fortran-aix/16.1.0?topic=conventions-linkage-area} examples: pc: 0, hppa: 0, ppc
    aix: 0x18 (equal to stkarg_offset)

Documentation on variable enum_type_data_t.group_sizes in module ida_typeinf:

    if present, specifies bitfield group sizes each group starts with a mask member

Documentation on variable enum_type_data_t.taenum_bits in module ida_typeinf:

    Type attributes for enums

Documentation on variable enum_type_data_t.bte in module ida_typeinf:

    enum member sizes (shift amount) and style

Documentation on variable typedef_type_data_t.til in module ida_typeinf:

    type library to use when resolving

Documentation on variable typedef_type_data_t.name in module ida_typeinf:

    is_ordref=false: target type name. we do not own this pointer!

Documentation on variable typedef_type_data_t.ordinal in module ida_typeinf:

    is_ordref=true: type ordinal number

Documentation on variable typedef_type_data_t.is_ordref in module ida_typeinf:

    is reference by ordinal?

Documentation on variable typedef_type_data_t.resolve in module ida_typeinf:

    should resolve immediately?

Documentation on variable udt_member_t.offset in module ida_typeinf:

    member offset in bits

Documentation on variable udt_member_t.size in module ida_typeinf:

    size in bits

Documentation on variable udt_member_t.name in module ida_typeinf:

    member name

Documentation on variable udt_member_t.cmt in module ida_typeinf:

    member comment

Documentation on variable udt_member_t.type in module ida_typeinf:

    member type

Documentation on variable udt_member_t.effalign in module ida_typeinf:

    effective field alignment (in bytes)

Documentation on variable udt_member_t.tafld_bits in module ida_typeinf:

    TAH bits.

Documentation on variable udt_member_t.fda in module ida_typeinf:

    field alignment (shift amount)

Documentation on variable udt_type_data_t.total_size in module ida_typeinf:

    total structure size in bytes

Documentation on variable udt_type_data_t.unpadded_size in module ida_typeinf:

    unpadded structure size in bytes

Documentation on variable udt_type_data_t.effalign in module ida_typeinf:

    effective structure alignment (in bytes)

Documentation on variable udt_type_data_t.taudt_bits in module ida_typeinf:

    TA... and TAUDT... bits.

Documentation on variable udt_type_data_t.sda in module ida_typeinf:

    declared structure alignment (shift amount+1). 0 - unspecified

Documentation on variable udt_type_data_t.pack in module ida_typeinf:

    #pragma pack() alignment (shift amount)

Documentation on variable udt_type_data_t.is_union in module ida_typeinf:

    is union or struct?

Documentation on variable bitfield_type_data_t.nbytes in module ida_typeinf:

    enclosing type size (1,2,4,8 bytes)

Documentation on variable bitfield_type_data_t.width in module ida_typeinf:

    number of bits

Documentation on variable bitfield_type_data_t.is_unsigned in module ida_typeinf:

    is bitfield unsigned?

Documentation on variable type_mods_t.type in module ida_typeinf:

    current type

Documentation on variable type_mods_t.name in module ida_typeinf:

    current type name

Documentation on variable type_mods_t.cmt in module ida_typeinf:

    comment for current type

Documentation on variable type_mods_t.flags in module ida_typeinf:

    Type modification bits

Documentation on variable TVIS_TYPE in module ida_typeinf:

    new type info is present

Documentation on variable TVIS_NAME in module ida_typeinf:

    new name is present

Documentation on variable TVIS_CMT in module ida_typeinf:

    new comment is present

Documentation on variable tinfo_visitor_t.state in module ida_typeinf:

    tinfo visitor states

Documentation on variable TVST_PRUNE in module ida_typeinf:

    don't visit children of current type

Documentation on variable TVST_DEF in module ida_typeinf:

    visit type definition (meaningful for typerefs)

Documentation on variable regobj_t.regidx in module ida_typeinf:

    index into dbg->registers

Documentation on variable regobj_t.relocate in module ida_typeinf:

    0-plain num, 1-must relocate

Documentation on variable PIO_NOATTR_FAIL in module ida_typeinf:

    missing attributes are not ok

Documentation on variable PIO_IGNORE_PTRS in module ida_typeinf:

    do not follow pointers

Documentation on variable valstr_t.oneline in module ida_typeinf:

    result if printed on one line in UTF-8 encoding

Documentation on variable valstr_t.length in module ida_typeinf:

    length if printed on one line

Documentation on variable valstr_t.members in module ida_typeinf:

    strings for members, each member separately

Documentation on variable valstr_t.info in module ida_typeinf:

    additional info

Documentation on variable valstr_t.props in module ida_typeinf:

    temporary properties, used internally

Documentation on variable VALSTR_OPEN in module ida_typeinf:

    printed opening curly brace '{'

Documentation on variable PDF_INCL_DEPS in module ida_typeinf:

    Include all type dependencies.

Documentation on variable PDF_DEF_FWD in module ida_typeinf:

    Allow forward declarations.

Documentation on variable PDF_DEF_BASE in module ida_typeinf:

    Include base types: __int8, __int16, etc..

Documentation on variable PDF_HEADER_CMT in module ida_typeinf:

    Prepend output with a descriptive comment.

Documentation on variable PCN_RADIX in module ida_typeinf:

    number base to use

Documentation on variable PCN_DEC in module ida_typeinf:

    decimal

Documentation on variable PCN_HEX in module ida_typeinf:

    hexadecimal

Documentation on variable PCN_OCT in module ida_typeinf:

    octal

Documentation on variable PCN_CHR in module ida_typeinf:

    character

Documentation on variable PCN_UNSIGNED in module ida_typeinf:

    add 'u' suffix

Documentation on variable PCN_LZHEX in module ida_typeinf:

    print leading zeroes for hexdecimal number

Documentation on variable PCN_NEGSIGN in module ida_typeinf:

    print negated value (-N) for negative numbers

Documentation on variable PCN_DECSEXT in module ida_typeinf:

    automatically extend sign of signed decimal numbers

Documentation on variable til_symbol_t.name in module ida_typeinf:

    symbol name

Documentation on variable til_symbol_t.til in module ida_typeinf:

    pointer to til

Documentation on variable op_t.n in module ida_ua:

    Number of operand (0,1,2). Initialized once at the start of work. You have no
    right to change its value.

Documentation on variable op_t.type in module ida_ua:

    Type of operand (see Operand types)

Documentation on variable op_t.offb in module ida_ua:

    Offset of operand value from the instruction start (0 means unknown). Of course
    this field is meaningful only for certain types of operands. Leave it equal to
    zero if the operand has no offset. This offset should point to the 'interesting'
    part of operand. For example, it may point to the address of a function in
    call func  or it may point to bytes holding '5' in
    mov  ax, [bx+5]  Usually bytes pointed to this offset are relocated (have fixup
    information).

Documentation on variable op_t.offo in module ida_ua:

    Same as offb (some operands have 2 numeric values used to form an operand). This
    field is used for the second part of operand if it exists. Currently this field
    is used only for outer offsets of Motorola processors. Leave it equal to zero if
    the operand has no offset.

Documentation on variable op_t.flags in module ida_ua:

    Operand flags

Documentation on variable op_t.dtype in module ida_ua:

    Type of operand value (see Operand value types). Usually first 9 types are used.
    This is the type of the operand itself, not the size of the addressing mode. for
    example, byte ptr [epb+32_bit_offset] will have dt_byte type.

Documentation on variable op_t.reg in module ida_ua:

    number of register (o_reg)

Documentation on variable op_t.phrase in module ida_ua:

    number of register phrase (o_phrase,o_displ). you yourself define numbers of
    phrases as you like

Documentation on variable op_t.value in module ida_ua:

    operand value (o_imm) or outer displacement (o_displ+OF_OUTER_DISP). integer
    values should be in IDA's (little-endian) order. when using ieee_realcvt(),
    floating point values should be in the processor's native byte order. dt_double
    and dt_qword values take up 8 bytes (value and addr fields for 32-bit modules).
    NB: in case a dt_dword/dt_qword immediate is forced to float by user, the kernel
    converts it to processor's native order before calling FP conversion routines.

Documentation on variable op_t.addr in module ida_ua:

    virtual address pointed or used by the operand. (o_mem,o_displ,o_far,o_near)

Documentation on variable op_t.specval in module ida_ua:

    This field may be used as you want.

Documentation on variable o_void in module ida_ua:

    No Operand.

Documentation on variable o_reg in module ida_ua:

    General Register (al,ax,es,ds...).
    
    The register number should be stored in op_t::reg. All processor registers,
    including special registers, can be represented by this operand type.

Documentation on variable o_mem in module ida_ua:

    Direct Memory Reference (DATA).
    
    A direct memory data reference whose target address is known at compilation
    time. The target virtual address is stored in op_t::addr and the full address is
    calculated as to_ea(  insn_t::cs, op_t::addr ). For the processors with complex
    memory organization the final address can be calculated using other segment
    registers. For flat memories, op_t::addr is the final address and insn_t::cs is
    usually equal to zero. In any case, the address within the segment should be
    stored in op_t::addr.

Documentation on variable o_phrase in module ida_ua:

    Memory Ref [Base Reg + Index Reg].
    
    A memory reference using register contents. Indexed, register based, and other
    addressing modes can be represented with the operand type. This addressing mode
    cannot contain immediate values (use o_displ instead). The phrase number should
    be stored in op_t::phrase. To denote the pre-increment and similar features
    please use additional operand fields like op_t::specflag... Usually op_t::phrase
    contains the register number and additional information is stored in
    op_t::specflags... Please note that this operand type cannot contain immediate
    values (except the scaling coefficients).

Documentation on variable o_displ in module ida_ua:

    Memory Ref [Base Reg + Index Reg + Displacement].
    
    A memory reference using register contents with displacement. The displacement
    should be stored in the op_t::addr field. The rest of information is stored the
    same way as in o_phrase.

Documentation on variable o_imm in module ida_ua:

    Immediate Value.
    
    Any operand consisting of only a number is represented by this operand type. The
    value should be stored in op_t::value. You may sign extend short (1-2 byte)
    values. In any case don't forget to specify op_t::dtype (should be set for all
    operand types).

Documentation on variable o_far in module ida_ua:

    Immediate Far Address (CODE).
    
    If the current processor has a special addressing mode for inter-segment
    references, then this operand type should be used instead of o_near. If you
    want, you may use PR_CHK_XREF in processor_t::flag to disable inter-segment
    calls if o_near operand type is used. Currently only IBM PC uses this flag.

Documentation on variable o_near in module ida_ua:

    Immediate Near Address (CODE).
    
    A direct memory code reference whose target address is known at the compilation
    time. The target virtual address is stored in op_t::addr and the final address
    is always to_ea( insn_t::cs, op_t::addr). Usually this operand type is used for
    the branches and calls whose target address is known. If the current processor
    has 2 different types of references for inter-segment and intra-segment
    references, then this should be used only for intra-segment references.
    
    If the above operand types do not cover all possible addressing modes, then use
    o_idpspec... operand types.

Documentation on variable o_idpspec0 in module ida_ua:

    processor specific type.

Documentation on variable o_idpspec1 in module ida_ua:

    processor specific type.

Documentation on variable o_idpspec2 in module ida_ua:

    processor specific type.

Documentation on variable o_idpspec3 in module ida_ua:

    processor specific type.

Documentation on variable o_idpspec4 in module ida_ua:

    processor specific type.

Documentation on variable o_idpspec5 in module ida_ua:

    processor specific type. (there can be more processor specific types)

Documentation on variable OF_NO_BASE_DISP in module ida_ua:

    base displacement doesn't exist. meaningful only for o_displ type. if set, base
    displacement (op_t::addr) doesn't exist.

Documentation on variable OF_OUTER_DISP in module ida_ua:

    outer displacement exists. meaningful only for o_displ type. if set, outer
    displacement (op_t::value) exists.

Documentation on variable PACK_FORM_DEF in module ida_ua:

    packed factor defined. (!o_reg + dt_packreal)

Documentation on variable OF_NUMBER in module ida_ua:

    the operand can be converted to a number only

Documentation on variable OF_SHOW in module ida_ua:

    should the operand be displayed?

Documentation on variable dt_byte in module ida_ua:

    8 bit integer

Documentation on variable dt_word in module ida_ua:

    16 bit integer

Documentation on variable dt_dword in module ida_ua:

    32 bit integer

Documentation on variable dt_float in module ida_ua:

    4 byte floating point

Documentation on variable dt_double in module ida_ua:

    8 byte floating point

Documentation on variable dt_tbyte in module ida_ua:

    variable size ( processor_t::tbyte_size) floating point

Documentation on variable dt_packreal in module ida_ua:

    packed real format for mc68040

Documentation on variable dt_qword in module ida_ua:

    64 bit integer

Documentation on variable dt_byte16 in module ida_ua:

    128 bit integer

Documentation on variable dt_code in module ida_ua:

    ptr to code (not used?)

Documentation on variable dt_void in module ida_ua:

    none

Documentation on variable dt_fword in module ida_ua:

    48 bit

Documentation on variable dt_bitfild in module ida_ua:

    bit field (mc680x0)

Documentation on variable dt_string in module ida_ua:

    pointer to asciiz string

Documentation on variable dt_unicode in module ida_ua:

    pointer to unicode string

Documentation on variable dt_ldbl in module ida_ua:

    long double (which may be different from tbyte)

Documentation on variable dt_byte32 in module ida_ua:

    256 bit integer

Documentation on variable dt_byte64 in module ida_ua:

    512 bit integer

Documentation on variable dt_half in module ida_ua:

    2-byte floating point

Documentation on variable insn_t.cs in module ida_ua:

    Current segment base paragraph. Initialized by the kernel.

Documentation on variable insn_t.ip in module ida_ua:

    Virtual address of the instruction (address within the segment). Initialized by
    the kernel.

Documentation on variable insn_t.ea in module ida_ua:

    Linear address of the instruction. Initialized by the kernel.

Documentation on variable insn_t.itype in module ida_ua:

    Internal code of instruction (only for canonical insns - not user defined!). IDP
    should define its own instruction codes. These codes are usually defined in
    ins.hpp. The array of instruction names and features (ins.cpp) is accessed using
    this code.

Documentation on variable insn_t.size in module ida_ua:

    Size of instruction in bytes. The analyzer should put here the actual size of
    the instruction.

Documentation on variable insn_t.auxpref in module ida_ua:

    processor dependent field

Documentation on variable insn_t.segpref in module ida_ua:

    processor dependent field

Documentation on variable insn_t.insnpref in module ida_ua:

    processor dependent field

Documentation on variable insn_t.flags in module ida_ua:

    Instruction flags

Documentation on variable insn_t.ops in module ida_ua:

    array of operands

Documentation on variable INSN_MACRO in module ida_ua:

    macro instruction

Documentation on variable INSN_MODMAC in module ida_ua:

    may modify the database to make room for the macro insn

Documentation on variable INSN_64BIT in module ida_ua:

    belongs to 64bit segment?

Documentation on variable STKVAR_VALID_SIZE in module ida_ua:

    x.dtype contains correct variable type (for insns like 'lea' this bit must be
    off). in general, dr_O references do not allow to determine the variable size

Documentation on variable OOF_SIGNMASK in module ida_ua:

    sign symbol (+/-) output

Documentation on variable OOFS_IFSIGN in module ida_ua:

    output sign if needed

Documentation on variable OOFS_NOSIGN in module ida_ua:

    don't output sign, forbid the user to change the sign

Documentation on variable OOFS_NEEDSIGN in module ida_ua:

    always out sign (+-)

Documentation on variable OOF_SIGNED in module ida_ua:

    output as signed if < 0

Documentation on variable OOF_NUMBER in module ida_ua:

    always as a number

Documentation on variable OOF_WIDTHMASK in module ida_ua:

    width of value in bits

Documentation on variable OOFW_IMM in module ida_ua:

    take from x.dtype

Documentation on variable OOFW_8 in module ida_ua:

    8 bit width

Documentation on variable OOFW_16 in module ida_ua:

    16 bit width

Documentation on variable OOFW_24 in module ida_ua:

    24 bit width

Documentation on variable OOFW_32 in module ida_ua:

    32 bit width

Documentation on variable OOFW_64 in module ida_ua:

    64 bit width

Documentation on variable OOF_ADDR in module ida_ua:

    output x.addr, otherwise x.value

Documentation on variable OOF_OUTER in module ida_ua:

    output outer operand

Documentation on variable OOF_ZSTROFF in module ida_ua:

    meaningful only if is_stroff(uFlag); append a struct field name if the field
    offset is zero? if AFL_ZSTROFF is set, then this flag is ignored.

Documentation on variable OOF_NOBNOT in module ida_ua:

    prohibit use of binary not

Documentation on variable OOF_SPACES in module ida_ua:

    do not suppress leading spaces; currently works only for floating point numbers

Documentation on variable OOF_ANYSERIAL in module ida_ua:

    if enum: select first available serial

Documentation on variable FCBF_CONT in module ida_ua:

    don't stop on decoding, or any other kind of error

Documentation on variable FCBF_ERR_REPL in module ida_ua:

    in case of an error, use a CP_REPLCHAR instead of a hex representation of the
    problematic byte

Documentation on variable FCBF_FF_LIT in module ida_ua:

    in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER Y WITH
    DIAERESIS). If both this, and FCBF_REPL are specified, this will take precedence

Documentation on variable FCBF_DELIM in module ida_ua:

    add the 'ash'-specified delimiters around the generated data. Note: if those are
    not defined and the INFFL_ALLASM is not set, format_charlit() will return an
    error

Documentation on variable fl_U in module ida_xref:

    unknown - for compatibility with old versions. Should not be used anymore.

Documentation on variable fl_CF in module ida_xref:

    Call Far This xref creates a function at the referenced location

Documentation on variable fl_CN in module ida_xref:

    Call Near This xref creates a function at the referenced location

Documentation on variable fl_JF in module ida_xref:

    Jump Far.

Documentation on variable fl_JN in module ida_xref:

    Jump Near.

Documentation on variable fl_USobsolete in module ida_xref:

    User specified (obsolete)

Documentation on variable fl_F in module ida_xref:

    Ordinary flow: used to specify execution flow to the next instruction.

Documentation on variable dr_U in module ida_xref:

    Unknown - for compatibility with old versions. Should not be used anymore.

Documentation on variable dr_O in module ida_xref:

    Offset The reference uses 'offset' of data rather than its value OR The
    reference appeared because the "OFFSET" flag of instruction is set. The meaning
    of this type is IDP dependent.

Documentation on variable dr_W in module ida_xref:

    Write access.

Documentation on variable dr_R in module ida_xref:

    Read access.

Documentation on variable dr_T in module ida_xref:

    Text (for forced operands only) Name of data is used in manual operand

Documentation on variable dr_I in module ida_xref:

    Informational (a derived java class references its base class informationally)

Documentation on variable dr_S in module ida_xref:

    Reference to enum member (symbolic constant)

Documentation on variable XREF_USER in module ida_xref:

    User specified xref. This xref will not be deleted by IDA. This bit should be
    combined with the existing xref types (cref_t & dref_t) Cannot be used for fl_F
    xrefs

Documentation on variable XREF_TAIL in module ida_xref:

    Reference to tail byte in extrn symbols.

Documentation on variable XREF_BASE in module ida_xref:

    Reference to the base part of an offset.

Documentation on variable XREF_MASK in module ida_xref:

    Mask to get xref type.

Documentation on variable XREF_PASTEND in module ida_xref:

    Reference is past item. This bit may be passed to add_dref() functions but it
    won't be saved in the database. It will prevent the destruction of eventual
    alignment directives.

Documentation on variable xrefblk_t.to in module ida_xref:

    the referenced address - filled by first_from(), next_from()

Documentation on variable xrefblk_t.iscode in module ida_xref:

    1-is code reference; 0-is data reference

Documentation on variable xrefblk_t.type in module ida_xref:

    type of the last returned reference (cref_t & dref_t)

Documentation on variable xrefblk_t.user in module ida_xref:

    1-is user defined xref, 0-defined by ida

Documentation on variable XREF_ALL in module ida_xref:

    return all references

Documentation on variable XREF_FAR in module ida_xref:

    don't return ordinary flow xrefs

Documentation on variable XREF_DATA in module ida_xref:

    return data references only

Documentation on variable AR_LONG in module idc:

    Array of longs

Documentation on variable AR_STR in module idc:

    Array of strings

Documentation on variable ARGV in module idc:

    The command line arguments passed to IDA via the -S switch.
